<?xml version="1.0"?><st-source><!-- Name: GraphQLJSONBundleName: GraphQLJSONBundleStructure: a Store.BundleForParcelParcel: nilParcelName: GraphQLJSONPrerequisiteParcels: #()Date: 4:36:36 PM April 20, 2018 --><time-stamp>From VisualWorksÂ® Personal Use Edition, 8.2 of 15 de julio de 2016 on 20 de abril de 2018 at 16:36:36</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>JSONEncoder</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream level pretty indent empty recursiveSet </inst-vars><class-inst-vars>characterMap </class-inst-vars><imports></imports><category></category><attributes><package>GraphQLJSONPkg</package></attributes></class><comment><class-id>JSONEncoder</class-id><body>JSONEncoder supports encoding objects in JSON format on a stream.  It also supports serializing objects with 'type' hints so that copies of the original objects can be reconstituted.  See class JSONDecoder for the corresponding decode/deserialize operations.Instance Variables:	empty	&lt;OrderedCollection&gt;	stack of empty states per level	indent	&lt;Integer&gt;	number of spaces to indent each level when in 'pretty' mode	level	&lt;Integer&gt;	current indent level	pretty	&lt;Boolean&gt;	true to insert whitespace between entries, false to pack everything tightly together	stream	&lt;Stream&gt;	the output stream on which the encoded JSON is writtenExamples:	| s |	s := String new writeStream.	(JSONEncoder on: s) encode: (Dictionary new at: 'foo' put: 'bar'; at: 'baz' put: 42; yourself).	s contents	==&gt;  '{"foo":"bar","baz":42}'			| s |	s := String new writeStream.	(JSONEncoder on: s) serialize: (Dictionary new at: #foo put: 'bar'; at: 'baz' put: 42; yourself).	s contents	==&gt;  '{"&amp;class":"Dictionary","&amp;contents":[{"&amp;class":"Association","key":"baz","value":42},{"&amp;class":"Association","key":{"&amp;class":"ByteSymbol""&amp;contents":"foo"},"value":"bar"}]}'</body></comment><class><name>JSONError</name><environment>Smalltalk</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GraphQLJSONPkg</package></attributes></class><comment><class-id>JSONError</class-id><body>A JSONError represents a parsing error encountered by the JSONParser.</body></comment><methods><class-id>JSONEncoder</class-id> <category>initialize-release</category><body package="GraphQLJSONPkg">initialize	self		level: 0;		pretty: false;		indent: 0;		empty: OrderedCollection new;		newRecursiveSet.</body><body package="GraphQLJSONPkg">newRecursiveSet	"Set the set used for recursion detection."	self recursiveSet: IdentitySet new.</body></methods><methods><class-id>JSONEncoder</class-id> <category>accessing</category><body package="GraphQLJSONPkg">empty	^empty</body><body package="GraphQLJSONPkg">empty: anObject	empty := anObject</body><body package="GraphQLJSONPkg">indent	^indent</body><body package="GraphQLJSONPkg">indent: anObject	indent := anObject</body><body package="GraphQLJSONPkg">level	^level</body><body package="GraphQLJSONPkg">level: anObject	level := anObject</body><body package="GraphQLJSONPkg">pretty	^pretty</body><body package="GraphQLJSONPkg">pretty: anObject	pretty := anObject</body><body package="GraphQLJSONPkg">recursiveSet	^recursiveSet</body><body package="GraphQLJSONPkg">recursiveSet: anObject	recursiveSet := anObject</body><body package="GraphQLJSONPkg">stream	^stream</body><body package="GraphQLJSONPkg">stream: anObject	stream := anObject</body></methods><methods><class-id>JSONEncoder</class-id> <category>encoding</category><body package="GraphQLJSONPkg">beginArray	stream nextPut: $[.	level := level + 1.	empty add: true.</body><body package="GraphQLJSONPkg">beginObject	(pretty and: [level &gt; 0]) 		ifTrue: 			[stream cr; space: level * indent. 			empty at: level put: false].				stream nextPut: ${.	level := level + 1.	empty add: true.</body><body package="GraphQLJSONPkg">emit: aString	"just copy the string to my stream"		stream nextPutAll: aString.</body><body package="GraphQLJSONPkg">emitClass: aClass	pretty ifTrue: [stream cr; space: level * indent].	empty at: level put: false.	stream nextPutAll: '"&amp;type"'.	self emitColon.	stream 		nextPut: $";		nextPutAll: aClass shortName;		nextPut: $".</body><body package="GraphQLJSONPkg">emitColon	stream nextPutAll: (pretty ifTrue: [' : '] ifFalse: [':']).</body><body package="GraphQLJSONPkg">emitComma	stream nextPutAll: (pretty ifTrue: [', '] ifFalse: [',']).</body><body package="GraphQLJSONPkg">emitKey: aString	pretty ifTrue: [stream cr; space: level * indent].	self emitString: aString.</body><body package="GraphQLJSONPkg">emitKey: aString value: anObject	self		emitKey: aString;		emitColon;		serialize: anObject</body><body package="GraphQLJSONPkg">emitNil		stream nextPutAll: 'null'.</body><body package="GraphQLJSONPkg">emitString: aString	level = 0		ifTrue: [			"If we're at level 0, we have to surround the string with an object definition, per the JSON spec..."			self				beginObject;				emitClass: aString class;				emitComma;				serializeKey: '&amp;value' value: aString;				endObject]		ifFalse: [			"as long as we're inside an object or array, we can just dump out the string."			empty at: level put: false.			stream nextPut: $".						aString do: [:char |				(self class characterMap at: char ifAbsent: [])					ifNotNil: [:replacementString | stream nextPutAll: replacementString]					ifNil: [stream nextPut: char]].								stream nextPut: $"].</body><body package="GraphQLJSONPkg">encodeArray: aCollection	| index |	self beginArray.		index := 0.	aCollection do: [:each |		index := index + 1.		index &gt; 1 ifTrue: [self emitComma].		self encode: each].			self endArray.</body><body package="GraphQLJSONPkg">encodeBasicContentsOf: anObject	self		emitKey: '&amp;contents';		emitColon;		beginArray.		1 to: anObject basicSize do: [:index |		index &gt; 1 ifTrue: [self emitComma].		self encode: (anObject basicAt: index)].			self endArray.</body><body package="GraphQLJSONPkg">encodeKey: aString value: anObject	"The line aString asString below may seem redundant but we need to cover cases where senders pass in objects and not strings. (e.g. Dictionary keys that are not strings but numbers). Obviously this breaks down if the object does not have a meaningful string representation. The dictionary key example is the only use case we have run into thus far."	self		emitKey: aString asString; 		emitColon;		encode: anObject</body><body package="GraphQLJSONPkg">endArray	(pretty and: [(empty at: level) not]) 		ifTrue: [stream cr; space: (level - 1) * indent].	level := level - 1.	empty removeLast.	stream nextPut: $].</body><body package="GraphQLJSONPkg">endObject	(pretty and: [(empty at: level) not]) 		ifTrue: [stream cr; space: (level - 1) * indent].	level := level - 1.	empty removeLast.	stream nextPut: $}.</body><body package="GraphQLJSONPkg">print: anObject		stream print: anObject.</body><body package="GraphQLJSONPkg">serializeArray: aCollection	| index |	self beginArray.		index := 0.	aCollection do: [:each |		index := index + 1.		index &gt; 1 ifTrue: [self emitComma].		self serialize: each].			self endArray.</body><body package="GraphQLJSONPkg">serializeBasicContentsOf: anObject	self		emitKey: '&amp;contents';		emitColon;		beginArray.		1 to: anObject basicSize do: [:index |		index &gt; 1 ifTrue: [self emitComma].		self serialize: (anObject basicAt: index)].			self endArray.</body><body package="GraphQLJSONPkg">serializeContents: aCollection	| index |	self		emitKey: '&amp;contents';		emitColon;		beginArray.		index := 0.	aCollection do: [:each |		index := index + 1.		index &gt; 1 ifTrue: [self emitComma].		self serialize: each].			self endArray.</body><body package="GraphQLJSONPkg">serializeKey: aString value: anObject	self		emitKey: aString;		emitColon;		serialize: anObject</body></methods><methods><class-id>JSONEncoder</class-id> <category>public interface</category><body package="GraphQLJSONPkg">encode: anObject	"Encode anObject as JSON data on aStream."		(recursiveSet includes: anObject)		ifTrue: [			self newRecursiveSet.			JSONError raiseErrorString: 'Recursive structure encountered while encoding an instance of ', anObject class printString ].	recursiveSet add: anObject.	anObject encodeAsJSONDataUsing: self.	recursiveSet remove: anObject ifAbsent: [].</body><body package="GraphQLJSONPkg">serialize: anObject	"Serialize anObject in a JSON format from which a copy of anObject can be reconstituted, on my stream."		(recursiveSet includes: anObject)		ifTrue: [			self newRecursiveSet.			JSONError raiseErrorString: 'Recursive structure encountered while serializing an instance of ', anObject class printString ].	recursiveSet add: anObject.	anObject serializeAsJSONUsing: self.	recursiveSet remove: anObject ifAbsent: [].</body></methods><methods><class-id>JSONEncoder class</class-id> <category>instance creation</category><body package="GraphQLJSONPkg">new	^super new initialize</body><body package="GraphQLJSONPkg">on: aStream	^self on: aStream pretty: false indent: 0</body><body package="GraphQLJSONPkg">on: aStream pretty: aBoolean	^self on: aStream pretty: aBoolean indent: (aBoolean ifTrue: [4] ifFalse: [0]).</body><body package="GraphQLJSONPkg">on: aStream pretty: aBoolean indent: anInteger	^self new		stream: aStream;		pretty: aBoolean;		indent: anInteger.</body></methods><methods><class-id>JSONEncoder class</class-id> <category>accessing</category><body package="GraphQLJSONPkg">characterMap	^characterMap</body></methods><methods><class-id>JSONEncoder class</class-id> <category>class initialization</category><body package="GraphQLJSONPkg">initialize	self initializeCharacterMap.</body><body package="GraphQLJSONPkg">initializeCharacterMap	characterMap := Dictionary new		at: (Character value: 0) put: '\u0000';		at: (Character value: 1) put: '\u0001';		at: (Character value: 2) put: '\u0002';		at: (Character value: 3) put: '\u0003';		at: (Character value: 4) put: '\u0004';		at: (Character value: 5) put: '\u0005';		at: (Character value: 6) put: '\u0006';		at: (Character value: 7) put: '\u0007';		at: Character backspace put: '\b';		at: Character tab put: '\t';		at: Character lf put: '\n';		at: (Character value: 11) put: '\u000B';		at: Character newPage put: '\f';		at: Character cr put: '\r';		at: (Character value: 14) put: '\u000E';		at: (Character value: 15) put: '\u000F';		at: (Character value: 16) put: '\u0010';		at: (Character value: 17) put: '\u0011';		at: (Character value: 18) put: '\u0012';		at: (Character value: 19) put: '\u0013';		at: (Character value: 20) put: '\u0014';		at: (Character value: 21) put: '\u0015';		at: (Character value: 22) put: '\u0016';		at: (Character value: 23) put: '\u0017';		at: (Character value: 24) put: '\u0018';		at: (Character value: 25) put: '\u0019';		at: (Character value: 26) put: '\u001A';		at: (Character value: 27) put: '\u001B';		at: (Character value: 28) put: '\u001C';		at: (Character value: 29) put: '\u001D';		at: (Character value: 30) put: '\u001E';		at: (Character value: 31) put: '\u001F';		at: $" put: '\"';		at: $\ put: '\\';		yourself</body></methods><methods><class-id>JSONEncoder class</class-id> <category>utility</category><body package="GraphQLJSONPkg">encode: anObject	"encode anObject on a String and return the result"	| s |	s := (String new: 256) writeStream.	(self on: s) encode: anObject.	^s contents</body><body package="GraphQLJSONPkg">encode: anObject on: aStream	"encode anObject on aStream."	^(self on: aStream) encode: anObject.</body><body package="GraphQLJSONPkg">encode: anObject onFileNamed: aString	"encode anObject on the file named aString."	| s |	s := aString asFilename writeStream.	[(self on: s) encode: anObject]		ensure: [s close].</body><body package="GraphQLJSONPkg">encode: anObject onFileNamed: aString pretty: aBoolean	"encode anObject on the file named aString."	| s |	s := aString asFilename writeStream.	[(self on: s pretty: aBoolean) encode: anObject]		ensure: [s close].</body><body package="GraphQLJSONPkg">serialize: anObject	"serialize anObject on a String and return the result"	| s |	s := (String new: 256) writeStream.	(self on: s) serialize: anObject.	^s contents</body><body package="GraphQLJSONPkg">serialize: anObject on: aStream	^ (self on: aStream) serialize: anObject.</body><body package="GraphQLJSONPkg">serialize: anObject onFileNamed: aString	"serialize anObject on the file named aString."	| s |	s := aString asFilename writeStream.	[self serialize: anObject on: s] ensure:[s close]</body><body package="GraphQLJSONPkg">serialize: anObject onFileNamed: aString pretty: aBoolean	"serialize anObject on the file named aString. aBoolean controls pretty encoding"	| s |	s := aString asFilename writeStream.	[(self on: s pretty: aBoolean) serialize: anObject] ensure:[s close].</body></methods><methods><class-id>JSONError</class-id> <category>printing</category><body package="GraphQLJSONPkg">description	"Answer the exception text."	^'JSON error: ', super description</body></methods><methods><class-id>Core.String</class-id> <category>storage/retrieval</category><body package="GraphQLJSONPkg">encodeAsJSONDataUsing: aJSONEncoder	aJSONEncoder emitString: self.</body></methods><methods><class-id>Core.Number</class-id> <category>storage/retrieval</category><body package="GraphQLJSONPkg">encodeAsJSONDataUsing: aJSONEncoder	aJSONEncoder print: self</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>storage/retrieval</category><body package="GraphQLJSONPkg">encodeAsJSONDataUsing: aJSONEncoder	aJSONEncoder encodeArray: self.</body></methods><methods><class-id>Core.Dictionary</class-id> <category>storage/retrieval</category><body package="GraphQLJSONPkg">encodeAsJSONDataUsing: aJSONEncoder	| index |	aJSONEncoder beginObject.	index := 0.	self keysAndValuesDo: [:key :val |		index := index + 1.		index &gt; 1 ifTrue: [aJSONEncoder emitComma].		aJSONEncoder encodeKey: key value: val].	aJSONEncoder endObject.</body></methods><methods><class-id>Core.Behavior</class-id> <category>storage/retrieval</category><body package="GraphQLJSONPkg">encodeAsJSONDataUsing: aJSONEncoder	aJSONEncoder emitString: self shortName.</body></methods><methods><class-id>Core.UndefinedObject</class-id> <category>storage/retrieval</category><body package="GraphQLJSONPkg">encodeAsJSONDataUsing: aJSONEncoder	aJSONEncoder emitNil</body></methods><methods><class-id>Core.Fraction</class-id> <category>storage/retrieval</category><body package="GraphQLJSONPkg">encodeAsJSONDataUsing: aJSONEncoder	aJSONEncoder print: self asFloat</body></methods><methods><class-id>Core.Boolean</class-id> <category>storage/retrieval</category><body package="GraphQLJSONPkg">encodeAsJSONDataUsing: aJSONEncoder	aJSONEncoder print: self.</body></methods><methods><class-id>Core.Object</class-id> <category>storage/retrieval</category><body package="GraphQLJSONPkg">encodeAsJSONDataUsing: aJSONEncoder	"Append a representation of the receiver as data to aStream. This representation will be vanilla JSON, and thus will not contain type hints needed to reconstitute the original object."	| aClass variableSize |	aClass := self class.	variableSize := aClass isVariable ifTrue: [self basicSize] ifFalse: [0].		aJSONEncoder beginObject.			1 to: aClass instSize do: [:index | 		index &gt; 1 ifTrue: [aJSONEncoder emitComma].		aJSONEncoder encodeKey: (aClass instVarNameForIndex: index) value: (self instVarAt: index)].						variableSize &gt; 0		ifTrue:			[aClass instSize &gt; 0 ifTrue: [aJSONEncoder emitComma].			1 to: variableSize do: [:index |				index &gt; 1 ifTrue: [aJSONEncoder emitComma].				aJSONEncoder encodeKey: index printString value: (self basicAt: index)]].	aJSONEncoder endObject.</body></methods><methods><class-id>Core.Character</class-id> <category>storage/retrieval</category><body package="GraphQLJSONPkg">encodeAsJSONDataUsing: aJSONEncoder	aJSONEncoder print: self.</body></methods><methods><class-id>Core.Text</class-id> <category>storage/retrieval</category><body package="GraphQLJSONPkg">encodeAsJSONDataUsing: aJSONEncoder	aJSONEncoder emitString: self string.</body></methods><methods><class-id>Core.Stream</class-id> <category>character writing</category><body package="GraphQLJSONPkg">space: aNumber	aNumber timesRepeat: [ self space ].</body></methods><initialize><class-id>JSONEncoder</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Stream</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private IOConstants.*			</imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>UndefinedObject</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Number</name><environment>Core</environment><super>Core.ArithmeticValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Fraction</name><environment>Core</environment><super>Core.Number</super><private>false</private><indexed-type>none</indexed-type><inst-vars>numerator denominator </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-Numbers</category><attributes><package>Magnitude-Numbers</package></attributes></class><class><name>Behavior</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>superclass methodDict format subclasses </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>SequenceableCollection</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>Text</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars>string runs </inst-vars><class-inst-vars></class-inst-vars><imports>			private Graphics.TextConstants.*			</imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>Character</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>immediate</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>String</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>Boolean</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Dictionary</name><environment>Core</environment><super>Core.Set</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class></st-source>