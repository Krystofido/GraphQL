<?xml version="1.0"?><st-source><!-- Name: GraphQLBetaExtentionsBundleName: GraphQLBetaExtentionsBundleStructure: a Store.BundleForParcelDevelopmentPrerequisites: #(#(#any 'GraphQLBeta' '') #(#any 'GraphQLJSONPkg' ''))Parcel: nilParcelName: GraphQLBetaExtentionsPrerequisiteDescriptions: #(#(#name 'GraphQLBeta' #componentType #package) #(#name 'GraphQLJSONPkg' #componentType #package))PrerequisiteParcels: #(#('GraphQLBeta' '') #('GraphQLJSONPkg' ''))Date: 4:36:47 PM April 20, 2018 --><time-stamp>From VisualWorksÂ® Personal Use Edition, 8.2 of 15 de julio de 2016 on 20 de abril de 2018 at 16:36:47</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>Stack</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>list </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GraphQLBetaExtentions</package></attributes></class><comment><class-id>Stack</class-id><body>I implement a simple Stack. #push: adds a new object of any kind on top of the stack. #pop returns the first element and remove it from the stack. #top answer the first element of the stack without removing it.</body></comment><class><name>OrderedDictionary</name><environment>Smalltalk</environment><super>GraphQLBeta.GraphQLObject</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>dictionary orderedKeys </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GraphQLBetaExtentions</package></attributes></class><comment><class-id>OrderedDictionary</class-id><body>I am a collection that act as a Dictionary except that I use key insertion order when enumerating, printing, or returing collections of keys/values/associations, but not when testing for equality (but it does not matters in this case).I will assume that you know the Dictionary class in this comment.Description--------------------I work mainly as a Dictionary except that I also store the keys in an Array that keeps the order of elements. I should be used ONLY if you need to keep the keys ordered. Else you should use a Dictionary that is faster and keep less values into memory. (I duplicate the keys).Insertion, update, and inclusion testing have O(1) complexity while removing has O(n) worst-case.Public API and Key Messages--------------------- #at: aKey put: aValue / #at: aKey ifAbsentPut: aValue 		allow to add an element.  - #at: aKey / #at: aKey ifAbsent: aBlock / #at: aKey ifPresent: aBlock ifAbsent: aBlock 		allow to access my values.- #keysDo: aBlock / #valuesDo: aBlock / #associationsDo: 		allow to iterate on me effectively.		- #keyAtIndex: anIndex / KeyAtIndex: anIndex ifAbsent: aBlock 		allow to acess my keys from an index.Examples------------------	"For basic examples see Dictionary comment."		ordDic := (Dictionary with: 1 -&gt; $a with: 2 -&gt; $b) asOrderedDictionary.	ordDic.   		"returns:  an OrderedDictionary(1-&gt;$a 2-&gt;$b)"	ordDic keyAtIndex: 2.		"returns:  2"	Internal Representation and Key Implementation Points.-------------------    Instance Variables	dictionary:			&lt;Dictionary&gt;		A dictionary where I store my keys and values.	orderedKeys:		&lt;Array&gt;			An ordered collection where I store my keys to maintain the order.I base my implementation on a Dictionary and when I need to execute an action where the order of the values is important I use the keys in my ordered collection.</body></comment><methods><class-id>Stack</class-id> <category>initialize-release</category><body package="GraphQLBetaExtentions">initialize	list := LinkedList new.</body></methods><methods><class-id>Stack</class-id> <category>accessing</category><body package="GraphQLBetaExtentions">list	^ list</body><body package="GraphQLBetaExtentions">pop 	^ self list removeFirst value</body><body package="GraphQLBetaExtentions">push: anObject 	"Adds a new object of any kind on top of the stack."	self list addFirst: (LinkValue value: anObject).	^ anObject.</body><body package="GraphQLBetaExtentions">top	^ self list first value.</body></methods><methods><class-id>Stack class</class-id> <category>instance creation</category><body package="GraphQLBetaExtentions">new	^ super new initialize</body></methods><methods><class-id>OrderedDictionary</class-id> <category>initialize-release</category><body package="GraphQLBetaExtentions">initialize	dictionary := Dictionary new: 10.	orderedKeys := Array new: 10.</body></methods><methods><class-id>OrderedDictionary</class-id> <category>accessing</category><body package="GraphQLBetaExtentions">associationAt: aKey	^ dictionary associationAt: aKey</body><body package="GraphQLBetaExtentions">associations	| associations i |	associations := Array new: self size.	i := 1.	self associationsDo: [:each |		associations at: i put: each.		i := i + 1].	^ associations.</body><body package="GraphQLBetaExtentions">associationsDo: aBlock	self keysDo: [:each | aBlock value: (self associationAt: each)]</body><body package="GraphQLBetaExtentions">at: aKey	^ dictionary at: aKey</body><body package="GraphQLBetaExtentions">at: aKey put: aValue	| oldSize |	oldSize := dictionary size.	dictionary at: aKey put: aValue.	dictionary size &gt; oldSize		ifTrue: [			orderedKeys size &gt; oldSize				ifFalse: [self growOrderedKeys].			orderedKeys at: oldSize + 1 put: aKey].	^ aValue.</body><body package="GraphQLBetaExtentions">do: aBlock	self valuesDo: aBlock</body><body package="GraphQLBetaExtentions">encodeAsJSONDataUsing: aJSONEncoder	| index |	aJSONEncoder beginObject.	index := 0.	(orderedKeys reject: #isNil) do: [ :k | | value |		index := index + 1.		value := dictionary at: k.		index &gt; 1 ifTrue: [aJSONEncoder emitComma].		aJSONEncoder encodeKey: k value: value	].	aJSONEncoder endObject.</body><body package="GraphQLBetaExtentions">growOrderedKeys	orderedKeys :=		(Array new: ((orderedKeys size * 1.5) asInteger max: 10))			replaceFrom: 1			to: orderedKeys size			with: orderedKeys			startingAt: 1.</body><body package="GraphQLBetaExtentions">includesKey: aKey	^ dictionary includesKey: aKey</body><body package="GraphQLBetaExtentions">keys	^ orderedKeys copyFrom: 1 to: self size</body><body package="GraphQLBetaExtentions">keysDo: aBlock	1 to: self size do: [:i | aBlock value: (orderedKeys at: i)]</body><body package="GraphQLBetaExtentions">size	^ dictionary size</body><body package="GraphQLBetaExtentions">values	^ self associations collect: [:each | each value]</body><body package="GraphQLBetaExtentions">valuesDo: aBlock	self keysDo: [:each | aBlock value: (self at: each)]</body></methods><methods><class-id>OrderedDictionary class</class-id> <category>instance creation</category><body package="GraphQLBetaExtentions">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>Core.Object</class-id> <category>accessing</category><body package="GraphQLBetaExtentions">as: aSimilarClass	"Create an object of class aSimilarClass that has similar contents to the receiver."	^ aSimilarClass newFrom: self</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="GraphQLBetaExtentions">isClass	^ false</body></methods><methods><class-id>Core.Object</class-id> <category>accessing</category><body package="GraphQLBetaExtentions">value	^self</body></methods><methods><class-id>Core.String class</class-id> <category>defaults</category><body package="GraphQLBetaExtentions">cr	"Answer a string containing a single carriage return character."	^ self with: Character cr</body></methods><methods><class-id>Core.String</class-id> <category>accessing</category><body package="GraphQLBetaExtentions">capitalized	"Return a copy with the first letter capitalized"	| cap |	self isEmpty ifTrue: [ ^self copy ].	cap := self copy.	cap at: 1 put: (cap at: 1) asUppercase.	^ cap</body></methods><methods><class-id>Core.Collection</class-id> <category>converting</category><body package="GraphQLBetaExtentions">asDictionary	^ self as: Dictionary.</body></methods><methods><class-id>Core.Collection</class-id> <category>enumerating</category><body package="GraphQLBetaExtentions">associationsDo: aBlock	"Evaluate aBlock for each of the receiver's elements (key/value 	associations).  If any non-association is within, the error is not caught now,	but later, when a key or value message is sent to it."	self do: aBlock</body><body package="GraphQLBetaExtentions">doWithIndex: aBlock2	"Support Set enumeration with a counter, even though not ordered"	| index |	index := 0.	self do: [:item | aBlock2 value: item value: (index := index+1)]</body></methods><methods><class-id>Core.Collection</class-id> <category>testing</category><body package="GraphQLBetaExtentions">ifNotEmpty: aBlock	"Evaluate the given block with the receiver as argument, answering its value    unless the receiver is empty, in which case answer the receiver."    ^self isEmpty          ifTrue: [self]          ifFalse: [aBlock cull: self] </body></methods><methods><class-id>Core.Collection</class-id> <category>enumerating</category><body package="GraphQLBetaExtentions">reject: rejectBlock thenCollect: collectBlock	"Utility method to improve readability."	^ (self reject: rejectBlock) collect: collectBlock</body></methods><methods><class-id>Core.Metaclass</class-id> <category>testing</category><body package="GraphQLBetaExtentions">isClass	^ true</body></methods><methods><class-id>Core.Class</class-id> <category>accessing</category><body package="GraphQLBetaExtentions">allMethods	| methods |	methods := OrderedCollection new.	self withAllSuperclasses do: [:each | methods addAll: each methodDictionary values ].	^ methods</body><body package="GraphQLBetaExtentions">encodeAsJSONDataUsing: aJSONEncoder	aJSONEncoder encode: self toDictionary</body><body package="GraphQLBetaExtentions">gqlMethods	| methods |	methods := OrderedCollection new.	methods addAll: self methodDictionary values.	^ methods</body></methods><methods><class-id>Core.Class</class-id> <category>testing</category><body package="GraphQLBetaExtentions">isClass	^ true</body></methods><methods><class-id>Core.Class</class-id> <category>user interface</category><body package="GraphQLBetaExtentions">subclass: aSubclassSymbol instanceVariableNames: instVarNames classVariableNames: classVarNames package: aPackageSymbol	"Added to allow for a simplified subclass creation experience. "	^ self		subclass: aSubclassSymbol		instanceVariableNames: instVarNames		classVariableNames: classVarNames		poolDictionaries: ''		category: aPackageSymbol</body></methods><methods><class-id>Core.Class</class-id> <category>accessing</category><body package="GraphQLBetaExtentions">toDictionary	^ Dictionary new 		at: #name put: name;		at: #gqlMethods put: self gqlMethods;		yourself</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>accessing</category><body package="GraphQLBetaExtentions">reduce: aBlock	"Fold the result of the receiver into aBlock. The argument aBlock must take two or more arguments. It applies the argument, binaryBlock cumulatively to the elements of the receiver. For sequenceable collections the elements will be used in order, for unordered collections the order is unspecified."		"#(1 2 3) reduce: [ :a :b | a + b ]		--&gt; 1 + 2 + 3 = 6	#(1 2 3 4 5) reduce: [ :a :b :c | a + b + c ]		--&gt; 1 + 2 + 3 + 4 + 5 = 15"			^ self reduceLeft: aBlock</body><body package="GraphQLBetaExtentions">reduceLeft: aBlock	"Fold the result of the receiver from left to right into aBlock. The argument aBlock must take two or more arguments."	"#(1 2 3) reduceLeft: [ :a :b | a - b ].		--&gt; ((1 - 2) - 3) = -4	#(1 + 3 - 5) reduceLeft: [ :a :op :b | a perform: op with: b ].		--&gt; ((1 + 3) - 5) = -1"	| arguments |	self emptyCheck.	arguments := Array new: aBlock argumentCount.	(arguments size = 0 or: [ (self size + 1) \\ (arguments size - 1) &gt; 0 ])		ifTrue: [ self error: 'Collection size and block argument count do not match.' ].	arguments at: 1 put: self first.	2 to: self size by: arguments size - 1 do: [ :index |		arguments			replaceFrom: 2 to: arguments size with: self startingAt: index;			at: 1 put: (aBlock valueWithArguments: arguments) ].	^ arguments first</body><body package="GraphQLBetaExtentions">third	^self at: 3</body></methods><methods><class-id>Core.Dictionary class</class-id> <category>instance creation</category><body package="GraphQLBetaExtentions">newFrom: aDict 	"Answer an instance of me containing the same associations as aDict.	 Error if any key appears twice."	| newDictionary |	newDictionary := self new: aDict size.		aDict associationsDo:		[:x |		(newDictionary includesKey: x key)			ifTrue: [self error: 'Duplicate key: ', x key printString]			ifFalse: [newDictionary add: x]].	^ newDictionary"	NewDictionary newFrom: {1-&gt;#a. 2-&gt;#b. 3-&gt;#c}	{1-&gt;#a. 2-&gt;#b. 3-&gt;#c} as: NewDictionary	NewDictionary newFrom: {1-&gt;#a. 2-&gt;#b. 1-&gt;#c}	{1-&gt;#a. 2-&gt;#b. 1-&gt;#c} as: NewDictionary"</body></methods><methods><class-id>Core.Point</class-id> <category>accessing</category><body package="GraphQLBetaExtentions">encodeAsJSONDataUsing: aJSONEncoder	aJSONEncoder encode: self toDictionary</body><body package="GraphQLBetaExtentions">toDictionary	^ Dictionary new 		at: #x put: x;		at: #y put: y;		yourself</body></methods><methods><class-id>Core.Behavior</class-id> <category>accessing</category><body package="GraphQLBetaExtentions">methodDict	^ self methodDictionary</body></methods><methods><class-id>Kernel.BlockClosure</class-id> <category>accessing</category><body package="GraphQLBetaExtentions">argumentCount	"Answer the number of arguments that must be used to evaluate this block"	^ self numArgs</body></methods><methods><class-id>Graphics.Rectangle</class-id> <category>accessing</category><body package="GraphQLBetaExtentions">encodeAsJSONDataUsing: aJSONEncoder	aJSONEncoder encode: self toDictionary</body><body package="GraphQLBetaExtentions">toDictionary	^ Dictionary new	   at: #origin put: origin;	   at: #corner put: corner;	   yourself</body></methods><methods><class-id>GraphQLBeta.GraphQLObject class</class-id> <category>instance creation</category><body package="GraphQLBetaExtentions">new	^super new initialize</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Collection</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>SequenceableCollection</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>String</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>Point</name><environment>Core</environment><super>Core.ArithmeticValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars>x y </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Geometry</category><attributes><package>Graphics-Geometry</package></attributes></class><class><name>Behavior</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>superclass methodDict format subclasses </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>GraphQLObject</name><environment>GraphQLBeta</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta</category><attributes><package>GraphQLBeta</package></attributes></class><class><name>Metaclass</name><environment>Core</environment><super>Core.ClassDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>thisClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>Rectangle</name><environment>Graphics</environment><super>Graphics.Geometric</super><private>false</private><indexed-type>none</indexed-type><inst-vars>origin corner </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Geometry</category><attributes><package>Graphics-Geometry</package></attributes></class><class><name>Class</name><environment>Core</environment><super>Core.ClassDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name classPool environment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>BlockClosure</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method outerContext copiedValues </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class></st-source>