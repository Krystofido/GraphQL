<?xml version="1.0"?><st-source><!-- Name: GraphQLBetaExtentionsBundleName: GraphQLBetaExtentionsBundleStructure: a Store.BundleForParcelDevelopmentPrerequisites: #(#(#any 'GraphQLBeta' '') #(#any 'GraphQLJSONPkg' '') #(#any 'JSONReader' ''))Parcel: nilParcelName: GraphQLBetaExtentionsPrerequisiteDescriptions: #(#(#name 'GraphQLBeta' #componentType #package) #(#name 'GraphQLJSONPkg' #componentType #package) #(#name 'JSONReader' #componentType #package))PrerequisiteParcels: #(#('GraphQLBeta' '') #('GraphQLJSONPkg' '') #('JSONReader' ''))Date: 5:22:50 PM January 25, 2019 --><time-stamp>From VisualWorksÂ® Personal Use Edition, 8.2 of July 15, 2016 on January 25, 2019 at 5:22:50 PM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>OrderedDictionary</name><environment>Smalltalk</environment><super>Core.Collection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>dictionary orderedKeys </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GraphQLBetaExtentions</package></attributes></class><comment><class-id>OrderedDictionary</class-id><body>I am a collection that act as a Dictionary except that I use key insertion order when enumerating, printing, or returing collections of keys/values/associations, but not when testing for equality (but it does not matters in this case).I will assume that you know the Dictionary class in this comment.Description--------------------I work mainly as a Dictionary except that I also store the keys in an Array that keeps the order of elements. I should be used ONLY if you need to keep the keys ordered. Else you should use a Dictionary that is faster and keep less values into memory. (I duplicate the keys).Insertion, update, and inclusion testing have O(1) complexity while removing has O(n) worst-case.Public API and Key Messages--------------------- #at: aKey put: aValue / #at: aKey ifAbsentPut: aValue 		allow to add an element.  - #at: aKey / #at: aKey ifAbsent: aBlock / #at: aKey ifPresent: aBlock ifAbsent: aBlock 		allow to access my values.- #keysDo: aBlock / #valuesDo: aBlock / #associationsDo: 		allow to iterate on me effectively.		- #keyAtIndex: anIndex / KeyAtIndex: anIndex ifAbsent: aBlock 		allow to acess my keys from an index.Examples------------------	"For basic examples see Dictionary comment."		ordDic := (Dictionary with: 1 -&gt; $a with: 2 -&gt; $b) asOrderedDictionary.	ordDic.   		"returns:  an OrderedDictionary(1-&gt;$a 2-&gt;$b)"	ordDic keyAtIndex: 2.		"returns:  2"	Internal Representation and Key Implementation Points.-------------------    Instance Variables	dictionary:			&lt;Dictionary&gt;		A dictionary where I store my keys and values.	orderedKeys:		&lt;Array&gt;			An ordered collection where I store my keys to maintain the order.I base my implementation on a Dictionary and when I need to execute an action where the order of the values is important I use the keys in my ordered collection.</body></comment><class><name>Stack</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>list </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GraphQLBetaExtentions</package></attributes></class><comment><class-id>Stack</class-id><body>I implement a simple Stack. #push: adds a new object of any kind on top of the stack. #pop returns the first element and remove it from the stack. #top answer the first element of the stack without removing it.</body></comment><methods><class-id>OrderedDictionary</class-id> <category>initialize-release</category><body package="GraphQLBetaExtentions">initialize	dictionary := Dictionary new: 10.	orderedKeys := Array new: 10.</body></methods><methods><class-id>OrderedDictionary</class-id> <category>accessing</category><body package="GraphQLBetaExtentions">associationAt: aKey	^ dictionary associationAt: aKey</body><body package="GraphQLBetaExtentions">associations	| associations i |	associations := Array new: self size.	i := 1.	self associationsDo: [:each |		associations at: i put: each.		i := i + 1].	^ associations.</body><body package="GraphQLBetaExtentions">associationsDo: aBlock	self keysDo: [:each | aBlock value: (self associationAt: each)]</body><body package="GraphQLBetaExtentions">at: aKey	^ dictionary at: aKey</body><body package="GraphQLBetaExtentions">at: aKey ifAbsent: aBlock	^ dictionary at: aKey ifAbsent: aBlock</body><body package="GraphQLBetaExtentions">at: aKey ifAbsentPut: aBlock	^ self at: aKey ifAbsent: [self at: aKey put: aBlock value]</body><body package="GraphQLBetaExtentions">at: aKey ifPresent: aBlock	^ dictionary at: aKey ifPresent: aBlock</body><body package="GraphQLBetaExtentions">at: aKey put: aValue	| oldSize |	oldSize := dictionary size.	dictionary at: aKey put: aValue.	dictionary size &gt; oldSize		ifTrue: [			orderedKeys size &gt; oldSize				ifFalse: [self growOrderedKeys].			orderedKeys at: oldSize + 1 put: aKey].	^ aValue.</body><body package="GraphQLBetaExtentions">do: aBlock	self valuesDo: aBlock</body><body package="GraphQLBetaExtentions">encodeAsJSONDataUsing: aJSONEncoder	| index |	aJSONEncoder beginObject.	index := 0.	(orderedKeys reject: #isNil) do: [ :k | | value |		index := index + 1.		value := dictionary at: k.		index &gt; 1 ifTrue: [aJSONEncoder emitComma].		aJSONEncoder encodeKey: k value: value	].	aJSONEncoder endObject.</body><body package="GraphQLBetaExtentions">growOrderedKeys	orderedKeys :=		(Array new: ((orderedKeys size * 1.5) asInteger max: 10))			replaceFrom: 1			to: orderedKeys size			with: orderedKeys			startingAt: 1.</body><body package="GraphQLBetaExtentions">includesKey: aKey	^ dictionary includesKey: aKey</body><body package="GraphQLBetaExtentions">keys	^ orderedKeys copyFrom: 1 to: self size</body><body package="GraphQLBetaExtentions">keysDo: aBlock	1 to: self size do: [:i | aBlock value: (orderedKeys at: i)]</body><body package="GraphQLBetaExtentions">size	^ dictionary size</body><body package="GraphQLBetaExtentions">values	^ self associations collect: [:each | each value]</body></methods><methods><class-id>OrderedDictionary</class-id> <category>testing</category><body package="GraphQLBetaExtentions">isDictionary	^true</body></methods><methods><class-id>OrderedDictionary</class-id> <category>comparing</category><body package="GraphQLBetaExtentions">= anObject	self == anObject		ifTrue: [^ true].	(self species == anObject species		and: [self size = anObject size])		ifFalse: [^ false].	dictionary associationsDo: [:each |		(anObject at: each key ifAbsent: [^ false]) = each value			ifFalse: [^ false]].	^ true.</body><body package="GraphQLBetaExtentions">hash	^ dictionary hash</body></methods><methods><class-id>OrderedDictionary</class-id> <category>adding</category><body package="GraphQLBetaExtentions">add: anAssociation	| oldSize |	oldSize := dictionary size.	dictionary add: anAssociation.	dictionary size &gt; oldSize		ifTrue: [			orderedKeys size &gt; oldSize				ifFalse: [self growOrderedKeys].			orderedKeys at: oldSize + 1 put: anAssociation key].	^ anAssociation.</body><body package="GraphQLBetaExtentions">addAll: anAssociationCollection	"Since Collection implements #associationsDo:, this method can accept	any collection of associations including Arrays and OrderedCollections"	anAssociationCollection associationsDo: [:each | self add: each].	^ anAssociationCollection.</body></methods><methods><class-id>OrderedDictionary</class-id> <category>enumerating</category><body package="GraphQLBetaExtentions">collect: aBlock	^ self species newFrom:		(self associations collect: [:each |			each key -&gt; (aBlock value: each value)])</body><body package="GraphQLBetaExtentions">keysAndValuesDo: aBlock	self keysDo: [:each | aBlock value: each value: (self at: each)]</body><body package="GraphQLBetaExtentions">valuesDo: aBlock	self keysDo: [:each | aBlock value: (self at: each)]</body></methods><methods><class-id>OrderedDictionary class</class-id> <category>instance creation</category><body package="GraphQLBetaExtentions">new	"Answer a newly created and initialized instance."	^super new initialize</body><body package="GraphQLBetaExtentions">newFrom: anAssociationCollection	| newDictionary |	newDictionary := self new.	anAssociationCollection associationsDo: [:each |		newDictionary			at: each key			put: each value].	^ newDictionary.</body></methods><methods><class-id>Stack</class-id> <category>initialize-release</category><body package="GraphQLBetaExtentions">initialize	list := LinkedList new.</body></methods><methods><class-id>Stack</class-id> <category>accessing</category><body package="GraphQLBetaExtentions">list	^ list</body><body package="GraphQLBetaExtentions">pop 	^ self list removeFirst value</body><body package="GraphQLBetaExtentions">push: anObject 	"Adds a new object of any kind on top of the stack."	self list addFirst: (LinkValue value: anObject).	^ anObject.</body><body package="GraphQLBetaExtentions">top	^ self list first value.</body></methods><methods><class-id>Stack class</class-id> <category>instance creation</category><body package="GraphQLBetaExtentions">new	^ super new initialize</body></methods><methods><class-id>Core.Object</class-id> <category>accessing</category><body package="GraphQLBetaExtentions">__typename	^ self class name</body><body package="GraphQLBetaExtentions">as: aSimilarClass	"Create an object of class aSimilarClass that has similar contents to the receiver."	^ aSimilarClass newFrom: self</body></methods><methods><class-id>Core.Object</class-id> <category>instrospection</category><body package="GraphQLBetaExtentions">className	"Answer a string characterizing the receiver's class, for use in list views for example"	^ self class name asString</body></methods><methods><class-id>Core.Object</class-id> <category>copying</category><body package="GraphQLBetaExtentions">deepCopy	^ self dcopy</body></methods><methods><class-id>Core.Object</class-id> <category>user interface</category><body package="GraphQLBetaExtentions">flag: object</body></methods><methods><class-id>Core.Object</class-id> <category>accessing</category><body package="GraphQLBetaExtentions">inform: string	Transcript show: string; cr.</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="GraphQLBetaExtentions">isArray	^false</body><body package="GraphQLBetaExtentions">isClass	^ false</body><body package="GraphQLBetaExtentions">isCollection	^ false</body><body package="GraphQLBetaExtentions">isDictionary	^false</body><body package="GraphQLBetaExtentions">isNotNil	"Coerces nil to false and everything else to true."	^true</body></methods><methods><class-id>Core.Object</class-id> <category>accessing</category><body package="GraphQLBetaExtentions">value	^self</body></methods><methods><class-id>Core.String class</class-id> <category>defaults</category><body package="GraphQLBetaExtentions">cr	"Answer a string containing a single carriage return character."	^ self with: Character cr</body></methods><methods><class-id>Core.String</class-id> <category>converting</category><body package="GraphQLBetaExtentions">asClass	| aSymbol |	aSymbol := self asSymbol.	^ Smalltalk allClasses	 detect: [:cls | cls name = aSymbol ].</body><body package="GraphQLBetaExtentions">asPackageIfAbsent: a	^ nil</body></methods><methods><class-id>Core.String</class-id> <category>accessing</category><body package="GraphQLBetaExtentions">capitalized	"Return a copy with the first letter capitalized"	| cap |	self isEmpty ifTrue: [ ^self copy ].	cap := self copy.	cap at: 1 put: (cap at: 1) asUppercase.	^ cap</body></methods><methods><class-id>Core.String</class-id> <category>copying</category><body package="GraphQLBetaExtentions">trim	"Trim separators from both sides of the receiving string."	"' this string will be trimmed   ' trim &gt;&gt;&gt; 'this string will be trimmed'"		^ self trimBoth</body><body package="GraphQLBetaExtentions">trimBoth	"Trim separators from both sides of the receiving string."		^ self trimBoth: [ :char | char isSeparator ]</body><body package="GraphQLBetaExtentions">trimBoth: aBlock	"Trim characters satisfying the condition given in aBlock from both sides of the receiving string."	^ self trimLeft: aBlock right: aBlock</body><body package="GraphQLBetaExtentions">trimLeft: aLeftBlock right: aRightBlock	"Trim characters satisfying the condition given in aLeftBlock from the left side and aRightBlock from the right sides of the receiving string."	| left right |	left := 1.	right := self size.		[ left &lt;= right and: [ aLeftBlock value: (self at: left) ] ]		whileTrue: [ left := left + 1 ].			[ left &lt;= right and: [ aRightBlock value: (self at: right) ] ]		whileTrue: [ right := right - 1 ].			^ self copyFrom: left to: right</body></methods><methods><class-id>Core.Collection class</class-id> <category>instance creation</category><body package="GraphQLBetaExtentions">with: firstObject with: secondObject with: thirdObject with: fourthObject with: fifthObject	"Answer an instance of me, containing the five arguments as the elements."	^ self new		add: firstObject;		add: secondObject;		add: thirdObject;		add: fourthObject;		add: fifthObject;		yourself</body></methods><methods><class-id>Core.Collection</class-id> <category>converting</category><body package="GraphQLBetaExtentions">asDictionary	^ self as: Dictionary.</body></methods><methods><class-id>Core.Collection</class-id> <category>enumerating</category><body package="GraphQLBetaExtentions">associationsDo: aBlock	"Evaluate aBlock for each of the receiver's elements (key/value 	associations).  If any non-association is within, the error is not caught now,	but later, when a key or value message is sent to it."	self do: aBlock</body><body package="GraphQLBetaExtentions">collect: collectBlock thenDo: doBlock 	"Utility method to improve readability."		^ self do: [ :each|		doBlock value: (collectBlock value: each)]</body><body package="GraphQLBetaExtentions">difference: aCollection	"Answer the set theoretic difference of two collections. Pay attention that the difference is not commutative, hence the order is important."	"(#(a b c d e f) difference:  #(a b z k))&gt;&gt;&gt; #(#f #d #e #c)"	"(#(a b z k) difference: #(a b c d e f)) &gt;&gt;&gt; #(#k #z)"	| set |	set := self asSet.	aCollection do: [ :each | set remove: each ifAbsent: [  ] ].	^ self species withAll: set asArray</body><body package="GraphQLBetaExtentions">doWithIndex: aBlock2	"Support Set enumeration with a counter, even though not ordered"	| index |	index := 0.	self do: [:item | aBlock2 value: item value: (index := index+1)]</body></methods><methods><class-id>Core.Collection</class-id> <category>controlling</category><body package="GraphQLBetaExtentions">ifEmpty: emptyBlock	^self isEmpty		ifTrue: [emptyBlock value]		ifFalse: [self]</body><body package="GraphQLBetaExtentions">ifEmpty: emptyBlock ifNotEmpty: notEmptyBlock	^self isEmpty		ifTrue: [emptyBlock value]		ifFalse: [			0 == notEmptyBlock numArgs				ifTrue: [notEmptyBlock value]				ifFalse: [notEmptyBlock value: self]]</body></methods><methods><class-id>Core.Collection</class-id> <category>testing</category><body package="GraphQLBetaExtentions">ifNotEmpty: aBlock	"Evaluate the given block with the receiver as argument, answering its value    unless the receiver is empty, in which case answer the receiver."    ^self isEmpty          ifTrue: [self]          ifFalse: [aBlock cull: self] </body></methods><methods><class-id>Core.Collection</class-id> <category>enumerating</category><body package="GraphQLBetaExtentions">includesAll: aCollection 	"Answer whether all the elements of aCollection are in the receiver."	aCollection do: [:elem | (self includes: elem) ifFalse: [^ false]].	^ true</body></methods><methods><class-id>Core.Collection</class-id> <category>testing</category><body package="GraphQLBetaExtentions">includesAny: aCollection 	"Answer whether any element of aCollection is one of the receiver's elements."	aCollection do: [:elem | (self includes: elem) ifTrue: [^ true]].	^ false</body></methods><methods><class-id>Core.Collection</class-id> <category>enumerating</category><body package="GraphQLBetaExtentions">intersection: aCollection	"Answer the set theoretic intersection of two collections."	"(#(1 2 3 4) intersection: #(3 4 5)) &gt;&gt;&gt; #(3 4)"	"(#(1 2 3 4) intersection: #()) &gt;&gt;&gt; #()"	"(#() intersection: #(1 2 3 4)) &gt;&gt;&gt; #()"	| set outputSet |	set := self asSet.	outputSet := Set new.	aCollection 		do: [ :each | 			((set includes: each) and: [ (outputSet includes: each) not ])				ifTrue: [ outputSet add: each ] ].	^ self species withAll: outputSet asArray</body></methods><methods><class-id>Core.Collection</class-id> <category>testing</category><body package="GraphQLBetaExtentions">isCollection	^ true</body></methods><methods><class-id>Core.Collection</class-id> <category>enumerating</category><body package="GraphQLBetaExtentions">reject: rejectBlock thenCollect: collectBlock	"Utility method to improve readability."	^ (self reject: rejectBlock) collect: collectBlock</body><body package="GraphQLBetaExtentions">select: selectBlock thenCollect: collectBlock	"Utility method to improve readability."	^ (self select: selectBlock) collect: collectBlock</body><body package="GraphQLBetaExtentions">select: selectBlock thenDo: doBlock    "Utility method to improve readability.	Do not create the intermediate collection."    self do: [: each |        ( selectBlock value: each ) 			ifTrue: [ doBlock value: each ]    ].</body></methods><methods><class-id>PetitParser.PPFailure</class-id> <category>accessing</category><body package="GraphQLBetaExtentions">asJsonDictionary	| error |	error := GraphQLBeta.GQLError new		message: 'Syntax Error: ', self message;		locationFor: self on: context stream contents.	^ Dictionary new 		at: 'errors' put: (OrderedCollection new 			add: error; yourself);		yourself</body></methods><methods><class-id>Core.Metaclass</class-id> <category>testing</category><body package="GraphQLBetaExtentions">isClass	^ true</body></methods><methods><class-id>Core.Class</class-id> <category>accessing</category><body package="GraphQLBetaExtentions">allMethods	| methods |	methods := OrderedCollection new.	self withAllSuperclasses do: [:each | methods addAll: each methodDictionary values ].	^ methods</body><body package="GraphQLBetaExtentions">encodeAsJSONDataUsing: aJSONEncoder	aJSONEncoder encode: self toDictionary</body><body package="GraphQLBetaExtentions">gqlMethods	| methods |	methods := OrderedCollection new.	methods addAll: self methodDictionary values.	^ methods</body></methods><methods><class-id>Core.Class</class-id> <category>testing</category><body package="GraphQLBetaExtentions">isClass	^ true</body></methods><methods><class-id>Core.Class</class-id> <category>user interface</category><body package="GraphQLBetaExtentions">subclass: aSubclassSymbol instanceVariableNames: instVarNames classVariableNames: classVarNames package: aPackageSymbol	"Added to allow for a simplified subclass creation experience. "	^ self		subclass: aSubclassSymbol		instanceVariableNames: instVarNames		classVariableNames: classVarNames		poolDictionaries: ''		category: aPackageSymbol</body></methods><methods><class-id>Core.Class</class-id> <category>accessing</category><body package="GraphQLBetaExtentions">toDictionary	^ Dictionary new 		at: #name put: name;		at: #gqlMethods put: self gqlMethods;		yourself</body></methods><methods><class-id>PetitParser.PPParser</class-id> <category>accessing-properties</category><body package="GraphQLBetaExtentions">performs: aBlock	^ PPActionParser on: self block: aBlock</body></methods><methods><class-id>Core.SequenceableCollection class</class-id> <category>instance creation</category><body package="GraphQLBetaExtentions">new: newSize streamContents: blockWithArg	| stream |	stream := WriteStream on: (self new: newSize).	blockWithArg value: stream.	^ stream contents</body><body package="GraphQLBetaExtentions">streamContents: blockWithArg	^ self new: 100 streamContents: blockWithArg</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>accessing</category><body package="GraphQLBetaExtentions">allButFirst	"Answer a copy of the receiver containing all but the first	element. Raise an error if there are not enough elements."	^ self allButFirst: 1</body><body package="GraphQLBetaExtentions">atAll: indexArray	"Answer a new collection like the receiver which contains all elements	of the receiver at the indices of indexArray."	"(#('one' 'two' 'three' 'four') atAll: #(3 2 4)) &gt;&gt;&gt; #('three' 'two' 'four')"	| newCollection |	newCollection := self species new: indexArray size.	1 to: indexArray size do:		[:index |		newCollection at: index put: (self at: (indexArray at: index))].	^ newCollection</body><body package="GraphQLBetaExtentions">fifth	"Answer the fifth element of the receiver.	Raise an error if there are not enough elements."	^ self at: 5</body><body package="GraphQLBetaExtentions">fourth	"Answer the fourth element of the receiver.	Raise an error if there are not enough elements."	^ self at: 4</body><body package="GraphQLBetaExtentions">reduce: aBlock	"Fold the result of the receiver into aBlock. The argument aBlock must take two or more arguments. It applies the argument, binaryBlock cumulatively to the elements of the receiver. For sequenceable collections the elements will be used in order, for unordered collections the order is unspecified."		"#(1 2 3) reduce: [ :a :b | a + b ]		--&gt; 1 + 2 + 3 = 6	#(1 2 3 4 5) reduce: [ :a :b :c | a + b + c ]		--&gt; 1 + 2 + 3 + 4 + 5 = 15"			^ self reduceLeft: aBlock</body><body package="GraphQLBetaExtentions">reduceLeft: aBlock	"Fold the result of the receiver from left to right into aBlock. The argument aBlock must take two or more arguments."	"#(1 2 3) reduceLeft: [ :a :b | a - b ].		--&gt; ((1 - 2) - 3) = -4	#(1 + 3 - 5) reduceLeft: [ :a :op :b | a perform: op with: b ].		--&gt; ((1 + 3) - 5) = -1"	| arguments |	self emptyCheck.	arguments := Array new: aBlock argumentCount.	(arguments size = 0 or: [ (self size + 1) \\ (arguments size - 1) &gt; 0 ])		ifTrue: [ self error: 'Collection size and block argument count do not match.' ].	arguments at: 1 put: self first.	2 to: self size by: arguments size - 1 do: [ :index |		arguments			replaceFrom: 2 to: arguments size with: self startingAt: index;			at: 1 put: (aBlock valueWithArguments: arguments) ].	^ arguments first</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>enumerating</category><body package="GraphQLBetaExtentions">reject: rejectBlock thenDo: aBlock	"Refer to the comment in Collection&gt;&gt;#reject:thenDo:"		|  each |		1 to: self size do: [ :index |		(rejectBlock value: (each := self at: index))			ifFalse: [ aBlock value: each ]].</body><body package="GraphQLBetaExtentions">select: selectBlock thenCollect: collectBlock	"Optimized version of Collection&gt;&gt;#select:thenCollect:"		| each |	^ self class new: self size streamContents: [ :stream|		1 to: self size do: [ :index |			(selectBlock value: (each := self at: index))				ifTrue: [ stream nextPut: (collectBlock value: each) ]]]</body><body package="GraphQLBetaExtentions">select: selectBock thenDo: aBlock	"Refer to the comment in Collection&gt;&gt;#select:thenDo:"		| each |	1 to: self size do: [ :index |		(selectBock value: (each := self at: index))			ifTrue: [ aBlock value: each ]].</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>accessing</category><body package="GraphQLBetaExtentions">sixth	"Answer the sixth element of the receiver.	Raise an error if there are not enough elements."	^ self at: 6</body><body package="GraphQLBetaExtentions">third	^self at: 3</body></methods><methods><class-id>Core.ArrayedCollection class</class-id> <category>instance creation</category><body package="GraphQLBetaExtentions">with: firstObject with: secondObject with: thirdObject with: fourthObject with: fifthObject	"Answer a new instance of me, containing only the five arguments as	elements."	| newCollection |	newCollection := self new: 5.	newCollection at: 1 put: firstObject.	newCollection at: 2 put: secondObject.	newCollection at: 3 put: thirdObject.	newCollection at: 4 put: fourthObject.	newCollection at: 5 put: fifthObject.	^newCollection</body></methods><methods><class-id>Core.Dictionary class</class-id> <category>instance creation</category><body package="GraphQLBetaExtentions">newFrom: aDict 	"Answer an instance of me containing the same associations as aDict.	 Error if any key appears twice."	| newDictionary |	newDictionary := self new: aDict size.		aDict associationsDo:		[:x |		(newDictionary includesKey: x key)			ifTrue: [self error: 'Duplicate key: ', x key printString]			ifFalse: [newDictionary add: x]].	^ newDictionary"	NewDictionary newFrom: {1-&gt;#a. 2-&gt;#b. 3-&gt;#c}	{1-&gt;#a. 2-&gt;#b. 3-&gt;#c} as: NewDictionary	NewDictionary newFrom: {1-&gt;#a. 2-&gt;#b. 1-&gt;#c}	{1-&gt;#a. 2-&gt;#b. 1-&gt;#c} as: NewDictionary"</body></methods><methods><class-id>Core.Dictionary</class-id> <category>accessing</category><body package="GraphQLBetaExtentions">at: key ifPresent: aPresentBlock ifAbsent: anAbsentBlock	"Lookup the given key in the receiver. If it is present, answer the	value of evaluating the first block optionally with the value associated	with the key.	Otherwise answer the value of the second block."	self at: key ifPresent: [:v | ^ aPresentBlock cull: v].	^ anAbsentBlock value</body><body package="GraphQLBetaExtentions">at: key ifPresent: aPresentBlock ifAbsentPut: anAbsentBlock	"Lookup the given key in the receiver. If it is present, answer the	value of evaluating the first block optionally with the value associated	with the key.	Otherwise store and return the result of evaluating the second block as the	new value of the key."	^ self		at: key		ifPresent: aPresentBlock		ifAbsent: [self at: key put: anAbsentBlock value]</body></methods><methods><class-id>Core.Dictionary</class-id> <category>testing</category><body package="GraphQLBetaExtentions">isDictionary	^true</body></methods><methods><class-id>Core.Dictionary</class-id> <category>enumerating</category><body package="GraphQLBetaExtentions">valuesDo: aBlock 		self keysAndValuesDo: [:key :value | aBlock value: value ]</body></methods><methods><class-id>GraphQLBeta.GraphQLObject class</class-id> <category>instance creation</category><body package="GraphQLBetaExtentions">new	^super new initialize</body></methods><methods><class-id>Core.Set</class-id> <category>enumerating</category><body package="GraphQLBetaExtentions">intersection: aCollection	"Answer the set theoretic intersection of two collections.	Optimized version for Sets where no intermediate Set is necessary"	"(#(1 2 3 4) asSet intersection: #(3 4 5) asSet) &gt;&gt;&gt; #(3 4) asSet"	"(#(1 2 3 4) asSet intersection: #() asSet) &gt;&gt;&gt; Set new"	"( #() asSet intersection: #(1 2 3 4) asSet) &gt;&gt;&gt; Set new"		| outputSet |	outputSet := self class new.	aCollection do: [ :each|		((self includes: each) and: [(outputSet includes: each) not])				ifTrue: [ outputSet add: each]].	^ outputSet</body></methods><methods><class-id>Core.Point</class-id> <category>accessing</category><body package="GraphQLBetaExtentions">encodeAsJSONDataUsing: aJSONEncoder	aJSONEncoder encode: self toDictionary</body><body package="GraphQLBetaExtentions">toDictionary	^ Dictionary new 		at: #x put: x;		at: #y put: y;		yourself</body></methods><methods><class-id>SUnit.TestCase</class-id> <category>accessing</category><body package="GraphQLBetaExtentions">assertCollection: actual hasSameElements: expected	"Assert that a collection contains the same elements as the given collection. Order is not checked, only the presence/absence of elements."	| missingElements additionalElements |		additionalElements := actual difference: expected.	missingElements := expected difference: (actual intersection: expected).	self 		assert: (additionalElements isEmpty and: [ missingElements isEmpty ])		description: (String streamContents: 			[:stream |			stream				nextPutAll: 'Given Collections do not match!'; lf;				tab; nextPutAll: 'additions : '; print: additionalElements asArray; lf;				tab; nextPutAll: 'missing: '; print: missingElements asArray; lf ])</body></methods><methods><class-id>Core.Behavior</class-id> <category>accessing</category><body package="GraphQLBetaExtentions">methodDict	^ self methodDictionary</body></methods><methods><class-id>Core.UndefinedObject</class-id> <category>testing</category><body package="GraphQLBetaExtentions">isNotNil 	"Refer to the comment in Object|isNotNil."	^false</body></methods><methods><class-id>Kernel.BlockClosure</class-id> <category>accessing</category><body package="GraphQLBetaExtentions">argumentCount	"Answer the number of arguments that must be used to evaluate this block"	^ self numArgs</body></methods><methods><class-id>Core.WriteStream</class-id> <category>accessing</category><body package="GraphQLBetaExtentions">lf	self nextPut: Character lf</body></methods><methods><class-id>Graphics.Rectangle</class-id> <category>accessing</category><body package="GraphQLBetaExtentions">encodeAsJSONDataUsing: aJSONEncoder	aJSONEncoder encode: self toDictionary</body><body package="GraphQLBetaExtentions">toDictionary	^ Dictionary new	   at: #origin put: origin;	   at: #corner put: corner;	   yourself</body></methods><methods><class-id>Kernel.NameSpace</class-id> <category>accessing</category><body package="GraphQLBetaExtentions">classNamed: symbol	^ Smalltalk  allClasses		detect: [:cls | cls name = symbol ]		ifFound: [:cls | cls ]		ifNone: [ nil ]</body><body package="GraphQLBetaExtentions">globals	^ self</body></methods><methods><class-id>Core.OrderedCollection</class-id> <category>enumerating</category><body package="GraphQLBetaExtentions">select: selectBlock thenCollect: collectBlock    " Optimized version Collection&gt;&gt;#select:thenCollect: "	| newCollection element |    newCollection := self copyEmpty.    firstIndex to: lastIndex do: [ :index |		element := self at: index.		(selectBlock value: element) 			ifTrue: [ newCollection addLast: (collectBlock value: element) ]].    ^ newCollection</body></methods><methods><class-id>Core.Array</class-id> <category>testing</category><body package="GraphQLBetaExtentions">isArray	^true</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>PPParser</name><environment>PetitParser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>properties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Parsers</category><attributes><package>PetitParser</package></attributes></class><class><name>Collection</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>SequenceableCollection</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>Array</name><environment>Core</environment><super>Core.ArrayedCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Arrayed</category><attributes><package>Collections-Arrayed</package></attributes></class><class><name>WriteStream</name><environment>Core</environment><super>Core.InternalStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>Point</name><environment>Core</environment><super>Core.ArithmeticValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars>x y </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Geometry</category><attributes><package>Graphics-Geometry</package></attributes></class><class><name>Behavior</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>superclass methodDict format subclasses </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>Rectangle</name><environment>Graphics</environment><super>Graphics.Geometric</super><private>false</private><indexed-type>none</indexed-type><inst-vars>origin corner </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Geometry</category><attributes><package>Graphics-Geometry</package></attributes></class><class><name>BlockClosure</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method outerContext copiedValues </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>UndefinedObject</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Metaclass</name><environment>Core</environment><super>Core.ClassDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>thisClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>TestCase</name><environment>SUnit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnitToo</package></attributes></class><class><name>Class</name><environment>Core</environment><super>Core.ClassDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name classPool environment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>Set</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>tally </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>Dictionary</name><environment>Core</environment><super>Core.Set</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>String</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>NameSpace</name><environment>Kernel</environment><super>Kernel.GeneralNameSpace</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parent name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Name Spaces</category><attributes><package>System-Name Spaces</package></attributes></class><class><name>PPFailure</name><environment>PetitParser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>message context position </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Core</category><attributes><package>PetitParser</package></attributes></class><class><name>OrderedCollection</name><environment>Core</environment><super>Core.SequenceableCollection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>firstIndex lastIndex </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Sequenceable</category><attributes><package>Collections-Sequenceable</package></attributes></class></st-source>