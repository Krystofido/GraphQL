<?xml version="1.0"?><st-source><!-- Name: PetitExtentionsBundleName: PetitExtentionsBundleStructure: a Store.BundleForParcelDevelopmentPrerequisites: #(#(#any 'PetitParser' '') #(#any 'PetitTests' ''))Parcel: nilParcelName: PetitExtentionsPrerequisiteDescriptions: #(#(#name 'PetitParser' #componentType #package) #(#name 'PetitTests' #componentType #package))PrerequisiteParcels: #(#('PetitParser' '') #('PetitTests' ''))Date: 4:36:10 PM April 20, 2018 --><time-stamp>From VisualWorksÂ® Personal Use Edition, 8.2 of 15 de julio de 2016 on 20 de abril de 2018 at 16:36:10</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><methods><class-id>Core.Object</class-id> <category>*petitparser-core-testing</category><body package="PetitExtentions">asString	^self printString</body></methods><methods><class-id>Core.Object</class-id> <category>*petitparser-core-converting</category><body package="PetitExtentions">becomeForward: other	^ self oneWayBecome: other</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="PetitExtentions">isCharacter	^false</body></methods><methods><class-id>Core.Object</class-id> <category>*petitparser-core-testing</category><body package="PetitExtentions">isPetitFailure	^ false</body><body package="PetitExtentions">isPetitParser	^ false</body></methods><methods><class-id>Core.String</class-id> <category>converting</category><body package="PetitExtentions">asInteger	^self asNumber asInteger</body></methods><methods><class-id>Core.Collection</class-id> <category>*petitparser-core-converting</category><body package="PetitExtentions">asParser    	"Create a range of characters between start and stop."	(self allSatisfy: [ :e | e isCharacter ]) ifTrue: [ 		| charSet |		charSet := PetitParser.PPCharSetPredicate on: [ :char | self includes: char ] .     	^ PetitParser.PPPredicateObjectParser on: charSet message: 'One of these charactes expected: ', self printString.	].	^ super asParser	"		($a to:$f) asParser parse:'a'		($a to:$f) asParser parse:'g'	"</body></methods><methods><class-id>PetitParser.PPContext class</class-id> <category>instance creation</category><body package="PetitExtentions">new	^ super new initialize</body></methods><methods><class-id>Core.Character</class-id> <category>*petitparser-core-converting</category><body package="PetitExtentions">asString	^ String with: self</body></methods><methods><class-id>Core.Character</class-id> <category>testing</category><body package="PetitExtentions">isCharacter	^true</body></methods><methods><class-id>Core.Character</class-id> <category>*petitparser-core-converting</category><body package="PetitExtentions">to: other	"Answer with a collection in ascii order -- $a to: $z"	^ (self asInteger to: other asInteger) collect:				[:ascii | Character value: ascii]</body></methods><methods><class-id>PetitParser.PPRepeatingParser class</class-id> <category>instance creation</category><body package="PetitExtentions">new	^ super new initialize</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>accessing</category><body package="PetitExtentions">second	"Answer the second element of the receiver.	Raise an error if there are not enough elements."	^ self at: 2</body></methods><methods><class-id>Core.UndefinedObject</class-id> <category>*petitparser-core-converting</category><body package="PetitExtentions">asParser	"Answer a parser that succeeds and does not consume anything."		^ PetitParser.PPEpsilonParser new</body></methods><methods><class-id>PetitParser.PPListParser class</class-id> <category>instance creation</category><body package="PetitExtentions">new	^ super new initialize</body></methods><methods><class-id>Core.PositionableStream</class-id> <category>*petitparser-core</category><body package="PetitExtentions">back	"Go back one element and return it."	self position = 0 ifTrue: [self positionError].	self skip: -1.	^ self peek</body><body package="PetitExtentions">peekBack	"Return the element at the previous position, without changing position.  Use indirect messages in case self is a StandardFileStream."	| element |	element := self back.	self skip: 1.	^ element</body><body package="PetitExtentions">positionError	"Since I am not necessarily writable, it is up to my subclasses to override 	position: if expanding the collection is preferrable to giving this error."	self error: 'Attempt to set the position of a PositionableStream out of bounds'</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Collection</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>SequenceableCollection</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>String</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>PositionableStream</name><environment>Core</environment><super>Core.PeekableStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>collection position readLimit writeLimit policy </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>Character</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>immediate</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>UndefinedObject</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class></st-source>