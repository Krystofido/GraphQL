<?xml version="1.0"?><st-source><!-- Name: GraphQLBetaBundleName: GraphQLBetaBundleStructure: a Store.BundleForParcelDevelopmentPrerequisites: #(#(#any 'PetitParser' '') #(#any 'SUnitToo' '') #(#any 'PetitTests' '') #(#any 'SUnitToo(lsoverage)' ''))Parcel: nilParcelName: GraphQLBetaPrerequisiteDescriptions: #(#(#name 'PetitParser' #componentType #package) #(#name 'SUnitToo' #componentType #package) #(#name 'PetitTests' #componentType #package) #(#name 'SUnitToo(lsoverage)' #componentType #package))PrerequisiteParcels: #(#('PetitParser' '') #('SUnitToo' '') #('PetitTests' '') #('SUnitToo(lsoverage)' ''))Date: 4:36:25 PM April 20, 2018 --><time-stamp>From VisualWorksÂ® Personal Use Edition, 8.2 of 15 de julio de 2016 on 20 de abril de 2018 at 16:36:25</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>GraphQLBeta</name><environment>Smalltalk</environment><private>false</private><imports>			private PetitParser.*			private Smalltalk.*			private PetitTests.*			</imports><category>GraphQLBeta</category><attributes><package>GraphQLBeta</package></attributes></name-space><class><name>GraphQLObject</name><environment>GraphQLBeta</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta</category><attributes><package>GraphQLBeta</package></attributes></class><comment><class-id>GraphQLBeta.GraphQLObject</class-id><body>I'm the default parent of the classes of the package GraphQLBeta.</body></comment><class><name>GQLSNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GraphQLObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>position </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-NodesSchema</category><attributes><package>GraphQLBeta-NodesSchema</package></attributes></class><comment><class-id>GraphQLBeta.GQLSNode</class-id><body>I represent a node generated by parsing the schema textPublic API and Key Messages- acceptVisitor:- initialize- position- position:    Instance Variables	position:		&lt;Integer&gt;</body></comment><class><name>GQLSArgumentFieldNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLSNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name type </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-NodesSchema</category><attributes><package>GraphQLBeta-NodesSchema</package></attributes></class><comment><class-id>GraphQLBeta.GQLSArgumentFieldNode</class-id><body>I represent an argument of a field node, like:name : String! number : Intother : ObjectPublic API and Key Messages- name- name: - type- type:    Instance Variables	name:		&lt;String&gt;	type:		&lt;GQLSTypeNode&gt;    Implementation Points</body></comment><class><name>GQLA</name><environment>GraphQLBeta</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Test-Trash</category><attributes><package>GraphQLBeta-Test-Trash</package></attributes></class><comment><class-id>GraphQLBeta.GQLA</class-id><body>Example class for testsPublic API and Key Messages- hey- heyID- id:   One simple example is simply gorgeous.	| anObject |	anObject := A new id: 1000.	anObject heyID.     Instance Variables	id:		Int</body></comment><class><name>GQLSTypeNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLSNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-NodesSchema</category><attributes><package>GraphQLBeta-NodesSchema</package></attributes></class><comment><class-id>GraphQLBeta.GQLSTypeNode</class-id><body>I represent a type node.For more information see my subclasses</body></comment><class><name>GQLSWrapTypeNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLSTypeNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>wrappedType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-NodesSchema</category><attributes><package>GraphQLBeta-NodesSchema</package></attributes></class><comment><class-id>GraphQLBeta.GQLSWrapTypeNode</class-id><body>I represent a wrap type. Public API and Key Messages- wrappedType- wrappedType:    Instance Variables	wrappedType:		&lt;GQLSTypeNode&gt;</body></comment><class><name>GQLSListTypeNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLSWrapTypeNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-NodesSchema</category><attributes><package>GraphQLBeta-NodesSchema</package></attributes></class><comment><class-id>GraphQLBeta.GQLSListTypeNode</class-id><body>I represent a list type.</body></comment><class><name>GQLNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GraphQLObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>position </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLNode</class-id><body>I represent a node of a graphql request Public API and Key Messages- acceptVisitor:  - executeOn:with:using:To see more information go to the subclasses</body></comment><class><name>GQLSelectionNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>directives </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLSelectionNode</class-id><body>I represent a selection on a request.Public API and Key Messages- directives    Instance Variables	directives:		&lt;Array&gt;    Implementation Points</body></comment><class><name>GQLFieldNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLSelectionNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>alias name arguments fullName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLFieldNode</class-id><body>I represent a field on a request.Public API and Key Messages- alias- arguments- fullName- isScalar- name    Instance Variables	alias:		&lt;String&gt;	arguments:		&lt;Array&gt;	fullName:		&lt;String&gt;	name:		&lt;String&gt;    Implementation Points</body></comment><class><name>GQLScalarFieldNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLFieldNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLScalarFieldNode</class-id><body>I represent a scalar field on a request.Public API and Key Messages- isScalar</body></comment><class><name>GQLAbstractGrammar</name><environment>GraphQLBeta</environment><super>PetitParser.PPCompositeParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sourceCharacter unicodeBOM whiteSpace lineTerminator commentChar comment comma token punctuator tokenName intValue floatValue stringValue integerPart nonZeroDigit digit fractionalPart exponentPart exponentIndicator sign stringDelimiter stringCharacter escapedUnicode escapedCharacter ignored booleanValue insignificantToken intType floatType scalarType stringType booleanType idType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Parser</category><attributes><package>GraphQLBeta-Parser</package></attributes></class><comment><class-id>GraphQLBeta.GQLAbstractGrammar</class-id><body>I represent a abstract grammar.Public API and Key Messages- booleanValue- comma- comment- commentChar- digit- escapedCharacter - escapedUnicode - exponentIndicator - exponentPart - floatValue - fractionalPart -ignored - insignificantToken - intValue - integerPart - lineTerminator - nonZeroDigit - punctuator - sign - sourceCharacter - start- stringCharacter - stringDelimiter - stringValue - token- tokenName- unicodeBOM- whiteSpace </body></comment><class><name>GQLRequestGrammar</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLAbstractGrammar</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selection field fragmentSpread inlineFragment alias arguments argument value fragmentName typeCondition namedType variable nullValue enumValue listValue objectValue variableDefinition type listType nonNullType directive definition operationDefinition fragmentDefinition operationType variableDefinitions directives selectionSet document defaultValue objectField operation nonNullNamedType nonNullListType named scalarField nonScalarField </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Parser</category><attributes><package>GraphQLBeta-Parser</package></attributes></class><comment><class-id>GraphQLBeta.GQLRequestGrammar</class-id><body>I represent the grammar defined for a graphql request.Public API and Key Messages- alias- argument- arguments- defaultValue- definition- directive- document- enumValue- field- fragmentDefinition- fragmentName- fragmentSpread- inlineFragment- listType- listValue- namedType- nonNullType- nullValue- objectField- objectValue- operationDefinition- operationType- selection- selectionSet- start- type- typeCondition- value- variable- variableDefinition- variableDefinitions</body></comment><class><name>GQLSingleAnonimousQueryGrammar</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLRequestGrammar</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Parser</category><attributes><package>GraphQLBeta-Parser</package></attributes></class><comment><class-id>GraphQLBeta.GQLSingleAnonimousQueryGrammar</class-id><body>I represent a  part of the grammar for the graphql request.Only fields with arguments. No fragments, no alias.Public API and Key Messages- document- field- selection- selectionSet- start</body></comment><class><name>GQLSingleAnonimousQueryEvaluator</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLSingleAnonimousQueryGrammar</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Parser</category><attributes><package>GraphQLBeta-Parser</package></attributes></class><comment><class-id>GraphQLBeta.GQLSingleAnonimousQueryEvaluator</class-id><body>I represent a evaluator of the graphql query single.Public API and Key Messages- argument- arguments- booleanValue- document- enumValue- field- floatValue- intValue- listValue- nullValue- objectField- objectValue- selection- selectionSet- stringValue- variable</body></comment><class><name>GQLValueNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLValueNode</class-id><body>I represent a value on a request.Public API and Key Messages- value    Instance Variables	value:		&lt;String&gt;    Implementation Points</body></comment><class><name>GQLSFieldNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLSNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name type arguments fullName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-NodesSchema</category><attributes><package>GraphQLBeta-NodesSchema</package></attributes></class><comment><class-id>GraphQLBeta.GQLSFieldNode</class-id><body>I represent a field node, I'm present on object and interface types.Public API and Key Messages- addArguments: - arguments- arguments: - fullName - getArgument: - name- name: - type- type:    Instance Variables	arguments:		&lt;Dictionary&gt;	fullName:		&lt;String&gt;	name:		&lt;String&gt;	type:		&lt;GQLSTypeNode&gt;</body></comment><class><name>GQLSInputObjectFieldNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLSFieldNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-NodesSchema</category><attributes><package>GraphQLBeta-NodesSchema</package></attributes></class><comment><class-id>GraphQLBeta.GQLSInputObjectFieldNode</class-id><body>I represent a field of a input object type. My type only could be: scalar, enum or an input object.</body></comment><class><name>GQLRequestGrammarTest</name><environment>GraphQLBeta</environment><super>PetitTests.PPCompositeParserTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Tests</category><attributes><package>GraphQLBeta-Tests</package></attributes></class><comment><class-id>GraphQLBeta.GQLRequestGrammarTest</class-id><body>A GQLSchemaGrammarTest is a test class for testing the behavior of GQLSchemaGrammar</body></comment><class><name>GQLTestQueryType</name><environment>GraphQLBeta</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Test-Utils</category><attributes><package>GraphQLBeta-Test-Utils</package></attributes></class><comment><class-id>GraphQLBeta.GQLTestQueryType</class-id><body>I represent a test query to test graphql requestPublic API and Key Messages- films- hello</body></comment><class><name>GQLSingleAnonimousQueryGrammarTest</name><environment>GraphQLBeta</environment><super>PetitTests.PPCompositeParserTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Tests</category><attributes><package>GraphQLBeta-Tests</package></attributes></class><comment><class-id>GraphQLBeta.GQLSingleAnonimousQueryGrammarTest</class-id><body>A GQLSingleAnonimousQueryGrammarTest is a test class for testing the behavior of GQLSingleAnonimousQueryGrammar</body></comment><class><name>GQLFragmentSpreadNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLSelectionNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLFragmentSpreadNode</class-id><body>I represent a fragment spread on a request.Public API and Key Messages- name    Instance Variables	name:		&lt;String&gt;    Implementation Points</body></comment><class><name>GQLSNamedTypeNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLSTypeNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-NodesSchema</category><attributes><package>GraphQLBeta-NodesSchema</package></attributes></class><comment><class-id>GraphQLBeta.GQLSNamedTypeNode</class-id><body>I represent a named type. Public API and Key Messages- name- name:    Instance Variables	name:		&lt;String&gt;</body></comment><class><name>GQLSScalarTypeNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLSNamedTypeNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-NodesSchema</category><attributes><package>GraphQLBeta-NodesSchema</package></attributes></class><comment><class-id>GraphQLBeta.GQLSScalarTypeNode</class-id><body>I represent a scalar type.Public API and Key Messages- isInputTypeFor more information see my subclasses.</body></comment><class><name>GQLSBooleanTypeNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLSScalarTypeNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-NodesSchema</category><attributes><package>GraphQLBeta-NodesSchema</package></attributes></class><comment><class-id>GraphQLBeta.GQLSBooleanTypeNode</class-id><body>I represent a boolean type.</body></comment><class><name>GQLSelectionSetNodeTest</name><environment>GraphQLBeta</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Tests</category><attributes><package>GraphQLBeta-Tests</package></attributes></class><comment><class-id>GraphQLBeta.GQLSelectionSetNodeTest</class-id><body>A GQLSelectionSetNodeTest is a test class for testing the behavior of GQLSelectionSetNode</body></comment><class><name>GQLFloatNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLValueNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLFloatNode</class-id><body>I represent a float value.Public API and Key Messages- executeOn:with:using:    Implementation Points</body></comment><class><name>GQLAbstractGrammarTest</name><environment>GraphQLBeta</environment><super>PetitTests.PPCompositeParserTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Tests</category><attributes><package>GraphQLBeta-Tests</package></attributes></class><comment><class-id>GraphQLBeta.GQLAbstractGrammarTest</class-id><body>A GQLAbstractGrammarTest is a test class for testing the behavior of GQLAbstractGrammar</body></comment><class><name>GQLArgumentNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLArgumentNode</class-id><body>I represent an argument on the request.Public API and Key Messages- name- name:- value- value:- executeOn:with:using:    Instance Variables	name:		&lt;String&gt;	value:		&lt;GQLValueNode&gt;</body></comment><class><name>GQLSEnumTypeNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLSNamedTypeNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stringValues </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-NodesSchema</category><attributes><package>GraphQLBeta-NodesSchema</package></attributes></class><comment><class-id>GraphQLBeta.GQLSEnumTypeNode</class-id><body>I represent a enum type. I have several values.Public API and Key Messages- addValues:- values    Instance Variables	stringValues:		&lt;Array&gt;    Implementation Points</body></comment><class><name>GQLDefinitionNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLDefinitionNode</class-id><body>I represent a definition on the request.For more information see my subclasses.</body></comment><class><name>GQLOperationDefinitionNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLDefinitionNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLOperationDefinitionNode</class-id><body>I represent the definition of an operation on the request.To more information see my subclasses.</body></comment><class><name>GQLListNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLValueNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLListNode</class-id><body>I represent a list value. My value is an array of other valuesPublic API and Key Messages- executeOn:with:using:    Implementation Points</body></comment><class><name>GQLSObjectTypeNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLSNamedTypeNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fieldSet interfaces </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-NodesSchema</category><attributes><package>GraphQLBeta-NodesSchema</package></attributes></class><comment><class-id>GraphQLBeta.GQLSObjectTypeNode</class-id><body>I represent a object type, i have fields and maybe some interfaces.Public API and Key Messages- addFields:- fields- getField:- implements:- interfaces    Instance Variables	fieldSet:		&lt;Dictionary&gt;	interfaces:		&lt;Array&gt;    Implementation Points</body></comment><class><name>GQLVariableNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLValueNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLVariableNode</class-id><body>I represent a variable value.</body></comment><class><name>GQLException</name><environment>GraphQLBeta</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars>node </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta</category><attributes><package>GraphQLBeta</package></attributes></class><comment><class-id>GraphQLBeta.GQLException</class-id><body>I represent an exception of graphql, I know the node that raise some kind of exception on the parsing or the validation or the type checking of the schema.Public API and Key Messages- node      - node: - signal   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Instance Variables	node:		&lt;Object&gt;    Implementation Points</body></comment><class><name>GQLSchemaGrammarEvaluatorTest</name><environment>GraphQLBeta</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Tests</category><attributes><package>GraphQLBeta-Tests</package></attributes></class><comment><class-id>GraphQLBeta.GQLSchemaGrammarEvaluatorTest</class-id><body>A GQLSchemaGrammarEvaluatorTest is a test class for testing the behavior of GQLSchemaGrammarEvaluator</body></comment><class><name>GraphQL</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GraphQLObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>rootInstance schema validator </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta</category><attributes><package>GraphQLBeta</package></attributes></class><comment><class-id>GraphQLBeta.GraphQL</class-id><body>I handle a request given a schema and an entry point. For default the schema will be always in the class side of the class Query.Public API and Key Messages- createSchema: - handleRequest:- schema- schema:Internal Representation and Key Implementation Points.    Instance Variables	rootInstance:		&lt;Query&gt;	schema:		&lt;GQLSchema&gt;	validator:		&lt;GQLTypeValidator&gt;    Implementation Points</body></comment><class><name>GQLObjectNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLValueNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>objectFields </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLObjectNode</class-id><body>I represent a object value. I'm a complex value, so I have object fields, like:{ name : "Juan", lastName : "Fernandez" }Public API and Key Messages- objectFields    Instance Variables	objectFields:		&lt;Array&gt;    Implementation Points</body></comment><class><name>GQLDocumentNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>definitions </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLDocumentNode</class-id><body>I represent a document. The principal node of the request.Public API and Key Messages- definitions- executeOn:with:using:    Instance Variables	definitions:		&lt;Array&gt;    Implementation Points</body></comment><class><name>GQLSInputObjectTypeNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLSNamedTypeNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fieldSet </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-NodesSchema</category><attributes><package>GraphQLBeta-NodesSchema</package></attributes></class><comment><class-id>GraphQLBeta.GQLSInputObjectTypeNode</class-id><body>I represent a input object type. I'm a input type, used as type of an argument.Public API and Key Messages- addFields:- getField:    Instance Variables	fieldSet:		&lt;Dictionary&gt;    Implementation Points</body></comment><class><name>GQLRequestGrammarEvaluatorTest</name><environment>GraphQLBeta</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Tests</category><attributes><package>GraphQLBeta-Tests</package></attributes></class><class><name>GQLRequestGrammarEvaluator</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLRequestGrammar</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Parser</category><attributes><package>GraphQLBeta-Parser</package></attributes></class><comment><class-id>GraphQLBeta.GQLRequestGrammarEvaluator</class-id><body>I represent a evaluator of the graphql request.</body></comment><class><name>GQLObjectFieldNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLObjectFieldNode</class-id><body>I represent a field of an object value.Public API and Key Messages- name- value    Instance Variables	name:		&lt;String&gt;	value:		&lt;GQLValueNode&gt;    Implementation Points</body></comment><class><name>GQLSInterfaceTypeNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLSNamedTypeNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fields </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-NodesSchema</category><attributes><package>GraphQLBeta-NodesSchema</package></attributes></class><comment><class-id>GraphQLBeta.GQLSInterfaceTypeNode</class-id><body>I represent a interface type. I have fields.Public API and Key Messages- addFields:- fields- getField:   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Instance Variables	fields:		&lt;Object&gt;    Implementation Points</body></comment><class><name>GQLStringNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLValueNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLStringNode</class-id><body>I represent a string value.Public API and Key Messages- executeOn:with:using:    Implementation Points</body></comment><class><name>GQLNonScalarFieldNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLFieldNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selectionSet </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLNonScalarFieldNode</class-id><body>I represent a non scalar field. This means that I have a selectionSet. For examplefieldNonScalar{	fieldScalar}Public API and Key Messages- isScalar- selectionSet    Instance Variables	selectionSet:		&lt;GQLSelectionSetNode&gt;    Implementation Points</body></comment><class><name>GQLBooleanNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLValueNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLBooleanNode</class-id><body>I represent a boolean value.Public API and Key Messages- executeOn:with:using:    Implementation Points</body></comment><class><name>GQLValidationException</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta</category><attributes><package>GraphQLBeta</package></attributes></class><comment><class-id>GraphQLBeta.GQLValidationException</class-id><body>I represent an exception of validation on graphql, I'm only called if the GQLSchema has a problem validating the parts of the schema vs the image of Smalltalk.Public API and Key Messages- messageClassText- messageMethodText:  aClassInstance Variables	node:		&lt;Object&gt;GQLValidationException new 			node: field; 			messageMethodText: Object</body></comment><class><name>GQLSIntTypeNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLSScalarTypeNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-NodesSchema</category><attributes><package>GraphQLBeta-NodesSchema</package></attributes></class><comment><class-id>GraphQLBeta.GQLSIntTypeNode</class-id><body>I represent a int type.</body></comment><class><name>GQLSchemaGrammarTest</name><environment>GraphQLBeta</environment><super>PetitTests.PPCompositeParserTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Tests</category><attributes><package>GraphQLBeta-Tests</package></attributes></class><comment><class-id>GraphQLBeta.GQLSchemaGrammarTest</class-id><body>A GQLSchemaGrammarTest is a test class for testing the behavior of GQLSchemaGrammar</body></comment><class><name>GQLTestFilm</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GraphQLObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id filmName rating </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Test-Utils</category><attributes><package>GraphQLBeta-Test-Utils</package></attributes></class><comment><class-id>GraphQLBeta.GQLTestFilm</class-id><body>I represent a film to test the graphql request.Public API and Key Messages- id   - initialize:name:rating:- name- rating- toDictionaryInternal Representation and Key Implementation Points.    Instance Variables	filmName:		&lt;String&gt;	id:		&lt;String&gt;	rating:		&lt;Integer&gt;Example	GQLTestFilm new: 1 name: 'Bella' rating: 7</body></comment><class><name>GraphQLBetaTest</name><environment>GraphQLBeta</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>graphQL schema evaluator </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Tests</category><attributes><package>GraphQLBeta-Tests</package></attributes></class><class><name>GQLVariableDefinitionNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name type defaultValue </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLVariableDefinitionNode</class-id><body>I represent a variable definition on the request.Public API and Key Messages- defaultValue- name- type    Instance Variables	defaultValue:		&lt;GQLValueNode&gt;	name:		&lt;String&gt;	type:		&lt;GQLSTypeNode&gt;    Implementation Points</body></comment><class><name>GQLSFloatTypeNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLSScalarTypeNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-NodesSchema</category><attributes><package>GraphQLBeta-NodesSchema</package></attributes></class><comment><class-id>GraphQLBeta.GQLSFloatTypeNode</class-id><body>I represent a Float type.</body></comment><class><name>GQLSelectionSetNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLOperationDefinitionNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selections </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLSelectionSetNode</class-id><body>I represent a selection set on a request.Public API and Key Messages- selections- collectFields- mergeSelectionSet:with:    Instance Variables	selections:		&lt;Array&gt;    Implementation Points</body></comment><class><name>GQLSStringTypeNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLSScalarTypeNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-NodesSchema</category><attributes><package>GraphQLBeta-NodesSchema</package></attributes></class><comment><class-id>GraphQLBeta.GQLSStringTypeNode</class-id><body>I represent a string type.</body></comment><class><name>GQLOperationNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLOperationDefinitionNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>type name variableDefinitions directives selectionSet </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLOperationNode</class-id><body>I represent an operation node of a request.Public API and Key Messages- directives- name- selectionSet- type- variableDefinitions    Instance Variables	directives:		&lt;Array&gt;	name:		&lt;String&gt;	selectionSet:		&lt;GQLSelectionSetNode&gt;	type:		&lt;GQLSTypeNode&gt;	variableDefinitions:		&lt;Array&gt;    Implementation Points</body></comment><class><name>GQLSingleAnonimousQueryEvaluatorTest</name><environment>GraphQLBeta</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Tests</category><attributes><package>GraphQLBeta-Tests</package></attributes></class><comment><class-id>GraphQLBeta.GQLSingleAnonimousQueryEvaluatorTest</class-id><body>A GQLSingleAnonimousQueryEvaluatorTest is a test class for testing the behavior of GQLSingleAnonimousQueryEvaluator</body></comment><class><name>Query</name><environment>GraphQLBeta</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>schema </class-inst-vars><imports></imports><category>GraphQLBeta</category><attributes><package>GraphQLBeta</package></attributes></class><comment><class-id>GraphQLBeta.Query</class-id><body>On my class side is defined the schema text and at my instance side are defined all the methods that are called by the schema. </body></comment><class><name>GQLInlineFragmentNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLSelectionNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>typeCondition selectionSet </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLInlineFragmentNode</class-id><body>I represent an inline fragment on a request.Public API and Key Messages- selectionSet- typeCondition    Instance Variables	selectionSet:		&lt;GQLSelectionSetNode&gt;	typeCondition:		&lt;GQLSTypeNode&gt;    Implementation Points</body></comment><class><name>GQLSUnionTypeNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLSNamedTypeNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>namedTypes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-NodesSchema</category><attributes><package>GraphQLBeta-NodesSchema</package></attributes></class><comment><class-id>GraphQLBeta.GQLSUnionTypeNode</class-id><body>I represent a union type and i have types.Public API and Key Messages- addTypes:- namedTypes    Instance Variables	namedTypes:		&lt;Dictionary&gt;</body></comment><class><name>GQLDirectiveNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name arguments </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLDirectiveNode</class-id><body>I represent a directive on a request.Public API and Key Messages- arguments- name    Instance Variables	arguments:		&lt;Array&gt;	name:		&lt;String&gt;    Implementation Points</body></comment><class><name>GQLSSchemaNodeTest</name><environment>GraphQLBeta</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>schemaNodes evaluator </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Tests</category><attributes><package>GraphQLBeta-Tests</package></attributes></class><comment><class-id>GraphQLBeta.GQLSSchemaNodeTest</class-id><body>A GQLSNodeEvaluatorTest is a test class for testing the behavior of GQLSNodeEvaluator</body></comment><class><name>GQLIntNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLValueNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLIntNode</class-id><body>I represent a int value.Public API and Key Messages- executeOn:with:using:    Implementation Points</body></comment><class><name>GQLNodeVisitor</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GraphQLObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>schemaContextStack schema </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Visitors</category><attributes><package>GraphQLBeta-Visitors</package></attributes></class><comment><class-id>GraphQLBeta.GQLNodeVisitor</class-id><body>I represent the validator to evaluate the document with the schema.Public API and Key Messages- initalize- schema"- visitArgumentNode:- visitDocumentNode:- visitInputValueNode:- visitObjectNode:- visitScalarNode:- visitSelectionSetNode:    Instance Variables	schema:		&lt;GQLSchema&gt;	schemaContextStack:		&lt;Stack&gt;For more information see the class GQLTypeValidator</body></comment><class><name>GQLTypeValidator</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLNodeVisitor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Visitors</category><attributes><package>GraphQLBeta-Visitors</package></attributes></class><comment><class-id>GraphQLBeta.GQLTypeValidator</class-id><body>I represent the validator of the request with the schema. I see if the types of the request are the same of the schema.Public API and Key Messages- validate:withSchema:  - visitArgumentNode: - visitInputValueNode:- visitObjectNode:- visitScalarNode:Example	validator := GQLTypeValidator new.	res := validator validate: document withSchema: schema.</body></comment><class><name>GQLEvaluationException</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta</category><attributes><package>GraphQLBeta</package></attributes></class><comment><class-id>GraphQLBeta.GQLEvaluationException</class-id><body>I represent an exception of evaluation on graphql, I'm only called if the GQLTypeValidator has a problem with visiting the parts of the document.Public API and Key Messages- node      - node: - signal    Instance Variables	node:		&lt;GQLNode&gt;GQLEvaluationException new 			node: aGQLArgumentNode; 			signal</body></comment><class><name>GQLFragmentNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLDefinitionNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name typeCondition directives selectionSet </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLFragmentNode</class-id><body>I represent a fragment on the request.Public API and Key Messages- directives- name- selectionSet- typeCondition    Instance Variables	directives:		&lt;Array&gt;	name:		&lt;String&gt;	selectionSet:		&lt;GQLSelectionSetNode&gt;	typeCondition:		&lt;GQLSTypeNode&gt;</body></comment><class><name>GQLSSchemaNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLSNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>schemaTypes scalarTypes root query </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-NodesSchema</category><attributes><package>GraphQLBeta-NodesSchema</package></attributes></class><comment><class-id>GraphQLBeta.GQLSSchemaNode</class-id><body>I represent a schema node, I have different types.Public API and Key Messages- addTypes:- getType:- types- validate    Instance Variables	scalarTypes:		&lt;Dictionary&gt;	schemaTypes:		&lt;Dictionary&gt;    Implementation Points</body></comment><class><name>GQLNullNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLValueNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLNullNode</class-id><body>I represent a null value on a request.</body></comment><class><name>GQLIQueryType</name><environment>GraphQLBeta</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Test-Trash</category><attributes><package>GraphQLBeta-Test-Trash</package></attributes></class><comment><class-id>GraphQLBeta.GQLIQueryType</class-id><body>Example class query  for testsPublic API and Key Messages- a- aId:- hello- helloName:- sumNums:</body></comment><class><name>GQLSIDTypeNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLSScalarTypeNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-NodesSchema</category><attributes><package>GraphQLBeta-NodesSchema</package></attributes></class><comment><class-id>GraphQLBeta.GQLSIDTypeNode</class-id><body>I represent a id type.</body></comment><class><name>GQLDocumentNodeTest</name><environment>GraphQLBeta</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>schema rootInstance </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Tests</category><attributes><package>GraphQLBeta-Tests</package></attributes></class><comment><class-id>GraphQLBeta.GQLDocumentNodeTest</class-id><body>A GQLDocumentNodeTest is a test class for testing the behavior of GQLDocumentNode</body></comment><class><name>GQLSchemaGrammar</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLAbstractGrammar</super><private>false</private><indexed-type>none</indexed-type><inst-vars>type listType nonNull objectType objectTypeName fieldSet fieldType field fieldName schema schemaType parameterName parameters parameter inputType ignoredSpaces listInputType enumType interfaceType unionType inputObjectType enumTypeName enumValueList interfaceTypeName unionTypeName unionValuesList fieldInputObjectSet fieldInputObject inputObjectTypeName nullValue namedType nonNullType nonNullListType nonNullNamedType baseType nonNullInputType nonNullBaseType nonNullListInputType namedInputType interfaceList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Parser</category><attributes><package>GraphQLBeta-Parser</package></attributes></class><comment><class-id>GraphQLBeta.GQLSchemaGrammar</class-id><body>I represent the grammar of the schema.Public API and Key Messages-  booleanType- field- fieldName- fieldSet- fieldType- floatType- idType- inputType- listInputType- listType- nonNull- objectType- obectTypeName- parameter- parameterName- parameters- scalarType- schema- singleInputType- singleType- start- stringType- type</body></comment><class><name>GQLSNonNullTypeNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLSWrapTypeNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-NodesSchema</category><attributes><package>GraphQLBeta-NodesSchema</package></attributes></class><comment><class-id>GraphQLBeta.GQLSNonNullTypeNode</class-id><body>I represent a non null type.</body></comment><class><name>GQLSchemaGrammarEvaluator</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLSchemaGrammar</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Parser</category><attributes><package>GraphQLBeta-Parser</package></attributes></class><comment><class-id>GraphQLBeta.GQLSchemaGrammarEvaluator</class-id><body>I represent a evaluator for the schema grammar.Public API and Key Messages- field- fieldSet- inputType- listInputType- listType- objectType- parameter- parameters- schema- singleInputType- singleType- start</body></comment><class><name>GQLEnumNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLValueNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLEnumNode</class-id><body>I represent a enum value on the request.</body></comment><methods><class-id>GraphQLBeta.GQLSNode</class-id> <category>initialization</category><body package="GraphQLBeta-NodesSchema">initialize"The default position is 0"	position := 0</body></methods><methods><class-id>GraphQLBeta.GQLSNode</class-id> <category>accessing</category><body package="GraphQLBeta-NodesSchema">position"Return the position"	^ position</body><body package="GraphQLBeta-NodesSchema">position: aNumber	"Set the position"	position := aNumber</body></methods><methods><class-id>GraphQLBeta.GQLSArgumentFieldNode</class-id> <category>accessing</category><body package="GraphQLBeta-NodesSchema">name"Return the name"	^ name</body><body package="GraphQLBeta-NodesSchema">name: aName"Set the name"	name := aName</body><body package="GraphQLBeta-NodesSchema">type"Return the type"	^ type </body><body package="GraphQLBeta-NodesSchema">type: aType"Set the type"	type := aType</body></methods><methods><class-id>GraphQLBeta.GQLA</class-id> <category>action</category><body package="GraphQLBeta-Test-Trash">createCopyAndDefault		GQLA new name: 'Lau'.	self createDefaultFriend </body><body package="GraphQLBeta-Test-Trash">createDefaultFriend	self createFriend.	self createFriend.	self createFriend</body><body package="GraphQLBeta-Test-Trash">createFriend	friends add: (B new)</body><body package="GraphQLBeta-Test-Trash">createFriendWithCity: aString	friends add: (B new city: aString)</body><body package="GraphQLBeta-Test-Trash">createString	name := 'bar','foo','asdf'.	^ 'foo'</body></methods><methods><class-id>GraphQLBeta.GQLA</class-id> <category>accessing</category><body package="GraphQLBeta-Test-Trash">friends	^ friends</body><body package="GraphQLBeta-Test-Trash">hey"Return heyhey"	^ #heyhey</body><body package="GraphQLBeta-Test-Trash">heyID"Return id and his value"	^ #id: , id</body><body package="GraphQLBeta-Test-Trash">id: aID"Set the id"	id := aID</body><body package="GraphQLBeta-Test-Trash">name: aString	name := aString</body></methods><methods><class-id>GraphQLBeta.GQLA</class-id> <category>initialization</category><body package="GraphQLBeta-Test-Trash">initialize	super initialize.	friends := OrderedCollection new.</body></methods><methods><class-id>GraphQLBeta.GQLSTypeNode</class-id> <category>testing</category><body package="GraphQLBeta-NodesSchema">isInputType"Return if is a input type"	^ false</body><body package="GraphQLBeta-NodesSchema">isWrappedType"Return if is a wrapped type"	^ false</body></methods><methods><class-id>GraphQLBeta.GQLSWrapTypeNode</class-id> <category>accessing</category><body package="GraphQLBeta-NodesSchema">wrappedType"Return the wrappedType"	^ wrappedType </body><body package="GraphQLBeta-NodesSchema">wrappedType: aType"Set the wrappedType"	wrappedType := aType</body></methods><methods><class-id>GraphQLBeta.GQLSWrapTypeNode</class-id> <category>testing</category><body package="GraphQLBeta-NodesSchema">isInputType"Return if the wrappedType is a inputType"	^ self wrappedType isInputType </body><body package="GraphQLBeta-NodesSchema">isWrappedType"Return if has a wrapped type"	^ true</body></methods><methods><class-id>GraphQLBeta.GQLNode</class-id> <category>initialization</category><body package="GraphQLBeta-Nodes">initialize	position := 0.</body></methods><methods><class-id>GraphQLBeta.GQLNode</class-id> <category>accessing</category><body package="GraphQLBeta-Nodes">executeOn: resolver with: env using: schema"This is responsability of the subclass"	self shouldBeImplemented</body><body package="GraphQLBeta-Nodes">position"Return the position"	^ position</body><body package="GraphQLBeta-Nodes">position: aPosition"Set the position"	position := aPosition</body></methods><methods><class-id>GraphQLBeta.GQLNode</class-id> <category>visiting</category><body package="GraphQLBeta-Nodes">acceptVisitor: aVisitor"This is responsability of the subclass"	self shouldBeImplemented</body></methods><methods><class-id>GraphQLBeta.GQLSelectionNode</class-id> <category>accessing</category><body package="GraphQLBeta-Nodes">directives"Return the directives"	^ directives</body><body package="GraphQLBeta-Nodes">directives: anObject"Set the directives"	directives := anObject</body></methods><methods><class-id>GraphQLBeta.GQLFieldNode</class-id> <category>accessing</category><body package="GraphQLBeta-Nodes">alias"Return the alias"	^ alias</body><body package="GraphQLBeta-Nodes">alias: anObject"Set the alias"	alias := anObject</body><body package="GraphQLBeta-Nodes">arguments"Return the arguments"	^ arguments</body><body package="GraphQLBeta-Nodes">arguments: anObject"If anObject is nil set the arguments to a new array, otherwise set the arguments"	anObject ifNil: [ arguments := Array new ]				ifNotNil: [ arguments := anObject ] </body><body package="GraphQLBeta-Nodes">fullName	"Return the full name"	fullName		ifNil: [ | write |			write := WriteStream on: String new.			write nextPutAll: self name.			self arguments				ifNotEmpty: [ :ags | 					ags doWithIndex: [ :ag :i | 							i = 1								ifTrue: [ write										nextPutAll: ag name capitalized;										nextPut: $: ]								ifFalse: [ write										nextPutAll: ag name;										nextPut: $: ] ] ].			fullName := write contents ].	^ fullName</body><body package="GraphQLBeta-Nodes">name"Return the name"	^ name</body><body package="GraphQLBeta-Nodes">name: anObject"Set the name"	name := anObject</body></methods><methods><class-id>GraphQLBeta.GQLFieldNode</class-id> <category>testing</category><body package="GraphQLBeta-Nodes">isScalar"To verify if a field is scalar"	self shouldBeImplemented</body></methods><methods><class-id>GraphQLBeta.GQLScalarFieldNode</class-id> <category>accessing</category><body package="GraphQLBeta-Nodes">executeOn: resolver with: env using: schema"Given a resolver, an enviroment and the schema, execute the scalar node"	| result params |	params := arguments		collect: [ :e | 			e				executeOn: resolver				with: env				using: schema ].	result := resolver		perform: self fullName asSymbol		withArguments: params asArray.	^ result</body></methods><methods><class-id>GraphQLBeta.GQLScalarFieldNode</class-id> <category>testing</category><body package="GraphQLBeta-Nodes">isScalar"Answer true for be a scalar field"	^ true</body></methods><methods><class-id>GraphQLBeta.GQLAbstractGrammar</class-id> <category>accessing</category><body package="GraphQLBeta-Parser">booleanType	"Return a token of a parser accepting Boolean"	^ 'Boolean' asParser token</body><body package="GraphQLBeta-Parser">floatType"Return a token of parser Float"	^ 'Float' asParser token</body><body package="GraphQLBeta-Parser">idType"Return a token of parser ID"	^ 'ID' asParser token</body><body package="GraphQLBeta-Parser">intType"Return a token of parse Int"	^ 'Int' asParser token</body><body package="GraphQLBeta-Parser">nullValue"Return a token of parsing: null"	^ 'null' asParser token</body><body package="GraphQLBeta-Parser">scalarType"Return a parser accepting:intTypefloatTypestringTypebooleanTypeidType"	^ intType / floatType / stringType / booleanType / idType</body><body package="GraphQLBeta-Parser">stringType"Return a token of parse String"	^ 'String' asParser token</body></methods><methods><class-id>GraphQLBeta.GQLAbstractGrammar</class-id> <category>grammar</category><body package="GraphQLBeta-Parser">booleanValue	"Return a token accepting true or false"	^ ('true' asParser / 'false' asParser)		flatten token</body><body package="GraphQLBeta-Parser">comma	"Return a parser accepting the comma"	^ $, asParser</body><body package="GraphQLBeta-Parser">comment	"Return a parser accepting the char # followed by a parser accepting the list of comment chars"	^ $# asParser , commentChar star</body><body package="GraphQLBeta-Parser">commentChar	"Return a parser that succes when fails accepting the newline and followed by a parser accepting the sourceCharacter"	^ #newline asParser not , sourceCharacter</body><body package="GraphQLBeta-Parser">digit"Return a parser accepting a digit"	^ #digit asParser</body><body package="GraphQLBeta-Parser">escapedCharacter	"Return a parser accepting all the characters associated with a escape, like: \t \r"	^ $" asParser / $\ asParser / $/ asParser		/ $b asParser / $f asParser / $n asParser		/ $r asParser / $t asParser</body><body package="GraphQLBeta-Parser">escapedUnicode"Return a parser accepting word four times"	^ #word asParser times: 4</body><body package="GraphQLBeta-Parser">exponentIndicator"Return a parser accepting the char e or the char E"	^ $e asParser / $E asParser</body><body package="GraphQLBeta-Parser">exponentPart	"Return a parser accepting a exponentIndicator follow by a parser accepting a optional sign follow by a parser accepting a list of digits"	^ exponentIndicator , sign optional		, digit plus</body><body package="GraphQLBeta-Parser">floatValue	"Return a parser accepting:	- integerPart fractionalPart exponentPart	- integerPart fractionalPart	- integerPart exponentPart"	^ (integerPart , fractionalPart		, exponentPart) flatten token		/			(integerPart , fractionalPart) flatten token		/ (integerPart , exponentPart) flatten token	"^ integerPart , ((fractionalPart , exponentPart) / fractionalPart / exponentPart )"</body><body package="GraphQLBeta-Parser">fractionalPart"Return a parser accepting . followed by a parser accepting one or more digits"	^ $. asParser , digit plus</body><body package="GraphQLBeta-Parser">ignored	"Return the parsers accepting the list of things we want to ignore"	^ comment / lineTerminator / unicodeBOM		/ whiteSpace / comma</body><body package="GraphQLBeta-Parser">insignificantToken	"Return a parser accepting the list of insignificant token"	^ whiteSpace / comment / lineTerminator</body><body package="GraphQLBeta-Parser">intValue	"Return a token representing the integerPart"	^ integerPart flatten token</body><body package="GraphQLBeta-Parser">integerPart	"Return a parser accepting:	- sign optional 0	- sign optional nonZero digitList"	^ sign optional		, ($0 asParser / (nonZeroDigit , digit star))</body><body package="GraphQLBeta-Parser">lineTerminator 	"New Line (U+000A)	Carriage Return (U+000D)New Line (U+000A)	Carriage Return (U+000D)New Line (U+000A)"	^ #newline asParser </body><body package="GraphQLBeta-Parser">nonZeroDigit	"Return a parser that succes when fails accepting the $0 and followed by a parser accepting the digit"	^ $0 asParser not , digit</body><body package="GraphQLBeta-Parser">punctuator"Return a parser accepting one of! $ ( ) ... : = @ [ ] { | }"	^ $! asParser / $$ asParser / $( asParser		/ $) asParser / '...' asParser		/ $: asParser / $= asParser		/ $@ asParser / $[ asParser		/ $] asParser / ${ asParser		/ $| asParser / $} asParser</body><body package="GraphQLBeta-Parser">sign	"Return a parser accepting the char + or -"	^ $+ asParser / $- asParser</body><body package="GraphQLBeta-Parser">sourceCharacter	"/[\u0009\u000A\u000D\u0020-\uFFFF]/ "	^ #any asParser</body><body package="GraphQLBeta-Parser">start	"Return a parser accepting the sourceCharacter and success at the end of the input"	^ sourceCharacter end</body><body package="GraphQLBeta-Parser">stringCharacter	"Return a parser accepting:	- SourceCharacter but not stringDelimiter or  \	- \u escapedUnicode	- \ escapedCharacter"	^ (stringDelimiter not , $\ asParser not		, sourceCharacter)		/ ('\u' asParser , escapedUnicode)		/ ('\' asParser , escapedCharacter)</body><body package="GraphQLBeta-Parser">stringDelimiter	"Return a parser accepting the quotation symbol"	^ $" asParser</body><body package="GraphQLBeta-Parser">stringValue	"Return a parser accepting a string delimited by quotation symbol"	^ (stringDelimiter , stringCharacter star		, stringDelimiter) flatten token</body><body package="GraphQLBeta-Parser">token	"Return the parser that accepts the lexical tokens: a punctuator or tokename or float value or int value or string value"	^ punctuator / tokenName / floatValue		/ intValue / stringValue</body><body package="GraphQLBeta-Parser">tokenName	"Return a parser accepting: _ letter _ wordList"	^ ($_ asParser / #letter asParser		, ($_ asParser / #word asParser) star)		flatten token</body><body package="GraphQLBeta-Parser">unicodeBOM	"Byte Order Mark (U+FEFF)"	^ 'U+FEFF' asParser  </body><body package="GraphQLBeta-Parser">whiteSpace	"Horizontal Tab (U+0009)	 Space (U+0020)"	^ #blank asParser</body></methods><methods><class-id>GraphQLBeta.GQLRequestGrammar</class-id> <category>grammar</category><body package="GraphQLBeta-Parser">alias"Return a parser accepting: tokenName :"	^ (tokenName trimRight: insignificantToken)		, ($: asParser trim: insignificantToken)</body><body package="GraphQLBeta-Parser">directives	"Return a parser accepting:	Directive+"	^ (directive trim: ignored) plus</body><body package="GraphQLBeta-Parser">field	"Return a parser accepting:	nonScalarField	scalarField"	^ nonScalarField / scalarField </body><body package="GraphQLBeta-Parser">fragmentSpread"Return a parser accepting: ... FragmentName DirectivesOptional"	^ '...' asParser , (fragmentName trim: ignored)		, directives optional</body><body package="GraphQLBeta-Parser">listType"Return a parser accepting:[ type ]"	^ ($[ asParser trimRight: ignored) , (type trimRight: ignored) , ($] asParser trimRight: ignored)</body><body package="GraphQLBeta-Parser">named"Return a name"	^ tokenName </body><body package="GraphQLBeta-Parser">namedType"Return a parser accepting:	-scalarType	-named"	^ scalarType / named</body><body package="GraphQLBeta-Parser">nonNullListType"Return a parser accepting:- listType !"	^ listType, $! asParser</body><body package="GraphQLBeta-Parser">nonNullNamedType"Return a parser accepting:- namedType !"	^ (namedType trim: ignored) , ($! asParser)</body><body package="GraphQLBeta-Parser">nonNullType"Return a parser accepting:- nonNullNamedType- nonNullListType"	^ (nonNullNamedType / nonNullListType) trim: ignored</body><body package="GraphQLBeta-Parser">nonScalarField"Return a parser accepting:- aliasOptional tokenName argumentsOptional directivesOptional selectionSet"	^ alias optional		, (tokenName trimRight: insignificantToken)		,			(arguments optional				trimRight: insignificantToken)		,			(directives optional				trimRight: insignificantToken),			(selectionSet trimRight: insignificantToken)</body><body package="GraphQLBeta-Parser">objectField"Return a parser accepting: tokenName : value"	^ tokenName		, ($: asParser trim: insignificantToken)		, value</body><body package="GraphQLBeta-Parser">operation"Return a parser accepting:- operationType tokenName variableDefinitionsOptional directivesOptional selectionSet"	^ (operationType , whiteSpace plus				, tokenName optional				,					(variableDefinitions optional						trim: insignificantToken)				,					(directives optional						trimRight: insignificantToken)				, (selectionSet trimRight: insignificantToken))</body><body package="GraphQLBeta-Parser">operationDefinition"Return a parser accepting:- selection set- operation"	^ selectionSet trim		/ operation</body><body package="GraphQLBeta-Parser">scalarField"Return a parser accepting:aliasOptional tokenName argumentsOptional directivesOptional"	^ alias optional		, (tokenName trimRight: insignificantToken)		,			(arguments optional				trimRight: insignificantToken)		,			(directives optional				trimRight: insignificantToken)</body><body package="GraphQLBeta-Parser">selectionSet	"Return a parser accepting:  { Selection+ }"	^ ${ asParser		, (selection trim: ignored) plus		, $} asParser</body><body package="GraphQLBeta-Parser">variableDefinitions"Return a parser accepting:( variableDefinition+ )"	^ $( asParser , ((variableDefinition trim: insignificantToken)  separatedBy: comma)		, $) asParser</body></methods><methods><class-id>GraphQLBeta.GQLRequestGrammar</class-id> <category>accessing</category><body package="GraphQLBeta-Parser">argument"Return a parser accepting:tokenName : Value"	^ tokenName		, ($: asParser trim: insignificantToken)		, value</body><body package="GraphQLBeta-Parser">arguments	"Return a parser accepting:( Argument+ )"	^ ($( asParser trimRight: ignored)		, (argument trimRight: ignored) plus		, $) asParser</body><body package="GraphQLBeta-Parser">defaultValue"Return a parser accepting:= value"	^ ($= asParser trimRight: insignificantToken) , value</body><body package="GraphQLBeta-Parser">definition	"Return a parser accepting operationDefinition or fragmentDefinition"	^ operationDefinition / fragmentDefinition</body><body package="GraphQLBeta-Parser">directive"Return a parser accepting:@ tokenName ArgumentsOptional"	^ $@ asParser		, (tokenName trimRight: insignificantToken)		, arguments optional</body><body package="GraphQLBeta-Parser">document	"Return a parser accepting one or more definitions"	^ definition plus</body><body package="GraphQLBeta-Parser">enumValue"Return a parser accepting a tokenName but not a booleanValue or null"	^ (booleanValue not , nullValue not		, tokenName) flatten token</body><body package="GraphQLBeta-Parser">fragmentDefinition"Return a parser accepting:fragment fragmentName typeCondition directiveOptional selectionSet"	^ 'fragment' asParser , whiteSpace plus		, (fragmentName trimRight: insignificantToken)		,			(typeCondition trimRight: insignificantToken)		,			(directives optional				trimRight: insignificantToken)		, (selectionSet trimRight: insignificantToken)</body><body package="GraphQLBeta-Parser">fragmentName"Return a parser accepting a token name but not on"	^ 'on' asParser not , tokenName</body><body package="GraphQLBeta-Parser">inlineFragment"Return a parser accepting:... typeConditionOptional directivesOptional selectionSet"	^ ('...' asParser trimRight: insignificantToken)		, (typeCondition optional trimRight: insignificantToken)		, (directives optional trimRight: insignificantToken) , selectionSet</body><body package="GraphQLBeta-Parser">listValue	"Return a parser accepting:	[]	[ Value* ]"	^ ($[ asParser trimRight: ignored)		, (value trimRight: ignored) star		, $] asParser token</body><body package="GraphQLBeta-Parser">objectValue	"Return a parser accepting: - { } - { ObjectField* }"	^ (${ asParser trimRight: ignored)		, (objectField trimRight: ignored) star		, $} asParser token</body><body package="GraphQLBeta-Parser">operationType"Return a parser accepting:- query- mutation"	^ 'query' asParser / 'mutation' asParser</body><body package="GraphQLBeta-Parser">selection"Return a token for a field or fragmentSpread or inlineFragment"	^ (field / fragmentSpread / inlineFragment)</body><body package="GraphQLBeta-Parser">start	"Return a parser accepting a document, transform this to a token and then end the input"	^ document end</body><body package="GraphQLBeta-Parser">type"Return a parser accepting:- nonNullType- namedType- listType"	^ nonNullType / namedType / listType</body><body package="GraphQLBeta-Parser">typeCondition"Return a parser accepting:on namedType"	^ 'on' asParser , whiteSpace plus , namedType</body><body package="GraphQLBeta-Parser">value	"[~Const]Variable IntValue FloatValue StringValue BooleanValue 	 NullValue EnumValue ListValue[~Const] ObjectValue[~Const]"		^ variable / floatValue / intValue / stringValue / booleanValue / nullValue / enumValue / listValue /  objectValue</body><body package="GraphQLBeta-Parser">variable"Return a token input from parse:$ tokenName"	^ ($$ asParser , tokenName) flatten token</body><body package="GraphQLBeta-Parser">variableDefinition"Return a parser accepting:variable : type defaultValueOptional"	^ variable , ($: asParser trim: insignificantToken) , (type trimRight: insignificantToken)		, defaultValue optional</body></methods><methods><class-id>GraphQLBeta.GQLSingleAnonimousQueryGrammar</class-id> <category>accessing</category><body package="GraphQLBeta-Parser">document"Return a selectionSet"	^ selectionSet</body><body package="GraphQLBeta-Parser">selection"Return a field"	^ field</body><body package="GraphQLBeta-Parser">selectionSet"Return a parser accepting:{ selection+ }"	^ ${ asParser		, (selection trim: ignored) plus		, $} asParser</body><body package="GraphQLBeta-Parser">start"Return a parser accepting a document and then the end of the input"	^ document end</body></methods><methods><class-id>GraphQLBeta.GQLSingleAnonimousQueryEvaluator</class-id> <category>accessing</category><body package="GraphQLBeta-Parser">argument	"Return an instance of GQLArgumentNode with  information about the query"	^ super argument		performs: [ :tokens | 			| node |			node := GQLArgumentNode new.			node name: (tokens at: 1) inputValue.			node value: (tokens at: 3).			node position: (tokens at: 1) start.			node ]</body><body package="GraphQLBeta-Parser">arguments	"Return the arguments parsed"	^ super arguments		performs: [ :tokens | tokens at: 2 ]</body><body package="GraphQLBeta-Parser">booleanValue"Return GQLBooleanNode instances with the information of the query"	^ super booleanValue		performs: [ :tokens | 			| node |			node := GQLBooleanNode new.			node value: tokens inputValue.			node position: tokens start. ]</body><body package="GraphQLBeta-Parser">document	"Return a instance of GQLDocumentNode with the information of the parser"	^ super document		performs: [ :tokens | 			| node |			node := GQLDocumentNode new.			node definitions: tokens ]</body><body package="GraphQLBeta-Parser">enumValue	"Return GQLEnumNode instance with the information of the request parsed"	^ super enumValue		performs: [ :tokens | 			| node |			node := GQLEnumNode new.			node				value: (tokens at: 1) inputValue.			node position: (tokens at: 1) start. ]</body><body package="GraphQLBeta-Parser">floatValue	"Return GQLFloatNode instance of input type float with the information of the request parsed"	^ super floatValue		performs: [ :tokens | 			| node |			node := GQLFloatNode new.			node value: tokens inputValue.			node position: tokens start. ]</body><body package="GraphQLBeta-Parser">intValue"Return GQLIntNode instance of input type Int with the information of the request parsed"	^ super intValue		performs: [ :tokens | 			| node |			node := GQLIntNode new.			node value: tokens inputValue.			node position: tokens start. ]</body><body package="GraphQLBeta-Parser">listValue"Return GQLListNode instance of input type List with the information of the request parsed"	^ super listValue		performs: [ :tokens | 			| node |			node := GQLListNode new.			node value: (tokens at: 2).			node ]</body><body package="GraphQLBeta-Parser">nonScalarField"Return a GQLNonScalarNode instance with the information of the request parsed"	^ super nonScalarField		performs: [ :tokens | 			| node |			node := GQLNonScalarFieldNode new.			node alias: (tokens at: 1).			node name: (tokens at: 2) inputValue.			node arguments: (tokens at: 3).			node selectionSet: (tokens at: 5).			node position: (tokens at: 2) start.			node ]</body><body package="GraphQLBeta-Parser">nullValue"Return GQLNullNode instance of input type null with the information of the request parsed"	^ super nullValue		performs: [ :tokens | 			| node |			node := GQLNullNode new.			node value: tokens inputValue.			node position: tokens start.]</body><body package="GraphQLBeta-Parser">objectField	"Return GQLObjectFieldNode instance with the information of the request parsed"	^ super objectField		performs: [ :tokens | 			| node |			node := GQLObjectFieldNode new.			node name: (tokens at: 1) inputValue.			node position: (tokens at: 1) start.			node value: (tokens at: 3) ]</body><body package="GraphQLBeta-Parser">objectValue	"Return GQLObjectNode instance of input type Object with the information of the request parsed"	^ super objectValue		performs: [ :tokens | 			| node |			node := GQLObjectNode new.			node objectFields: (tokens at: 2).			node position: (tokens at: 2) position.			node ]</body><body package="GraphQLBeta-Parser">scalarField"Return a GQLScalarFieldNode instance with the information of the request parsed"	^ super scalarField		performs: [ :tokens | 			| node |			node := GQLScalarFieldNode new.			node alias: (tokens at: 1).			node name: (tokens at: 2) inputValue.			node arguments: (tokens at: 3).			node position: (tokens at: 2) start.			node ]</body><body package="GraphQLBeta-Parser">selection"Return the tokens parsed"	^ super selection performs: [ :tokens | tokens ]</body><body package="GraphQLBeta-Parser">selectionSet"Return a instance of GQLSelectionSetNode with the information of the parser"	^ super selectionSet		performs: [ :tokens | 			| node val |			val := tokens at: 2.			node := GQLSelectionSetNode new.			node selections: val ]</body><body package="GraphQLBeta-Parser">stringValue"Return GQLStringNode instance of input type String with the information of the request parsed"	^ super stringValue		performs: [ :tokens | 			| node |			node := GQLStringNode new.			node value: tokens inputValue.			node position: tokens start. ]</body><body package="GraphQLBeta-Parser">variable"Return GQLVariableNode instance of input type variable with the information of the request parsed"	^ super variable		performs: [ :tokens | 			| node |			node := GQLVariableNode new.			node value: tokens inputValue.			node name: #Variable ]</body></methods><methods><class-id>GraphQLBeta.GQLValueNode</class-id> <category>accessing</category><body package="GraphQLBeta-Nodes">value"Return the value"	^ value</body><body package="GraphQLBeta-Nodes">value: anObject"Set the value"	value := anObject</body></methods><methods><class-id>GraphQLBeta.GQLSFieldNode</class-id> <category>accessing</category><body package="GraphQLBeta-NodesSchema">arguments"Return the arguments"	^ arguments</body><body package="GraphQLBeta-NodesSchema">fullName	"Return the full name"	fullName		ifNil: [ | write |			write := WriteStream on: String new.			write nextPutAll: self name.			self arguments				ifNotEmpty: [ :ags | 					ags keys						doWithIndex: [ :na :i | 							i = 1								ifTrue: [ write										nextPutAll: na capitalized;										nextPut: $: ]								ifFalse: [ write										nextPutAll: na;										nextPut: $: ] ] ].			fullName := write contents ].	^ fullName</body><body package="GraphQLBeta-NodesSchema">getArgument: aString	"Return a argument given his name"	(arguments includesKey: aString)		ifTrue: [ ^ arguments at: aString ].	^ nil</body><body package="GraphQLBeta-NodesSchema">name"Return the name"	^ name</body><body package="GraphQLBeta-NodesSchema">name: aName"Set the name"	name := aName</body><body package="GraphQLBeta-NodesSchema">type"Return the type"	^ type</body><body package="GraphQLBeta-NodesSchema">type: aType"Set the type"	type := aType</body></methods><methods><class-id>GraphQLBeta.GQLSFieldNode</class-id> <category>initialization</category><body package="GraphQLBeta-NodesSchema">initialize	super initialize.	arguments := Dictionary new</body></methods><methods><class-id>GraphQLBeta.GQLSFieldNode</class-id> <category>adding</category><body package="GraphQLBeta-NodesSchema">addArguments: aArray"Given a collection puts the values on a dictionary for improve the search"	aArray		ifNotNil: [ :array | array do: [ :argument | arguments at: argument name put: argument ] ]</body></methods><methods><class-id>GraphQLBeta.GQLRequestGrammarTest</class-id> <category>initialization</category><body package="GraphQLBeta-Tests">parserClass	^ GQLRequestGrammar</body></methods><methods><class-id>GraphQLBeta.GQLRequestGrammarTest</class-id> <category>tests-grammar</category><body package="GraphQLBeta-Tests">testAlias	|text|	text := 'smallPic:'.	self parse: text rule: #alias.	text := 'smallPic :'.	self parse: text rule: #alias.		</body><body package="GraphQLBeta-Tests">testArgument	|text|	text := 'id:4'.	self parse: text rule: #argument.</body><body package="GraphQLBeta-Tests">testArguments	|text|	text := '(id: 4)'.	self parse: text rule: #arguments.	text := '(id: 4, pass: 1233, pass2: 12312)'.	self parse: text rule: #arguments.</body><body package="GraphQLBeta-Tests">testDirectives	self parse: '@skip(if: true)' rule: #directives.	self fail: 'missing@(if: true)' rule: #directives.</body><body package="GraphQLBeta-Tests">testDocument	| text |	text := 'fragment friendFields on User {  		id  		name 	 	profilePic(size: 50)	}'.	self parse: text rule: #document.		text := 'fragment friendFields on User { 	 	id  		name  		...standardProfilePic	}'.	self parse: text rule: #document.		text := '{	  likeStory {			story {  	  	  		likeCount  	 		} 	 	}	}'.	self parse: text rule: #document.	text := 'mutation fetchLikeStory($var:Int){	  likeStory(storyID: Int) {			story {  	  	  		likeCount  	 		} 	 	}	}'.	self parse: text rule: #document.		text := '{	  likeStory($storyID: Int=12) {			story {  	  	  		likeCount  	 		} 	 	}	}'.	self fail: text rule: #document.	</body><body package="GraphQLBeta-Tests">testEnumValue	self parse: 'ENUM_VALUE' rule: #enumValue.	self parse: 'any_other_name_value_noSpaces' rule: #enumValue.	self fail: 'true' rule: #enumValue.	self fail: 'false' rule: #enumValue.	self fail: 'null' rule: #enumValue.</body><body package="GraphQLBeta-Tests">testField	|text|	text := 'me'.	self parse: text rule: #field.		text := 'user(id: 4) {    name  }'.	self parse: text rule: #field.</body><body package="GraphQLBeta-Tests">testFragmentDefinition	|text|	text := 'fragment friendFields on User {  id  name  profilePic(size: 50)}'.	self parse: text rule: #fragmentDefinition.		text := 'fragment friendFields on User {  id  name  ...standardProfilePic}'.	self parse: text rule: #fragmentDefinition.	</body><body package="GraphQLBeta-Tests">testFragmentSpread	|text|	text := '...friendFields'.	self parse: text rule: #fragmentSpread.</body><body package="GraphQLBeta-Tests">testInlineFragment	|text|	text := '... on User {      friends {        count      }    }'.	self parse: text rule: #inlineFragment.		text := '... @include(if: $expandedInfo) {      firstName      lastName      birthday    }'.	self parse: text rule: #inlineFragment.</body><body package="GraphQLBeta-Tests">testInlineFragments	|text|	text := '... on User {      friends {        count      }    }'.	self parse: text rule: #inlineFragment.		text := '... @include(if: $expandedInfo) {      firstName      lastName      birthday    }'.	self parse: text rule: #inlineFragment.</body><body package="GraphQLBeta-Tests">testListValue	self parse: '[1, 2, 3]' rule: #listValue.	self parse: '["a"]' rule: #listValue.	self parse: '[]' rule: #listValue.	self parse: '[[], "a", 1]' rule: #listValue.	self fail: 'null' rule: #listValue.	self fail: '123.123e12' rule: #listValue.</body><body package="GraphQLBeta-Tests">testNamedType	self parse: 'NamedType' rule: #namedType.	self fail: 'NonNullType!' rule: #namedType.</body><body package="GraphQLBeta-Tests">testNonNullType	self parse: 'NonNullType!' rule: #nonNullType.	self fail: 'NonNullType' rule: #nonNullType.</body><body package="GraphQLBeta-Tests">testNullValue	self parse: 'null' rule: #nullValue.	self fail: '123.123' rule: #nullValue.	self fail: 'asdf' rule: #nullValue.</body><body package="GraphQLBeta-Tests">testObjectField	|text|		text := '_4__ : null'.	self parse: text rule: #objectField.	text := 'age : 12'.	self parse: text rule: #objectField.	</body><body package="GraphQLBeta-Tests">testObjectValue	|text|		text := '{ }'.	self parse: text rule: #objectValue.		text := '{name: "12.43", age: 53 }'.	self parse: text rule: #objectValue.	</body><body package="GraphQLBeta-Tests">testOperationDefinition	|text|		text := '{	  likeStory {			story {  	  	  		likeCount  	 		} 	 	}	}'.	self parse: text rule: #operationDefinition.	text := 'mutation fetchLikeStory($var:Int){	  likeStory(storyID: Int) {			story {  	  	  		likeCount  	 		} 	 	}	}'.	self parse: text rule: #operationDefinition.		text := '{	  likeStory($storyID: Int=12) {			story {  	  	  		likeCount  	 		} 	 	}	}'.	self fail: text rule: #operationDefinition.</body><body package="GraphQLBeta-Tests">testSelectionSet	|text|		text := '{		films {			id #comment			name 			rating 		}	}'.	self parse: text rule: #selectionSet.	text := '{			parents { 				firstName			}  			firstName  			lastName			friends { 				nickname				lastname			}		}'.	self parse: text rule: #selectionSet.	text := '{  			friends(id:4) { 				nickname			}  			firstName  			lastName		}'.	self parse: text rule: #selectionSet.</body><body package="GraphQLBeta-Tests">testType	self parse: 'NonNullType' rule: #type.	self parse: 'NonNullType!' rule: #type.	self parse: '[Named]' rule: #type.	self parse: '[Named!]' rule: #type.	self parse: '[Named]!' rule: #type.	self parse: '[Named!]!' rule: #type.	self parse: 'Boolean' rule: #type.	self parse: 'Int!' rule: #type.	self parse: '[Float]' rule: #type.	self parse: '[String!]' rule: #type.	self parse: '[ID]!' rule: #type.	self parse: '[Int!]!' rule: #type	</body><body package="GraphQLBeta-Tests">testTypeCondition	|text|	text := 'on User'.	self parse: text rule: #typeCondition.</body><body package="GraphQLBeta-Tests">testValue	"implement tests with test contained in intValue floatValue, StringValue,	BooleanValue, NullValue, EnumValue, ListValue, ObjectValue"		"int value"	self parse: '2312' rule: #value.	self parse: '-123' rule: #value.	self parse: '+444' rule: #value.	"float value"	self parse: '2312.12' rule: #value.	self parse: '-123.23e12' rule: #value.	self parse: '-123.23E12' rule: #value.	self parse: '12' rule: #value.	"boolean value"	self parse: 'true' rule: #value.	self parse: 'false' rule: #value.	"string value"	self parse: '""' rule: #value.	self parse: '"any other kind of text +_)(*&amp;^%$#@ |}{:?&gt;&lt;][/;.,"' rule: #value.	self parse: '"\u00f3 \\ \/ \b \f \n \r \t"' rule: #value.	"list value"	self parse: '[1, 2, 3]' rule: #value.	self parse: '["a"]' rule: #value.	self parse: '[]' rule: #value.	self parse: '[[], "a", 1]' rule: #value.	"null value"	self parse: 'null' rule: #value.		"enum value"		self parse: 'ENUM_VALUE' rule: #value.	self parse: 'any_other_name_value_noSpaces' rule: #value.	self parse: '{ }' rule: #value.	self parse: '{name: "12.43", age: 53 }' rule: #value.	</body><body package="GraphQLBeta-Tests">testVariable	self parse: '$someVariableName' rule: #variable.	self fail: 'missing$atthebegining' rule: #variable.</body><body package="GraphQLBeta-Tests">testVariableDefinition	self parse: '$devicePicSize: Int' rule: #variableDefinition.	self parse: '$devicePicSize: Int = 12' rule: #variableDefinition.</body><body package="GraphQLBeta-Tests">testVariableDefinitions	self parse: '($devicePicSize: Int)' rule: #variableDefinitions.	self parse: '($devicePicSize: Int = 12)' rule: #variableDefinitions.	self parse: '($devicePicSize: Int = 12, $devicePicSize: Int = 2)' rule: #variableDefinitions.	self fail: '($devicePicSize: Int = 12,)' rule: #variableDefinitions.	self fail: '$devicePicSize: Int = 12' rule: #variableDefinitions.</body></methods><methods><class-id>GraphQLBeta.GQLTestQueryType</class-id> <category>accessing</category><body package="GraphQLBeta-Test-Utils">films	| data |	data := OrderedCollection new.	data add: (GQLTestFilm new: 1 name: 'harry potter y la piedra filosofal' rating: 9). 	data addLast: (GQLTestFilm new: 2 name: 'el seÃ±or de los anillos' rating: 8). 	data addLast: (GQLTestFilm new: 3 name: 'terminator' rating: 5). 	data addLast: (GQLTestFilm new: 4 name: 'rambo' rating: 5). 	data addLast: (GQLTestFilm new: 5 name: 'robocop' rating: 5). 	data addLast: (GQLTestFilm new: 6 name: 'alien' rating: 7). 	data addLast: (GQLTestFilm new: 7 name: 'annie' rating: 6). 	^ data</body><body package="GraphQLBeta-Test-Utils">hello	^ 'hello world'</body></methods><methods><class-id>GraphQLBeta.GQLSingleAnonimousQueryGrammarTest</class-id> <category>initialization</category><body package="GraphQLBeta-Tests">parserClass	^ GQLSingleAnonimousQueryGrammar </body><body package="GraphQLBeta-Tests">testComposedDocument	| text |	text := '{		films { 			id 			name 			rating 		}	}'.		self parse: text rule: #document</body><body package="GraphQLBeta-Tests">testComposedDocumentWithArguments	| text |	text := '{		films (ids:["1", "2"]){ 			id			name 			rating (stringify: true)		}	}'.		self parse: text rule: #document</body><body package="GraphQLBeta-Tests">testSimpleDocument	| text |	text := '{  			firstName  			lastName		}'.		self parse: text rule: #document.</body><body package="GraphQLBeta-Tests">testSimpleDocumentWithArguments	| text |	text := '{  			firstName (upercase:true)  			lastName		}'.		self parse: text rule: #document.	text := '{		films (ids:["1", "2"]){ 			id			name 			rating (stringify: true)		}	}'.		self parse: text rule: #document</body></methods><methods><class-id>GraphQLBeta.GQLFragmentSpreadNode</class-id> <category>accessing</category><body package="GraphQLBeta-Nodes">name"Return the name"	^ name</body><body package="GraphQLBeta-Nodes">name: anObject"Set the name"	name := anObject</body></methods><methods><class-id>GraphQLBeta.GQLSNamedTypeNode</class-id> <category>accessing</category><body package="GraphQLBeta-NodesSchema">name"Return the name"	^ name</body><body package="GraphQLBeta-NodesSchema">name: aName"Set the name"	name := aName	</body></methods><methods><class-id>GraphQLBeta.GQLSScalarTypeNode</class-id> <category>testing</category><body package="GraphQLBeta-NodesSchema">isInputType"Return if is a input type"	^ true</body></methods><methods><class-id>GraphQLBeta.GQLSBooleanTypeNode</class-id> <category>initialization</category><body package="GraphQLBeta-NodesSchema">initialize	super initialize.	name := 'Boolean'</body></methods><methods><class-id>GraphQLBeta.GQLSelectionSetNodeTest</class-id> <category>tests-accessing</category><body package="GraphQLBeta-Tests">testMergeSelectionSetWith	|selectionSet objectNode1 objectNode2 innerEscalar|	selectionSet := GQLSelectionSetNode new.	objectNode1 := GQLNonScalarFieldNode new.	objectNode1 name: 'film'.	innerEscalar := Array with: (GQLFieldNode new name: 'name').	objectNode1 selectionSet: (GQLSelectionSetNode new selections: innerEscalar).		objectNode2 := GQLNonScalarFieldNode new.	objectNode2 name: 'film'.	innerEscalar := Array with: (GQLFieldNode new name: 'rating').	objectNode2 selectionSet: (GQLSelectionSetNode new selections: innerEscalar).		selectionSet mergeSelectionSet: objectNode1  with: objectNode2 .		self assert:  objectNode1 selectionSet selections size equals: 2.</body></methods><methods><class-id>GraphQLBeta.GQLFloatNode</class-id> <category>accessing</category><body package="GraphQLBeta-Nodes">executeOn: resolver with: env using: schema"Execute the input value according to the resolver, the enviroment and the schema"	^ value asNumber</body></methods><methods><class-id>GraphQLBeta.GQLAbstractGrammarTest</class-id> <category>accessing</category><body package="GraphQLBeta-Tests">parserClass	^ GQLAbstractGrammar </body><body package="GraphQLBeta-Tests">testBooleanValue	"boolean value"	self parse: 'true' rule: #booleanValue.	self parse: 'false' rule: #booleanValue.	self fail: 'anyOtherValue' rule: #booleanValue.	self fail: '1' rule: #booleanValue.	self fail: '0' rule: #booleanValue.</body><body package="GraphQLBeta-Tests">testComma	"comma"	self parse: ',' rule: #comma.	self fail: 'any other text' rule: #comma.</body><body package="GraphQLBeta-Tests">testComment	self parse: '#some comment' rule: #comment.	self parse: '###' rule: #comment.	self fail: '#dsfd' rule: #comment.	self fail: 'asdf' rule: #comment.	self fail: ' ' rule: #comment.</body><body package="GraphQLBeta-Tests">testCommentChar"	self parse: '###' rule: #commentChar."	self parse: 's' rule: #commentChar.	 '+_)(*&amp;^%$#@!~.}{:"?&gt;&lt;|\][;. 		' do: [ :each | self parse: each asString rule:  #commentChar ].	self fail: ' 	' rule: #commentChar</body><body package="GraphQLBeta-Tests">testFloatValue	"float value"	self parse: '2312.12' rule: #floatValue.	self parse: '-123.23e12' rule: #floatValue.	self parse: '-123.23E12' rule: #floatValue.	self fail: '12' rule: #floatValue.	self fail: 'a123' rule: #floatValue.	self fail: '123.123a' rule: #floatValue.</body><body package="GraphQLBeta-Tests">testIgnored	"UnicodeBOM"	"self parse: '""' rule: #ignored."	"self fail: '""any other text but " "' rule: #ignored."	"Whitespace"	self parse: ' ' rule: #ignored.	self parse: '	' rule: #ignored.	"LineTerminator"	self parse: '' rule: #ignored.	"Comment"	self parse: '#some comment' rule: #ignored.	self parse: '###' rule: #ignored.	"comma"	self parse: ',' rule: #ignored.</body><body package="GraphQLBeta-Tests">testInsignificantToken		'	 		' do: [ :each | self parse: each asString rule:  #insignificantToken ].</body><body package="GraphQLBeta-Tests">testIntValue	"int value"	self parse: '2312' rule: #intValue.	self parse: '-123' rule: #intValue.	self parse: '+444' rule: #intValue.	self fail: '123.123' rule: #intValue.	self fail: '123.123e12' rule: #intValue.</body><body package="GraphQLBeta-Tests">testLineTerminator	"LineTerminator"	self parse: '' rule: #lineTerminator.	self fail: ' ' rule: #lineTerminator.</body><body package="GraphQLBeta-Tests">testNonZeroDigit	self parse: '1' rule: #nonZeroDigit.	self fail: '0' rule: #nonZeroDigit.</body><body package="GraphQLBeta-Tests">testPunctuator	"punctuator"	self parse: '{' rule: #punctuator.	self parse: '}' rule: #punctuator.	self parse: '...' rule: #punctuator.	self parse: '[' rule: #punctuator.	self parse: ']' rule: #punctuator.	self parse: '!' rule: #punctuator.	self parse: '$' rule: #punctuator.	self parse: '|' rule: #punctuator.	self parse: ':' rule: #punctuator.	self parse: '@' rule: #punctuator.	self parse: '=' rule: #punctuator.	self fail: 'any other character' rule: #punctuator.</body><body package="GraphQLBeta-Tests">testStringValue	"string value"	self parse: '""' rule: #stringValue.	self parse: '"any other kind of text +_)(*&amp;^%$#@ |}{:?&gt;&lt;][/;.,"' rule: #stringValue.	self parse: '"\u00f3 \\ \/ \b \f \n \r \t"' rule: #stringValue.	self fail: '"any other text but " "' rule: #stringValue.</body><body package="GraphQLBeta-Tests">testToken	"punctuator"	self parse: '{' rule: #punctuator.	self parse: '}' rule: #punctuator.	self parse: '...' rule: #punctuator.	self parse: '[' rule: #punctuator.	self parse: ']' rule: #punctuator.	self parse: '!' rule: #punctuator.	self parse: '$' rule: #punctuator.	self parse: '|' rule: #punctuator.	self parse: ':' rule: #punctuator.	self parse: '@' rule: #punctuator.	self parse: '=' rule: #punctuator.	"names"	self parse: '_Name23' rule: #token.	self parse: 'some_Name' rule: #token.	self parse: 'S' rule: #token.	self parse: '_' rule: #token.	"int value"	self parse: '2312' rule: #token.	self parse: '-123' rule: #token.	self parse: '+444' rule: #token.	"float value"	self parse: '2312.12' rule: #token.	self parse: '-123.23e12' rule: #token.	self parse: '-123.23E12' rule: #token.	"boolean value"	self parse: 'true' rule: #token.	self parse: 'false' rule: #token.	"string value"	self parse: '""' rule: #token.	self parse: '"any other kind of text +_)(*&amp;^%$#@ |}{:?&gt;&lt;][/;.,"' rule: #token.	self parse: '"\u00f3 \\ \/ \b \f \n \r \t"' rule: #token.</body><body package="GraphQLBeta-Tests">testTokenName	"names"	self parse: '_Name23' rule: #tokenName.	self parse: 'some_Name' rule: #tokenName.	self parse: 'S' rule: #tokenName.	self parse: '_' rule: #tokenName.	self fail: '' rule: #tokenName.	self fail: ' someName' rule: #tokenName.</body><body package="GraphQLBeta-Tests">testWhiteSpace	"WhiteSpace"	self parse: ' ' rule: #whiteSpace.	self parse: '	' rule: #whiteSpace.	self fail: 'any other text but  ' rule: #whiteSpace.</body></methods><methods><class-id>GraphQLBeta.GQLArgumentNode</class-id> <category>accessing</category><body package="GraphQLBeta-Nodes">executeOn: resolver with: env using: schema"Pass to execute the argument value"	^ value		executeOn: resolver		with: env		using: schema</body><body package="GraphQLBeta-Nodes">name"Return the name"	^ name</body><body package="GraphQLBeta-Nodes">name: anObject"Set the name"	name := anObject</body><body package="GraphQLBeta-Nodes">value"Return the value"	^ value</body><body package="GraphQLBeta-Nodes">value: anObject"Set the value"	value := anObject</body></methods><methods><class-id>GraphQLBeta.GQLSEnumTypeNode</class-id> <category>adding</category><body package="GraphQLBeta-NodesSchema">addValues: values"Set the string of values "	stringValues := values</body></methods><methods><class-id>GraphQLBeta.GQLSEnumTypeNode</class-id> <category>accessing</category><body package="GraphQLBeta-NodesSchema">values"Return the string values"	^ stringValues</body></methods><methods><class-id>GraphQLBeta.GQLSEnumTypeNode</class-id> <category>testing</category><body package="GraphQLBeta-NodesSchema">isInputType"Return if is input type"	^ true</body></methods><methods><class-id>GraphQLBeta.GQLListNode</class-id> <category>accessing</category><body package="GraphQLBeta-Nodes">executeOn: resolver with: env using: schema"Execute the input value according to the resolver, the enviroment and the schema"	^ value collect: [ :e | 					e						executeOn: resolver						with: env						using: schema ]</body></methods><methods><class-id>GraphQLBeta.GQLSObjectTypeNode</class-id> <category>accessing</category><body package="GraphQLBeta-NodesSchema">fields"Return the fields"	^ fieldSet</body><body package="GraphQLBeta-NodesSchema">getField: aFieldName	"Return the field given his name"	| res |	res := (fieldSet includesKey: aFieldName)		ifTrue: [ fieldSet at: aFieldName ]		ifFalse: [ nil ].	^ res</body><body package="GraphQLBeta-NodesSchema">getFieldType: aFieldName	"Return the type of a field"	| res |	res := (fieldSet includesKey: aFieldName)		ifTrue: [ (fieldSet at: aFieldName) type ]		ifFalse: [ nil ].	^ res</body><body package="GraphQLBeta-NodesSchema">implements: aArray"Set the interfaces that implements"	interfaces := aArray</body><body package="GraphQLBeta-NodesSchema">interfaces"Return the interfaces"	^ interfaces</body></methods><methods><class-id>GraphQLBeta.GQLSObjectTypeNode</class-id> <category>initialization</category><body package="GraphQLBeta-NodesSchema">initialize	super initialize.	fieldSet := Dictionary new</body></methods><methods><class-id>GraphQLBeta.GQLSObjectTypeNode</class-id> <category>adding</category><body package="GraphQLBeta-NodesSchema">addFields: aArray"Given a collection puts the values on a dictionary for improve the search"	aArray do: [ :field | fieldSet at: field name put: field ]</body></methods><methods><class-id>GraphQLBeta.GQLException</class-id> <category>*GraphQLBeta</category><body package="GraphQLBeta">node"Return the element that causes a exception"	^ node</body><body package="GraphQLBeta">node: aNode"Recive a node element that causes a exception"	node := aNode</body><body package="GraphQLBeta">signal"Raise the exception"	^ super signal</body></methods><methods><class-id>GraphQLBeta.GQLException</class-id> <category>accessing</category><body package="GraphQLBeta">defaultAction	"No one has handled this error, but now give them a chance to decide how to debug it.  If none handle this either then open debugger (see UnhandedError-defaultAction)"	UnhandledError signalForException: self</body></methods><methods><class-id>GraphQLBeta.GQLSchemaGrammarEvaluatorTest</class-id> <category>test-schemaEnumType</category><body package="GraphQLBeta-Tests">testIncompleteSchemaEnumType	| text schema |	text := 'enum CatCommand {}'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: PPFailure.	text := 'enum { JUMP }'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: PPFailure.	text := 'enum CatCommand { JUMP'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: PPFailure</body><body package="GraphQLBeta-Tests">testSchemaEnumType	| text schema dog cat |	text := 'enum DogCommand { SIT, DOWN, HEEL }			  enum CatCommand { JUMP }'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: GQLSSchemaNode.	dog := schema getType: 'DogCommand'.	cat := schema getType: 'CatCommand'.	self assert: dog class equals: GQLSEnumTypeNode.	self assert: cat class equals: GQLSEnumTypeNode.	self assert: dog values size equals: 3.	self assert: cat values size equals: 1.	self assert: dog values first equals: 'SIT'.	self assert: dog values second equals: 'DOWN'.	self assert: dog values third equals: 'HEEL'.	self assert: cat values first equals: 'JUMP'.</body></methods><methods><class-id>GraphQLBeta.GQLSchemaGrammarEvaluatorTest</class-id> <category>test-schemaInputObjectType</category><body package="GraphQLBeta-Tests">testIncompleteSchemaInputObjectType	| text schema |	text := 'input ExampleInputObject { 			 	a: String  				b: !				c: OtherInputObject			}'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: PPFailure.	text := 'input ExampleInputObject { 			 	a: String  				b: Int!				c: OtherInputObject			'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: PPFailure.	text := 'input ExampleInputObject { 			 	a: String  				b: Int!				c: OtherInputObject!!			}'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: PPFailure</body><body package="GraphQLBeta-Tests">testSchemaInputObjectType	| text schema inputObject |	text := 'input ExampleInputObject { 			 	a: String  				b: Int!				c: OtherInputObject			}'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: GQLSSchemaNode.	inputObject := schema getType: 'ExampleInputObject'.	self assert: inputObject class equals: GQLSInputObjectTypeNode.	self assert: inputObject name equals: 'ExampleInputObject'.	self assert: (inputObject getField: 'a') class equals: GQLSInputObjectFieldNode.	self assert: (inputObject getField: 'a') type class equals: GQLSStringTypeNode.	self assert: (inputObject getField: 'b') type wrappedType class equals: GQLSIntTypeNode.	self assert: (inputObject getField: 'c') type class equals: GQLSNamedTypeNode.</body></methods><methods><class-id>GraphQLBeta.GQLSchemaGrammarEvaluatorTest</class-id> <category>tests-schemaObjectTypes</category><body package="GraphQLBeta-Tests">testIncompleteSchemaObjectType	| text schema |	text := 'type Query{              name :             }'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: PPFailure.	text := 'type Query{              name : String            }				{}'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: PPFailure.	text := 'type Query{              name : String            }				type Class{ 				  name :				}'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: PPFailure</body><body package="GraphQLBeta-Tests">testIncompleteSchemaObjectTypeParameters	| text schema |	text := 'type Query{              name (id: Int : String            }'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: PPFailure.	text := 'type Query{              name (id: Int, ) : String            }				{}'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: PPFailure.	text := 'type Query{              name (id:Int) : String            }				type Class{ 				  name :				}'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: PPFailure</body><body package="GraphQLBeta-Tests">testSchemaObjectType	| text schema someType someOtherType var |	text := 'type SomeType {					someName : [Int]					otherVariable 	:String				},				type SomeOtherTypeName {					someName 	: [String ! ]				}'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: GQLSSchemaNode.	someType := schema types at: 'SomeType'.	someOtherType := schema types at: 'SomeOtherTypeName'.	self assert: someType class equals: GQLSObjectTypeNode.	self assert: someType name equals: 'SomeType'.	var := someType fields at: 'someName'.	self assert: var class equals: GQLSFieldNode.	self assert: var name equals: 'someName'.	self assert: var type class equals: GQLSListTypeNode.		self assert: someOtherType fields values first type class equals: GQLSListTypeNode.	self assert: var type wrappedType name equals: 'Int'.	var := someType fields at: 'otherVariable'.	self assert: var name equals: 'otherVariable'.	self assert: var type name equals: 'String'</body><body package="GraphQLBeta-Tests">testSchemaObjectTypeParameters	| text schema someType var |	text := 'type SomeType {					field(id: Int) : [Int]					otherVariable(param: String, param2: [Int]!):String 					a (param: [Int]!):Int				},				type SomeOtherTypeName {					someName (a:String!): [String ! ]					someName2 :String 				}'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: GQLSSchemaNode.	someType := schema types at: 'SomeType'.	self assert: someType class equals: GQLSObjectTypeNode.	self assert: someType name equals: 'SomeType'.	self assert: someType fields values third name equals: 'otherVariable'.	var := someType fields at: 'a'.	self		assert: var arguments values first class		equals: GQLSArgumentFieldNode.	self		assert: var arguments values first class		equals: GQLSArgumentFieldNode.	self		assert: var arguments values first type class		equals: GQLSNonNullTypeNode.	self		assert: var arguments values first type wrappedType class		equals: GQLSListTypeNode</body><body package="GraphQLBeta-Tests">testSchemaObjectTypeWithInterface	| text schema someType someOtherType |	text := 'type SomeType implements Type{					someName : [Int]				},				type SomeOtherTypeName implements Type, Other {					someName 	: String !				}'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: GQLSSchemaNode.	someType := schema types at: 'SomeType'.	someOtherType := schema types at: 'SomeOtherTypeName'.	self assert: someType class equals: GQLSObjectTypeNode.	self assert: someType name equals: 'SomeType'.	self assert: someType interfaces size equals: 1.	self assert: someType interfaces first equals: 'Type'.	self assert: someOtherType class equals: GQLSObjectTypeNode.	self assert: someOtherType name equals: 'SomeOtherTypeName'.	self assert: someOtherType interfaces size equals: 2.	self assert: someOtherType interfaces first equals: 'Type'.	self assert: someOtherType interfaces second equals: 'Other'.</body></methods><methods><class-id>GraphQLBeta.GQLSchemaGrammarEvaluatorTest</class-id> <category>test-schemaUnionType</category><body package="GraphQLBeta-Tests">testIncompleteSchemaUnionType	| text schema |	text := 'union CatOrDog = Cat |'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: PPFailure.	text := 'union CatOrDog  Cat | Dog'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: PPFailure.	text := 'union CatOrDog = Cat | |'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: PPFailure</body><body package="GraphQLBeta-Tests">testSchemaUnionType	| text schema dog cat |	text := 'union CatOrDog = Cat | Dog				union DogOrHuman = Dog | Human | Alien'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: GQLSSchemaNode.	cat := schema getType: 'CatOrDog'.	dog := schema getType: 'DogOrHuman'.	self assert: dog class equals: GQLSUnionTypeNode.	self assert: cat class equals: GQLSUnionTypeNode.	self assert: dog namedTypes size equals: 3.	self assert: cat namedTypes size equals: 2.	self assert: dog namedTypes first equals: 'Dog'.	self assert: dog namedTypes second equals: 'Human'.	self assert: dog namedTypes third equals: 'Alien'.	self assert: cat namedTypes first equals: 'Cat'.	self assert: cat namedTypes second equals: 'Dog'.</body></methods><methods><class-id>GraphQLBeta.GQLSchemaGrammarEvaluatorTest</class-id> <category>test-schemaInterfaceType</category><body package="GraphQLBeta-Tests">testIncompleteSchemaInterfaceType	| text schema |	text := 'interface NamedEntity {				  name: String			  '.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: PPFailure.	text := 'interface NamedEntity {				  name: 			  }'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: PPFailure.	text := 'interface NamedEntity {				  name: String : Int			  }'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: PPFailure</body><body package="GraphQLBeta-Tests">testSchemaInterfaceType	| text schema interface |	text := 'interface NamedEntity {				  field(id: Int) : [Int]				  otherVariable(param: String, param2: [Int]!) : String 				  a (param: [Int]!) : A			  }'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: GQLSSchemaNode.	interface := schema getType: 'NamedEntity'.	self assert: interface class equals: GQLSInterfaceTypeNode.	self assert: interface name equals: 'NamedEntity'.	self assert: (interface getField: 'field') class equals: GQLSFieldNode.	self assert: (interface getField: 'field') type class equals: GQLSListTypeNode.	self assert: (interface getField: 'field') type wrappedType class equals: GQLSIntTypeNode.	self assert: (interface getField: 'otherVariable') type class equals: GQLSStringTypeNode.	self assert: ((interface getField: 'otherVariable') getArgument: 'param2') type class equals: GQLSNonNullTypeNode.	self assert: (interface getField: 'a') type class equals: GQLSNamedTypeNode.</body></methods><methods><class-id>GraphQLBeta.GraphQL</class-id> <category>accessing</category><body package="GraphQLBeta">handleRequest: aTextRequest	"Given a text request, this is parsed and validated with the schema defined, if everything is ok then execute the request"	| document validation |	document := GQLSingleAnonimousQueryEvaluator		parse: aTextRequest.	(document isKindOf: PPFailure) 	ifTrue: [ GQLException new messageText: 'Fail parsing on request'; signal ].	validation := GQLDocumentNode new.	"validation := validator		validate: document		withSchema: schema."	(validation isKindOf: GQLDocumentNode)		ifTrue: [ ^ document				executeOn: rootInstance				with: #()				using: schema ].	^ validation</body><body package="GraphQLBeta">schema"Return the schema"	^ schema</body><body package="GraphQLBeta">schema: aGQLSchema"Set the schema"	schema := aGQLSchema</body></methods><methods><class-id>GraphQLBeta.GraphQL</class-id> <category>initialization</category><body package="GraphQLBeta">createSchema: aTextSchema"Given a text schema, parses this text if everything is ok then evaluate this nodes and the schema is validated"	schema := GQLSchemaGrammarEvaluator		parse: aTextSchema.	(schema isKindOf: PPFailure)		ifTrue: [ GQLEvaluationException new messageText: 'Fail parsing on schema'; signal. ]		ifFalse: [ schema validate.			schema root: rootInstance ]</body><body package="GraphQLBeta">initialize"Initialize the validator and the entry point with the default schema"	validator := GQLTypeValidator new.	rootInstance := Query new.	self createSchema: Query schema</body></methods><methods><class-id>GraphQLBeta.GQLObjectNode</class-id> <category>accessing</category><body package="GraphQLBeta-Nodes">objectFields"Return the object fields"	^ objectFields</body><body package="GraphQLBeta-Nodes">objectFields: anObject"Set the object fields"	objectFields := anObject</body></methods><methods><class-id>GraphQLBeta.GQLDocumentNode</class-id> <category>accessing</category><body package="GraphQLBeta-Nodes">definitions"Return the definitions"		^ definitions </body><body package="GraphQLBeta-Nodes">definitions: aArray"Set the definitions"	definitions := aArray</body><body package="GraphQLBeta-Nodes">executeOn: root with: env using: schema"Given a root, an enviroment and the schema, execute this document"	^ definitions		executeOn: root		with: env		using: schema</body></methods><methods><class-id>GraphQLBeta.GQLSInputObjectTypeNode</class-id> <category>initialization</category><body package="GraphQLBeta-NodesSchema">initialize	super initialize.	fieldSet := Dictionary new</body></methods><methods><class-id>GraphQLBeta.GQLSInputObjectTypeNode</class-id> <category>adding</category><body package="GraphQLBeta-NodesSchema">addFields: aArray"Given a collection puts the values on a dictionary for improve the search"	aArray do: [ :field | fieldSet at: field name put: field ]</body></methods><methods><class-id>GraphQLBeta.GQLSInputObjectTypeNode</class-id> <category>accessing</category><body package="GraphQLBeta-NodesSchema">getField: aFieldName	"Return the field given his name"	| res |	res := (fieldSet includesKey: aFieldName)		ifTrue: [ fieldSet at: aFieldName ]		ifFalse: [ nil ].	^ res</body></methods><methods><class-id>GraphQLBeta.GQLSInputObjectTypeNode</class-id> <category>testing</category><body package="GraphQLBeta-NodesSchema">isInputType"Return if if a input type"	^ true</body></methods><methods><class-id>GraphQLBeta.GQLRequestGrammarEvaluatorTest</class-id> <category>test-grammar-fields</category><body package="GraphQLBeta-Tests">testFieldsAlias	| text document userField userSelection |	text := '{  				user(id: 4) {    					name    					smallPic: profilePic(size: 64)    					bigPic: profilePic(size: 1024)  			}		}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: GQLDocumentNode.	userField := document definitions first selections first.	self assert: userField class equals: GQLNonScalarFieldNode.	self assert: userField name equals: 'user'.	self assert: userField arguments first name equals: 'id'.	userSelection := userField selectionSet.	self assert: userSelection class equals: GQLSelectionSetNode.	self assert: userSelection selections first name equals: 'name'.	self assert: userSelection selections second name equals: 'profilePic'.	self assert: userSelection selections second alias equals: 'smallPic'.	self assert: userSelection selections second arguments first value value equals: '64'.	self assert: userSelection selections third name equals: 'profilePic'.	self assert: userSelection selections third alias equals: 'bigPic'.	self assert: userSelection selections third arguments first value value equals: '1024'.	</body><body package="GraphQLBeta-Tests">testFieldsIncomplete	| text document  |	text := '{  				user(id: 4) {    					name    					bigPic: profilePic(size: 1024)  					}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: PPFailure.		text := '{  				user(id: 4) {    					name    					bigPic: profilePic(size: )  				}		}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: PPFailure.		text := 'query myQuery {  				experimentalField @skip(if: )			}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: PPFailure.</body><body package="GraphQLBeta-Tests">testFieldsWithArguments	| text document filmsSelection firstSubSelection actorsSelection|	text := '{				films(inYear: 2016){					rating				}				actors(inMovie : "Star wars", active : true){					name				}			}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: GQLDocumentNode.	filmsSelection := document definitions first selections first.	self assert: filmsSelection   class equals: GQLNonScalarFieldNode.	self assert: filmsSelection   name equals: 'films'.	self assert: filmsSelection   arguments size equals: 1.	self assert: filmsSelection   arguments first name equals: 'inYear'.	self assert: filmsSelection   arguments first value class equals: GQLIntNode.	self assert: filmsSelection   arguments first value value equals: '2016'.	firstSubSelection := filmsSelection selectionSet.	self assert: firstSubSelection class equals: GQLSelectionSetNode.	self assert: firstSubSelection selections first name equals: 'rating'.	actorsSelection := document definitions first selections second.	self assert: actorsSelection  name equals: 'actors'.	self assert: actorsSelection  arguments size equals: 2.	self assert: actorsSelection arguments first name equals: 'inMovie'.	self assert: actorsSelection arguments first value class equals: GQLStringNode.	self assert: actorsSelection arguments first value value equals: '"Star wars"'.	self assert: actorsSelection arguments second name equals: 'active'.	self assert: actorsSelection arguments second value class equals: GQLBooleanNode.	self assert: actorsSelection arguments second value value equals: 'true'.</body><body package="GraphQLBeta-Tests">testFieldsWithDirectives	| text document operation field |	text := 'query myQuery($someTest: Boolean) {  				experimentalField @skip(if: $someTest)			}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: GQLDocumentNode.	operation := document definitions first.	self assert: operation class equals: GQLOperationNode.	self assert: operation name equals: 'myQuery'.	self assert: operation type equals: 'query'.	self assert: operation variableDefinitions first name class equals: GQLVariableNode.	self assert: operation variableDefinitions first name value equals: '$someTest'.	self assert: operation variableDefinitions first type class equals: GQLSBooleanTypeNode.	field := operation selectionSet selections first.	self assert: field class equals: GQLScalarFieldNode.	self assert: field name equals: 'experimentalField'.	self assert: field directives first name equals: 'skip'.	self assert: field directives first arguments size equals: 1.	self assert: field directives first arguments first name equals: 'if'.	self assert: field directives first arguments first value class equals: GQLVariableNode.	self assert: field directives first arguments first value value equals: '$someTest'.	</body><body package="GraphQLBeta-Tests">testSimpleFields	| text document principalSelection firstSubSelection secondSubSelection|	text := '{				allFilms{					name					actors{						name					}				}			}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: GQLDocumentNode.	principalSelection := document definitions first.	self assert: principalSelection class equals: GQLSelectionSetNode.	self assert: principalSelection selections first class equals: GQLNonScalarFieldNode.	self assert: principalSelection selections first name equals: 'allFilms'.	firstSubSelection := principalSelection selections first selectionSet.	self assert: firstSubSelection class equals: GQLSelectionSetNode.	self assert: firstSubSelection selections first name equals: 'name'.	self assert: firstSubSelection selections second name equals: 'actors'.	secondSubSelection := firstSubSelection selections second selectionSet.	self assert: secondSubSelection selections first name equals: 'name'.	</body></methods><methods><class-id>GraphQLBeta.GQLRequestGrammarEvaluatorTest</class-id> <category>test-grammar-fragmentSpread</category><body package="GraphQLBeta-Tests">testFragmentSpread	| text document nestedFragments firstSubSelection firstFragment secondFragment |	text := 'query withNestedFragments {  				user(id: 4) {    					...familiarFields    					mutualFriends(first: 10) {      					...friendFields    					}  				}	}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: GQLDocumentNode.	nestedFragments := document definitions first.	self assert: nestedFragments class equals: GQLOperationNode.	self assert: nestedFragments type equals: 'query'.	self assert: nestedFragments name equals: 'withNestedFragments'.		firstSubSelection := nestedFragments selectionSet selections first.	self assert: firstSubSelection class equals: GQLNonScalarFieldNode.	self assert: firstSubSelection name equals: 'user'.	self assert: firstSubSelection arguments first name equals: 'id'.	self assert: firstSubSelection arguments first value class equals: GQLIntNode.	self assert: firstSubSelection arguments first value value equals: '4'. 		firstFragment := firstSubSelection selectionSet selections first.	self assert: firstFragment name equals: 'familiarFields'.		secondFragment := firstSubSelection selectionSet selections second selectionSet selections first.	self assert: secondFragment name equals: 'friendFields'.	</body><body package="GraphQLBeta-Tests">testFragmentSpreadIncorrect	| text document |	text := 'query withNestedFragments {  				user(id: 4) {    					...familiarFields @skip(if: $someTest){						user					}  				}	}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: PPFailure.		text := 'query withNestedFragments {  				user(id: 4) {    					...familiarFields @skip(if: $someTest){					}  				}	}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: PPFailure.		text := 'query withNestedFragments {  				user(id: 4) {    					...familiarFields{						name					}  				}	}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: PPFailure.</body><body package="GraphQLBeta-Tests">testFragmentSpreadWithDirectives	| text document nestedFragments firstSubSelection firstFragment |	text := 'query withNestedFragments {  				user(id: 4) {    					...familiarFields @skip(if: $someTest)  				}	}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: GQLDocumentNode.	nestedFragments := document definitions first.	self assert: nestedFragments class equals: GQLOperationNode.	self assert: nestedFragments type equals: 'query'.	self assert: nestedFragments name equals: 'withNestedFragments'.		firstSubSelection := nestedFragments selectionSet selections first.	self assert: firstSubSelection class equals: GQLNonScalarFieldNode.	self assert: firstSubSelection name equals: 'user'.	self assert: firstSubSelection arguments first name equals: 'id'.	self assert: firstSubSelection arguments first value class equals: GQLIntNode.	self assert: firstSubSelection arguments first value value equals: '4'. 		firstFragment := firstSubSelection selectionSet selections first.	self assert: firstFragment name equals: 'familiarFields'.	self assert: firstFragment directives first name equals: 'skip'.	self assert: firstFragment directives first arguments first name equals: 'if'.	self assert: firstFragment directives first arguments first value value equals: '$someTest'.</body></methods><methods><class-id>GraphQLBeta.GQLRequestGrammarEvaluatorTest</class-id> <category>test-grammar-variableDefinitions</category><body package="GraphQLBeta-Tests">testVariableListType	| text document operation field |	text := 'query myQuery($someTest: [ Boolean ]) {  				experimentalField				}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: GQLDocumentNode.	operation := document definitions first.	self assert: operation class equals: GQLOperationNode.	self assert: operation name equals: 'myQuery'.	self assert: operation type equals: 'query'.	self assert: operation variableDefinitions first name class equals: GQLVariableNode.	self assert: operation variableDefinitions first name value equals: '$someTest'.	self assert: operation variableDefinitions first type class equals: GQLSListTypeNode.	self assert: operation variableDefinitions first type wrappedType class equals: GQLSBooleanTypeNode.	field := operation selectionSet selections first.	self assert: field class equals: GQLScalarFieldNode.	self assert: field name equals: 'experimentalField'.</body><body package="GraphQLBeta-Tests">testVariableListTypeNamed	| text document operation field |	text := 'query myQuery($someTest: [ Some ]) {  				experimentalField				}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: GQLDocumentNode.	operation := document definitions first.	self assert: operation class equals: GQLOperationNode.	self assert: operation name equals: 'myQuery'.	self assert: operation type equals: 'query'.	self assert: operation variableDefinitions first name class equals: GQLVariableNode.	self assert: operation variableDefinitions first name value equals: '$someTest'.	self assert: operation variableDefinitions first type class equals: GQLSListTypeNode.	self assert: operation variableDefinitions first type wrappedType class equals: GQLSNamedTypeNode.	self assert: operation variableDefinitions first type wrappedType name equals: 'Some'.	field := operation selectionSet selections first.	self assert: field class equals: GQLScalarFieldNode.	self assert: field name equals: 'experimentalField'.</body><body package="GraphQLBeta-Tests">testVariableListTypeNonNull	| text document operation field |	text := 'query myQuery($someTest: [ Int! ]) {  				experimentalField				}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: GQLDocumentNode.	operation := document definitions first.	self assert: operation class equals: GQLOperationNode.	self assert: operation name equals: 'myQuery'.	self assert: operation type equals: 'query'.	self assert: operation variableDefinitions first name class equals: GQLVariableNode.	self assert: operation variableDefinitions first name value equals: '$someTest'.	self assert: operation variableDefinitions first type class equals: GQLSListTypeNode.	self assert: operation variableDefinitions first type wrappedType class equals: GQLSNonNullTypeNode.	self assert: operation variableDefinitions first type wrappedType wrappedType class equals: GQLSIntTypeNode.	field := operation selectionSet selections first.	self assert: field class equals: GQLScalarFieldNode.	self assert: field name equals: 'experimentalField'.</body><body package="GraphQLBeta-Tests">testVariableListTypeNonNullNamed	| text document operation field |	text := 'query myQuery($someTest: [ Some! ]) {  				experimentalField				}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: GQLDocumentNode.	operation := document definitions first.	self assert: operation class equals: GQLOperationNode.	self assert: operation name equals: 'myQuery'.	self assert: operation type equals: 'query'.	self assert: operation variableDefinitions first name class equals: GQLVariableNode.	self assert: operation variableDefinitions first name value equals: '$someTest'.	self assert: operation variableDefinitions first type class equals: GQLSListTypeNode.	self assert: operation variableDefinitions first type wrappedType class equals: GQLSNonNullTypeNode.	self assert: operation variableDefinitions first type wrappedType wrappedType class equals: GQLSNamedTypeNode.	self assert: operation variableDefinitions first type wrappedType wrappedType name equals: 'Some'.	field := operation selectionSet selections first.	self assert: field class equals: GQLScalarFieldNode.	self assert: field name equals: 'experimentalField'.</body><body package="GraphQLBeta-Tests">testVariableNamedType	| text document operation field |	text := 'query myQuery($someTest: Some) {  				experimentalField				}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: GQLDocumentNode.	operation := document definitions first.	self assert: operation class equals: GQLOperationNode.	self assert: operation name equals: 'myQuery'.	self assert: operation type equals: 'query'.	self assert: operation variableDefinitions first name class equals: GQLVariableNode.	self assert: operation variableDefinitions first name value equals: '$someTest'.	self assert: operation variableDefinitions first type class equals: GQLSNamedTypeNode.	self assert: operation variableDefinitions first type name equals: 'Some'.	field := operation selectionSet selections first.	self assert: field class equals: GQLScalarFieldNode.	self assert: field name equals: 'experimentalField'.</body><body package="GraphQLBeta-Tests">testVariableNonNullListType	| text document operation field |	text := 'query myQuery($someTest: [ Float ]!) {  				experimentalField				}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: GQLDocumentNode.	operation := document definitions first.	self assert: operation class equals: GQLOperationNode.	self assert: operation name equals: 'myQuery'.	self assert: operation type equals: 'query'.	self assert: operation variableDefinitions first name class equals: GQLVariableNode.	self assert: operation variableDefinitions first name value equals: '$someTest'.	self assert: operation variableDefinitions first type class equals: GQLSNonNullTypeNode.	self assert: operation variableDefinitions first type wrappedType class equals: GQLSListTypeNode.	self assert: operation variableDefinitions first type wrappedType wrappedType class equals: GQLSFloatTypeNode.	field := operation selectionSet selections first.	self assert: field class equals: GQLScalarFieldNode.	self assert: field name equals: 'experimentalField'.</body><body package="GraphQLBeta-Tests">testVariableNonNullListTypeNamed	| text document operation field |	text := 'query myQuery($someTest: [ Some ]!) {  				experimentalField				}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: GQLDocumentNode.	operation := document definitions first.	self assert: operation class equals: GQLOperationNode.	self assert: operation name equals: 'myQuery'.	self assert: operation type equals: 'query'.	self assert: operation variableDefinitions first name class equals: GQLVariableNode.	self assert: operation variableDefinitions first name value equals: '$someTest'.	self assert: operation variableDefinitions first type class equals: GQLSNonNullTypeNode.	self assert: operation variableDefinitions first type wrappedType class equals: GQLSListTypeNode.	self assert: operation variableDefinitions first type wrappedType wrappedType class equals: GQLSNamedTypeNode.	self assert: operation variableDefinitions first type wrappedType wrappedType name equals: 'Some'.	field := operation selectionSet selections first.	self assert: field class equals: GQLScalarFieldNode.	self assert: field name equals: 'experimentalField'.</body><body package="GraphQLBeta-Tests">testVariableNonNullListTypeNonNull	| text document operation field |	text := 'query myQuery($someTest: [ Boolean! ]!) {  				experimentalField				}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: GQLDocumentNode.	operation := document definitions first.	self assert: operation class equals: GQLOperationNode.	self assert: operation name equals: 'myQuery'.	self assert: operation type equals: 'query'.	self assert: operation variableDefinitions first name class equals: GQLVariableNode.	self assert: operation variableDefinitions first name value equals: '$someTest'.	self assert: operation variableDefinitions first type class equals: GQLSNonNullTypeNode.	self assert: operation variableDefinitions first type wrappedType class equals: GQLSListTypeNode.	self assert: operation variableDefinitions first type wrappedType wrappedType class equals: GQLSNonNullTypeNode.	self assert: operation variableDefinitions first type wrappedType wrappedType wrappedType class equals: GQLSBooleanTypeNode.	field := operation selectionSet selections first.	self assert: field class equals: GQLScalarFieldNode.	self assert: field name equals: 'experimentalField'.</body><body package="GraphQLBeta-Tests">testVariableNonNullListTypeNonNullNamed	| text document operation field |	text := 'query myQuery($someTest: [ Some! ]!) {  				experimentalField				}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: GQLDocumentNode.	operation := document definitions first.	self assert: operation class equals: GQLOperationNode.	self assert: operation name equals: 'myQuery'.	self assert: operation type equals: 'query'.	self assert: operation variableDefinitions first name class equals: GQLVariableNode.	self assert: operation variableDefinitions first name value equals: '$someTest'.	self assert: operation variableDefinitions first type class equals: GQLSNonNullTypeNode.	self assert: operation variableDefinitions first type wrappedType class equals: GQLSListTypeNode.	self assert: operation variableDefinitions first type wrappedType wrappedType class equals: GQLSNonNullTypeNode.	self assert: operation variableDefinitions first type wrappedType wrappedType wrappedType class equals: GQLSNamedTypeNode.	self assert: operation variableDefinitions first type wrappedType wrappedType wrappedType name equals: 'Some'.	field := operation selectionSet selections first.	self assert: field class equals: GQLScalarFieldNode.	self assert: field name equals: 'experimentalField'.</body><body package="GraphQLBeta-Tests">testVariableNonNullNamedType	| text document operation field |	text := 'query myQuery($someTest: Some!) {  				experimentalField				}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: GQLDocumentNode.	operation := document definitions first.	self assert: operation class equals: GQLOperationNode.	self assert: operation name equals: 'myQuery'.	self assert: operation type equals: 'query'.	self assert: operation variableDefinitions first name class equals: GQLVariableNode.	self assert: operation variableDefinitions first name value equals: '$someTest'.	self assert: operation variableDefinitions first type class equals: GQLSNonNullTypeNode.	self assert: operation variableDefinitions first type wrappedType class equals: GQLSNamedTypeNode.	self assert: operation variableDefinitions first type wrappedType name equals: 'Some'.	field := operation selectionSet selections first.	self assert: field class equals: GQLScalarFieldNode.	self assert: field name equals: 'experimentalField'.</body><body package="GraphQLBeta-Tests">testVariableNonNullScalarType	| text document operation field |	text := 'query myQuery($someTest: ID!) {  				experimentalField				}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: GQLDocumentNode.	operation := document definitions first.	self assert: operation class equals: GQLOperationNode.	self assert: operation name equals: 'myQuery'.	self assert: operation type equals: 'query'.	self assert: operation variableDefinitions first name class equals: GQLVariableNode.	self assert: operation variableDefinitions first name value equals: '$someTest'.	self assert: operation variableDefinitions first type class equals: GQLSNonNullTypeNode.	self assert: operation variableDefinitions first type wrappedType class equals: GQLSIDTypeNode.	field := operation selectionSet selections first.	self assert: field class equals: GQLScalarFieldNode.	self assert: field name equals: 'experimentalField'.</body><body package="GraphQLBeta-Tests">testVariableScalarType	| text document operation field |	text := 'query myQuery($someTest: String) {  				experimentalField				}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: GQLDocumentNode.	operation := document definitions first.	self assert: operation class equals: GQLOperationNode.	self assert: operation name equals: 'myQuery'.	self assert: operation type equals: 'query'.	self assert: operation variableDefinitions first name class equals: GQLVariableNode.	self assert: operation variableDefinitions first name value equals: '$someTest'.	self assert: operation variableDefinitions first type class equals: GQLSStringTypeNode.	field := operation selectionSet selections first.	self assert: field class equals: GQLScalarFieldNode.	self assert: field name equals: 'experimentalField'.</body></methods><methods><class-id>GraphQLBeta.GQLRequestGrammarEvaluatorTest</class-id> <category>test-grammar-values</category><body package="GraphQLBeta-Tests">testArgumentsCompositeObjectValue	| text document field values |	text := '{  				nearestThing(countries: [{ name: "Bolivia" , continent: "America" } , 												{ name : "Chile" , continent: "America"}])	}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: GQLDocumentNode.	field := document definitions first selections first.	self assert: field name equals: 'nearestThing'.	self assert: field arguments size equals: 1.	self assert: field arguments first name equals: 'countries'.	self assert: field arguments first value class equals: GQLListNode.	values := field arguments first value value.	values do: [ :of |		self assert: of class equals: GQLObjectNode ].	self assert: values first objectFields first name equals: 'name'.	self assert: values first objectFields first value value equals: '"Bolivia"'.	self assert: values first objectFields second name equals: 'continent'.	self assert: values first objectFields second value value equals: '"America"'.	self assert: values second objectFields first name equals: 'name'.	self assert: values second objectFields first value value equals: '"Chile"'.	self assert: values second objectFields second name equals: 'continent'.	self assert: values second objectFields second value value equals: '"America"'.</body><body package="GraphQLBeta-Tests">testArgumentsEnumValue	| text document filmsSelection |	text := '{				films(ofGender: FavoriteGender){					rating					name				}			}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: GQLDocumentNode.	filmsSelection := document definitions first selections first.	self assert: filmsSelection   name equals: 'films'.	self assert: filmsSelection   arguments size equals: 1.	self assert: filmsSelection   arguments first name equals: 'ofGender'.	self assert: filmsSelection   arguments first value class equals: GQLEnumNode.	self assert: filmsSelection   arguments first value value equals: 'FavoriteGender'.</body><body package="GraphQLBeta-Tests">testArgumentsListScalarValue	| text document filmsSelection |	text := '{				films(inYears: [ 2016, 2012, 2000], withActors: [ "Adam Sandler", "Cris Rock" ]){					rating					name				}			}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: GQLDocumentNode.	filmsSelection := document definitions first selections first.	self assert: filmsSelection   name equals: 'films'.	self assert: filmsSelection   arguments size equals: 2.	self assert: filmsSelection   arguments first name equals: 'inYears'.	self assert: filmsSelection   arguments first value class equals: GQLListNode.	filmsSelection arguments first value value 		do: [ :year | self assert: year class equals: GQLIntNode ].	self assert: filmsSelection   arguments first value value first value equals: '2016'.	self assert: filmsSelection   arguments first value value second value equals: '2012'.	self assert: filmsSelection   arguments first value value third value equals: '2000'.	self assert: filmsSelection   arguments second name equals: 'withActors'.	self assert: filmsSelection   arguments second value class equals: GQLListNode.	filmsSelection arguments second value value 		do: [ :actor | self assert: actor class equals: GQLStringNode ].	self assert: filmsSelection   arguments second value value first value equals: '"Adam Sandler"'.	self assert: filmsSelection   arguments second value value second value equals: '"Cris Rock"'.</body><body package="GraphQLBeta-Tests">testArgumentsNullValue	| text document filmsSelection |	text := '{				films(inYear: 2016, visual: null){					rating					name				}			}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: GQLDocumentNode.	filmsSelection := document definitions first selections first.	self assert: filmsSelection   name equals: 'films'.	self assert: filmsSelection   arguments size equals: 2.	self assert: filmsSelection   arguments first name equals: 'inYear'.	self assert: filmsSelection   arguments first value class equals: GQLIntNode.	self assert: filmsSelection   arguments first value value equals: '2016'.	self assert: filmsSelection   arguments second name equals: 'visual'.	self assert: filmsSelection   arguments second value class equals: GQLNullNode.	self assert: filmsSelection   arguments second value value equals: 'null'.	self assert: filmsSelection selectionSet selections first name equals: 'rating'.	self assert: filmsSelection selectionSet selections second name equals: 'name'.</body><body package="GraphQLBeta-Tests">testArgumentsObjectValue	| text document field objectValue |	text := '{  				nearestThing(location: { lon: 12.43, lat: -53.211 })	}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: GQLDocumentNode.	field := document definitions first selections first.	self assert: field name equals: 'nearestThing'.	self assert: field arguments size equals: 1.	self assert: field arguments first name equals: 'location'.	objectValue := field arguments first value.	self assert: objectValue class equals: GQLObjectNode.	objectValue objectFields do: [ :of |		self assert: of class equals: GQLObjectFieldNode ].	self assert: objectValue objectFields first name equals: 'lon'.	self assert: objectValue objectFields first value value equals: '12.43'.	self assert: objectValue objectFields second name equals: 'lat'.	self assert: objectValue objectFields second value value equals: '-53.211'.</body><body package="GraphQLBeta-Tests">testArgumentsSimpleScalarValue	| text document filmsSelection actorsSelection|	text := '{				films(inYear: 2016, minorRating: 5.5){					rating				}				actors(inMovie : "Star wars", active : true){					name				}			}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: GQLDocumentNode.	filmsSelection := document definitions first selections first.	self assert: filmsSelection   name equals: 'films'.	self assert: filmsSelection   arguments size equals: 2.	self assert: filmsSelection   arguments first name equals: 'inYear'.	self assert: filmsSelection   arguments first value class equals: GQLIntNode.	self assert: filmsSelection   arguments first value value equals: '2016'.	self assert: filmsSelection   arguments second name equals: 'minorRating'.	self assert: filmsSelection   arguments second value class equals: GQLFloatNode.	self assert: filmsSelection   arguments second value value equals: '5.5'.	actorsSelection := document definitions first selections second.	self assert: actorsSelection  name equals: 'actors'.	self assert: actorsSelection  arguments size equals: 2.	self assert: actorsSelection arguments first name equals: 'inMovie'.	self assert: actorsSelection arguments first value class equals: GQLStringNode.	self assert: actorsSelection arguments first value value equals: '"Star wars"'.	self assert: actorsSelection arguments second name equals: 'active'.	self assert: actorsSelection arguments second value class equals: GQLBooleanNode.	self assert: actorsSelection arguments second value value equals: 'true'.</body><body package="GraphQLBeta-Tests">testArgumentsVariableValue	| text document filmsSelection |	text := '{				films(inYears: $years withActors: $actors){					rating					name				}			}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: GQLDocumentNode.	filmsSelection := document definitions first selections first.	self assert: filmsSelection   name equals: 'films'.	self assert: filmsSelection   arguments size equals: 2.	self assert: filmsSelection   arguments first name equals: 'inYears'.	self assert: filmsSelection   arguments first value class equals: GQLVariableNode.	self assert: filmsSelection   arguments first value value equals: '$years'.	self assert: filmsSelection   arguments second name equals: 'withActors'.	self assert: filmsSelection   arguments second value class equals: GQLVariableNode.	self assert: filmsSelection   arguments second value value equals: '$actors'.</body></methods><methods><class-id>GraphQLBeta.GQLRequestGrammarEvaluatorTest</class-id> <category>test-grammar-inlineFragment</category><body package="GraphQLBeta-Tests">testInlineFragmentIncomplete	| text document |	text := 'query inlineFragmentNoType($expandedInfo: Boolean) {    					... @include(if: ) {      					firstName      					birthday    					}	}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: PPFailure.		text := 'query inlineFragmentNoType($expandedInfo: Boolean) {    					.. on User {      					firstName      					birthday    					}	}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: PPFailure.</body><body package="GraphQLBeta-Tests">testInlineFragmentWithDirectives	| text document inlineFragmentTyping firstSubSelection firstFragment  |	text := 'query inlineFragmentNoType($expandedInfo: Boolean) {  				user(handle: "zuck") {    					id    					... @include(if: $expandedInfo) {      					firstName    					}  				}	}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: GQLDocumentNode.	inlineFragmentTyping := document definitions first.	self assert: inlineFragmentTyping class equals: GQLOperationNode.	self assert: inlineFragmentTyping type equals: 'query'.	self assert: inlineFragmentTyping name equals: 'inlineFragmentNoType'.	self assert: inlineFragmentTyping variableDefinitions first type class equals: GQLSBooleanTypeNode.	self assert: inlineFragmentTyping variableDefinitions first name value equals: '$expandedInfo'.		firstSubSelection := inlineFragmentTyping selectionSet selections first.	self assert: firstSubSelection class equals: GQLNonScalarFieldNode.	self assert: firstSubSelection name equals: 'user'.	self assert: firstSubSelection arguments first name equals: 'handle'.	self assert: firstSubSelection arguments first value class equals: GQLStringNode.	self assert: firstSubSelection arguments first value value equals: '"zuck"'. 		firstFragment := firstSubSelection selectionSet selections second.	self assert: firstFragment directives first name equals: 'include'.	self assert: firstFragment directives first arguments first name equals: 'if'.	self assert: firstFragment directives first arguments first value class equals: GQLVariableNode.	self assert: firstFragment directives first arguments first value value equals: '$expandedInfo'.	self assert: firstFragment selectionSet selections first name equals: 'firstName'.	</body><body package="GraphQLBeta-Tests">testInlineFragmentWithTypeCondition	| text document inlineFragmentTyping firstSubSelection firstFragment secondFragment |	text := 'query inlineFragmentTyping {  				profiles(handles: ["zuck", "cocacola"]) {   					handle    					... on User {      					friends {        						count      					}    					}    					... on Page {      					likers {        						count      					}    					}  				}			}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: GQLDocumentNode.	inlineFragmentTyping := document definitions first.	self assert: inlineFragmentTyping class equals: GQLOperationNode.	self assert: inlineFragmentTyping type equals: 'query'.	self assert: inlineFragmentTyping name equals: 'inlineFragmentTyping'.		firstSubSelection := inlineFragmentTyping selectionSet selections first selectionSet.	self assert: firstSubSelection class equals: GQLSelectionSetNode.	self assert: firstSubSelection selections first name equals: 'handle'.		firstFragment := firstSubSelection selections second.	self assert: firstFragment typeCondition class equals: GQLSNamedTypeNode.	self assert: firstFragment typeCondition name equals: 'User'.	self assert: firstFragment selectionSet selections first name equals: 'friends'.	self assert: firstFragment selectionSet selections first selectionSet selections first name equals: 'count'.		secondFragment := firstSubSelection selections third.	self assert: secondFragment typeCondition class equals: GQLSNamedTypeNode.	self assert: secondFragment typeCondition name equals: 'Page'.	self assert: secondFragment selectionSet selections first name equals: 'likers'.	self assert: secondFragment selectionSet selections first selectionSet selections first name equals: 'count'.	</body></methods><methods><class-id>GraphQLBeta.GQLRequestGrammarEvaluatorTest</class-id> <category>test-grammar-operation</category><body package="GraphQLBeta-Tests">testOperationFail	| text document |	text := 'mutation { 				likeStory(storyID: 12345) { 			 	story {    				}  			}		}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: PPFailure.		text := 'mutation { 				likeStory(storyID: .12345) {  			}		}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: PPFailure.		text := '{ 				likeStor(storyID: 12345) {  			}		}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: PPFailure.</body><body package="GraphQLBeta-Tests">testOperationMutation	| text document operation firstField subField |	text := 'mutation { 				likeStory(storyID: 12345) { 			 	story {      				likeCount    				}  			}		}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: GQLDocumentNode.	operation := document definitions first.	self assert: operation class equals: GQLOperationNode.	self assert: operation type equals: 'mutation'.	firstField := operation selectionSet selections first.	self assert: firstField class equals: GQLNonScalarFieldNode.	self assert: firstField name equals: 'likeStory'.	self assert: firstField arguments first name equals: 'storyID'.	self assert: firstField arguments first value class equals: GQLIntNode.	self assert: firstField arguments first value value equals: '12345'.	subField := firstField selectionSet selections first.	self assert: subField name equals: 'story'.	self assert: subField selectionSet selections first name equals: 'likeCount'.	</body><body package="GraphQLBeta-Tests">testOperationWithDirective	| text document operation firstField |	text := 'query @skip(if: $foo) { 				 field			}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: GQLDocumentNode.	operation := document definitions first.	self assert: operation class equals: GQLOperationNode.	self assert: operation type equals: 'query'.	self assert: operation directives first name equals: 'skip'.	self assert: operation directives first arguments first name equals: 'if'.	self assert: operation directives first arguments first value class equals: GQLVariableNode.	self assert: operation directives first arguments first value value equals: '$foo'.	firstField := operation selectionSet selections first.	self assert: firstField class equals: GQLScalarFieldNode.	self assert: firstField name equals: 'field'.</body><body package="GraphQLBeta-Tests">testOperationWithVariableDefaultValue	| text document operation field |	text := 'query myQuery($atOtherHomes: Boolean = true) {  				isHousetrained(atOtherHomes: $atOtherHomes)				}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: GQLDocumentNode.	operation := document definitions first.	self assert: operation class equals: GQLOperationNode.	self assert: operation name equals: 'myQuery'.	self assert: operation type equals: 'query'.	self assert: operation variableDefinitions first name class equals: GQLVariableNode.	self assert: operation variableDefinitions first name value equals: '$atOtherHomes'.	self assert: operation variableDefinitions first type class equals: GQLSBooleanTypeNode.	self assert: operation variableDefinitions first defaultValue class equals: GQLBooleanNode.	field := operation selectionSet selections first.	self assert: field class equals: GQLScalarFieldNode.	self assert: field name equals: 'isHousetrained'.	self assert: field arguments first name equals: 'atOtherHomes'.	self assert: field arguments first value class equals: GQLVariableNode.	self assert: field arguments first value value equals: '$atOtherHomes'.	</body><body package="GraphQLBeta-Tests">testOperationWithVariableDefinitions	| text document operation field |	text := 'query myQuery($someTest: Boolean) {  				experimentalField @include(if: $someTest)				}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: GQLDocumentNode.	operation := document definitions first.	self assert: operation class equals: GQLOperationNode.	self assert: operation name equals: 'myQuery'.	self assert: operation type equals: 'query'.	self assert: operation variableDefinitions first name class equals: GQLVariableNode.	self assert: operation variableDefinitions first name value equals: '$someTest'.	self assert: operation variableDefinitions first type class equals: GQLSBooleanTypeNode.	field := operation selectionSet selections first.	self assert: field class equals: GQLScalarFieldNode.	self assert: field name equals: 'experimentalField'.	self assert: field directives first name equals: 'include'.	self assert: field directives first arguments size equals: 1.	self assert: field directives first arguments first name equals: 'if'.	self assert: field directives first arguments first value class equals: GQLVariableNode.	self assert: field directives first arguments first value value equals: '$someTest'.	</body></methods><methods><class-id>GraphQLBeta.GQLRequestGrammarEvaluatorTest</class-id> <category>test-grammar-fragment</category><body package="GraphQLBeta-Tests">testFragment	| text document withFragment fragment |	text := 'query withFragment {      			...friendFields			}			fragment friendFields on User { 				name 				profilePic(size: 50)	}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: GQLDocumentNode.	withFragment := document definitions first.	self assert: withFragment class equals: GQLOperationNode.	self assert: withFragment type equals: 'query'.	self assert: withFragment name equals: 'withFragment'.	self assert: withFragment selectionSet selections first class equals: GQLFragmentSpreadNode.	self assert: withFragment selectionSet selections first name equals: 'friendFields'.		fragment := document definitions second.	self assert: fragment class equals: GQLFragmentNode.	self assert: fragment name equals: 'friendFields'.	self assert: fragment typeCondition class equals: GQLSNamedTypeNode.	self assert: fragment typeCondition name equals: 'User'.	self assert: fragment selectionSet selections first name equals: 'name'.	self assert: fragment selectionSet selections second name equals: 'profilePic'.	self assert: fragment selectionSet selections second arguments first name equals: 'size'.	self assert: fragment selectionSet selections second arguments first value class equals: GQLIntNode.	self assert: fragment selectionSet selections second arguments first value value equals: '50'.	</body><body package="GraphQLBeta-Tests">testFragmentIncorrect	| text document |	text := 'query withFragment {      			...friendFields			}			fragment on User { 				name 				profilePic(size: 50)	}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: PPFailure.		text := 'query withFragment {      			...friendFields			}			fragment friendFields { 				name 				profilePic(size: 50)	}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: PPFailure.		text := 'query withFragment {      			...friendFields			}			fragment friendFields on User {	}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: PPFailure.	</body><body package="GraphQLBeta-Tests">testFragmentWithDirectives	| text document withFragment fragment |	text := 'query withFragment {      			...friends			}			fragment friends on User @directiveBehavior { 				id	}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: GQLDocumentNode.	withFragment := document definitions first.	self assert: withFragment class equals: GQLOperationNode.	self assert: withFragment type equals: 'query'.	self assert: withFragment name equals: 'withFragment'.	self assert: withFragment selectionSet selections first class equals: GQLFragmentSpreadNode.	self assert: withFragment selectionSet selections first name equals: 'friends'.		fragment := document definitions second.	self assert: fragment class equals: GQLFragmentNode.	self assert: fragment name equals: 'friends'.	self assert: fragment typeCondition class equals: GQLSNamedTypeNode.	self assert: fragment typeCondition name equals: 'User'.	self assert: fragment directives first name equals: 'directiveBehavior'.	self assert: fragment selectionSet selections first name equals: 'id'.	</body></methods><methods><class-id>GraphQLBeta.GQLRequestGrammarEvaluator</class-id> <category>grammar</category><body package="GraphQLBeta-Parser">alias"Return the alias"	^ super alias		performs: [ :tokens | (tokens at: 1) inputValue ]</body><body package="GraphQLBeta-Parser">argument"Return a GQLArgumentNode instance with the information parsed of the request"	^ super argument		performs: [ :tokens | 			|node|			node := GQLArgumentNode new.			node name: (tokens at: 1) inputValue.			node value: (tokens at: 3).			node ]</body><body package="GraphQLBeta-Parser">arguments"Return the arguments"	^ super arguments		performs: [ :tokens | tokens at: 2 ]</body><body package="GraphQLBeta-Parser">booleanType	"Return a GQLSBooleanType instance"	^ super booleanType		performs: [ :tokens | 			| node |			node := GQLSBooleanTypeNode new.			node ]</body><body package="GraphQLBeta-Parser">booleanValue"Return the boolean value"	^ super booleanValue		performs: [ :tokens | 			| node |			node := GQLBooleanNode new.			node value: tokens inputValue.			node ]</body><body package="GraphQLBeta-Parser">defaultValue"Return the default value"	^ super defaultValue		performs: [ :tokens | (tokens at: 2) ]</body><body package="GraphQLBeta-Parser">directive"Return a GQLDirectiveNode instance with the information of the request"	^ super directive		performs: [ :tokens | 			|node|			node := GQLDirectiveNode new.			node name: (tokens at: 2) inputValue.			node arguments: (tokens at: 3).			node ]</body><body package="GraphQLBeta-Parser">document	"Return a instance of GQLDocumentNode with the information of the parser"	^ super document		performs: [ :tokens | 			| node |			node := GQLDocumentNode new.			node definitions: tokens ]</body><body package="GraphQLBeta-Parser">enumValue"Return the enum value"	^ super enumValue		performs: [ :tokens | 			| node |			node := GQLEnumNode new.			node value: tokens inputValue.			node ]</body><body package="GraphQLBeta-Parser">floatType	"Return a GQLSFloatTypeNode instance"	^ super floatType		performs: [ :tokens | 			| node |			node := GQLSFloatTypeNode new.			node ]</body><body package="GraphQLBeta-Parser">floatValue"Return the variable"	^ super floatValue		performs: [ :tokens | 			| node |			node := GQLFloatNode new.			node value: tokens inputValue.			node ]</body><body package="GraphQLBeta-Parser">fragmentDefinition	"Return a instance of GQLFragmentNode with the information of the request"	^ super fragmentDefinition		performs: [ :tokens | 			| node |			node := GQLFragmentNode new.			node name: (tokens at: 3).			node typeCondition: (tokens at: 4).			node directives: (tokens at: 5).			node selectionSet: (tokens at: 6).			node]</body><body package="GraphQLBeta-Parser">fragmentName"Return the fragmentName"	^ super fragmentName		performs: [ :tokens | (tokens at: 2) inputValue ]</body><body package="GraphQLBeta-Parser">fragmentSpread	"Return a instance of GQLFragmentSpreadNode with the information of the request"	^ super fragmentSpread		performs: [ :tokens | 			| node |			node := GQLFragmentSpreadNode new.			node name: (tokens at: 2).			node directives: (tokens at: 3).			node]</body><body package="GraphQLBeta-Parser">idType	"Return a GQLSIDType instance"	^ super idType		performs: [ :tokens | 			| node |			node := GQLSIDTypeNode new.			node ]</body><body package="GraphQLBeta-Parser">inlineFragment	"Return a instance of GQLInlineFragmentNode with the information of the request"	^ super inlineFragment		performs: [ :tokens | 			| node |			node := GQLInlineFragmentNode new.			node typeCondition: (tokens at: 2).			node directives: (tokens at: 3).			node selectionSet: (tokens at: 4)]</body><body package="GraphQLBeta-Parser">intType	"Return a GQLSIntTypeNode instance"	^ super intType		performs: [ :tokens | 			| node |			node := GQLSIntTypeNode new.			node position: tokens start.			node ]</body><body package="GraphQLBeta-Parser">intValue"Return the intValue"	^ super intValue		performs: [ :tokens | 			| node |			node := GQLIntNode new.			node value: tokens inputValue.			node ]</body><body package="GraphQLBeta-Parser">listType"Return a list type"	^ super listType		performs: [ :tokens | 			| node |			node := GQLSListTypeNode new.			node wrappedType: (tokens at: 2).			node position: (tokens at: 2) position.			node ]</body><body package="GraphQLBeta-Parser">listValue"Return the list value"	^ super listValue		performs: [ :tokens | 			| node |			node := GQLListNode new.			node value: (tokens at: 2).			node ]</body><body package="GraphQLBeta-Parser">named	"Return a GQLSNamedTypeNode instance with his name and the position on the request"	^ super named		performs: [ :tokens | 			| node |			node := GQLSNamedTypeNode new.			node name: tokens inputValue.			node position: tokens start.			node ]</body><body package="GraphQLBeta-Parser">nonNullType"Return the non null type"	^ super nonNullType		performs: [ :tokens | 			| node |			node := GQLSNonNullTypeNode new.			node wrappedType: (tokens at: 1).			node position: (tokens at: 1) position.			node ]</body><body package="GraphQLBeta-Parser">nonScalarField"Return a GQLNonScalarNode instance with the information of the request parsed"	^ super nonScalarField		performs: [ :tokens | 			| node |			node := GQLNonScalarFieldNode new.			node alias: (tokens at: 1).			node name: (tokens at: 2) inputValue.			node arguments: (tokens at: 3).			node selectionSet: (tokens at: 5).			node position: (tokens at: 2) start.			node ]</body><body package="GraphQLBeta-Parser">nullValue"Return the nullValue"	^ super nullValue		performs: [ :tokens | 			| node |			node := GQLNullNode new.			node value: tokens inputValue.			node ]</body><body package="GraphQLBeta-Parser">objectField"Return a GQLObjectFieldNode instance with the information from the request"	^ super objectField		performs: [ :tokens | 			| node |			node := GQLObjectFieldNode new.			node name: (tokens at: 1) inputValue.			node value: (tokens at: 3).			node ]</body><body package="GraphQLBeta-Parser">objectValue"Return the objectValue"	^ super objectValue		performs: [ :tokens | 			| node |			node := GQLObjectNode new.			node objectFields: (tokens at: 2).			node ]</body><body package="GraphQLBeta-Parser">operation	"Return a instance of GQLOperationNode with the information of the parser"	^ super operation		performs: [ :tokens | 			| node |			node := GQLOperationNode new.			node type: (tokens at: 1).			node name: (tokens at: 3).			node variableDefinitions: (tokens at: 4).			node directives: (tokens at: 5).			node selectionSet: (tokens at: 6)]</body><body package="GraphQLBeta-Parser">scalarField"Return a GQLScalarFieldNode instance with the information from the request"	^ super scalarField		performs: [ :tokens | 			|node|			node := GQLScalarFieldNode new.			node alias: (tokens at: 1).			node name: (tokens at: 2) inputValue.			node arguments: (tokens at: 3).			node directives: (tokens at: 4).			node ]</body><body package="GraphQLBeta-Parser">selectionSet"Return a set of selections"	^ super selectionSet		performs: [ :tokens | 			|node|			node := GQLSelectionSetNode new.			node selections: (tokens at: 2).			node ]</body><body package="GraphQLBeta-Parser">stringType	"Return a GQLSStringType instance"	^ super stringType		performs: [ :tokens | 			| node |			node := GQLSStringTypeNode new.			node ]</body><body package="GraphQLBeta-Parser">stringValue"Return the string value"	^ super stringValue		performs: [ :tokens | 			| node |			node := GQLStringNode new.			node value: tokens inputValue.			node ]</body><body package="GraphQLBeta-Parser">typeCondition"Return the type condition"	^ super typeCondition		performs: [ :tokens | (tokens at: 3) ]</body><body package="GraphQLBeta-Parser">variable"Return a GQLVariableNode instance with the value assigned"	^ super variable		performs: [ :tokens | 			| node |			node := GQLVariableNode new.			node value: tokens inputValue.			node ]</body><body package="GraphQLBeta-Parser">variableDefinition"Return a GQLVariableDefinitionNode instance with the name, type and the default value of the variable"	^ super variableDefinition		performs: [ :tokens |			| node |			node := GQLVariableDefinitionNode new.			node name: (tokens at: 1).			node type: (tokens at: 3).			node defaultValue: (tokens at: 4).			node ]</body><body package="GraphQLBeta-Parser">variableDefinitions"Return the variable definitions"	^ super variableDefinitions		performs: [ :tokens | tokens at: 2 ]</body></methods><methods><class-id>GraphQLBeta.GQLObjectFieldNode</class-id> <category>accessing</category><body package="GraphQLBeta-Nodes">name"Return the name"	^ name</body><body package="GraphQLBeta-Nodes">name: anObject"Set the name"	name := anObject</body><body package="GraphQLBeta-Nodes">value"Return the value"	^ value</body><body package="GraphQLBeta-Nodes">value: anObject"Set the value"	value := anObject</body></methods><methods><class-id>GraphQLBeta.GQLSInterfaceTypeNode</class-id> <category>initialization</category><body package="GraphQLBeta-NodesSchema">initialize	super initialize.	fields := Dictionary new</body></methods><methods><class-id>GraphQLBeta.GQLSInterfaceTypeNode</class-id> <category>adding</category><body package="GraphQLBeta-NodesSchema">addFields: aArray"Puts the fields of the array on a dictionary"	aArray do: [ :field | fields at: field name put: field ]</body></methods><methods><class-id>GraphQLBeta.GQLSInterfaceTypeNode</class-id> <category>accessing</category><body package="GraphQLBeta-NodesSchema">fields"Return the fields"	^ fields</body><body package="GraphQLBeta-NodesSchema">getField: aFieldName	"Return the field given his name"	| res |	res := (fields includesKey: aFieldName)		ifTrue: [ fields at: aFieldName ]		ifFalse: [ nil ].	^ res</body></methods><methods><class-id>GraphQLBeta.GQLStringNode</class-id> <category>accessing</category><body package="GraphQLBeta-Nodes">executeOn: resolver with: env using: schema"Execute the input value according to the resolver, the enviroment and the schema"	 ^ value				copyFrom: 2				to: value size - 1</body></methods><methods><class-id>GraphQLBeta.GQLNonScalarFieldNode</class-id> <category>accessing</category><body package="GraphQLBeta-Nodes">executeOn: resolver with: env using: schema"Given a resolver, an enviroment and the schema, execute the request"	| objectValue type result params className |	params := arguments		collect: [ :e | 			e executeOn: resolver with: env using: schema ].	objectValue := resolver		perform: self fullName asSymbol		withArguments: params asArray.	className := resolver isClass		ifTrue: [ #Class ]		ifFalse: [ resolver class name ].	type := (schema getType: className)		getFieldType: self name.	type class = GQLSListTypeNode		ifTrue: [ result := OrderedCollection new.			objectValue				do: [ :el | 					result						add:							(self selectionSet executeOn: el with: env using: schema) ] ]		ifFalse: [ result := self selectionSet executeOn: objectValue with: env using: schema ].	^ result</body><body package="GraphQLBeta-Nodes">selectionSet"Return the selection set"	^ selectionSet</body><body package="GraphQLBeta-Nodes">selectionSet: anObject"Set the selection set"	selectionSet := anObject</body></methods><methods><class-id>GraphQLBeta.GQLNonScalarFieldNode</class-id> <category>testing</category><body package="GraphQLBeta-Nodes">isScalar"Answer false because is not scalar"	^ false</body></methods><methods><class-id>GraphQLBeta.GQLBooleanNode</class-id> <category>accessing</category><body package="GraphQLBeta-Nodes">executeOn: resolver with: env using: schema"Execute the input value according to the resolver, the enviroment and the schema"	^ value = 'true'</body></methods><methods><class-id>GraphQLBeta.GQLValidationException</class-id> <category>message</category><body package="GraphQLBeta">messageClassText"Message for class that doesn't exist on the image of Smalltalk"	| writer |	writer := WriteStream on: String new.	writer		nextPutAll: 'No exist the class ';		nextPutAll: node name.	self messageText: writer contents</body><body package="GraphQLBeta">messageMethodText: aClass"Message for the method that doesn't exist on the Class"	| writer |	writer := WriteStream on: String new.	writer		nextPutAll: 'No exist the method ';		nextPutAll: node fullName;		nextPutAll: ' on the class ';		nextPutAll: aClass name.	self messageText: writer contents</body></methods><methods><class-id>GraphQLBeta.GQLSIntTypeNode</class-id> <category>initialization</category><body package="GraphQLBeta-NodesSchema">initialize	super initialize.	name := 'Int'</body></methods><methods><class-id>GraphQLBeta.GQLSchemaGrammarTest</class-id> <category>test-grammar-listInputType</category><body package="GraphQLBeta-Tests">testListInputType	"Inner types only input type"	self parse: '[Int]' rule: #listInputType.	self parse: '[String ! ]' rule: #listInputType.	self parse: '[Some!]' rule: #listInputType.	self parse: '[Some ! ] ' rule: #listInputType.	self parse: '[[Int]]' rule: #listInputType</body><body package="GraphQLBeta-Tests">testListInputTypeIncorrect	self fail: 'Int !' rule: #listInputType.	self fail: '[Int ! ]!!' rule: #listInputType.	self fail: '[Int ! ]!' rule: #listInputType.	self fail: '[String ' rule: #listInputType.	self fail: '[Some ' rule: #listInputType.	self fail: '[Some! ' rule: #listInputType.	self fail: '[Some !!' rule: #listInputType.	self fail: '[ Some ] !' rule: #listInputType.</body></methods><methods><class-id>GraphQLBeta.GQLSchemaGrammarTest</class-id> <category>tests-grammar</category><body package="GraphQLBeta-Tests">parserClass	^ GQLSchemaGrammar</body><body package="GraphQLBeta-Tests">testSchemaAll	| text |	text := 'enum DogCommand { SIT, DOWN, HEEL }				type Dog implements Pet {  					name: String!  					nickname: String  					barkVolume: Int  					doesKnowCommand(dogCommand: DogCommand!): Boolean!  					isHousetrained(atOtherHomes: Boolean): Boolean!  					owner: Human				}				interface Sentient {  					name: String!				}				interface Pet { 					 name: String!				}				type Alien implements Sentient {  					name: String!  					homePlanet: String				}				type Human implements Sentient {  					name: String!				}				enum CatCommand { JUMP }			type Cat implements Pet {  				name: String!  				nickname: String  				doesKnowCommand(catCommand: CatCommand!): Boolean!  				meowVolume: Int			}			union CatOrDog = Cat | Dog			union DogOrHuman = Dog | Human			union HumanOrAlien = Human | Alien			type QueryRoot {  				dog: Dog			}'.	self parse: text rule: #schema</body><body package="GraphQLBeta-Tests">testSchemaInputObjectType	| text |	text := 'input MessageInput {  				content: String 				author: String			}			type Message {  				id: ID!  				content: String  				author: String			}			type Query {  				getMessage(id: ID!): Message			}'.	self parse: text rule: #schema.	self parse: 'input SomeType {						someName : [Int]					}' rule: #schema.	self parse: 'input SomeOtherTypeName {						someName 	: [String ! ],						someName 	:String 					}' rule: #schema</body><body package="GraphQLBeta-Tests">testSchemaObjectType	| text |	text := 'type SomeType {					someName : [Int]				},				type SomeOtherTypeName {					someName 	: [String ! ]					someName 	:String 				}'.	self parse: text rule: #schema.	self parse: 'type SomeType {						someName : [Int]					}' rule: #schema.	self parse: 'type SomeOtherTypeName {						someName 	: [String ! ],						someName 	:String 					}' rule: #schema</body><body package="GraphQLBeta-Tests">testSchemaWithEnum	| text |	text := 'enum DogCommand { SIT, DOWN, HEEL }				type SomeType {					someName : [Int]				},				type SomeOtherTypeName {					someName 	: [String ! ]					someName 	:String 				}'.	self parse: text rule: #schema.	self		parse:			'type SomeType {						someName : [Int]					}			enum DogCommand { SIT, DOWN, HEEL }'		rule: #schema.	self		parse:			'enum CatCommand { JUMP }			type SomeOtherTypeName {						someName 	: [String ! ],						someName 	:String 					}			enum DogCommand { SIT, DOWN, HEEL }'		rule: #schema</body><body package="GraphQLBeta-Tests">testSchemaWithInterface	| text |	text := 'type SomeType {					someName : [Int]				},				interface SomeOtherTypeName {					someName 	: [String ! ]					someName 	:String 				}'.	self parse: text rule: #schema.	self		parse:			'interface SomeType {						someName : [Int]					}'		rule: #schema.</body><body package="GraphQLBeta-Tests">testSchemaWithUnion	| text |	text := 'union DogOrHuman = Dog | Human				union HumanOrAlien = Human | Alien				type SomeType {					someName : [Int]				},				type SomeOtherTypeName {					someName 	: [String ! ]					someName 	:String 				}'.	self parse: text rule: #schema.	self		parse:			'type SomeType {						someName : [Int]					}			union HumanOrAlien = Human | Alien'		rule: #schema.	self		parse:			'union HumanOrAlien = Human | Alien			type SomeOtherTypeName {						someName 	: [String ! ],						someName 	:String 					}			union DogOrHuman = Dog | Human'		rule: #schema</body></methods><methods><class-id>GraphQLBeta.GQLSchemaGrammarTest</class-id> <category>test-grammar-field</category><body package="GraphQLBeta-Tests">testField	self parse: 'someName1 	: Int' rule: #field.	self parse: 'someName2 	: [String ! ]!' rule: #field.	self parse: 'someName3 	: 	ID !' rule: #field.	self parse: 'someName4 	: 	SomeOtherType !' rule: #field.	self parse: 'withParam1 ( aParam: String): 	SomeOtherType !' rule: #field.	self parse: 'withParam2( aParam: String, bParam:Int): 	SomeOtherType !' rule: #field.	self		parse: 'withParam3( aParam: String, someOtherParam:Int): 	SomeOtherType !'		rule: #field.</body><body package="GraphQLBeta-Tests">testFieldIncorrect	self fail: '123:Int !' rule: #field.	self fail: 'someName : [ String' rule: #field.	self fail: 'some : !' rule: #field.	self fail: 'some() : Int' rule: #field.	self fail: 'some : 123' rule: #field.	self fail: 'some : [String !' rule: #field</body></methods><methods><class-id>GraphQLBeta.GQLSchemaGrammarTest</class-id> <category>test-grammar-enumType</category><body package="GraphQLBeta-Tests">testEnumType	self parse: 'enum DogCommand { SIT, DOWN, HEEL }' rule: #enumType.	self parse: 'enum CatCommand { JUMP }' rule: #enumType.</body><body package="GraphQLBeta-Tests">testFailEnumTypeIncomplete	self fail: 'enum { ROSE, LAVANDA}' rule: #enumType.	self fail: 'enum ROSE, LAVANDA' rule: #enumType.	self fail: 'enum { }' rule: #enumType.	self fail: 'enum FLOWER' rule: #enumType.	self fail: 'enum true { ROSE, LAVANDA}' rule: #enumType.	self fail: 'enum false { ROSE, LAVANDA}' rule: #enumType.	self fail: 'enum null { ROSE, LAVANDA}' rule: #enumType.	self fail: 'FLOWER' rule: #enumType.	self fail: 'FLOWER { ROSE, LAVANDA}' rule: #enumType.</body><body package="GraphQLBeta-Tests">testFailEnumTypeOther	self fail: '{someName 	: 	ID !}' rule: #enumType.	self fail: 'type {someName 	: 	ID !}' rule: #enumType.	self fail: 'type {}' rule: #enumType.	self fail: 'type Some {}' rule: #enumType.	self fail: 'type implements' rule: #enumType.	self fail: 'type Some implements {}' rule: #enumType.	self fail: 'type Some implements {someName : ID}' rule: #enumType.	self fail: 'type Some Other { someName: ID}' rule: #enumType.	self fail: 'interface Sentiet { name : String}' rule: #enumType.	self fail: 'interface { name : String}' rule: #enumType.	self fail: 'union CatOrDog = Cat | Dog' rule: #enumType</body></methods><methods><class-id>GraphQLBeta.GQLSchemaGrammarTest</class-id> <category>test-grammar-nonNullType</category><body package="GraphQLBeta-Tests">testNonNullType	self parse: 'Int!' rule: #nonNullType.	self parse: 'SomeOtherType !' rule: #nonNullType.	self parse: '[ Int ]!' rule: #nonNullType.	self parse: '[ Int! ]!' rule: #nonNullType.	self parse: '[ SomeOtherType ]!' rule: #nonNullType.	self parse: '[ SomeOtherType! ]!' rule: #nonNullType.</body><body package="GraphQLBeta-Tests">testNonNullTypeIncorrect	self fail: 'Int!!' rule: #nonNullType.	self fail: 'Int' rule: #nonNullType.	self fail: 'SomeOtherType' rule: #nonNullType.	self fail: '[ Int! ]' rule: #nonNullType.	self fail: '[ Int ]' rule: #nonNullType.	self fail: '[ SomeOtherType ]' rule: #nonNullType.	self fail: '[ SomeOtherType! ]' rule: #nonNullType</body></methods><methods><class-id>GraphQLBeta.GQLSchemaGrammarTest</class-id> <category>test-grammar-interfaceType</category><body package="GraphQLBeta-Tests">testFailInterfaceTypeOther	self fail: '{someName 	: 	ID !}' rule: #interfaceType.	self fail: 'type {someName 	: 	ID !}' rule: #interfaceType.	self fail: 'type {}' rule: #interfaceType.	self fail: 'type Some {}' rule: #interfaceType.	self fail: 'type implements' rule: #interfaceType.	self fail: 'type Some implements {}' rule: #interfaceType.	self fail: 'type Some implements {someName : ID}' rule: #interfaceType.	self fail: 'type Some Other { someName: ID}' rule: #interfaceType.	self fail: 'union CatOrDog = Cat | Dog' rule: #interfaceType.	self fail: 'enum Some { someName: ID}' rule: #interfaceType.</body><body package="GraphQLBeta-Tests">testInterfaceType	self parse: 'interface DogCommand { some : Int}' rule: #interfaceType.	self parse:			'interface CatCommand { other : [ Int ]												  name : String !												  friends : [ Cat ]! }'		rule: #interfaceType.	self parse:			'interface CatCommand { other : [ Int ! ] !												  name(some : String) : String !												  friends : [ Cat ]! }'		rule: #interfaceType.</body><body package="GraphQLBeta-Tests">testInterfaceTypeIncorrect	self fail: 'interface  { some : Int}' rule: #interfaceType.	self		fail:			'interface CatCommand { other : [ Int 												  name : String !												  friends : [ Cat ]! }'		rule: #interfaceType.	self		fail:			'interface CatCommand { other :												  name : String !												  friends : [ Cat ]! }'		rule: #interfaceType</body></methods><methods><class-id>GraphQLBeta.GQLSchemaGrammarTest</class-id> <category>test-grammar-objectType</category><body package="GraphQLBeta-Tests">testFailObjectTypeIncomplete	self fail: '{someName 	: 	ID !}' rule: #objectType.	self fail: 'type {someName 	: 	ID !}' rule: #objectType.	self fail: 'type {}' rule: #objectType.	self fail: 'type Some {}' rule: #objectType.	self fail: 'type implements' rule: #objectType.	self fail: 'type Some implements {}' rule: #objectType.	self fail: 'type Some implements {someName : ID}' rule: #objectType.	self fail: 'type Some Other { someName: ID}' rule: #objectType.</body><body package="GraphQLBeta-Tests">testFailObjectTypeOther	self fail: 'enum Flower { ROSE, LAVANDA}' rule: #objectType.	self fail: 'interface Sentiet { name : String}' rule: #objectType.	self fail: 'union CatOrDog = Cat | Dog' rule: #objectType</body><body package="GraphQLBeta-Tests">testObjectType	self parse: 'type SomeType {someName : [Int]}' rule: #objectType.	self		parse: 'type SomeOtherTypeName {someName 	: [String ! ], someName 	:String }'		rule: #objectType.	self parse: 'type Some {someObject : Some }' rule: #objectType.	self parse: 'type Some {someObject : Some ! }' rule: #objectType.	self parse: 'type Some {someObject : [ Some ] ! }' rule: #objectType.	self parse: 'type Some {someObject : [ Some ! ] }' rule: #objectType.	self parse: 'type Some {someObject : [ Some ! ] ! }' rule: #objectType.	self parse: 'type Some implements Other { some : Int }' rule: #objectType.	self		parse: 'type SomeOtherTypeName implements Other {someName 	: [String ! ], someName 	:String }'		rule: #objectType.	self parse: 'type Some implements Other {someObject : Some }' rule: #objectType.	self parse: 'type Some implements Other {someObject(a : String) : Some }' rule: #objectType.	self parse: 'type Some implements Other {someObject(a : String, p: Some) : Some }' rule: #objectType.	self parse: 'type Some implements Other {someObject : Some ! }' rule: #objectType.	self parse: 'type Some implements Other {someObject : [ Some ] ! }' rule: #objectType.	self parse: 'type Some implements Other {someObject : [ Some ! ] }' rule: #objectType.	self parse: 'type Some implements Other {someObject : [ Some ! ] ! }' rule: #objectType.</body></methods><methods><class-id>GraphQLBeta.GQLSchemaGrammarTest</class-id> <category>test-grammar-parameter</category><body package="GraphQLBeta-Tests">testParameter	self parse: 'p1:[Int!]!' rule: #parameter.	self parse: 'p1 : [String ! ]' rule: #parameter.	self parse: 'p2: String!' rule: #parameter.	self parse: 'p : Some' rule: #parameter.	self parse: 'p : Some!' rule: #parameter.	self parse: 'p : [ Some ] !' rule: #parameter.	self parse: 'p : [Some!] !' rule: #parameter.</body><body package="GraphQLBeta-Tests">testParameterIncorrect	self fail: 'Int !' rule: #parameter.	self fail: 'p1:' rule: #parameter.	self fail: 'p1: !' rule: #parameter.	self fail: 'p1 Int' rule: #parameter.	self fail: 'p1 !' rule: #parameter.</body></methods><methods><class-id>GraphQLBeta.GQLSchemaGrammarTest</class-id> <category>test-grammar-inputObjectType</category><body package="GraphQLBeta-Tests">testFailInputObjectTypeIncomplete	self fail: '{someName 	: 	ID !}' rule: #inputObjectType.	self fail: 'input {someName 	: 	ID !}' rule: #inputObjectType.	self fail: 'input {}' rule: #inputObjectType.	self fail: 'input Some {}' rule: #inputObjectType.	self fail: 'input Some {}' rule: #inputObjectType.	self fail: 'input Some {some : }' rule: #inputObjectType.	self fail: 'input Some Other { someName: ID}' rule: #inputObjectType.	self fail: 'input Some { someName(a : ) : ID}' rule: #inputObjectType.	self fail: 'input Some { someName(a : String, b ) : ID}' rule: #inputObjectType.</body><body package="GraphQLBeta-Tests">testFailInputObjectTypeOther	self fail: 'enum Flower { ROSE, LAVANDA}' rule: #inputObjectType.	self fail: 'interface Sentiet { name : String}' rule: #inputObjectType.	self fail: 'union CatOrDog = Cat | Dog' rule: #inputObjectType.	self fail: 'type SomeType {someName : [Int]}' rule: #inputObjectType.	self fail: 'type SomeType implements Some {someName : [Int]}' rule: #inputObjectType.</body><body package="GraphQLBeta-Tests">testInputObjectType	self parse: 'input SomeType {someName : [Int]}' rule: #inputObjectType.	self		parse: 'input SomeOtherTypeName {someName 	: [String ! ], someName 	:String }'		rule: #inputObjectType.	self parse: 'input Some {someObject : Some }' rule: #inputObjectType.	self parse: 'input Some {someObject : Some ! }' rule: #inputObjectType.	self parse: 'input Some {someObject : [ Some ] ! }' rule: #inputObjectType.	self parse: 'input Some {someObject : [ Some ! ] }' rule: #inputObjectType.	self parse: 'input Some {someObject : [ Some ! ] ! }' rule: #inputObjectType.	self parse: 'input Some { some : Int }' rule: #inputObjectType.	self parse: 'input Some { some(p : String) : Int }' rule: #inputObjectType.	self parse: 'input Some { some(p : Some) : Int }' rule: #inputObjectType.	self parse: 'input Some { some(p : String, a : Some) : Int }' rule: #inputObjectType.</body></methods><methods><class-id>GraphQLBeta.GQLSchemaGrammarTest</class-id> <category>test-grammar-inputTypes</category><body package="GraphQLBeta-Tests">testInputType	self parse: '[Int ! ]!' rule: #inputType.	self parse: '[String ! ]' rule: #inputType.	self parse: '[ String ]!' rule: #inputType.	self parse: 'Int !' rule: #inputType.	self parse: 'String' rule: #inputType.	self parse: 'Some' rule: #inputType.</body><body package="GraphQLBeta-Tests">testInputTypeIncorrect	self fail: '[Int' rule: #inputType.	self fail: '[String !' rule: #inputType.	self fail: '[ ]!' rule: #inputType.	self fail: '!' rule: #inputType.	self fail: '[Some' rule: #inputType.</body></methods><methods><class-id>GraphQLBeta.GQLSchemaGrammarTest</class-id> <category>test-grammar-unionType</category><body package="GraphQLBeta-Tests">testFailUnionTypeOther	self fail: '{someName 	: 	ID !}' rule: #unionType.	self fail: 'type {someName 	: 	ID !}' rule: #unionType.	self fail: 'type {}' rule: #unionType.	self fail: 'type Some {}' rule: #unionType.	self fail: 'type implements' rule: #unionType.	self fail: 'type Some implements {}' rule: #unionType.	self fail: 'type Some implements {someName : ID}' rule: #unionType.	self fail: 'type Some Other { someName: ID}' rule: #unionType.	self fail: 'interface Sentiet { name : String}' rule: #unionType.	self fail: 'enum FLOWER { ROSE, LAVANDA }' rule: #unionType.</body><body package="GraphQLBeta-Tests">testUnionType	self parse: 'union CatOrDog = Cat | Dog' rule: #unionType.	self parse: 'union DogOrHuman = Dog | Human' rule: #unionType</body><body package="GraphQLBeta-Tests">testUnionTypeIncorrect	self fail: 'union CatOrDog = Cat | ' rule: #unionType.	self fail: 'union = Cat | Dog' rule: #unionType.	self fail: 'union CatOrDog Cat | Dog' rule: #unionType.	self fail: 'union CatOrDog = Cat Dog' rule: #unionType.</body></methods><methods><class-id>GraphQLBeta.GQLSchemaGrammarTest</class-id> <category>test-grammar-listType</category><body package="GraphQLBeta-Tests">testListType	self parse: '[Int]' rule: #listType.	self parse: '[SomeObject ]' rule: #listType.	self parse: '[String! ]' rule: #listType.	self parse: '[SomeObject ! ] ' rule: #listType.</body><body package="GraphQLBeta-Tests">testListTypeIncorrect	self fail: 'Int !' rule: #listType.	self fail: '[Int]!' rule: #listType.	self fail: '[Int ! ]!!' rule: #listType.	self fail: '[String ' rule: #listType.	self fail: '[Some !' rule: #listType</body></methods><methods><class-id>GraphQLBeta.GQLSchemaGrammarTest</class-id> <category>test-grammar-parameters</category><body package="GraphQLBeta-Tests">testParameters	self parse: '(p1:[Int], p2:String)' rule: #parameters.	self parse: '(p1 : [String ! ])' rule: #parameters.	self parse: '( p1 :[Int ! ]!, p2: String!)' rule: #parameters.</body><body package="GraphQLBeta-Tests">testParametersIncorrect	self fail: '(Int !)' rule: #parameters.	self fail: '(p1, p2)' rule: #parameters.	self fail: '(p1 : Int' rule: #parameters.	self fail: '(p1 Int)' rule: #parameters.	self fail: '(p1 Int!)' rule: #parameters.	self fail: '(p1 : !)' rule: #parameters.	self fail: '(p1 : Int, p2)' rule: #parameters.	self fail: '(p1, p2 : Int)' rule: #parameters.</body></methods><methods><class-id>GraphQLBeta.GQLSchemaGrammarTest</class-id> <category>test-grammar-nonNullInputType</category><body package="GraphQLBeta-Tests">testNonNullInputType	self parse: 'Int!' rule: #nonNullInputType.	self parse: 'SomeOtherType !' rule: #nonNullInputType.	self parse: '[ Int ]!' rule: #nonNullInputType.	self parse: '[ Int! ]!' rule: #nonNullInputType.	self parse: '[ SomeOtherType ]!' rule: #nonNullInputType.	self parse: '[ SomeOtherType! ]!' rule: #nonNullInputType</body><body package="GraphQLBeta-Tests">testNonNullInputTypeIncorrect	self fail: 'Int!!' rule: #nonNullInputType.	self fail: 'Int' rule: #nonNullInputType.	self fail: 'SomeOtherType' rule: #nonNullInputType.	self fail: '[ Int! ]' rule: #nonNullInputType.	self fail: '[ Int ]' rule: #nonNullInputType.	self fail: '[ SomeOtherType ]' rule: #nonNullInputType.	self fail: '[ SomeOtherType! ]' rule: #nonNullInputType</body></methods><methods><class-id>GraphQLBeta.GQLSchemaGrammarTest</class-id> <category>test-grammar-fieldSet</category><body package="GraphQLBeta-Tests">testFieldSet	self parse: '{someName : [Int]}' rule: #fieldSet.	self parse: '{someName 	: [String ! ], someName 	:String }' rule: #fieldSet.	self parse: '{someName 	: [String ! ] someName 	:String }' rule: #fieldSet.	self parse: '{someName 	: String !, someName 	:String }' rule: #fieldSet.	self parse: '{someName 	: String ! someName 	:String }' rule: #fieldSet.	self parse: '{someName 	: [String !] ! someName 	:String }' rule: #fieldSet.</body><body package="GraphQLBeta-Tests">testFieldSetIncorrect	self fail: 'someName 	: 	ID !' rule: #fieldSet.	self fail: '{}' rule: #fieldSet.	self fail: '{ someName }' rule: #fieldSet.	self fail: '{ someName : }' rule: #fieldSet.	self fail: '{ someName : !}' rule: #fieldSet.	self fail: '{ someName ID}' rule: #fieldSet.	self fail: '{ someName ID!}' rule: #fieldSet.	self fail: '{ someName !}' rule: #fieldSet.</body></methods><methods><class-id>GraphQLBeta.GQLTestFilm</class-id> <category>accessing</category><body package="GraphQLBeta-Test-Utils">id	^ id		</body><body package="GraphQLBeta-Test-Utils">name	^ filmName 	</body><body package="GraphQLBeta-Test-Utils">rating	^ rating		</body><body package="GraphQLBeta-Test-Utils">toDictionary	^ Dictionary new 		at: #id put: id;		at: #name put: filmName;		at: #rating put: rating	</body></methods><methods><class-id>GraphQLBeta.GQLTestFilm</class-id> <category>initialization</category><body package="GraphQLBeta-Test-Utils">initialize: anId name: aString rating: aNumber	id := anId.	filmName := aString.	rating := aNumber	</body></methods><methods><class-id>GraphQLBeta.GQLTestFilm class</class-id> <category>instance creation</category><body package="GraphQLBeta-Test-Utils">new: id name: filmName rating: rating	| inst |	inst := self new.	inst initialize: id name: filmName rating: rating.	^ inst.	</body></methods><methods><class-id>GraphQLBeta.GraphQLBetaTest</class-id> <category>tests</category><body package="GraphQLBeta-Tests">testSchemaGeneratorAndQuery	| text request document response root |	text := 'type GQLIQueryType {					hello : String					a : A				}				type A {					hey : String				}'.	schema := GQLSchemaGrammarEvaluator parse: text.	root := GQLIQueryType new.	schema root: root.	request := '{		hello		a { hey }	}'.	document := GQLSingleAnonimousQueryEvaluator parse: request.	response := document executeOn: root with: #() using: schema.	self assert: response class equals: OrderedDictionary.	self assert: (response at: 'hello') asString equals: 'helloWorld'.	self assert: (response at: 'hello') ~= 'hello World'.	self assert: (response at: 'a') class equals: OrderedDictionary.	self assert: ((response at: 'a') at: 'hey') asString equals: 'heyhey'</body><body package="GraphQLBeta-Tests">testSchemaGeneratorAndQueryWithParamameters	| text request document response root |	text := 'type GQLIQueryType {					hello(name:String) : String					sum(nums:[Int]) : Int					a : A				}				type A {					hey : String				}'.	schema := GQLSchemaGrammarEvaluator parse: text.	root := GQLIQueryType new.	schema root: root.	request := '{		hello(name:"Luke Skywalker")		sum(nums:[1,2,3,4])		a { hey }	}'.	document := GQLSingleAnonimousQueryEvaluator parse: request.	response := document executeOn: root with: #() using: schema.	self assert: response class equals: OrderedDictionary.	self assert: (response at: 'hello') equals: 'helloLuke Skywalker'.	self assert: (response at: 'hello') ~= 'hello World'.	self assert: (response at: 'a') class equals: OrderedDictionary.	self assert: ((response at: 'a') at: 'hey') asString equals: 'heyhey'.	self assert: (response at: 'sum') equals: 10</body><body package="GraphQLBeta-Tests">testSchemaGeneratorAndQueryWithParamametersOnObjects	| text request document response root |	text := 'type GQLIQueryType {					hello(name:String) : String					sum(nums:[Int]) : Int					a(id:ID) : A				}				type A {					heyID : String				}'.	schema := GQLSchemaGrammarEvaluator parse: text.	root := GQLIQueryType new.	schema root: root.	request := '{		hello(name:"Luke Skywalker")		sum(nums:[1,2,3,4])		a(id:"asdf1231asdf") { heyID }	}'.	document := GQLSingleAnonimousQueryEvaluator parse: request.	response := document executeOn: root with: #() using: schema.	self assert: response class equals: OrderedDictionary.	self assert: (response at: 'hello') equals: 'helloLuke Skywalker'.	self assert: (response at: 'hello') ~= 'hello World'.	self assert: (response at: 'a') class equals: OrderedDictionary.	self		assert: ((response at: 'a') at: 'heyID') asString		equals: 'id:asdf1231asdf'.	self assert: (response at: 'sum') equals: 10</body></methods><methods><class-id>GraphQLBeta.GQLVariableDefinitionNode</class-id> <category>accessing</category><body package="GraphQLBeta-Nodes">defaultValue"Return the defaultValue"	^ defaultValue</body><body package="GraphQLBeta-Nodes">defaultValue: anObject"Set the default value"	defaultValue := anObject</body><body package="GraphQLBeta-Nodes">name"Return the name"	^ name</body><body package="GraphQLBeta-Nodes">name: anObject"Set the name"	name := anObject</body><body package="GraphQLBeta-Nodes">type"Return the type"	^ type</body><body package="GraphQLBeta-Nodes">type: anObject"Set the type"	type := anObject</body></methods><methods><class-id>GraphQLBeta.GQLSFloatTypeNode</class-id> <category>initialization</category><body package="GraphQLBeta-NodesSchema">initialize	super initialize.	name := 'Float'</body></methods><methods><class-id>GraphQLBeta.GQLSelectionSetNode</class-id> <category>accessing</category><body package="GraphQLBeta-Nodes">executeOn: root with: env using: schema	"Execute the field nodes with the root, an enviroment and the schema"	| collectedFields response |	collectedFields := self collectFields.	response := OrderedDictionary new.	collectedFields		do: [ :f | 			response				at: f name				put:					(f executeOn: root with: env using: schema) ].	^ response</body><body package="GraphQLBeta-Nodes">selections"Return the selections"	^ selections</body><body package="GraphQLBeta-Nodes">selections: fields"Set the selections"	selections := fields</body></methods><methods><class-id>GraphQLBeta.GQLSelectionSetNode</class-id> <category>actions</category><body package="GraphQLBeta-Nodes">collectFields	"Collect all the fields"	| groupedFields |	groupedFields := OrderedDictionary new.	selections		do: [ :field | 			| responseKey |			responseKey := field name.			(groupedFields includesKey: responseKey)				ifTrue: [ field isScalar					ifFalse: [ self								mergeSelectionSet: (groupedFields at: responseKey)								with: field ] ]				ifFalse:					[ groupedFields at: responseKey put: field ] ].	^ groupedFields</body><body package="GraphQLBeta-Nodes">mergeSelectionSet: field1 with: field2"Merge two selection sets"	| newFieldNodes |	newFieldNodes := OrderedCollection new.	field2 selectionSet selections		do: [ :f | newFieldNodes add: f ].	field1 selectionSet selections		do: [ :f | newFieldNodes add: f ].	field1 selectionSet selections: newFieldNodes asArray</body></methods><methods><class-id>GraphQLBeta.GQLSStringTypeNode</class-id> <category>initialization</category><body package="GraphQLBeta-NodesSchema">initialize	super initialize.	name := 'String'</body></methods><methods><class-id>GraphQLBeta.GQLOperationNode</class-id> <category>accessing</category><body package="GraphQLBeta-Nodes">directives"Return the directives"	^ directives</body><body package="GraphQLBeta-Nodes">directives: anObject"Set the directives"	directives := anObject</body><body package="GraphQLBeta-Nodes">name"Return the name"	^ name</body><body package="GraphQLBeta-Nodes">name: aName"Set the name"	aName ifNotNil: [ name := aName inputValue ]</body><body package="GraphQLBeta-Nodes">selectionSet"Return the selection set"	^ selectionSet</body><body package="GraphQLBeta-Nodes">selectionSet: anObject"Set the selection set"	selectionSet := anObject</body><body package="GraphQLBeta-Nodes">type"Return the type"	^ type</body><body package="GraphQLBeta-Nodes">type: anObject"Set the type"	type := anObject</body><body package="GraphQLBeta-Nodes">variableDefinitions"Return the variable definitions"	^ variableDefinitions</body><body package="GraphQLBeta-Nodes">variableDefinitions: anObject"Set the variable definitions"	variableDefinitions := anObject</body></methods><methods><class-id>GraphQLBeta.GQLSingleAnonimousQueryEvaluatorTest</class-id> <category>tests-accessing</category><body package="GraphQLBeta-Tests">testDocument	| request document |	request := '{		hello	}'.	document := GQLSingleAnonimousQueryEvaluator parse: request.		self assert: document class equals: GQLDocumentNode.	self assert: document definitions class equals: GQLSelectionSetNode.	self assert: document definitions selections first class equals: GQLScalarFieldNode.	self assert: document definitions selections first name equals: 'hello'.	request := '{		hello		hello		films { 			name			rating		}	}'.	document := GQLSingleAnonimousQueryEvaluator parse: request.	self assert: document class equals: GQLDocumentNode.	self assert: document definitions class equals: GQLSelectionSetNode.	self assert: document definitions selections first class equals: GQLScalarFieldNode.	self assert: document definitions selections second class equals: GQLScalarFieldNode.	self assert: document definitions selections third class equals: GQLNonScalarFieldNode.	self assert: document definitions selections first name equals: 'hello'.	self assert: document definitions selections second name equals: 'hello'.	self assert: document definitions selections third name equals: 'films'.		"object inner fields"		self assert: ((document definitions selections third) selectionSet selections at:1) class equals: GQLScalarFieldNode.	self assert: ((document definitions selections third) selectionSet selections at:1) name equals: 'name'.	self assert: ((document definitions selections third) selectionSet selections at:2) class equals: GQLScalarFieldNode.	self assert: ((document definitions selections third) selectionSet selections at:2) name equals: 'rating'.	</body><body package="GraphQLBeta-Tests">testDocumentComposePosition	| request document fields selectionSet |	request := '{		hello		films { 			name			rating		}	}'.	document := GQLSingleAnonimousQueryEvaluator parse: request.	fields := document definitions selections.	selectionSet := fields second selectionSet selections.		self assert: fields first position equals: 5.	self assert: fields second position equals: 13.	self assert: selectionSet first position equals: 25.	self assert: selectionSet second position equals: 33.</body><body package="GraphQLBeta-Tests">testDocumentComposedWithArguments	| request document |	request := '{		hello		hello(name: "Luke")		films { 			name (capitalize:true, prefix: "Film ")			rating		}	}'.	document := GQLSingleAnonimousQueryEvaluator parse: request.	self assert: document class equals: GQLDocumentNode.	self assert: document definitions class equals: GQLSelectionSetNode.	self assert: (document definitions selections at: 1) class equals: GQLScalarFieldNode.	self assert: (document definitions selections at: 1) name equals: 'hello'.	self assert: (document definitions selections at: 2) name equals: 'hello'.		self assert: (document definitions selections at: 3) class equals: GQLNonScalarFieldNode.	self assert: (document definitions selections at: 3) name equals: 'films'.		"arguments"	self assert: ((document definitions selections at: 2) arguments at: 1) class 	     equals: GQLArgumentNode.	self assert: ((document definitions selections at: 2) arguments at: 1) name 	     equals: 'name'.	self assert: ((document definitions selections at: 2) arguments at: 1) value class 	     equals: GQLStringNode.		"object inner fields"		self assert: ((document definitions selections at: 3) selectionSet selections at:1) class equals: GQLScalarFieldNode .	self assert: ((document definitions selections at: 3) selectionSet selections at:1) name equals: 'name'.	self assert: ((document definitions selections at: 3) selectionSet selections at:2) class equals: GQLScalarFieldNode.	self assert: ((document definitions selections at: 3) selectionSet selections at:2) name equals: 'rating'.	"arguments"	self assert: (((document definitions selections at: 3) selectionSet selections at:1) arguments at: 1) class 		  equals: GQLArgumentNode.	self assert: (((document definitions selections at: 3) selectionSet selections at:1) arguments at: 1) name 		  equals: 'capitalize'.	self assert: (((document definitions selections at: 3) selectionSet selections at:1) arguments at: 2) name 		  equals: 'prefix'.	</body><body package="GraphQLBeta-Tests">testDocumentPosition	| request document fields |	request := '{		hello		films	}'.	document := GQLSingleAnonimousQueryEvaluator parse: request.	fields := document definitions selections.		self assert: fields first position equals: 5.	self assert: fields second position equals: 13.</body><body package="GraphQLBeta-Tests">testDocumentSimpleWithArguments	| request document |	request := '{		hello (name: "Luke")	}'.	document := GQLSingleAnonimousQueryEvaluator parse: request.		self assert: document class equals: GQLDocumentNode.	self assert: document definitions class equals: GQLSelectionSetNode.	self assert: document definitions selections first class equals: GQLScalarFieldNode.	self assert: document definitions selections first name equals: 'hello'.		self assert: ((document definitions selections at: 1) arguments at: 1) class equals: GQLArgumentNode.	self assert: ((document definitions selections at: 1) arguments at: 1) name equals: 'name'.	self assert: ((document definitions selections at: 1) arguments at: 1) value class equals: GQLStringNode.	</body><body package="GraphQLBeta-Tests">testDocumentWithArgumentsPosition	| request document fields arguments |	request := '{		hello (name : "Luke")	}'.	document := GQLSingleAnonimousQueryEvaluator parse: request.	fields := document definitions selections.	arguments := fields first arguments.		self assert: fields first position equals: 5.	self assert: arguments first position equals: 12.</body></methods><methods><class-id>GraphQLBeta.Query</class-id> <category>accessing</category><body package="GraphQLBeta">allClasses	^ Smalltalk allClasses.</body><body package="GraphQLBeta">allFilms	^ OrderedCollection new 		add: (Film			name: 'terminator'			rating: 5			director: 'James Cameron');		add: (Film			name: 'Star wars: New Hope'			rating: 9			director: 'George Lucas');		add: (Film			name: 'Star wars: The Clone Wars'			rating: 6			director: 'Dave Filoni');		add: (Film			name: 'Star wars: The Empire Strikes Back'			rating: 8			director: 'Irvin Kershner');		add: (Film			name: 'Star wars: Return of Jedi'			rating: 7			director: 'Richard Marquand');		add: (Film			name: 'Star wars: The Phantom Menace'			rating: 6			director: 'George Lucas');		add: (Film			name: 'Star wars: Attack of the Clones'			rating: 6			director: 'George Lucas');		yourself</body><body package="GraphQLBeta">allRectangles	^ Rectangle allInstances.</body><body package="GraphQLBeta">hello	^ 'hello'</body></methods><methods><class-id>GraphQLBeta.Query class</class-id> <category>accessing</category><body package="GraphQLBeta">schema"The text of the schema"	^ 'type Query{			allClasses : [ Class ]			allRectangles : [ Rectangle ]			allFilms: [ Film ]	   },		type Film{			name : String			rating : Int			director : String		},	   type Class{			name : String			methods : [ CompiledMethod ]		},		type CompiledMethod{			selector : String		},		type Rectangle{			origin : Point			corner : Point		},		type Point{			x : Float			y : Float		}		'</body></methods><methods><class-id>GraphQLBeta.GQLInlineFragmentNode</class-id> <category>accessing</category><body package="GraphQLBeta-Nodes">selectionSet"Return the selection set"	^ selectionSet</body><body package="GraphQLBeta-Nodes">selectionSet: anObject"Set the selection set"	selectionSet := anObject</body><body package="GraphQLBeta-Nodes">typeCondition"Return the type condition"	^ typeCondition</body><body package="GraphQLBeta-Nodes">typeCondition: anObject"Set the type condition"	typeCondition := anObject</body></methods><methods><class-id>GraphQLBeta.GQLSUnionTypeNode</class-id> <category>accessing</category><body package="GraphQLBeta-NodesSchema">namedTypes"Return the named types"	^ namedTypes</body></methods><methods><class-id>GraphQLBeta.GQLSUnionTypeNode</class-id> <category>adding</category><body package="GraphQLBeta-NodesSchema">addTypes: types"Given a collection puts the values on a dictionary for improve the search"	namedTypes := types</body></methods><methods><class-id>GraphQLBeta.GQLDirectiveNode</class-id> <category>accessing</category><body package="GraphQLBeta-Nodes">arguments"Return the arguments"	^ arguments</body><body package="GraphQLBeta-Nodes">arguments: anObject"Set the arguments"	arguments := anObject</body><body package="GraphQLBeta-Nodes">name"Return the name"	^ name</body><body package="GraphQLBeta-Nodes">name: anObject"Set the name"	name := anObject</body></methods><methods><class-id>GraphQLBeta.GQLSSchemaNodeTest</class-id> <category>tests</category><body package="GraphQLBeta-Tests">testFullName	| text schema objectType fields |	text := 'type GQLTestFilm{             id : String            name : String         }'.	schema := GQLSchemaGrammarEvaluator parse: text.	objectType := schema types values first.	self assert: objectType name equals: 'GQLTestFilm'.	fields := objectType fields values.	self assert: fields first fullName equals: 'name'.	self assert: fields second fullName equals: 'id'</body><body package="GraphQLBeta-Tests">testFullNameWithParameters	| text schema objectType fields |	text := 'type GQLIBType{             some (name : String, parameters : String) : String         }'.	schema := GQLSchemaGrammarEvaluator parse: text.	objectType := schema types values first.	self assert: objectType name equals: 'GQLIBType'.	fields := objectType fields values.	self assert: fields first fullName equals: 'someName:parameters:'</body><body package="GraphQLBeta-Tests">testInvalidateSimpleClass	| text schema validated |	text := 'type GQLTestFilm{             actors : String         }'.	schema := GQLSchemaGrammarEvaluator parse: text.	validated := schema validate.	self assert: (validated isKindOf: GQLException)</body><body package="GraphQLBeta-Tests">testInvalidateSimpleClassWithParameters	| text schema validated |	text := 'type GQLIBType{             some (name : String) : String         }'.	schema := GQLSchemaGrammarEvaluator parse: text.	validated := schema validate.	self assert: (validated isKindOf: GQLException)</body><body package="GraphQLBeta-Tests">testNodesParametersPosition	| text schema type fields parameters |	text := 'type GQLTestFilm{             id : String            name (id : String) : String         }'.	schema := GQLSchemaGrammarEvaluator parse: text.	type := schema types values first.	fields := type fields values.	parameters := fields first arguments values.	self assert: type position equals: 6.	self assert: fields first position equals: 56.	self assert: fields second position equals: 32.	self assert: parameters first position equals: 62</body><body package="GraphQLBeta-Tests">testNodesPosition	| text schema type fields |	text := 'type GQLTestFilm{             id : String            name : String         }'.	schema := GQLSchemaGrammarEvaluator parse: text.	type := schema types values first.	fields := type fields values.	self assert: type position equals: 6.	self assert: fields first position equals: 56.	self assert: fields second position equals: 32</body><body package="GraphQLBeta-Tests">testValidateSimpleClass	| text schema validated |	text := 'type GQLTestFilm{             id : String            name : String         }'.	schema := GQLSchemaGrammarEvaluator parse: text.	validated := schema validate.	self assert: validated equals: schema</body><body package="GraphQLBeta-Tests">testValidateSimpleClassWithParameters	| text schema validated |	text := 'type GQLIQueryType{             sum (nums: [Int]) : Int         }'.	schema := GQLSchemaGrammarEvaluator parse: text.	validated := schema validate.	self assert: validated equals: schema</body></methods><methods><class-id>GraphQLBeta.GQLSSchemaNodeTest</class-id> <category>tests-visiting</category><body package="GraphQLBeta-Tests">testEvaluate	| text schema |	text := 'type A {					b (id: Int): B					c (p1: [Int], p2:String): [Int]					d (param:String)	:String 				},				type B {					someName 	: [String ! ]					someName 	:String 				}'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: (schema types at: 'A') class equals: GQLSObjectTypeNode.	self		assert: (((schema types at: 'A') getField: 'd') getArgument: 'param') class		equals: GQLSArgumentFieldNode.	self		assert: (((schema types at: 'A') getField: 'd') getArgument: 'param') type class		equals: GQLSStringTypeNode.	self		assert: (((schema types at: 'A') getField: 'c') getArgument: 'p1') type class		equals: GQLSListTypeNode</body></methods><methods><class-id>GraphQLBeta.GQLIntNode</class-id> <category>accessing</category><body package="GraphQLBeta-Nodes">executeOn: resolver with: env using: schema"Execute the input value according to the resolver, the enviroment and the schema"	^ value asInteger</body></methods><methods><class-id>GraphQLBeta.GQLNodeVisitor</class-id> <category>visiting</category><body package="GraphQLBeta-Visitors">visitArgumentNode: aGQLArgumentNode"Given a argument node validate if is correct to the respective type then continue the validation"	| param |	param := schemaContextStack top		getArgument: aGQLArgumentNode argumentName.	param ifNil: [ ^ self ].	schemaContextStack push: param inputType.	aGQLArgumentNode inputValue		acceptVisitor: self.	schemaContextStack pop</body><body package="GraphQLBeta-Visitors">visitDocumentNode: documentNode"Given a document node validate if the selection set is correct"	"query only, TODO: mutation"	schemaContextStack push: schema query.	documentNode selectionSet		acceptVisitor: self</body><body package="GraphQLBeta-Visitors">visitInputValueNode: aGQLInputValueNode</body><body package="GraphQLBeta-Visitors">visitObjectNode: objectNode	"Given a object node see if is correct then continue the validation"	| field |	field := schemaContextStack top		getField: objectNode fieldName.	field ifNil: [ ^ self ].	"visit arguments"	schemaContextStack push: field.	objectNode arguments		do: [ :a | a acceptVisitor: self ].	schemaContextStack pop.	"visit inner types"	field type class = GQLListNode 		ifTrue: [ "visit List's inner type if"			schemaContextStack				push: field type wrappedType ]		ifFalse: [ schemaContextStack push: field type ].	objectNode selectionSet		acceptVisitor: self.	schemaContextStack pop</body><body package="GraphQLBeta-Visitors">visitScalarNode: scalarNode	"Given a scalar node see if is correct and then continue the validation"	| field |	field := schemaContextStack top		getField: scalarNode fieldName.	field ifNil: [ ^ self ].	"visit arguments"	schemaContextStack push: field.	scalarNode arguments		do: [ :a | a acceptVisitor: self ].	schemaContextStack pop</body><body package="GraphQLBeta-Visitors">visitSelectionSetNode: selectionSetNode	"Given a selection set node validate each field node"	^ selectionSetNode fields		collect:			[ :fieldNode | fieldNode acceptVisitor: self ]</body></methods><methods><class-id>GraphQLBeta.GQLNodeVisitor</class-id> <category>initialize</category><body package="GraphQLBeta-Visitors">initialize"Initialize the stack "	schemaContextStack := Stack new</body><body package="GraphQLBeta-Visitors">schema: aSchema"Set the schema"	schema := aSchema</body></methods><methods><class-id>GraphQLBeta.GQLTypeValidator</class-id> <category>validation</category><body package="GraphQLBeta-Visitors">validate: document withSchema: aGQLschema	"Given a document(request) and the schema start to validate at the document"	| res |	schema := aGQLschema.	[ document acceptVisitor: self.	res := document ]		on: GQLException		do: [ :e | res := e ].	^ res</body></methods><methods><class-id>GraphQLBeta.GQLTypeValidator</class-id> <category>visiting</category><body package="GraphQLBeta-Visitors">visitArgumentNode: aGQLArgumentNode	"Given an argument node see if the argument belongs to the corresponding top of the stack, if not raise a GQLEvaluationException"	| param |	param := schemaContextStack top getArgument: aGQLArgumentNode argumentName.	param		ifNil: [ GQLEvaluationException new				node: aGQLArgumentNode;				messageArgumentText: schemaContextStack top;				signal ].	super visitArgumentNode: aGQLArgumentNode</body><body package="GraphQLBeta-Visitors">visitInputValueNode: aGQLInputValueNode	"Given a input value node see if corresponds to the type of the stack if not raise a exception"	| schemaType |	schemaType := schemaContextStack top.	(schemaType		isAValidType: aGQLInputValueNode)		ifFalse: [ GQLEvaluationException new				node: aGQLInputValueNode;				messageInputText;				signal ]</body><body package="GraphQLBeta-Visitors">visitObjectNode: objectNode	"Given a object node validate if exist at the schema if not raise a exception"	| field |	field := schemaContextStack top		getField: objectNode fieldName.	field		ifNil: [ GQLEvaluationException new				node: objectNode;				messageObjectText;				signal ].	super visitObjectNode: objectNode</body><body package="GraphQLBeta-Visitors">visitScalarNode: scalarNode"Given a scalar node see if this exist at the schema if not raise a exception"	| field |	field := schemaContextStack top		getField: scalarNode fieldName.	field isNil		ifTrue: [ GQLEvaluationException new				node: scalarNode;				messageScalarText;				signal ].	super visitScalarNode: scalarNode</body></methods><methods><class-id>GraphQLBeta.GQLEvaluationException</class-id> <category>message</category><body package="GraphQLBeta">messageArgumentText: aNode	"Message for argument that doesn't exist on the definition of schema"	| writer |	writer := WriteStream on: String new.	writer		nextPutAll: 'No exist the argument ';		nextPutAll: node argumentName;		nextPutAll: ' on the definition of the schema, on the node ';		nextPutAll: aNode fieldName.	self messageText: writer contents</body><body package="GraphQLBeta">messageInputText	"Message for input that doesn't exist on the definition of schema"	| writer |	writer := WriteStream on: String new.	writer		nextPutAll: 'No valid input type: ';		nextPutAll: node inputType;		nextPutAll: ' on the definition of the schema'.	self messageText: writer contents</body><body package="GraphQLBeta">messageObjectText	"Message for object that doesn't exist on the definition of schema"	| writer |	writer := WriteStream on: String new.	writer		nextPutAll: 'No valid object type: ';		nextPutAll: node fieldName;		nextPutAll: ' on the definition of the schema'.	self messageText: writer contents</body><body package="GraphQLBeta">messageScalarText	"Message for scalar that doesn't exist on the definition of schema"	| writer |	writer := WriteStream on: String new.	writer		nextPutAll: 'No valid scalar: ';		nextPutAll: node fieldName;		nextPutAll: ' on the definition of the schema'.	self messageText: writer contents</body></methods><methods><class-id>GraphQLBeta.GQLFragmentNode</class-id> <category>accessing</category><body package="GraphQLBeta-Nodes">directives"Return the directives"	^ directives</body><body package="GraphQLBeta-Nodes">directives: anObject"Set the directives"	directives := anObject</body><body package="GraphQLBeta-Nodes">name"Return the name"	^ name</body><body package="GraphQLBeta-Nodes">name: anObject"Set the name"	name := anObject</body><body package="GraphQLBeta-Nodes">selectionSet"Return the selection set"	^ selectionSet</body><body package="GraphQLBeta-Nodes">selectionSet: anObject"Set the selection set"	selectionSet := anObject</body><body package="GraphQLBeta-Nodes">typeCondition"Return the type condition"	^ typeCondition</body><body package="GraphQLBeta-Nodes">typeCondition: anObject"Set the type condition"	typeCondition := anObject</body></methods><methods><class-id>GraphQLBeta.GQLSSchemaNode</class-id> <category>accessing</category><body package="GraphQLBeta-NodesSchema">getType: aTypeName	"Return the type corresponding to the given type name"	(schemaTypes includesKey: aTypeName asString)		ifTrue: [ ^ schemaTypes at: aTypeName asString].	^ scalarTypes at: aTypeName asString</body><body package="GraphQLBeta-NodesSchema">root: anInstance"Set an instance as root and his class as the query"	root := anInstance.	query := self		getType: anInstance class name</body><body package="GraphQLBeta-NodesSchema">types"Return the types"	^ schemaTypes </body></methods><methods><class-id>GraphQLBeta.GQLSSchemaNode</class-id> <category>initialization</category><body package="GraphQLBeta-NodesSchema">initialize	super initialize.	self initializeScalarTypes.	schemaTypes := Dictionary new</body><body package="GraphQLBeta-NodesSchema">initializeScalarTypes	"Creates a dictionary with the default scalar types"	scalarTypes := Dictionary new.	scalarTypes at: 'Int' put: GQLSIntTypeNode new.	scalarTypes at: 'String' put: GQLSStringTypeNode new.	scalarTypes at: 'ID' put: GQLSIDTypeNode new.	scalarTypes at: 'Boolean' put: GQLSBooleanTypeNode new.	scalarTypes at: 'Float' put: GQLSFloatTypeNode new</body></methods><methods><class-id>GraphQLBeta.GQLSSchemaNode</class-id> <category>adding</category><body package="GraphQLBeta-NodesSchema">addTypes: aCollection"Given a collection puts the values on a dictionary for improve the search"	aCollection do: [ :type | schemaTypes at: type name put: type ]</body></methods><methods><class-id>GraphQLBeta.GQLSSchemaNode</class-id> <category>development support</category><body package="GraphQLBeta-NodesSchema">validate	"Return self if all the types exist on the smalltalk image and also the fields, if not raise a GQLValidationException"	| allClasses |	allClasses := Smalltalk allClasses.	self types do: [ :assoc | 		| class fields |		class := allClasses 			detect: [ :c | c name = assoc name asSymbol ]			ifNone: [ ^ GQLValidationException new				node: assoc value;				messageClassText ].					fields := assoc value fields values.		fields do: [ :field | 			class allMethods				detect: [ :method | method selector = field fullName asSymbol ]				ifNone: [ ^ GQLValidationException new					node: field;					messageMethodText: assoc ] ] ].	^ self</body></methods><methods><class-id>GraphQLBeta.GQLIQueryType</class-id> <category>accessing</category><body package="GraphQLBeta-Test-Trash">a	^ GQLA new</body><body package="GraphQLBeta-Test-Trash">aId: aID	^ GQLA new id: aID</body><body package="GraphQLBeta-Test-Trash">hello ^ #helloWorld</body><body package="GraphQLBeta-Test-Trash">helloName: aString	^ #hello , aString.</body><body package="GraphQLBeta-Test-Trash">sumNums: aCollection	^ aCollection reduce: [ :a :b | a + b ].</body></methods><methods><class-id>GraphQLBeta.GQLSIDTypeNode</class-id> <category>initialization</category><body package="GraphQLBeta-NodesSchema">initialize	super initialize.	name := 'ID'</body></methods><methods><class-id>GraphQLBeta.GQLDocumentNodeTest</class-id> <category>tests-accessing</category><body package="GraphQLBeta-Tests">setUp	| text |	text := 'type GQLTestQueryType{					hello : String					films : [ GQLTestFilm ]				},				type GQLTestFilm{					id : String					name : String					rating : Int				}'.		schema := GQLSchemaGrammarEvaluator parse: text.	schema validate.		rootInstance := GQLTestQueryType new.	schema root: rootInstance.		</body><body package="GraphQLBeta-Tests">testComposedRequestInterpret	| request response document |	request := '{		hello		hello		films { 			rating			name		}	}'.	document := GQLSingleAnonimousQueryEvaluator parse: request.	response := document executeOn: rootInstance with: #() using: schema.		self assert: response class equals: OrderedDictionary.	self assert: (response at:'hello') equals: 'hello world'.	self assert: (response at:'films') class equals: OrderedCollection.	self assert: ((response at:'films') first at: 'rating') equals: 9.	self assert: ((response at:'films') first at: 'name') equals: 'harry potter y la piedra filosofal'</body><body package="GraphQLBeta-Tests">testSimpleRequestInterpret	| request response document |	request := '{		hello	}'.	document := GQLSingleAnonimousQueryEvaluator parse: request.	response := document executeOn: rootInstance with: #() using: schema.		self assert: response class equals: OrderedDictionary.	self assert: (response at:'hello') equals: 'hello world'.</body></methods><methods><class-id>GraphQLBeta.GQLSchemaGrammar</class-id> <category>grammar</category><body package="GraphQLBeta-Parser">baseType"Return a parser accepting object filed base types"	^ scalarType / namedType		"enumTypeName / objectTypeName / interfaceTypeName / unionTypeName "</body><body package="GraphQLBeta-Parser">enumType	"Return a parser accepting:enum enumTypeName enumValueList"	^ 'enum' asParser , (enumTypeName trim: ignored) , enumValueList</body><body package="GraphQLBeta-Parser">enumTypeName	"Return a token name that is not a true, false or null"	^ (booleanValue not , nullValue not , tokenName) flatten token</body><body package="GraphQLBeta-Parser">enumValueList	"Return a parser accepting:{ tokenName+ }"	^ ${ asParser , (tokenName trim: ignored) plus , $} asParser</body><body package="GraphQLBeta-Parser">field"Return a parser accepting:fieldName parametersOptional : fieldType"	^ fieldName , (parameters trim: ignored) optional , ($: asParser trim: ignored)		, fieldType</body><body package="GraphQLBeta-Parser">fieldInputObject	"Return a parser accepting:fieldName parametersOptional : fieldInputObjectType"	^ fieldName , (parameters trim: ignored) optional , ($: asParser trim: ignored) , inputType </body><body package="GraphQLBeta-Parser">fieldInputObjectSet	"Return a parser accepting:{ fieldInputObject+ }"	^ ${ asParser , (fieldInputObject trim: ignored) plus , $} asParser</body><body package="GraphQLBeta-Parser">fieldName	^ tokenName </body><body package="GraphQLBeta-Parser">fieldSet"Return a parser accepting:{ field+ }"	^ ${ asParser , (field trim: ignored) plus , $} asParser</body><body package="GraphQLBeta-Parser">fieldType"Return a parser accepting baseType or wrappedType"	^ nonNullType / baseType / listType </body><body package="GraphQLBeta-Parser">ignoredSpaces	"Return the parsers accepting the list of things we want to ignore"	^ comment / lineTerminator / unicodeBOM		/ whiteSpace</body><body package="GraphQLBeta-Parser">inputObjectType	"Return a parser accepting:input inputObjectTypeName fieldSet"	^ 'input' asParser , (inputObjectTypeName trim: ignored) , fieldInputObjectSet</body><body package="GraphQLBeta-Parser">inputObjectTypeName"Return a token name"	^ tokenName	</body><body package="GraphQLBeta-Parser">inputType	^ nonNullInputType / namedInputType / listInputType</body><body package="GraphQLBeta-Parser">interfaceList	^ ('implements' asParser trim: ignored), ((interfaceTypeName trim: ignoredSpaces) separatedBy: ($, asParser trim: ignoredSpaces))</body><body package="GraphQLBeta-Parser">interfaceType	"Return a parser accepting:interface interfaceTypeName fieldSet"	^ 'interface' asParser , (interfaceTypeName trim: ignored) , fieldSet</body><body package="GraphQLBeta-Parser">interfaceTypeName	"Return a token name"	^ tokenName</body><body package="GraphQLBeta-Parser">listInputType"Return a parser accepting:[ inputType ] "	^ $[ asParser , (inputType trim: ignored) , ($] asParser trimRight: ignored)</body><body package="GraphQLBeta-Parser">listType	"Return a parser accepting: [ fieldType ]"	^ $[ asParser , (fieldType trim: ignored) , ($] asParser trimRight: ignored)</body><body package="GraphQLBeta-Parser">namedInputType	"Return a token name"	^ scalarType / namedType</body><body package="GraphQLBeta-Parser">namedType"Return a token name"	^ tokenName</body><body package="GraphQLBeta-Parser">nonNull"Return a parser accepting !"	^ $! asParser</body><body package="GraphQLBeta-Parser">nonNullBaseType	"Return a parser accepting: type nonNull"	^ (baseType trim: ignored) , nonNull </body><body package="GraphQLBeta-Parser">nonNullInputType	"Return a parser accepting: namedType nonNull"	^ nonNullNamedType / nonNullListInputType</body><body package="GraphQLBeta-Parser">nonNullListInputType	"Return a parser accepting: listInputType!"	^ listInputType, nonNull</body><body package="GraphQLBeta-Parser">nonNullListType	"Return a parser accepting: listType!"	^ listType, nonNull</body><body package="GraphQLBeta-Parser">nonNullNamedType	"Return a parser accepting: nametype nonNull"	^ (namedType trim: ignored) , nonNull </body><body package="GraphQLBeta-Parser">nonNullType	"Return a parser accepting: type nonNull"	^ nonNullBaseType / nonNullListType</body><body package="GraphQLBeta-Parser">objectType	"Return a parser accepting:type objectTypeName implementsOptional fieldSet"	^ 'type' asParser , (objectTypeName trim: ignored), interfaceList optional , fieldSet</body><body package="GraphQLBeta-Parser">objectTypeName"Return a token name"	^ tokenName</body><body package="GraphQLBeta-Parser">parameter"Return a parser accepting: parameterName : inputType"	^ parameterName , ($: asParser trim: ignored) , inputType</body><body package="GraphQLBeta-Parser">parameterName"Return a token name"	^ tokenName</body><body package="GraphQLBeta-Parser">parameters"Return a parser accepting:  ( parameter+ )"	^ ($( asParser trimRight: ignored) , (parameter trimRight: ignored) plus , $) asParser</body><body package="GraphQLBeta-Parser">schema"Return a parser accepting one or more type"	^ (schemaType trim: ignored) plus</body><body package="GraphQLBeta-Parser">schemaType	"Return a parser accepting:- objectType- enumType- interfaceType- unionType- inputObjectType"	^ objectType / enumType / interfaceType / unionType / inputObjectType</body><body package="GraphQLBeta-Parser">start"Return a parser accepting a schema and then the end of the input"	^ schema end</body><body package="GraphQLBeta-Parser">type"Return a parser accepting:- scalarType- objectTypeName- enumTypeName- interfaceTypeName- unionTypeName"	^ scalarType / objectTypeName / enumTypeName / interfaceTypeName / unionTypeName </body><body package="GraphQLBeta-Parser">unionType	"Return a parser accepting:union unionTypeName = unionValuesList"	^ 'union' asParser , (unionTypeName trim: ignored) , ($= asParser trim: ignored), unionValuesList </body><body package="GraphQLBeta-Parser">unionTypeName	"Return a token name"	^ tokenName</body><body package="GraphQLBeta-Parser">unionValuesList	"Return a parser accepting:  objectTypeName | unionValue "	^ (objectTypeName trimRight: ignored) separatedBy: ($| asParser trim: ignored)</body></methods><methods><class-id>GraphQLBeta.GQLSchemaGrammarEvaluator</class-id> <category>accessing</category><body package="GraphQLBeta-Parser">booleanType	"Return a GQLSBooleanType instance"	^ super booleanType		performs: [ :tokens | 			| node |			node := GQLSBooleanTypeNode new.			node ]</body><body package="GraphQLBeta-Parser">enumType	"Return a GQLSEnumTypeNode instance with the enumTypeName, the values and the position on the text schema"	^ super enumType		performs: [ :tokens | 			| node |			node := GQLSEnumTypeNode new.			node name: (tokens at: 2) inputValue.			node addValues: (tokens at: 3).			node position: (tokens at: 2) start ]</body><body package="GraphQLBeta-Parser">enumValueList	"Return an array"	^ super enumValueList		performs: [ :tokens | 			(tokens at: 2) collect: #inputValue ]</body><body package="GraphQLBeta-Parser">field	"Return a GQLSFieldNode instance with the name, arguments, type and position on the text schema"	^ super field		performs: [ :tokens | 			| node |			node := GQLSFieldNode new.			node name: (tokens at: 1) inputValue.			node addArguments: (tokens at: 2).			node type: (tokens at: 4).			node position: (tokens at: 1) start.			node fullName.			node ]</body><body package="GraphQLBeta-Parser">fieldInputObject	"Return a GQLSFieldInputObjectFieldNode instance with the name, arguments, type and position on the text schema"	^ super field		performs: [ :tokens | 			| node |			node := GQLSInputObjectFieldNode new.			node name: (tokens at: 1) inputValue.			node addArguments: (tokens at: 2).			node type: (tokens at: 4).			node position: (tokens at: 1) start.			node fullName.			node ]</body><body package="GraphQLBeta-Parser">fieldInputObjectSet"Return the fields"	^ super fieldInputObjectSet		performs: [ :tokens | tokens at: 2 ]</body><body package="GraphQLBeta-Parser">fieldSet"Return the fields"	^ super fieldSet		performs: [ :tokens | tokens at: 2 ]</body><body package="GraphQLBeta-Parser">floatType	"Return a GQLSFloatType instance"	^ super floatType		performs: [ :tokens | 			| node |			node := GQLSFloatTypeNode new.			node ]</body><body package="GraphQLBeta-Parser">idType	"Return a GQLSIDType instance"	^ super idType		performs: [ :tokens | 			| node |			node := GQLSIDTypeNode new.			node ]</body><body package="GraphQLBeta-Parser">inputObjectType	"Return a GQLSInputObjectTypeNode instance with the input object name, the fields and the position on the text schema"	^ super inputObjectType		performs: [ :tokens | 			| node |			node := GQLSInputObjectTypeNode new.			node name: (tokens at: 2) inputValue.			node addFields: (tokens at: 3).			node position: (tokens at: 2) start ]</body><body package="GraphQLBeta-Parser">inputType"Return the tokens"	^ super inputType performs: [ :tokens | tokens ]</body><body package="GraphQLBeta-Parser">intType	"Return a GQLSIntType instance"	^ super intType		performs: [ :tokens | 			| node |			node := GQLSIntTypeNode new.			node position: tokens start.			node ]</body><body package="GraphQLBeta-Parser">interfaceList	"Return an array"	^ super interfaceList		performs: [ :tokens | 			(tokens at: 2) reject: #isCharacter thenCollect: #inputValue ]</body><body package="GraphQLBeta-Parser">interfaceType	"Return a GQLSInterfaceTypeNode instance with the enumTypeName, the values and the position on the text schema"	^ super interfaceType		performs: [ :tokens | 			| node |			node := GQLSInterfaceTypeNode new.			node name: (tokens at: 2) inputValue.			node addFields: (tokens at: 3).			node position: (tokens at: 2) start ]</body><body package="GraphQLBeta-Parser">listInputType	"Return a GQLSListTypeNode instance with the innerInputType and if is null"	^ super listInputType		performs: [ :tokens | 			| node |			node := GQLSListTypeNode new.			node wrappedType: (tokens at: 2).			node position: (tokens at: 2) position.			node ]</body><body package="GraphQLBeta-Parser">listType	"Return a GQLSListTypeNode instance with the innerTypeNode"	^ super listType		performs: [ :tokens | 			| node |			node := GQLSListTypeNode new.			node wrappedType: (tokens at: 2).			node position: (tokens at: 2) position.			node ]</body><body package="GraphQLBeta-Parser">namedType	"Return a GQLSNamedTypeNode instance with the wrapped type"	^ super namedType		performs: [ :tokens | 			| node |			node := GQLSNamedTypeNode new.			node name: tokens inputValue.			node position: tokens start.			node ]</body><body package="GraphQLBeta-Parser">nonNullInputType	"Return a GQLSNonNullInputTypeNode instance with the wrapped type"	^ super nonNullInputType		performs: [ :tokens | 			| node |			node := GQLSNonNullTypeNode new.			node wrappedType: (tokens at: 1).			node position: (tokens at: 1) position.			node ]</body><body package="GraphQLBeta-Parser">nonNullType	"Return a GQLSNonNullTypeNode instance with the wrapped type"	^ super nonNullType		performs: [ :tokens | 			| node |			node := GQLSNonNullTypeNode new.			node wrappedType: (tokens at: 1).			node position: (tokens at: 1) position.			node ]</body><body package="GraphQLBeta-Parser">objectType	"Return a GQLSObjectTypeNode instance with the objectTypeName, the fields and the position on the text schema"	^ super objectType		performs: [ :tokens | 			| node |			node := GQLSObjectTypeNode new.			node name: (tokens at: 2) inputValue.			node addFields: (tokens at: 4).			node implements: (tokens at: 3).			node position: (tokens at: 2) start ]</body><body package="GraphQLBeta-Parser">parameter	"Return a GQLSParameterNode instance with the parameterName, inputType and the position on the text schema"	^ super parameter		performs: [ :tokens | 			| node |			node := GQLSArgumentFieldNode new.			node name: (tokens at: 1) inputValue.			node type: (tokens at: 3).			node position: (tokens at: 1) start.			node ]</body><body package="GraphQLBeta-Parser">parameters"Return the list of parameter"	^ super parameters		performs: [ :tokens | tokens at: 2 ]</body><body package="GraphQLBeta-Parser">schema	"Return a GQLSchemaNode instance with the types defined on the text schema"	^ super schema		performs: [ :types | 			| node |			node := GQLSSchemaNode new.			node addTypes: types ]</body><body package="GraphQLBeta-Parser">start	"Return a parser accepting schema and then the input ends"	^ schema end</body><body package="GraphQLBeta-Parser">stringType	"Return a GQLSStringType instance"	^ super stringType		performs: [ :tokens | 			| node |			node := GQLSStringTypeNode new.			node ]</body><body package="GraphQLBeta-Parser">unionType	"Return a GQLSUnionTypeNode instance with the union name, the values and the position on the text schema"	^ super unionType		performs: [ :tokens | 			| node |			node := GQLSUnionTypeNode new.			node name: (tokens at: 2) inputValue.			node addTypes: (tokens at: 4).			node position: (tokens at: 2) start ]</body><body package="GraphQLBeta-Parser">unionValuesList	"Return an array"	^ super unionValuesList		performs: [ :tokens |			tokens reject: #isCharacter thenCollect: #inputValue. ]</body></methods><methods><class-id>Core.Metaclass</class-id> <category>*GraphQLBeta</category><body package="GraphQLBeta">visualworksName	^ self baseClass visualworksName , ' class'.</body></methods><methods><class-id>Core.Dictionary</class-id> <category>*GraphQLBeta</category><body package="GraphQLBeta">qlcollect: aBlock	^ self collect: aBlock</body></methods><methods><class-id>SUnit.TestResource class</class-id> <category>*GraphQLBeta</category><body package="GraphQLBeta">visualworksName	^ self == TestResource ifTrue: ['Smalltalk.SUnit.TestResource'] ifFalse: [self name]</body></methods><methods><class-id>PetitParser.PPParser</class-id> <category>*GraphQLBeta</category><body package="GraphQLBeta">performs: aBlock	^ self ==&gt; aBlock</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>PPParser</name><environment>PetitParser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>properties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Parsers</category><attributes><package>PetitParser</package></attributes></class><class><name>Exception</name><environment>Core</environment><super>Core.GenericException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>TestCase</name><environment>SUnit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnitToo</package></attributes></class><class><name>PPCompositeParserTest</name><environment>PetitTests</environment><super>PetitTests.PPAbstractParserTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parser result debugResult </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitTests-Core</category><attributes><package>PetitTests</package></attributes></class><class><name>Metaclass</name><environment>Core</environment><super>Core.ClassDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>thisClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>PPCompositeParser</name><environment>PetitParser</environment><super>PetitParser.PPDelegateParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dependencies </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Tools</category><attributes><package>PetitParser</package></attributes></class><class><name>Dictionary</name><environment>Core</environment><super>Core.Set</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class></st-source>