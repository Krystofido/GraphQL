<?xml version="1.0"?><st-source><!-- Name: SwazooBundleName: SwazooBundleStructure: a Store.BundleForParcelComment: Swazoo (Smalltalk Web Application Zoo) is an open source, vendor agnostic,dialect neutral Smalltalk HTTP server with resource and web requestresolution framework. Swazoo is currently supported on Squeak, PharoVisualWorks and Dolphin Smalltalk. Currently its main features are:    * virtual site support    * clean web request resolution framework    * static web serving    * input streaming of HTTP requests (for large file uploads)    * output streaming (chunking) for responding large files and for Comet    * WebSocket support    * Gzip compressionQuick installation steps are:    1. load bundle or parcel Swazoo    2. In a workspace doIt SwazooServer demoStart    3. in your browser open http://localhost:8888More about Swazoo on its website:	http://www.swazoo.orgHappy Swazoo-ing from your Swazoo team :)DevelopmentPrerequisites: #(#(#parcel 'SUnit' '') #(#parcel 'Sport' '') #(#any 'HashesBase' '') #(#any 'Protocols-Common' '') #(#any 'Compression-ZLib' '') #(#any 'MD5' '') #(#any 'SHA' ''))Parcel: nilParcelName: SwazooPrerequisiteDescriptions: #(#(#name 'SUnit' #loadResolution #parcel) #(#name 'Sport' #loadResolution #parcel) #(#name 'HashesBase' #componentType #package) #(#name 'Protocols-Common' #componentType #package) #(#name 'Compression-ZLib' #componentType #package) #(#name 'MD5' #componentType #package) #(#name 'SHA' #componentType #package))PrerequisiteParcels: #(#('SUnit' '') #('Sport' '') #('HashesBase' '') #('Protocols-Common' '') #('Compression-ZLib' '') #('MD5' '') #('SHA' '') #('SUnit' ''))Version: 2.3.0 - 1Date: 11:34:18 AM August 8, 2014 --><time-stamp>From VisualWorksÂ®, Pre-Release 8.0 (jul14.2) of July 18, 2014 on August 8, 2014 at 11:34:18 AM</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>Swazoo</name><environment>Smalltalk</environment><private>false</private><imports>			private Smalltalk.*			</imports><category>Swazoo-Compatibility</category><attributes><package>Swazoo-Core</package></attributes></name-space><class><name>HeaderField</name><environment>Swazoo</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>httpFieldNameToClassDictionary </class-inst-vars><imports></imports><category>Swazoo-Headers</category><attributes><package>Swazoo-Headers</package></attributes></class><class><name>SpecificHeaderField</name><environment>Swazoo</environment><super>Swazoo.HeaderField</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Headers</category><attributes><package>Swazoo-Headers</package></attributes></class><class><name>HTTPAuthorizationField</name><environment>Swazoo</environment><super>Swazoo.SpecificHeaderField</super><private>false</private><indexed-type>none</indexed-type><inst-vars>credentials </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Headers</category><attributes><package>Swazoo-Headers</package></attributes></class><class><name>SwazooSiteError</name><environment>Swazoo</environment><super>SpError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Exceptions</category><attributes><package>Swazoo-Exceptions</package></attributes></class><class><name>SwazooResource</name><environment>Swazoo</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>enabled uriPattern parent </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Core</category><attributes><package>Swazoo-Core</package></attributes></class><comment><class-id>Swazoo.SwazooResource</class-id><body>Resource is an abstract class for all so called web resources. Such resource has its url address and can serve with responding to web requests. Every resource need to #answerTo: aHTTPRequest with aHTTPResponse. Site is a subclass of a Resource. You can subclass it with your own implementation. There is also a CompositeResource, which can hold many subresources. Site is also aCopmpositeResource and therefore you can add your own resources to your site.</body></comment><class><name>FileMappingResource</name><environment>Swazoo</environment><super>Swazoo.SwazooResource</super><private>false</private><indexed-type>none</indexed-type><inst-vars>directoryIndex filePath </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Resources</category><attributes><package>Swazoo-Fileserver</package></attributes></class><class><name>FileResource</name><environment>Swazoo</environment><super>Swazoo.FileMappingResource</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Resources</category><attributes><package>Swazoo-Fileserver</package></attributes></class><class><name>HomeResource</name><environment>Swazoo</environment><super>Swazoo.FileResource</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Resources</category><attributes><package>Swazoo-Fileserver</package></attributes></class><class><name>SwazooHTTPRequestError</name><environment>Swazoo</environment><super>SpError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Exceptions</category><attributes><package>Swazoo-Exceptions</package></attributes></class><class><name>FileResourceTest</name><environment>Swazoo</environment><super>XProgramming.SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>resource </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Tests</category><attributes><package>Swazoo-Tests</package></attributes></class><class><name>SwazooHTTPParseError</name><environment>Swazoo</environment><super>SpError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Exceptions</category><attributes><package>Swazoo-Exceptions</package></attributes></class><class><name>SwazooCompilerTest</name><environment>Swazoo</environment><super>XProgramming.SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Tests</category><attributes><package>Swazoo-Tests</package></attributes></class><class><name>ContentTypeField</name><environment>Swazoo</environment><super>Swazoo.SpecificHeaderField</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mediaType transferCodings </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Headers</category><attributes><package>Swazoo-Headers</package></attributes></class><class><name>SwazooCompiler</name><environment>Swazoo</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>accessor </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Compatibility</category><attributes><package>Swazoo-Resources</package></attributes></class><class><name>HTTPDateField</name><environment>Swazoo</environment><super>Swazoo.SpecificHeaderField</super><private>false</private><indexed-type>none</indexed-type><inst-vars>date </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Headers</category><attributes><package>Swazoo-Headers</package></attributes></class><class><name>HTTPWWWAuthenticateField</name><environment>Swazoo</environment><super>Swazoo.SpecificHeaderField</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Headers</category><attributes><package>Swazoo-Headers</package></attributes></class><class><name>HTTPWWWAuthenticateBasicField</name><environment>Swazoo</environment><super>Swazoo.HTTPWWWAuthenticateField</super><private>false</private><indexed-type>none</indexed-type><inst-vars>realm </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Headers</category><attributes><package>Swazoo-Headers</package></attributes></class><class><name>HTTPMatchField</name><environment>Swazoo</environment><super>Swazoo.SpecificHeaderField</super><private>false</private><indexed-type>none</indexed-type><inst-vars>entityTags </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Headers</category><attributes><package>Swazoo-Headers</package></attributes></class><class><name>HTTPIfNoneMatchField</name><environment>Swazoo</environment><super>Swazoo.HTTPMatchField</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Headers</category><attributes><package>Swazoo-Headers</package></attributes></class><comment><class-id>Swazoo.HTTPIfNoneMatchField</class-id><body>This is a confitional header field.  The HTTP client is asking for a resource on the basis of this condition.  So, we need to have first found the resource, and then we can considder the condition, as follows ...From RFC 2616:14.26 If-None-Match   The If-None-Match request-header field is used with a method to make   it conditional. A client that has one or more entities previously   obtained from the resource can verify that none of those entities is   current by including a list of their associated entity tags in the   If-None-Match header field. The purpose of this feature is to allow   efficient updates of cached information with a minimum amount of   transaction overhead. It is also used to prevent a method (e.g. PUT)   from inadvertently modifying an existing resource when the client   believes that the resource does not exist.   As a special case, the value "*" matches any current entity of the   resource.       If-None-Match = "If-None-Match" ":" ( "*" | 1#entity-tag )   If any of the entity tags match the entity tag of the entity that   would have been returned in the response to a similar GET request   (without the If-None-Match header) on that resource, or if "*" is   given and any current entity exists for that resource, then the   server MUST NOT perform the requested method, unless required to do   so because the resource's modification date fails to match that   supplied in an If-Modified-Since header field in the request.   Instead, if the request method was GET or HEAD, the server SHOULD   respond with a 304 (Not Modified) response, including the cache-   related header fields (particularly ETag) of one of the entities that   matched. For all other request methods, the server MUST respond with   a status of 412 (Precondition Failed).   See section 13.3.3 for rules on how to determine if two entities tags   match. The weak comparison function can only be used with GET or HEAD   requests.   If none of the entity tags match, then the server MAY perform the   requested method as if the If-None-Match header field did not exist,   but MUST also ignore any If-Modified-Since header field(s) in the   request. That is, if no entity tags match, then the server MUST NOT   return a 304 (Not Modified) response.   If the request would, without the If-None-Match header field, result   in anything other than a 2xx or 304 status, then the If-None-Match   header MUST be ignored. (See section 13.3.4 for a discussion of   server behavior when both If-Modified-Since and If-None-Match appear   in the same request.)   The meaning of "If-None-Match: *" is that the method MUST NOT be   performed if the representation selected by the origin server (or by   a cache, possibly using the Vary mechanism, see section 14.44)   exists, and SHOULD be performed if the representation does not exist.   This feature is intended to be useful in preventing races between PUT   operations.   Examples:       If-None-Match: "xyzzy"       If-None-Match: W/"xyzzy"       If-None-Match: "xyzzy", "r2d2xxxx", "c3piozzzz"       If-None-Match: W/"xyzzy", W/"r2d2xxxx", W/"c3piozzzz"       If-None-Match: *   The result of a request having both an If-None-Match header field and   either an If-Match or an If-Unmodified-Since header fields is   undefined by this specification.</body></comment><class><name>HTTPMessage</name><environment>Swazoo</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>task headers body </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Messages</category><attributes><package>Swazoo-Messages</package></attributes></class><class><name>HTTPRequest</name><environment>Swazoo</environment><super>Swazoo.HTTPMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>requestLine peer timestamp ip environmentData resolution encrypted authenticated </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Messages</category><attributes><package>Swazoo-Messages</package></attributes></class><class><name>HTTPTrace</name><environment>Swazoo</environment><super>Swazoo.HTTPRequest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Messages</category><attributes><package>Swazoo-Messages</package></attributes></class><comment><class-id>Swazoo.HTTPTrace</class-id><body>HTTPTrace rfc26216 section 9.8   The TRACE method is used to invoke a remote, application-layer loop-   back of the request message. The final recipient of the request   SHOULD reflect the message received back to the client as the   entity-body of a 200 (OK) response</body></comment><class><name>HTTPAuthorizationBasicField</name><environment>Swazoo</environment><super>Swazoo.HTTPAuthorizationField</super><private>false</private><indexed-type>none</indexed-type><inst-vars>userid password </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Headers</category><attributes><package>Swazoo-Headers</package></attributes></class><class><name>HTTPOptions</name><environment>Swazoo</environment><super>Swazoo.HTTPRequest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Messages</category><attributes><package>Swazoo-Messages</package></attributes></class><comment><class-id>Swazoo.HTTPOptions</class-id><body>HTTPOptionsrfc26216 section 9.2   The OPTIONS method represents a request for information about the   communication options available on the request/response chain   identified by the Request-URI. This method allows the client to   determine the options and/or requirements associated with a resource,   or the capabilities of a server, without implying a resource action   or initiating a resource retrieval.</body></comment><class><name>SwazooStream</name><environment>Swazoo</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>socket readBuffer writeBuffer chunked </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Compatibility</category><attributes><package>Swazoo-HTTP</package></attributes></class><comment><class-id>Swazoo.SwazooStream</class-id><body>SwazooStream is a binary stream directly to a TCP socket. It also includes methods nextLine and nextUnfoldedLine which return a line as string, not binary.For sending and receiving binary data use methods in accessing-bytes, for character/string data use usual methods like next, nextPut: in accessingInstance Variables:	readBuffer	&lt;ReadStream binary&gt;  received bytes are buffered here (about 1024 at once)	socket	      &lt;SwazooSocket&gt;	  actual TCP socket to send/receive data	writeBuffer	&lt;WriteStream binary)&gt; sent bytes are buffered here (until flushed to socket)</body></comment><class><name>URIResolution</name><environment>Swazoo</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>position request </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-HTTP</category><attributes><package>Swazoo-HTTP</package></attributes></class><class><name>HTTPResponse</name><environment>Swazoo</environment><super>Swazoo.HTTPMessage</super><private>false</private><indexed-type>none</indexed-type><inst-vars>statusCode statusText </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Messages</category><attributes><package>Swazoo-Messages</package></attributes></class><class><name>HTTPPost</name><environment>Swazoo</environment><super>Swazoo.HTTPRequest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>postData entityBody readPosition </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Messages</category><attributes><package>Swazoo-Messages</package></attributes></class><comment><class-id>Swazoo.HTTPPost</class-id><body>HTTPPost rfc26216 section 9.5   The POST method is used to request that the origin server accept the   entity enclosed in the request as a new subordinate of the resource   identified by the Request-URI in the Request-Line.Instance Variables:	entityBody	&lt;&gt;		postData	&lt;HTTPPostDataArray&gt;	</body></comment><class><name>HTTPUserAgentField</name><environment>Swazoo</environment><super>Swazoo.SpecificHeaderField</super><private>false</private><indexed-type>none</indexed-type><inst-vars>productTokens </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Headers</category><attributes><package>Swazoo-Headers</package></attributes></class><comment><class-id>Swazoo.HTTPUserAgentField</class-id><body>RFC 2616: 14.43 User-Agent   The User-Agent request-header field contains information about the   user agent originating the request. This is for statistical purposes,   the tracing of protocol violations, and automated recognition of user   agents for the sake of tailoring responses to avoid particular user   agent limitations. User agents SHOULD include this field with   requests. The field can contain multiple product tokens (section 3.8)   and comments identifying the agent and any subproducts which form a   significant part of the user agent. By convention, the product tokens   are listed in order of their significance for identifying the   application.       User-Agent     = "User-Agent" ":" 1*( product | comment )   Example:       User-Agent: CERN-LineMode/2.15 libwww/2.17b3</body></comment><class><name>HTTPAllowField</name><environment>Swazoo</environment><super>Swazoo.SpecificHeaderField</super><private>false</private><indexed-type>none</indexed-type><inst-vars>methods </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Headers</category><attributes><package>Swazoo-Headers</package></attributes></class><class><name>SwazooMD5Digest</name><environment>Swazoo</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>timestamp secret </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Swazoo-Messages</package></attributes></class><comment><class-id>Swazoo.SwazooMD5Digest</class-id><body>SwazooMD5Digest is used for MD5 hashing and preparing digests for HTTP Digest Authentication according to rfc2617.</body></comment><class><name>HTTPException</name><environment>Swazoo</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars>response </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Exceptions</category><attributes><package>Swazoo-Exceptions</package></attributes></class><comment><class-id>Swazoo.HTTPException</class-id><body>HTTPException immediatelly returns attached HTTP response to client. That way it is easier to respond with different status codes (like 201 Created). Not only error ones! You can respond somewhere deeply in code of your resource with raising that exception and adding a prepared HTTPResponse. This exception is non-resumable!Example of ways to raise http response (200 Ok):	HTTPException raiseResponse: (HTTPResponse new code: 200).	HTTPException raiseResponseCode: 200.	HTTPException ok.Instance Variables:	response	&lt;HTTPResponse&gt;	a response to be sent to client</body></comment><class><name>HTTPIfUnmodifiedSinceField</name><environment>Swazoo</environment><super>Swazoo.SpecificHeaderField</super><private>false</private><indexed-type>none</indexed-type><inst-vars>date </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Headers</category><attributes><package>Swazoo-Headers</package></attributes></class><class><name>SwazooStreamNoDataError</name><environment>Swazoo</environment><super>SpError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Exceptions</category><attributes><package>Swazoo-Exceptions</package></attributes></class><class><name>HTTPHostField</name><environment>Swazoo</environment><super>Swazoo.SpecificHeaderField</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hostName portNumber </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Headers</category><attributes><package>Swazoo-Headers</package></attributes></class><class><name>MimeObject</name><environment>Swazoo</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>contentType value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Messages</category><attributes><package>Swazoo-Messages</package></attributes></class><class><name>HTTPPostDatum</name><environment>Swazoo</environment><super>Swazoo.MimeObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>filename writeStream writeBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Messages</category><attributes><package>Swazoo-Messages</package></attributes></class><class><name>URIResolutionTest</name><environment>Swazoo</environment><super>XProgramming.SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Tests</category><attributes><package>Swazoo-Tests</package></attributes></class><class><name>HTTPConnection</name><environment>Swazoo</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream loop server task other </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-HTTP</category><attributes><package>Swazoo-HTTP</package></attributes></class><class><name>SwazooHTTPPutError</name><environment>Swazoo</environment><super>Swazoo.SwazooHTTPRequestError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Exceptions</category><attributes><package>Swazoo-Exceptions</package></attributes></class><class><name>RedirectionResource</name><environment>Swazoo</environment><super>Swazoo.SwazooResource</super><private>false</private><indexed-type>none</indexed-type><inst-vars>targetUri </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Resources</category><attributes><package>Swazoo-Resources</package></attributes></class><class><name>SwazooSocket</name><environment>Swazoo</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>accessor </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Compatibility</category><attributes><package>Swazoo-HTTP</package></attributes></class><class><name>HTTPDelete</name><environment>Swazoo</environment><super>Swazoo.HTTPRequest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Messages</category><attributes><package>Swazoo-Messages</package></attributes></class><comment><class-id>Swazoo.HTTPDelete</class-id><body>HTTPDelete rfc26216 section 9.7The DELETE method requests that the origin server delete the resource   identified by the Request-URI. This method MAY be overridden by human   intervention (or other means) on the origin server. The client cannot   be guaranteed that the operation has been carried out, even if the   status code returned from the origin server indicates that the action   has been completed successfully. However, the server SHOULD NOT   indicate success unless, at the time the response is given, it   intends to delete the resource or move it to an inaccessible   location. ...</body></comment><class><name>HTTPStreamedResponse</name><environment>Swazoo</environment><super>Swazoo.HTTPResponse</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream count length state semaphore compressed gzStream </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Messages</category><attributes><package>Swazoo-Messages</package></attributes></class><comment><class-id>Swazoo.HTTPStreamedResponse</class-id><body>HTTPStreamedResponse HTTP/1.1 	no length   	chunkedHTTP/1.1	length		streamed directly, with contentLengthHTTP/1.0	no length   	simulated streaming: into entity first, then sent as normal response (not yet impl.)HTTP/1.0  	length 		streamed directly, with content lengthInstance Variables:	stream		&lt;SwazooStream&gt; where to stream a response	count		&lt;Integer&gt; 		how many bytes already streamed	length		&lt;Integer&gt;		announced length of response, optional	state		&lt;Symbol&gt;		#header #streaming #closed				semaphore	&lt;Semaphore&gt;	to signal end of response</body></comment><class><name>SwazooURI</name><environment>Swazoo</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>protocol hostname port identifier queries </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-HTTP</category><attributes><package>Swazoo-HTTP</package></attributes></class><class><name>HTTPGet</name><environment>Swazoo</environment><super>Swazoo.HTTPRequest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Messages</category><attributes><package>Swazoo-Messages</package></attributes></class><comment><class-id>Swazoo.HTTPGet</class-id><body>HTTPGet rfc26216 section 9.3   The GET method means retrieve whatever information (in the form of an   entity) is identified by the Request-URI. If the Request-URI refers   to a data-producing process, it is the produced data which shall be   returned as the entity in the response and not the source text of the   process, unless that text happens to be the output of the process.</body></comment><class><name>HTTPAuthenticationChallenge</name><environment>Swazoo</environment><super>Swazoo.HTTPResponse</super><private>false</private><indexed-type>none</indexed-type><inst-vars>resource </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Swazoo-Messages</package></attributes></class><class><name>HTTPCookieField</name><environment>Swazoo</environment><super>Swazoo.SpecificHeaderField</super><private>false</private><indexed-type>none</indexed-type><inst-vars>values </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Headers</category><attributes><package>Swazoo-Headers</package></attributes></class><class><name>HTTPCacheControlField</name><environment>Swazoo</environment><super>Swazoo.SpecificHeaderField</super><private>false</private><indexed-type>none</indexed-type><inst-vars>directives private maxAge noStore noCache mustRevalidate </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Headers</category><attributes><package>Swazoo-Headers</package></attributes></class><class><name>WebSocketTest</name><environment>Swazoo</environment><super>XProgramming.SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Tests</category><attributes><package>Swazoo-Tests</package></attributes></class><class><name>SwazooHeaderFieldParseError</name><environment>Swazoo</environment><super>SpError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Exceptions</category><attributes><package>Swazoo-Exceptions</package></attributes></class><class><name>SwazooURITest</name><environment>Swazoo</environment><super>XProgramming.SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fooURI barURI queryURI </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Tests</category><attributes><package>Swazoo-Tests</package></attributes></class><class><name>HTTPSetCookieField</name><environment>Swazoo</environment><super>Swazoo.SpecificHeaderField</super><private>false</private><indexed-type>none</indexed-type><inst-vars>cookies </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Headers</category><attributes><package>Swazoo-Headers</package></attributes></class><class><name>HelloWorldResourceTest</name><environment>Swazoo</environment><super>XProgramming.SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>hello </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Tests</category><attributes><package>Swazoo-Tests</package></attributes></class><class><name>SwazooHTTPPostError</name><environment>Swazoo</environment><super>Swazoo.SwazooHTTPRequestError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Exceptions</category><attributes><package>Swazoo-Exceptions</package></attributes></class><class><name>SwazooBuffer</name><environment>Swazoo</environment><super>Core.ReadWriteStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>type resize </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Compatibility</category><attributes><package>Swazoo-HTTP</package></attributes></class><comment><class-id>Swazoo.SwazooBuffer</class-id><body>SwazooBuffer is used for efficient buffering of receiving or sending data to TCP socket. Efficiency is achieved with reusing of stream content array instead of initializing it everytime buffer is emptied, as was in previous Swazoo versions. SwazooBuffer is a subclass of ReadWriteStream, with additional #clear to empty buffer.</body></comment><class><name>ContentDispositionField</name><environment>Swazoo</environment><super>Swazoo.SpecificHeaderField</super><private>false</private><indexed-type>none</indexed-type><inst-vars>type parameters </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Headers</category><attributes><package>Swazoo-Headers</package></attributes></class><class><name>SwazooWebSocket</name><environment>Swazoo</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>version connection recBlock </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Swazoo-HTTP</package></attributes></class><comment><class-id>Swazoo.SwazooWebSocket</class-id><body>WebSocket for handling WebSocket messages. By default it just echo incomming messages.More on http://www.swazoo.org/websocket</body></comment><class><name>HTTPLocationField</name><environment>Swazoo</environment><super>Swazoo.SpecificHeaderField</super><private>false</private><indexed-type>none</indexed-type><inst-vars>uri </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Headers</category><attributes><package>Swazoo-Headers</package></attributes></class><class><name>SwazooCacheControlTest</name><environment>Swazoo</environment><super>XProgramming.SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>resource cacheTarget request cacheControl </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Tests</category><attributes><package>Swazoo-Tests</package></attributes></class><class><name>HTTPETagField</name><environment>Swazoo</environment><super>Swazoo.SpecificHeaderField</super><private>false</private><indexed-type>none</indexed-type><inst-vars>entityTag </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Headers</category><attributes><package>Swazoo-Headers</package></attributes></class><comment><class-id>Swazoo.HTTPETagField</class-id><body>RFC 2626 14.19 ETag   The ETag response-header field provides the current value of the   entity tag for the requested variant. The headers used with entity   tags are described in sections 14.24, 14.26 and 14.44. The entity tag   MAY be used for comparison with other entities from the same resource   (see section 13.3.3).      ETag = "ETag" ":" entity-tag   Examples:      ETag: "xyzzy"      ETag: W/"xyzzy"      ETag: ""</body></comment><class><name>WebSocketConnection</name><environment>Swazoo</environment><super>Swazoo.HTTPConnection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Swazoo-HTTP</package></attributes></class><comment><class-id>Swazoo.WebSocketConnection</class-id><body>WebSocketConnection is an updated HTTP connection to a WebSocket one for bidirectional messaging between client and server.More on http://www.swazoo.org/websocket</body></comment><class><name>HTTPRequestTest</name><environment>Swazoo</environment><super>XProgramming.SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>request </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Tests</category><attributes><package>Swazoo-Tests</package></attributes></class><class><name>CompositeResource</name><environment>Swazoo</environment><super>Swazoo.SwazooResource</super><private>false</private><indexed-type>none</indexed-type><inst-vars>children </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Core</category><attributes><package>Swazoo-Core</package></attributes></class><class><name>ServerRootComposite</name><environment>Swazoo</environment><super>Swazoo.CompositeResource</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-HTTP</category><attributes><package>Swazoo-HTTP</package></attributes></class><class><name>FileResponse</name><environment>Swazoo</environment><super>Swazoo.HTTPResponse</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Messages</category><attributes><package>Swazoo-Fileserver</package></attributes></class><class><name>HTTPPut</name><environment>Swazoo</environment><super>Swazoo.HTTPRequest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>putData </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Messages</category><attributes><package>Swazoo-Messages</package></attributes></class><comment><class-id>Swazoo.HTTPPut</class-id><body>HTTPPut rfc26216 section 9.6   The PUT method requests that the enclosed entity be stored under the   supplied Request-URI. If the Request-URI refers to an already   existing resource, the enclosed entity SHOULD be considered as a   modified version of the one residing on the origin server. If the   Request-URI does not point to an existing resource, and that URI is   capable of being defined as a new resource by the requesting user   agent, the origin server can create the resource with that URI. If a   new resource is created, the origin server MUST inform the user agent   via the 201 (Created) response. If an existing resource is modified,   either the 200 (OK) or 204 (No Content) response codes SHOULD be sent   to indicate successful completion of the request. If the resource   could not be created or modified with the Request-URI, an appropriate   error response SHOULD be given that reflects the nature of the   problem. The recipient of the entity MUST NOT ignore any Content-*   (e.g. Content-Range) headers that it does not understand or implement   and MUST return a 501 (Not Implemented) response in such cases.Instance Variables:	putData	&lt;&gt;	</body></comment><class><name>TCPAnalyser</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Tests</category><attributes><package>Swazoo-Tests</package></attributes></class><comment><class-id>TCPAnalyser</class-id><body>EtherealTCPAnalyser - support for analysing TCP packets recorded by Ethereal Network Protocol Analyser</body></comment><class><name>SwazooAuthNonce</name><environment>Swazoo</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>timestamp secret </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Swazoo-Messages</package></attributes></class><comment><class-id>Swazoo.SwazooAuthNonce</class-id><body>SwazooAuthNonce is used for HTTP Digest Authentication, see rfc2617 3.2.1:   nonce     A server-specified data string which should be uniquely generated     each time a 401 response is made. It is recommended that this     string be base64 or hexadecimal data. Specifically, since the     string is passed in the header lines as a quoted string, the     double-quote character is not allowed.     The contents of the nonce are implementation dependent. The quality     of the implementation depends on a good choice. A nonce might, for     example, be constructed as the base 64 encoding of         time-stamp H(time-stamp ":" ETag ":" private-key)Instance Variables:	secret	&lt;String&gt;	 secret, just simple 'self hash'	timestamp	&lt;Timestamp&gt;	timestamp used for generating that nounce</body></comment><class><name>HTTPServerField</name><environment>Swazoo</environment><super>Swazoo.SpecificHeaderField</super><private>false</private><indexed-type>none</indexed-type><inst-vars>productTokens </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Headers</category><attributes><package>Swazoo-Headers</package></attributes></class><class><name>SwazooSite</name><environment>Swazoo</environment><super>Swazoo.CompositeResource</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name serving </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Core</category><attributes><package>Swazoo-Core</package></attributes></class><comment><class-id>Swazoo.SwazooSite</class-id><body>Site : Swazoo can serve many sites at once (virtual sites). Class Site is therefore a main class to start configuring your server. It holds an IP, port and hostname of your site.</body></comment><class><name>SwazooDemoSite</name><environment>Swazoo</environment><super>Swazoo.SwazooSite</super><private>false</private><indexed-type>none</indexed-type><inst-vars>webSocket </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Resources</category><attributes><package>Swazoo-Resources</package></attributes></class><class><name>SwazooTask</name><environment>Swazoo</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>connection request response </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Messages</category><attributes><package>Swazoo-Messages</package></attributes></class><comment><class-id>Swazoo.SwazooTask</class-id><body>A SwazooTask is simply a request-response pair.  This class just makes the task (ha!) of dealing with requests and responses a bit easier.</body></comment><class><name>SwazooServerTest</name><environment>Swazoo</environment><super>XProgramming.SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Tests</category><attributes><package>Swazoo-Tests</package></attributes></class><class><name>HTTPServerTest</name><environment>Swazoo</environment><super>XProgramming.SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>server stream </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Tests</category><attributes><package>Swazoo-Tests</package></attributes></class><class><name>HTTPPostTest</name><environment>Swazoo</environment><super>XProgramming.SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>request </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Tests</category><attributes><package>Swazoo-Tests</package></attributes></class><class><name>SwazooConfigurationTest</name><environment>Swazoo</environment><super>XProgramming.SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Tests</category><attributes><package>Swazoo-Tests</package></attributes></class><class><name>HTTPHeaders</name><environment>Swazoo</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fields </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Headers</category><attributes><package>Swazoo-Headers</package></attributes></class><class><name>GenericHeaderField</name><environment>Swazoo</environment><super>Swazoo.HeaderField</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Headers</category><attributes><package>Swazoo-Headers</package></attributes></class><class><name>HTTPLastModifiedField</name><environment>Swazoo</environment><super>Swazoo.SpecificHeaderField</super><private>false</private><indexed-type>none</indexed-type><inst-vars>timestamp </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Headers</category><attributes><package>Swazoo-Headers</package></attributes></class><class><name>HTTPServer</name><environment>Swazoo</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>ip port connections sites socket loop isMultiThreading </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-HTTP</category><attributes><package>Swazoo-HTTP</package></attributes></class><class><name>HTTPAuthenticationBasicChallenge</name><environment>Swazoo</environment><super>Swazoo.HTTPAuthenticationChallenge</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Swazoo-Messages</package></attributes></class><class><name>HTTPAcceptField</name><environment>Swazoo</environment><super>Swazoo.SpecificHeaderField</super><private>false</private><indexed-type>none</indexed-type><inst-vars>mediaTypes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Headers</category><attributes><package>Swazoo-Headers</package></attributes></class><class><name>SwazooSocketTest</name><environment>Swazoo</environment><super>XProgramming.SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>input output </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Tests</category><attributes><package>Swazoo-Tests</package></attributes></class><class><name>HTTPIfModifiedSinceField</name><environment>Swazoo</environment><super>Swazoo.SpecificHeaderField</super><private>false</private><indexed-type>none</indexed-type><inst-vars>date </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Headers</category><attributes><package>Swazoo-Headers</package></attributes></class><class><name>HomeResourceTest</name><environment>Swazoo</environment><super>XProgramming.SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>resource </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Tests</category><attributes><package>Swazoo-Tests</package></attributes></class><class><name>HTTPContentLengthField</name><environment>Swazoo</environment><super>Swazoo.SpecificHeaderField</super><private>false</private><indexed-type>none</indexed-type><inst-vars>contentLength </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Headers</category><attributes><package>Swazoo-Headers</package></attributes></class><class><name>HTTPResponseTest</name><environment>Swazoo</environment><super>XProgramming.SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>response </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Tests</category><attributes><package>Swazoo-Tests</package></attributes></class><class><name>URIIdentifier</name><environment>Swazoo</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-HTTP</category><attributes><package>Swazoo-HTTP</package></attributes></class><class><name>SiteIdentifier</name><environment>Swazoo</environment><super>Swazoo.URIIdentifier</super><private>false</private><indexed-type>none</indexed-type><inst-vars>ip port host </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-HTTP</category><attributes><package>Swazoo-HTTP</package></attributes></class><class><name>HTTPExpiresField</name><environment>Swazoo</environment><super>Swazoo.SpecificHeaderField</super><private>false</private><indexed-type>none</indexed-type><inst-vars>timestamp </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Headers</category><attributes><package>Swazoo-Headers</package></attributes></class><class><name>HTTPString</name><environment>Swazoo</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Compatibility</category><attributes><package>Swazoo-HTTP</package></attributes></class><comment><class-id>Swazoo.HTTPString</class-id><body>This class contains some utility methods that were previously implemented as extentions to system classes.  This is really a stop-gap until, perhaps, the SwazooStream yeilds HTTPStrings.</body></comment><class><name>HTTPWWWAuthenticateDigestField</name><environment>Swazoo</environment><super>Swazoo.HTTPWWWAuthenticateField</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Headers</category><attributes><package>Swazoo-Headers</package></attributes></class><class><name>HTTPIfMatchField</name><environment>Swazoo</environment><super>Swazoo.HTTPMatchField</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Headers</category><attributes><package>Swazoo-Headers</package></attributes></class><comment><class-id>Swazoo.HTTPIfMatchField</class-id><body>From RFC 261614.24 If-Match   The If-Match request-header field is used with a method to make it   conditional. A client that has one or more entities previously   obtained from the resource can verify that one of those entities is   current by including a list of their associated entity tags in the   If-Match header field. Entity tags are defined in section 3.11. The   purpose of this feature is to allow efficient updates of cached   information with a minimum amount of transaction overhead. It is also   used, on updating requests, to prevent inadvertent modification of   the wrong version of a resource. As a special case, the value "*"   matches any current entity of the resource.       If-Match = "If-Match" ":" ( "*" | 1#entity-tag )   If any of the entity tags match the entity tag of the entity that   would have been returned in the response to a similar GET request   (without the If-Match header) on that resource, or if "*" is given   and any current entity exists for that resource, then the server MAY   perform the requested method as if the If-Match header field did not   exist.   A server MUST use the strong comparison function (see section 13.3.3)   to compare the entity tags in If-Match.   If none of the entity tags match, or if "*" is given and no current   entity exists, the server MUST NOT perform the requested method, and   MUST return a 412 (Precondition Failed) response. This behavior is   most useful when the client wants to prevent an updating method, such   as PUT, from modifying a resource that has changed since the client   last retrieved it.   If the request would, without the If-Match header field, result in   anything other than a 2xx or 412 status, then the If-Match header   MUST be ignored.   The meaning of "If-Match: *" is that the method SHOULD be performed   if the representation selected by the origin server (or by a cache,   possibly using the Vary mechanism, see section 14.44) exists, and   MUST NOT be performed if the representation does not exist.   A request intended to update a resource (e.g., a PUT) MAY include an   If-Match header field to signal that the request method MUST NOT be   applied if the entity corresponding to the If-Match value (a single   entity tag) is no longer a representation of that resource. This   allows the user to indicate that they do not wish the request to be   successful if the resource has been changed without their knowledge.   Examples:       If-Match: "xyzzy"       If-Match: "xyzzy", "r2d2xxxx", "c3piozzzz"       If-Match: *   The result of a request having both an If-Match header field and   either an If-None-Match or an If-Modified-Since header fields is   undefined by this specification.</body></comment><class><name>SwazooBenchmarks</name><environment>Swazoo</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>server content </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Tests</category><attributes><package>Swazoo-Tests</package></attributes></class><comment><class-id>Swazoo.SwazooBenchmarks</class-id><body>SwazooBenchmarks stores several benchmarks and performance routines1. set #contentSize to desired response size2.  SwazooBenchmark startSocketServer3. httperf --server localhost --port 9999 --uri "/" --rate 40 --num-conn 40     (increase rate and num-conn until request rate is the same as those numbers)</body></comment><class><name>URIParsingTest</name><environment>Swazoo</environment><super>XProgramming.SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Tests</category><attributes><package>Swazoo-Tests</package></attributes></class><class><name>SwazooServer</name><environment>Swazoo</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sites servers other </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Core</category><attributes><package>Swazoo-Core</package></attributes></class><comment><class-id>Swazoo.SwazooServer</class-id><body>SwazooServer is where all begins in Swazoo!SwazooServer singleton : return one and only one server which holds the Sites. Also used to start and stop all sites ato once, to add new sited etc. When running, a collection of HTTPServers is also stored in SwazooServer singleton.SwazooServer demoStart  will create and run a demo site on http://localhost:8888 which                                      returns a web page with 'Hello World!'</body></comment><class><name>CompositeResourceTest</name><environment>Swazoo</environment><super>XProgramming.SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>composite </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Tests</category><attributes><package>Swazoo-Tests</package></attributes></class><class><name>SiteTest</name><environment>Swazoo</environment><super>XProgramming.SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>site </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Tests</category><attributes><package>Swazoo-Tests</package></attributes></class><class><name>HTTPIfRangeField</name><environment>Swazoo</environment><super>Swazoo.SpecificHeaderField</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tagOrDate </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Headers</category><attributes><package>Swazoo-Headers</package></attributes></class><class><name>HTTPConnectionField</name><environment>Swazoo</environment><super>Swazoo.SpecificHeaderField</super><private>false</private><indexed-type>none</indexed-type><inst-vars>connectionToken </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Headers</category><attributes><package>Swazoo-Headers</package></attributes></class><comment><class-id>Swazoo.HTTPConnectionField</class-id><body>c.f. RFC 2616 14.10   The Connection header has the following grammar:       Connection = "Connection" ":" 1#(connection-token)       connection-token  = token</body></comment><class><name>HTTPAuthenticationDigestChallenge</name><environment>Swazoo</environment><super>Swazoo.HTTPAuthenticationChallenge</super><private>false</private><indexed-type>none</indexed-type><inst-vars>nonce opaque </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>Swazoo-Messages</package></attributes></class><class><name>TestPseudoSocket</name><environment>Swazoo</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>byteStreamToServer byteStreamFromServer clientWaitSemaphore serverWaitSemaphore ipAddress </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Tests</category><attributes><package>Swazoo-Tests</package></attributes></class><comment><class-id>Swazoo.TestPseudoSocket</class-id><body>TestPseudoSocket is a drop in replacement for a SwazooSocket that can be used during testing to feed bytes into a running SwazooHTTPServer and grab the responses without having to start a real socket pair.So, to the HTTP server it must look like a server socket.  To the tester it must look like a write stream (to send bytes to the HTTP server) and a read stream (to read the HTTP responses).</body></comment><class><name>SiteIdentifierTest</name><environment>Swazoo</environment><super>XProgramming.SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>identifier </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Tests</category><attributes><package>Swazoo-Tests</package></attributes></class><class><name>RedirectionResourceTest</name><environment>Swazoo</environment><super>XProgramming.SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>resource </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Tests</category><attributes><package>Swazoo-Tests</package></attributes></class><class><name>SwazooBufferTest</name><environment>Swazoo</environment><super>XProgramming.SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Tests</category><attributes><package>Swazoo-Tests</package></attributes></class><class><name>HeaderFieldTest</name><environment>Swazoo</environment><super>XProgramming.SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Tests</category><attributes><package>Swazoo-Tests</package></attributes></class><class><name>ResourceTest</name><environment>Swazoo</environment><super>XProgramming.SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>resource </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Tests</category><attributes><package>Swazoo-Tests</package></attributes></class><class><name>SwazooBaseExtensionsTest</name><environment>Swazoo</environment><super>XProgramming.SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Tests</category><attributes><package>Swazoo-Tests</package></attributes></class><class><name>SwazooStreamTest</name><environment>Swazoo</environment><super>XProgramming.SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>input output </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Tests</category><attributes><package>Swazoo-Tests</package></attributes></class><class><name>SwazooCacheControl</name><environment>Swazoo</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>request cacheTarget etag lastModified </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Resources</category><attributes><package>Swazoo-Fileserver</package></attributes></class><class><name>HelloWorldResource</name><environment>Swazoo</environment><super>Swazoo.SwazooResource</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Resources</category><attributes><package>Swazoo-Resources</package></attributes></class><comment><class-id>Swazoo.HelloWorldResource</class-id><body>HelloWorldResource as a simple example and for testing purposes</body></comment><class><name>HTTPRefererField</name><environment>Swazoo</environment><super>Swazoo.SpecificHeaderField</super><private>false</private><indexed-type>none</indexed-type><inst-vars>uri </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Headers</category><attributes><package>Swazoo-Headers</package></attributes></class><comment><class-id>Swazoo.HTTPRefererField</class-id><body>RFC 2616: 14.36 Referer   The Referer[sic] request-header field allows the client to specify,   for the server's benefit, the address (URI) of the resource from   which the Request-URI was obtained (the "referrer", although the   header field is misspelled.) The Referer request-header allows a   server to generate lists of back-links to resources for interest,   logging, optimized caching, etc. It also allows obsolete or mistyped   links to be traced for maintenance. The Referer field MUST NOT be   sent if the Request-URI was obtained from a source that does not have   its own URI, such as input from the user keyboard.       Referer        = "Referer" ":" ( absoluteURI | relativeURI )   Example:       Referer: http://www.w3.org/hypertext/DataSources/Overview.html   If the field value is a relative URI, it SHOULD be interpreted   relative to the Request-URI. The URI MUST NOT include a fragment. See   section 15.1.3 for security considerations.</body></comment><class><name>HTTPAuthorizationDigestField</name><environment>Swazoo</environment><super>Swazoo.HTTPAuthorizationField</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Headers</category><attributes><package>Swazoo-Headers</package></attributes></class><class><name>HTTPHead</name><environment>Swazoo</environment><super>Swazoo.HTTPRequest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Messages</category><attributes><package>Swazoo-Messages</package></attributes></class><comment><class-id>Swazoo.HTTPHead</class-id><body>HTTPHeadrfc26216 section 9.4   The HEAD method is identical to GET except that the server MUST NOT   return a message-body in the response. The metainformation contained   in the HTTP headers in response to a HEAD request SHOULD be identical   to the information sent in response to a GET request. This method can   be used for obtaining metainformation about the entity implied by the   request without transferring the entity-body itself. This method is   often used for testing hypertext links for validity, accessibility,   and recent modification.</body></comment><class><name>WebSocketMessage</name><environment>Swazoo</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>payload masked mask opcode final </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Messages</category><attributes><package>Swazoo-Messages</package></attributes></class><class><name>HTTPRequestLine</name><environment>Swazoo</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method requestURI httpVersion </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Messages</category><attributes><package>Swazoo-Messages</package></attributes></class><class><name>SpEnvironment</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>ImageStartupTaskBlocks ImageShutdownTaskBlocks </class-inst-vars><imports></imports><category>SpEnvironmental</category><attributes><package>Swazoo-Extensions</package></attributes></class><class><name>HTTPPostDataArray</name><environment>Swazoo</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>underlyingCollection stream parsed </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Messages</category><attributes><package>Swazoo-Messages</package></attributes></class><comment><class-id>Swazoo.HTTPPostDataArray</class-id><body>Introduced the HTTPPostDataArray to hold post data in an HTTPRequest in place of a Dictionary.  This is because it is legal for there to be more than one entry with the same name (key) and using a Dictionary  looses data (!).Instance Variables:	underlyingCollection	&lt;&gt;	</body></comment><shared-variable><name>Singleton</name><environment>Swazoo.SwazooServer</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Swazoo-Core</package></attributes></shared-variable><shared-variable><name>Singleton</name><environment>Swazoo.SwazooBenchmarks</environment><private>false</private><constant>false</constant><category>singleton</category><initializer>Array new: 5</initializer><attributes><package>Swazoo-Tests</package></attributes></shared-variable><shared-variable><name>StatusCodes</name><environment>Swazoo.HTTPResponse</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Swazoo-Messages</package></attributes></shared-variable><shared-variable><name>ContentTypes</name><environment>Swazoo.FileResource</environment><private>false</private><constant>false</constant><category>As yet unclassified</category><attributes><package>Swazoo-Fileserver</package></attributes></shared-variable><methods><class-id>Swazoo.HeaderField</class-id> <category>printing</category><body package="Swazoo-Headers">printOn: aStream 	aStream		nextPutAll: self name;		nextPutAll: ': '.	self valuesAsStringOn: aStream.	^self</body><body package="Swazoo-Headers">valuesAsString	| targetStream |	targetStream := WriteStream on: String new.	self valuesAsStringOn: targetStream.	^targetStream contents</body><body package="Swazoo-Headers">valuesAsStringOn: aStream	^self subclassResponsibility</body></methods><methods><class-id>Swazoo.HeaderField</class-id> <category>accessing</category><body package="Swazoo-Headers">fieldName	^self subclassResponsibility</body><body package="Swazoo-Headers">name	^self subclassResponsibility</body><body package="Swazoo-Headers">values	^self subclassResponsibility</body></methods><methods><class-id>Swazoo.HeaderField</class-id> <category>testing</category><body package="Swazoo-Headers">isConditional	^false</body><body package="Swazoo-Headers">isContentDisposition	^false</body><body package="Swazoo-Headers">isContentType	^false</body></methods><methods><class-id>Swazoo.HeaderField</class-id> <category>services</category><body package="Swazoo-Headers">combineWith: aHeaderField 	SwazooHeaderFieldParseError raiseSignal: 'Not supported'</body></methods><methods><class-id>Swazoo.HeaderField class</class-id> <category>private</category><body package="Swazoo-Headers">classForFieldName: aString 	"^a ClassIf I can find a specific header field with a name matching aString I return that.  Otherwise I return the GenericHeaderField class."	^self httpFieldNameToClassDictionary at: aString		ifAbsent: [GenericHeaderField]</body><body package="Swazoo-Headers">httpFieldNameToClassDictionary	"^a ClassI return the dictionarry of my subclasses keyed on the name of the field they represent.Note that we only need *Request* headers listed in here because they are the only thing we will be parsing for."	"After a change here, remeber to do 'HeaderField resetHttpFieldNameToClassDictionary' "	httpFieldNameToClassDictionary isNil 		ifTrue: 			[| headerClasses |			headerClasses := OrderedCollection new.			headerClasses				add: ContentDispositionField;				add: HTTPContentLengthField;				add: ContentTypeField;				add: HTTPAcceptField;				add: HTTPAuthorizationField;				add: HTTPConnectionField;				add: HTTPHostField;				add: HTTPIfMatchField;				add: HTTPIfModifiedSinceField;				add: HTTPIfNoneMatchField;				add: HTTPIfRangeField;				add: HTTPIfUnmodifiedSinceField;				add: HTTPRefererField;				add: HTTPUserAgentField.			httpFieldNameToClassDictionary := Dictionary new.			headerClasses do: 					[:aClass | 					httpFieldNameToClassDictionary at: aClass fieldName asUppercase put: aClass]].	^httpFieldNameToClassDictionary</body><body package="Swazoo-Headers">newForFieldName: fieldNameString withValueFrom: fieldValueString 	^self subclassResponsibility</body><body package="Swazoo-Headers">resetHttpFieldNameToClassDictionary		httpFieldNameToClassDictionary := nil .	^self</body></methods><methods><class-id>Swazoo.HeaderField class</class-id> <category>instance creation</category><body package="Swazoo-Headers">fromLine: aString 	| sourceStream fieldName fieldValue fieldClass |	sourceStream := ReadStream on: aString.	fieldName := (HTTPString trimBlanksFrom: (sourceStream upTo: $:)) 				asUppercase.	fieldClass := self classForFieldName: fieldName.	fieldValue := HTTPString trimBlanksFrom: sourceStream upToEnd.	^fieldClass newForFieldName: fieldName withValueFrom: fieldValue</body></methods><methods><class-id>Swazoo.SpecificHeaderField</class-id> <category>private</category><body package="Swazoo-Headers">parseValueFrom: aString	^self subclassResponsibility</body><body package="Swazoo-Headers">readParametersFrom: sourceStream 	"^a Dictionaryc.f. RFC 2616 3.6 Transfer Codings"	| parameters |	parameters := Dictionary new.	[sourceStream atEnd] whileFalse: 			[| attribute value |			attribute := HTTPString trimBlanksFrom: (sourceStream upTo: $=).			value := HTTPString trimBlanksFrom: (sourceStream upTo: $;).			parameters at: attribute put: value].	^parameters</body></methods><methods><class-id>Swazoo.SpecificHeaderField</class-id> <category>accessing</category><body package="Swazoo-Headers">name	^self class fieldName</body><body package="Swazoo-Headers">parameterAt: aString ifAbsent: aBlock 1 halt: 'use the transfer encodings of the field, not this'.	^self parameters at: aString ifAbsent: aBlock</body><body package="Swazoo-Headers">values	^Array with: self value</body></methods><methods><class-id>Swazoo.SpecificHeaderField</class-id> <category>initialize-release</category><body package="Swazoo-Headers">valueFrom: fieldValueString 	self parseValueFrom: fieldValueString.	^self</body></methods><methods><class-id>Swazoo.SpecificHeaderField class</class-id> <category>private</category><body package="Swazoo-Headers">newForFieldName: fieldNameString withValueFrom: fieldValueString 	^self newWithValueFrom: fieldValueString</body><body package="Swazoo-Headers">newWithValueFrom: fieldValueString 	^self new valueFrom: fieldValueString</body></methods><methods><class-id>Swazoo.SpecificHeaderField class</class-id> <category>accessing</category><body package="Swazoo-Headers">fieldName	^self subclassResponsibility</body></methods><methods><class-id>Swazoo.HTTPAuthorizationField</class-id> <category>accessing</category><body package="Swazoo-Headers">credentials	^credentials</body></methods><methods><class-id>Swazoo.HTTPAuthorizationField</class-id> <category>printing</category><body package="Swazoo-Headers">valuesAsStringOn: aStream 	aStream nextPutAll: self credentials.	^self</body></methods><methods><class-id>Swazoo.HTTPAuthorizationField</class-id> <category>private</category><body package="Swazoo-Headers">parseValueFrom: aString 	credentials := HTTPString trimBlanksFrom: aString.	^self</body></methods><methods><class-id>Swazoo.HTTPAuthorizationField class</class-id> <category>private</category><body package="Swazoo-Headers">newForFieldName: fieldNameString withValueFrom: fieldValueString 	"^an HTTPAuthorizationFieldI return an instance of one of my concrete subclasses.  To get to this point, the field name *must* be 'AUTHORIZATION'."	| sourceStream schemeName |	sourceStream := ReadStream on: fieldValueString.	schemeName := sourceStream upTo: Character space.	^schemeName = 'Basic' 		ifTrue: [HTTPAuthorizationBasicField newWithValueFrom: sourceStream upToEnd]		ifFalse: [HTTPAuthorizationDigestField newWithValueFrom: sourceStream upToEnd]</body></methods><methods><class-id>Swazoo.HTTPAuthorizationField class</class-id> <category>accessing</category><body package="Swazoo-Headers">fieldName	^'Authorization'</body></methods><methods><class-id>Swazoo.SwazooResource</class-id> <category>private</category><body package="Swazoo-Core">match: anIdentifier 	^self uriPattern match: anIdentifier</body><body package="Swazoo-Core">parent: aResource	parent := aResource</body></methods><methods><class-id>Swazoo.SwazooResource</class-id> <category>private-initialize</category><body package="Swazoo-Core">initUriPattern	self uriPattern: ''</body><body package="Swazoo-Core">initialize	self enable.	self initUriPattern</body><body package="Swazoo-Core">onResourceCreated	"Received after the resource has been added to its parent resource. Opportunity to perform initialization that depends on knowledge of the resource tree structure"</body></methods><methods><class-id>Swazoo.SwazooResource</class-id> <category>authentication</category><body package="Swazoo-Core">authenticationRealm	"rfc2617 3.2.1: A string to be displayed to users so they know which username and     password to use. This string should contain at least the name of     the host performing the authentication and might additionally     indicate the collection of users who might have access. An example     might be 'registered_users@gotham.news.com' "	^'Swazoo server'</body><body package="Swazoo-Core">authenticationScheme	"#Basic or #Digest, see rfc2617. Digest is recomended because password	goes encrypted to server"	^#Digest</body><body package="Swazoo-Core">unauthorizedResponse	"Resource should call this method and return its result immediately, if request is not authorized 	to access that resource and a HTTP authorization is needed"	^Swazoo.HTTPAuthenticationChallenge newForResource: self</body><body package="Swazoo-Core">unauthorizedResponsePage	"Resource should override this method with it's own html message"	^'&lt;HTML&gt;  &lt;HEAD&gt;    &lt;TITLE&gt;Authentication error&lt;/TITLE&gt;  &lt;/HEAD&gt;  &lt;BODY&gt;    &lt;H1&gt;401 Authentication error&lt;/H1&gt;    &lt;P&gt;Bad username or password&lt;/P&gt;  &lt;/BODY&gt;&lt;/HTML&gt;'</body></methods><methods><class-id>Swazoo.SwazooResource</class-id> <category>accessing</category><body package="Swazoo-Core">currentUrl	| stream |	stream := WriteStream on: String new.	self printUrlOn: stream.	^stream contents</body><body package="Swazoo-Core">helpResolve: aResolution 	^aResolution resolveLeafResource: self</body><body package="Swazoo-Core">parent	^parent</body><body package="Swazoo-Core">printUrlOn: aWriteStream 	self parent printUrlOn: aWriteStream.	aWriteStream nextPutAll: self uriPattern</body><body package="Swazoo-Core">root	^self parent isNil		ifTrue: [self]		ifFalse: [self parent root]</body><body package="Swazoo-Core">uriPattern	^uriPattern</body><body package="Swazoo-Core">uriPattern: anIdentifier 	anIdentifier notNil ifTrue: [uriPattern := anIdentifier]</body></methods><methods><class-id>Swazoo.SwazooResource</class-id> <category>testing</category><body package="Swazoo-Core">canAnswer	^self isEnabled and: [self isValidlyConfigured]</body><body package="Swazoo-Core">isEnabled	^enabled</body><body package="Swazoo-Core">isValidlyConfigured	^self uriPattern ~= ''</body></methods><methods><class-id>Swazoo.SwazooResource</class-id> <category>start/stop</category><body package="Swazoo-Core">disable	enabled := false</body><body package="Swazoo-Core">enable	enabled := true</body><body package="Swazoo-Core">start</body><body package="Swazoo-Core">stop</body></methods><methods><class-id>Swazoo.SwazooResource</class-id> <category>serving</category><body package="Swazoo-Core">answerTo: aRequest	"override in your Resource and return a HTTPResponse"	^nil</body></methods><methods><class-id>Swazoo.SwazooResource class</class-id> <category>instance creation</category><body package="Swazoo-Core">new	^super new initialize</body><body package="Swazoo-Core">uriPattern: aString 	^self new uriPattern: aString</body></methods><methods><class-id>Swazoo.FileMappingResource</class-id> <category>serving</category><body package="Swazoo-Fileserver">answerTo: aRequest 	(self checkExistence: aRequest) ifFalse: [^nil].	(self checkURI: aRequest) 		ifFalse: 			[| response |			response := HTTPResponse movedPermanently.			response headers 				addField: (HTTPLocationField new uriString: aRequest uri identifier , '/').			^response].	^self file: (self fileFor: aRequest) answerTo: aRequest</body></methods><methods><class-id>Swazoo.FileMappingResource</class-id> <category>private</category><body package="Swazoo-Fileserver">checkExistence: aRequest 	(self rootFileFor: aRequest) exists ifFalse: [^false].	^(self fileFor: aRequest) exists</body><body package="Swazoo-Fileserver">checkURI: aRequest 	| needsFinalSlash |	needsFinalSlash := (self rootFileFor: aRequest) isDirectory 				and: [aRequest uri isDirectory not].	^needsFinalSlash not</body><body package="Swazoo-Fileserver">file: aFilename answerTo: aRequest 	^self subclassResponsibility</body><body package="Swazoo-Fileserver">fileDirectory	^SpFilename named: self filePath</body><body package="Swazoo-Fileserver">fileFor: aRequest 	| fn |	fn := self rootFileFor: aRequest.	fn isDirectory ifTrue: [fn := fn construct: self directoryIndex].	^fn</body><body package="Swazoo-Fileserver">rootFileFor: aRequest 	^aRequest tailPath inject: self fileDirectory		into: 			[:subPath :each | 			(#('.' '..') includes: (HTTPString trimBlanksFrom: each)) 				ifTrue: [subPath]				ifFalse: [subPath construct: each]]</body></methods><methods><class-id>Swazoo.FileMappingResource</class-id> <category>accessing</category><body package="Swazoo-Fileserver">directoryIndex	^directoryIndex</body><body package="Swazoo-Fileserver">directoryIndex: aString 	directoryIndex := aString</body><body package="Swazoo-Fileserver">filePath	^filePath</body><body package="Swazoo-Fileserver">filePath: aString 	filePath := aString</body></methods><methods><class-id>Swazoo.FileMappingResource</class-id> <category>private-initialize</category><body package="Swazoo-Fileserver">initialize	super initialize.	self directoryIndex: 'index.html'</body></methods><methods><class-id>Swazoo.FileMappingResource class</class-id> <category>instance creation</category><body package="Swazoo-Fileserver">uriPattern: aString filePath: aFilePath 	^(self uriPattern: aString) filePath: aFilePath</body><body package="Swazoo-Fileserver">uriPattern: aString filePath: aFilePath directoryIndex: anotherString 	^(self uriPattern: aString)		filePath: aFilePath;		directoryIndex: anotherString</body></methods><methods><class-id>Swazoo.FileResource</class-id> <category>private</category><body package="Swazoo-Fileserver">contentTypeFor: aString 	^ContentTypes 		at: aString asLowercase 		ifAbsent: ['application/octet-stream']</body><body package="Swazoo-Fileserver">file: aFilename answerTo: aRequest 	| cacheControl response |	cacheControl := SwazooCacheControl new request: aRequest				cacheTarget: aFilename.	response := cacheControl isNotModified 				ifTrue: [HTTPResponse notModified]				ifFalse: 					[FileResponse ok entity: ((MimeObject new)								value: aFilename;								contentType: (self contentTypeFor: aFilename extension))].	cacheControl addResponseHeaders: response.	^response</body></methods><methods><class-id>Swazoo.FileResource class</class-id> <category>class initialization</category><body package="Swazoo-Fileserver">initialize	"self initialize"	ContentTypes := (Dictionary new)				add: '.txt' -&gt; 'text/plain';				add: '.html' -&gt; 'text/html';				add: '.htm' -&gt; 'text/html';				add: '.css' -&gt; 'text/css';				add: '.xml' -&gt; 'text/xml';				add: '.js' -&gt; 'text/javascript';				add: '.png' -&gt; 'image/png';				add: '.gif' -&gt; 'image/gif';				add: '.jpg' -&gt; 'image/jpeg';				add: '.m3u' -&gt; 'audio/mpegurl';				add: '.ico' -&gt; 'image/x-icon';				add: '.pdf' -&gt; 'application/pdf';				yourself</body></methods><methods><class-id>Swazoo.HomeResource</class-id> <category>accessing</category><body package="Swazoo-Fileserver">answerTo: aRequest 	aRequest tailPath isEmpty ifTrue: [^nil].	(self validateHomePath: aRequest tailPath first) ifFalse: [^nil].	^super answerTo: aRequest</body></methods><methods><class-id>Swazoo.HomeResource</class-id> <category>private</category><body package="Swazoo-Fileserver">rootFileFor: aRequest 	| homeKey file |	homeKey := aRequest tailPath first copyFrom: 2				to: aRequest tailPath first size.	file := (self fileDirectory construct: homeKey) construct: 'html'.	(aRequest tailPath copyFrom: 2 to: aRequest tailPath size) 		do: [:each | each = '..' ifFalse: [file := file construct: each]].	^file</body><body package="Swazoo-Fileserver">validateHomePath: aString 	^aString first = $~</body></methods><methods><class-id>Swazoo.FileResourceTest</class-id> <category>testing</category><body package="Swazoo-Tests">testContentType	self assert: (resource contentTypeFor: '.txt') = 'text/plain'.	self assert: (resource contentTypeFor: '.html') = 'text/html'</body><body package="Swazoo-Tests">testDirectoryIndex	| request response |	request := HTTPGet request: 'foo/'.	resource directoryIndex: 'abc.html'.	response := URIResolution resolveRequest: request startingAt: resource.	self assert: response statusCode = 200.	self assert: request resourcePath size = 1.	self assert: request resourcePath first = 'foo'</body><body package="Swazoo-Tests">testETag	"Filename etags do not have the leading and trailing double quotes.  Header fields add the quotes as necessary"	| request response etag |	request := HTTPGet request: 'foo/abc.html'.	response := URIResolution resolveRequest: request startingAt: resource.	self assert: response statusCode = 200.	self 		assert: (etag := (response headers fieldOfClass: HTTPETagField) entityTag) 				notNil.	request := HTTPGet request: 'foo/abc.html'.	request headers addField: (HTTPIfNoneMatchField new addEntityTag: etag).	response := URIResolution resolveRequest: request startingAt: resource.	self assert: response statusCode = 304.	self assert: (response headers fieldOfClass: HTTPETagField) entityTag = etag.	request := HTTPGet request: 'foo/abc.html'.	request headers addField: (HTTPIfNoneMatchField new valueFrom: '"wrong"').	response := URIResolution resolveRequest: request startingAt: resource.	self assert: response statusCode = 200.	self assert: (response headers fieldOfClass: HTTPETagField) entityTag = etag</body><body package="Swazoo-Tests">testExistantFile	| request response |	request := HTTPGet request: 'foo/abc.html'.	response := URIResolution resolveRequest: request startingAt: resource.	self assert: response statusCode = 200.	self assert: request resourcePath size = 1.	self assert: request resourcePath first = 'foo'</body><body package="Swazoo-Tests">testNonexistantFile	| request response |	request := HTTPGet request: 'foo/notThere.html'.	response := URIResolution resolveRequest: request startingAt: resource.	self assert: response isNil</body><body package="Swazoo-Tests">testRedirection	| request response |	request := HTTPGet request: 'foo'.	resource directoryIndex: 'abc.html'.	response := URIResolution resolveRequest: request startingAt: resource.	self assert: response statusCode = 301.	self assert: (response headers fieldNamed: 'Location') uri asString 				= 'http://foo/'.	self assert: (response headers fieldNamed: 'Location') uri host = 'foo'</body><body package="Swazoo-Tests">testRelativeFile	| request response |	request := HTTPGet request: 'foo/../', resource fileDirectory tail, '/abc.html'.	response := URIResolution resolveRequest: request startingAt: resource.	self assert: response isNil</body><body package="Swazoo-Tests">testSafeConstruct	| request response |	request := HTTPGet request: 'foo/../abc.html'.	response := URIResolution resolveRequest: request startingAt: resource.	self assert: response statusCode = 200.	request := HTTPGet request: 'foo/.. /./abc.html'.	response := URIResolution resolveRequest: request startingAt: resource.	self assert: response statusCode = 200</body></methods><methods><class-id>Swazoo.FileResourceTest</class-id> <category>running</category><body package="Swazoo-Tests">setUp	| directory firstFile ws |	directory := SpFilename named: 'fResTest'.	directory exists ifFalse: [directory makeDirectory].	firstFile :=  (SpFilename named: 'fResTest') construct: 'abc.html'.	ws := firstFile writeStream.	[ws nextPutAll: 'hello'] ensure: [ws close].	resource := FileResource uriPattern: 'foo' filePath: 'fResTest'</body><body package="Swazoo-Tests">tearDown	((SpFilename named: 'fResTest') construct: 'abc.html') delete.	(SpFilename named: 'fResTest') delete</body></methods><methods><class-id>Swazoo.SwazooCompilerTest</class-id> <category>running</category><body package="Swazoo-Tests">testEvaluate	self assert: (SwazooCompiler evaluate: '1 + 2 * 3') = 9</body><body package="Swazoo-Tests">testEvaluateReceiver	self assert: (SwazooCompiler evaluate: 'self + 2 * 3' receiver: 1) = 9</body></methods><methods><class-id>Swazoo.ContentTypeField</class-id> <category>accessing</category><body package="Swazoo-Headers">charset: aString	"add a specified character set to the content type field"	self transferCodings		at: 'charset' 		put: aString</body><body package="Swazoo-Headers">defaultMediaType	"^a StringSee RFC 2616 '7.2.1 Type'.  If no media type is specified, application/octet-stream is the default."	^'application/octet-stream'</body><body package="Swazoo-Headers">mediaType	^mediaType isNil ifTrue: [self defaultMediaType] ifFalse: [mediaType]</body><body package="Swazoo-Headers">mediaType: aString 	mediaType := aString.	^self</body><body package="Swazoo-Headers">transferCodings	transferCodings isNil ifTrue: [transferCodings := Dictionary new].	^transferCodings</body></methods><methods><class-id>Swazoo.ContentTypeField</class-id> <category>private</category><body package="Swazoo-Headers">parseValueFrom: aString 	| sourceStream |	sourceStream := aString readStream.	mediaType := (HTTPString trimBlanksFrom: (sourceStream upTo: $;)).	transferCodings := self readParametersFrom: sourceStream.	^self</body></methods><methods><class-id>Swazoo.ContentTypeField</class-id> <category>testing</category><body package="Swazoo-Headers">isContentType	^true</body></methods><methods><class-id>Swazoo.ContentTypeField</class-id> <category>printing</category><body package="Swazoo-Headers">valuesAsStringOn: aStream 	aStream nextPutAll: self mediaType.	self transferCodings isEmpty ifFalse: 		[self transferCodings keysAndValuesDo: 			[:name :value | 			aStream				nextPutAll: '; ';				nextPutAll: name;				nextPut: $=;				nextPutAll: value]].	^self</body></methods><methods><class-id>Swazoo.ContentTypeField class</class-id> <category>accessing</category><body package="Swazoo-Headers">fieldName	^'Content-Type'</body></methods><methods><class-id>Swazoo.SwazooCompiler class</class-id> <category>evaluation</category><body package="Swazoo-Resources">evaluate: aString         ^SpEnvironment            evaluate: aString            receiver: SwazooCompiler            in: self class environment</body><body package="Swazoo-Resources">evaluate: aString receiver: anObject 	^SpEnvironment 		evaluate: aString		receiver: anObject		in: self class environment</body></methods><methods><class-id>Swazoo.HTTPDateField</class-id> <category>accessing</category><body package="Swazoo-Headers">date	^date</body><body package="Swazoo-Headers">date: aDate 	"^selfNote that this is an HTTP Date, and so is really a timestamp :-/ "	date := aDate.	^self</body></methods><methods><class-id>Swazoo.HTTPDateField</class-id> <category>printing</category><body package="Swazoo-Headers">valuesAsStringOn: aStream 	self date asRFC1123StringOn: aStream.	^self</body></methods><methods><class-id>Swazoo.HTTPDateField class</class-id> <category>accessing</category><body package="Swazoo-Headers">fieldName	^'Date'</body></methods><methods><class-id>Swazoo.HTTPWWWAuthenticateField</class-id> <category>testing</category><body package="Swazoo-Headers">isBasic	"^a BooleanI return true if I represent a header for basic authentication. c.f. RFC 2617 sec 2."	^false</body><body package="Swazoo-Headers">isDigest	"^a BooleanI return true if I represent a header for digest authentication. c.f. RFC 2617 sec 3."	^false</body></methods><methods><class-id>Swazoo.HTTPWWWAuthenticateField class</class-id> <category>accessing</category><body package="Swazoo-Headers">fieldName	^'WWW-Authenticate'</body></methods><methods><class-id>Swazoo.HTTPWWWAuthenticateBasicField</class-id> <category>testing</category><body package="Swazoo-Headers">isBasic	"^a BooleanI return true if I represent a header for basic authentication. c.f. RFC 2617 sec 2."	^true</body></methods><methods><class-id>Swazoo.HTTPWWWAuthenticateBasicField</class-id> <category>printing</category><body package="Swazoo-Headers">valuesAsStringOn: aStream 	aStream		nextPutAll: 'Basic realm="';		nextPutAll: self realm;		nextPut: $".	^self</body></methods><methods><class-id>Swazoo.HTTPWWWAuthenticateBasicField</class-id> <category>accessing</category><body package="Swazoo-Headers">realm	"^a StringI return the realm for which I represent an autentication challenge.  This string will be presented to the browser user in the login dialog."	^realm</body><body package="Swazoo-Headers">realm: anObject	realm := anObject</body></methods><methods><class-id>Swazoo.HTTPMatchField</class-id> <category>testing</category><body package="Swazoo-Headers">isConditional	^true</body><body package="Swazoo-Headers">matchesAnyCurrentEntity	^entityTags = '*'</body></methods><methods><class-id>Swazoo.HTTPMatchField</class-id> <category>services</category><body package="Swazoo-Headers">addEntityTag: aString 	self entityTags add: aString.	^self</body><body package="Swazoo-Headers">combineWith: aHeaderField 	"^selfI add the entity tags of aHeaderField to my own collection of entity tags."	self entityTags addAll: aHeaderField entityTags.	^self</body></methods><methods><class-id>Swazoo.HTTPMatchField</class-id> <category>accessing</category><body package="Swazoo-Headers">entityTags	^self matchesAnyCurrentEntity 		ifTrue: [nil]		ifFalse: 			[entityTags isNil ifTrue: [entityTags := OrderedCollection new].			entityTags]</body></methods><methods><class-id>Swazoo.HTTPMatchField</class-id> <category>printing</category><body package="Swazoo-Headers">valuesAsStringOn: targetStream 	self write: self entityTags first asQuotedStringTo: targetStream.	2 to: self entityTags size		do: 			[:tagIndex | 			targetStream nextPut: $,.			self write: (self entityTags at: tagIndex) asQuotedStringTo: targetStream].	^self</body><body package="Swazoo-Headers">write: aString asQuotedStringTo: targetStream 	"^selfSee RFC 2616 2.2"	targetStream nextPut: $".	aString do: 			[:character | 			character == $" 				ifTrue: [targetStream nextPutAll: '\"']				ifFalse: [targetStream nextPut: character]].	targetStream nextPut: $".	^self</body></methods><methods><class-id>Swazoo.HTTPMatchField</class-id> <category>private</category><body package="Swazoo-Headers">parseValueFrom: aString 	aString = '*' 		ifTrue: [entityTags := aString]		ifFalse: 			[| sourceStream |			entityTags := OrderedCollection new.			sourceStream := ReadStream on: aString.			[sourceStream atEnd] whileFalse: 					[| entityTag |					sourceStream upTo: $".					entityTag := sourceStream upTo: $".					entityTags add: entityTag.					sourceStream upTo: $,]].	^self</body></methods><methods><class-id>Swazoo.HTTPIfNoneMatchField</class-id> <category>testing</category><body package="Swazoo-Headers">isCacheHitFor: anEntity 	"^a BooleanI return true if an anEntity is a cache hit given the conditional I represent.  So in my case, I'm looking to see that the entity has a tag which is in my collection of entityTags.anEntity *must* respond to &gt;&gt;entityTag"	^self entityTags includes: anEntity entityTag</body></methods><methods><class-id>Swazoo.HTTPIfNoneMatchField class</class-id> <category>accessing</category><body package="Swazoo-Headers">fieldName	^'If-None-Match'</body></methods><methods><class-id>Swazoo.HTTPMessage</class-id> <category>initialize-release</category><body package="Swazoo-Messages">addInitialHeaders	"^self This is a no-op.  My subclasses may wish to add some initial headers."	^self</body><body package="Swazoo-Messages">initHeaders	headers := HTTPHeaders new.	self addInitialHeaders.</body></methods><methods><class-id>Swazoo.HTTPMessage</class-id> <category>accessing</category><body package="Swazoo-Messages">body	^body</body><body package="Swazoo-Messages">body: aByteArray	body := aByteArray</body><body package="Swazoo-Messages">headers	headers isNil ifTrue: [self initHeaders].	^headers</body><body package="Swazoo-Messages">task	"on which task (request/response pair) this message belongs"	"to get a connection on which this task belongs, use task connection"	^task</body><body package="Swazoo-Messages">task: aSwazooTask	task := aSwazooTask</body></methods><methods><class-id>Swazoo.HTTPMessage</class-id> <category>accessing-headers</category><body package="Swazoo-Messages">headerAt: aKey ifAbsent: aBlock	^self headers fieldNamed: aKey  ifNone: aBlock</body><body package="Swazoo-Messages">headerValueAt: aKey	^(self headerAt: aKey ifAbsent: [^nil]) value</body></methods><methods><class-id>Swazoo.HTTPRequest</class-id> <category>accessing-queries</category><body package="Swazoo-Messages">includesQuery: aString 	^self uri includesQuery: aString</body><body package="Swazoo-Messages">queryAt: aKey 	^self uri queryAt: aKey</body><body package="Swazoo-Messages">queryAt: aKey ifAbsent: aBlock 	^self uri queryAt: aKey ifAbsent: aBlock</body><body package="Swazoo-Messages">queryData	^self uri queryData</body></methods><methods><class-id>Swazoo.HTTPRequest</class-id> <category>accessing</category><body package="Swazoo-Messages">environmentAt: aKey 	^self environmentAt: aKey ifAbsent: [nil]</body><body package="Swazoo-Messages">environmentAt: aKey ifAbsent: aBlock 	^self environmentData at: aKey ifAbsent: aBlock</body><body package="Swazoo-Messages">environmentAt: aKey put: aValue 	self environmentData at: aKey put: aValue</body><body package="Swazoo-Messages">httpVersion	^self requestLine httpVersion</body><body package="Swazoo-Messages">ip	^ip</body><body package="Swazoo-Messages">methodName	"HTTP method used for a request"	^self class methodName</body><body package="Swazoo-Messages">peer	^peer</body><body package="Swazoo-Messages">requestLine	"^an HTTPRequestLine"	requestLine isNil ifTrue: [self initRequestLine].	^requestLine</body><body package="Swazoo-Messages">resolution	^resolution</body><body package="Swazoo-Messages">resolution: anObject	resolution := anObject</body><body package="Swazoo-Messages">resourcePath	^self resolution resourcePath</body><body package="Swazoo-Messages">session	^self environmentAt: #session</body><body package="Swazoo-Messages">session: aSession 	self environmentAt: #session put: aSession</body><body package="Swazoo-Messages">tailPath	^self resolution tailPath</body><body package="Swazoo-Messages">timestamp	^timestamp</body><body package="Swazoo-Messages">uri	^self requestLine requestURI</body><body package="Swazoo-Messages">uriString	^self uri identifier</body><body package="Swazoo-Messages">urlString	^self uri value</body></methods><methods><class-id>Swazoo.HTTPRequest</class-id> <category>services</category><body package="Swazoo-Messages">conditionalHeaderFields	"^an OrderedCollectionI return my collection of conditional header fields.  A conditional GET requires that each of these is checked against the current state of the target resource."	^self headers fields select: [:aField | aField isConditional]</body><body package="Swazoo-Messages">respondUsing: responseBlock 	"^an HTTPResponseBy default, I let aBlock handle creating the response by passing myself as the agrument to the block.  My subclasses may override this method and directly respond.  This is most likely for Unsupported requests and for things like OPTIONS requsts.  c.f. HTTPServer&gt;&gt;answerTo: "	^responseBlock value: self</body></methods><methods><class-id>Swazoo.HTTPRequest</class-id> <category>private</category><body package="Swazoo-Messages">authenticated	^authenticated</body><body package="Swazoo-Messages">encrypted	^encrypted</body><body package="Swazoo-Messages">ensureFullRead	"that is, that everything is read from a socket stream. Importanf for HTTPost and defered parsing	of postData"</body><body package="Swazoo-Messages">environmentData	environmentData isNil ifTrue: [self initEnvironmentData].	^environmentData</body><body package="Swazoo-Messages">ip: anObject	ip := anObject</body><body package="Swazoo-Messages">peer: anObject	peer := anObject</body><body package="Swazoo-Messages">printOn: aStream 	| isAjax |	isAjax := (self headerAt: 'X-Requested-With' ifAbsent: [nil-&gt;nil]) value = 'XMLHttpRequest'.	aStream nextPutAll: 'a HTTPRequest ', (isAjax ifTrue: ['AJAX '] ifFalse: ['']), self methodName.	self isHttp10 ifTrue: [aStream nextPutAll: ' HTTP/1.0'].	self peer notNil ifTrue: [aStream cr; tab; nextPutAll: ' from: '; nextPutAll: self peer].	aStream cr; tab; nextPutAll: ' at: '. aStream nextPutAll: 		self timestamp printString, '.', self timestamp milliseconds printString.	aStream cr; tab; nextPutAll: ' host: '; nextPutAll: (self headerAt: 'Host' ifAbsent: ['']) hostName.	aStream cr; tab; nextPutAll: ' url: '. self uri printOn: aStream.	self referer notNil ifTrue:		[aStream cr; tab; nextPutAll: ' referer: '. self referer printOn: aStream].	self userAgent notNil ifTrue: [aStream cr; tab; nextPutAll: ' browser: '; nextPutAll: self userAgent].	self connection notNil ifTrue: [aStream cr; tab; nextPutAll: ' connection: '; nextPutAll: self connection].	self keepAlive notNil ifTrue: [aStream cr; tab; nextPutAll: ' keep-alive: '; nextPutAll: self keepAlive].	self isPost ifTrue:		[self postData notEmpty ifTrue:			[aStream cr; tab; nextPutAll: 'postData: '.			self postData keysAndValuesDo: [:key :value | 				aStream cr; tab; tab; nextPutAll: key, '='; nextPutAll: value value.] ].		self entityBody notNil ifTrue:			[aStream cr; tab; nextPutAll: 'entityBody: '.			aStream nextPutAll: self entityBody ] ].	^self</body><body package="Swazoo-Messages">queries	^self uri queries</body><body package="Swazoo-Messages">readBodyFrom: aStream 	(self headers includesFieldOfClass: HTTPContentLengthField) ifFalse: 		[(self upgrade notNil and: [self upgrade = 'WebSocket'])  "WebSocket request has no contentLength???"			ifTrue: [^self body: (aStream nextBytes: 8)]			ifFalse: [^nil] ].	self body: (aStream nextBytes: self contentLength)</body><body package="Swazoo-Messages">request: aUriString from: aHostString at: anIPString 	"For testing only (I'm guessing / hoping!).A request is manufactured that has a request line method of &gt;&gt;methodName and a request line URI with an identifier of aUriString.  A Host header is added to the headers and the ip address is set to anIP string.  I also set the HTTP version to #(1 1).This may result in a corrupt or invalid request, but that's the natutre of testing, I guess."	requestLine := (HTTPRequestLine new)				method: self class methodName;				requestURI: ((SwazooURI new)							identifier: aUriString;							yourself);				httpVersion: #(1 1);				yourself.	self headers addField: (HTTPHostField newWithValueFrom: aHostString).	self ip: anIPString.	^self</body><body package="Swazoo-Messages">setAuthenticated 		authenticated := true</body><body package="Swazoo-Messages">setEncrypted	encrypted := true</body></methods><methods><class-id>Swazoo.HTTPRequest</class-id> <category>accessing-headers</category><body package="Swazoo-Messages">connection	^(self headers fieldOfClass: HTTPConnectionField ifNone: [^nil]) 		connectionToken</body><body package="Swazoo-Messages">contentLength	^(self headers fieldOfClass: HTTPContentLengthField) contentLength</body><body package="Swazoo-Messages">cookie	| field |	field := self headers fields at: 'COOKIE' ifAbsent: [^nil].	^field value"	field := self headers fieldOfClass: HTTPCookieField ifNone: [nil].	^field isNil ifTrue: [nil] ifFalse: [field valuesAsString]"</body><body package="Swazoo-Messages">host	^(self headers fieldOfClass: HTTPHostField ifNone: [^String new]) 		hostName</body><body package="Swazoo-Messages">keepAlive	"how many seconds a connection must be kept alive"	^(self headers fieldNamed: 'KeepAlive' ifNone: [^nil]) value</body><body package="Swazoo-Messages">port	"^an IntegerI return the port number to which the request was directed."	| host |	host := self headers fieldOfClass: HTTPHostField.	^(host notNil and: [(self httpVersion at: 2) = 1])		ifTrue: [host portNumber]		ifFalse: [self requestLine requestURI port]</body><body package="Swazoo-Messages">referer	| field |	field := self headers fieldOfClass: HTTPRefererField ifNone: [nil].	^field isNil ifTrue: [nil] ifFalse: [field uri asString]</body><body package="Swazoo-Messages">upgrade	"protocol to upgrade to"	^(self headerAt: 'Upgrade' ifAbsent: [^nil]) value</body><body package="Swazoo-Messages">userAgent	| userAgentField |	userAgentField := self headers fieldOfClass: HTTPUserAgentField				ifNone: [nil].	^userAgentField isNil ifTrue: [nil] ifFalse: [userAgentField productTokens]</body></methods><methods><class-id>Swazoo.HTTPRequest</class-id> <category>testing</category><body package="Swazoo-Messages">hasCookie	"check if  Cookie:  was in request header"	"it is GenericHeaderField!"	^self headers fields includesKey: 'COOKIE'"	^self headers includesFieldOfClass: HTTPCookieField"</body><body package="Swazoo-Messages">isAuthenticated	^self authenticated isNil not</body><body package="Swazoo-Messages">isClose	| connectionField |	connectionField := self headers fieldOfClass: HTTPConnectionField				ifNone: [nil].	^connectionField notNil and: [connectionField connectionTokenIsClose]</body><body package="Swazoo-Messages">isConnectionUpgrade	((self headerAt: 'Connection' ifAbsent: [^false]) 		connectionToken tokensBasedOn: $,) do: [:each |			each trimBlanks = 'Upgrade' ifTrue: [^true]].	^ false</body><body package="Swazoo-Messages">isDelete	^false</body><body package="Swazoo-Messages">isEncrypted	^self encrypted isNil not</body><body package="Swazoo-Messages">isFromLinux	^self userAgent notNil and: ['*Linux*' match: self userAgent]</body><body package="Swazoo-Messages">isFromMSIE	^self userAgent notNil and: ['*MSIE*' match: self userAgent]</body><body package="Swazoo-Messages">isFromNetscape	"NS&gt;7.0 or Mozilla or Firefox"	^self userAgent notNil and: ['*Gecko*' match: self userAgent]</body><body package="Swazoo-Messages">isFromWindows	^self userAgent notNil and: ['*Windows*' match: self userAgent]</body><body package="Swazoo-Messages">isGet	^false</body><body package="Swazoo-Messages">isHead	^false</body><body package="Swazoo-Messages">isHttp10	"Version of requests's HTTP protocol is 1.0"	^self requestLine isHttp10</body><body package="Swazoo-Messages">isHttp11	"Version of requests's HTTP protocol is 1.0"	^self requestLine isHttp11</body><body package="Swazoo-Messages">isKeepAlive	| header |	header := self connection.	header isNil ifTrue: [^false].	^'*Keep-Alive*' match: header</body><body package="Swazoo-Messages">isOptions	^false</body><body package="Swazoo-Messages">isPost	^false</body><body package="Swazoo-Messages">isPut	^false</body><body package="Swazoo-Messages">isTrace	^false</body><body package="Swazoo-Messages">isWebSocketRequest	"upgrade connection to WebSocket request. See http://www.swazoo.org/websocket for more"	^self isConnectionUpgrade 		and: [self upgrade asLowercase =  'websocket']</body><body package="Swazoo-Messages">wantsConnectionClose	self isClose ifTrue: [^true].	^self isHttp10 and: [self isKeepAlive not]</body></methods><methods><class-id>Swazoo.HTTPRequest</class-id> <category>initialize-release</category><body package="Swazoo-Messages">for: aRequestLine readFrom: aSwazooStream 	"^selfI parse my headers from aStream and update my URI and HTTP version information from aRequest line.  I need to parse the headers first because, for some reason, the URI insists on knowing the host, and this is taken from the Host: header field."	requestLine := aRequestLine.	headers := HTTPHeaders readFrom: aSwazooStream.	self isGet ifTrue: [self readBodyFrom: aSwazooStream]. "if any"	self setTimestamp.	^self</body><body package="Swazoo-Messages">initEnvironmentData	environmentData := Dictionary new</body><body package="Swazoo-Messages">initRequestLine	requestLine := HTTPRequestLine new</body><body package="Swazoo-Messages">setTimestamp	timestamp := SpTimestamp now</body></methods><methods><class-id>Swazoo.HTTPRequest</class-id> <category>accessing-response</category><body package="Swazoo-Messages">streamedResponse	"prepares (if not already) and return a streamed response"	"necessary because we need an output stream to stream into"	self task response isNil ifTrue: 		[self task response: 			(HTTPStreamedResponse on: self task stream: self task connection stream)].	self task response class == Swazoo.HTTPStreamedResponse 		ifFalse: [self error: 'not streamed response?'].  "this can happen if response is from before"	^self task response</body><body package="Swazoo-Messages">webSocket	"creates and returns a WebSocket instance to send/receive messages bidirectionally to/from browser"	" 'all webSocket answerToUpgradeRequest: aRequest ' immediatelly after this call"	"More on http://www.swazoo.org/websocket"	self isWebSocketRequest ifFalse: [^self error: 'This must be an upgrade to WebSocket request'].	^SwazooWebSocket new.</body></methods><methods><class-id>Swazoo.HTTPRequest class</class-id> <category>tests support</category><body package="Swazoo-Messages">request: aUriString 	"For testing only (I'm guessing / hoping!).  The idea to to create a request for a resource with the URI 'someHost/aUriString'."	^self 		request: aUriString		from: 'someHost'		at: 'someIP'</body><body package="Swazoo-Messages">request: aUriString from: aHostString at: anIPString 	"For testing only (I'm guessing / hoping!).A request is manufactured that has a request line method of &gt;&gt;methodName and a request line URI with an identifier of aUriString.  A Host header is added to the headers and the ip address is set to anIP string.This may result in a corrupt or invalid request, but that's the natutre of testing, I guess."	^self new 		request: aUriString		from: aHostString		at: anIPString</body></methods><methods><class-id>Swazoo.HTTPRequest class</class-id> <category>accessing</category><body package="Swazoo-Messages">allMethodNames	"...of all request methods we support there"	self subclasses collect: [:each | each methodName].</body><body package="Swazoo-Messages">methodName	"HTTP method used for a request"	^self subclassResponsibility</body></methods><methods><class-id>Swazoo.HTTPRequest class</class-id> <category>instance creation</category><body package="Swazoo-Messages">newFor: aRequestLine readFrom: aSwazooStream 	"to support an additional http method, simply subclass a HTTPRequest!"	| targetClass |	targetClass := aRequestLine method = 'GET' 		ifTrue: [HTTPGet] "most used anyway"		ifFalse: [aRequestLine method = 'POST'  			ifTrue: [HTTPPost]  "second most used"			ifFalse: [self subclasses detect: [:each | 				each methodName = aRequestLine method] ifNone: [nil] ] ].	targetClass isNil ifTrue: [^HTTPException notImplemented].	^targetClass new for: aRequestLine readFrom: aSwazooStream</body><body package="Swazoo-Messages">readFrom: aSwazooStream 	"^an HTTPRequestI create and return a new instance of one of my subclasses which will represent the HTTP request presumed to be the contents of aStream.The first step is to work out which of my subclasses to create.  I do this by parsing the 'request-line' from the stream.  The request-line contains the 'method', and I look for the subclass that handles this method and delegate the rest of the message parsing to a new instance of that class."	| requestLine |	requestLine := HTTPRequestLine readFrom: aSwazooStream.	^self newFor: requestLine readFrom: aSwazooStream</body></methods><methods><class-id>Swazoo.HTTPTrace</class-id> <category>testing</category><body package="Swazoo-Messages">isTrace	^true</body></methods><methods><class-id>Swazoo.HTTPTrace class</class-id> <category>accessing</category><body package="Swazoo-Messages">methodName	^'TRACE'</body></methods><methods><class-id>Swazoo.HTTPAuthorizationBasicField</class-id> <category>private</category><body package="Swazoo-Headers">resolveUserPass	"Get the userid and password from the credentials string."	| userPassString sourceStream |	userPassString := HTTPString stringFromBytes: (FastBase64Encoding decodeBase64Encoded: self credentials).	sourceStream := ReadStream on: userPassString.	userid := sourceStream upTo: $:.	password := sourceStream atEnd	"GemStone crashes if upToEnd is sent when already atEnd"				ifTrue: [String new]				ifFalse: [sourceStream upToEnd]."(FastBase64Encoding decodeBase64Encoded: 'QWxhZGRpbjpvcGVuIHNlc2FtZQ==') asString"</body></methods><methods><class-id>Swazoo.HTTPAuthorizationBasicField</class-id> <category>services</category><body package="Swazoo-Headers">password	"^a StringI return the password string (as defined in RFC 2617 pp.2) part of the user-pass value in my credentials."	password isNil ifTrue: [self resolveUserPass].	^password</body><body package="Swazoo-Headers">userid	"^a StringI return the userid string (as defined in RFC 2617 pp.2) part of the user-pass value in my credentials."	userid isNil ifTrue: [self resolveUserPass].	^userid</body></methods><methods><class-id>Swazoo.HTTPAuthorizationBasicField</class-id> <category>printing</category><body package="Swazoo-Headers">valuesAsStringOn: aStream 	aStream nextPutAll: 'Basic '.	super valuesAsStringOn: aStream.	^self</body></methods><methods><class-id>Swazoo.HTTPOptions</class-id> <category>testing</category><body package="Swazoo-Messages">isOptions	^true</body></methods><methods><class-id>Swazoo.HTTPOptions</class-id> <category>services</category><body package="Swazoo-Messages">respondUsing: responseBlock 	"^an HTTPResponseI represent a request for the options supported by this server.  I respond with a 200 (OK) and a list of my supported methods in an Allow: header.  I ignore the responseBlock."	| response allowField |	response := HTTPResponse ok.	allowField := HTTPAllowField new.	allowField methods addAll: self class allMethodNames.	response headers addField: allowField.	^response</body></methods><methods><class-id>Swazoo.HTTPOptions class</class-id> <category>accessing</category><body package="Swazoo-Messages">methodName	^'OPTIONS'</body></methods><methods><class-id>Swazoo.SwazooStream</class-id> <category>chunking</category><body package="Swazoo-HTTP">isChunked	"sending in chunks (transfer encoding: chunked)"	^chunked notNil and: [chunked]</body><body package="Swazoo-HTTP">resetChunked	"sending in chunks (transfer encoding: chunked)"	chunked := false</body><body package="Swazoo-HTTP">setChunked	"sending in chunks (transfer encoding: chunked)"	chunked := true</body></methods><methods><class-id>Swazoo.SwazooStream</class-id> <category>private</category><body package="Swazoo-HTTP">fillBuffer	self socket isNil ifTrue: [^self]. "if SwazooStream is used for tests only"	self readBuffer refillFrom: self socket.</body><body package="Swazoo-HTTP">print: anObject 	anObject printOn: self</body><body package="Swazoo-HTTP">readBuffer	readBuffer isNil ifTrue: [self initReadBuffer].	^readBuffer</body><body package="Swazoo-HTTP">readBuffer: aSwazooBuffer	readBuffer := aSwazooBuffer</body><body package="Swazoo-HTTP">setSocket: aSwazooSocket 	self socket: aSwazooSocket.</body><body package="Swazoo-HTTP">socket	^socket</body><body package="Swazoo-HTTP">socket: aSocket	socket := aSocket</body><body package="Swazoo-HTTP">syncBuffer	self readBuffer atEnd ifTrue: [self fillBuffer]</body><body package="Swazoo-HTTP">writeBuffer	writeBuffer isNil ifTrue: [self initWriteBuffer].	^writeBuffer</body></methods><methods><class-id>Swazoo.SwazooStream</class-id> <category>initialize-release</category><body package="Swazoo-HTTP">close	"close TCP socket and relase buffers"	self socket close.	self nilWriteBuffer.	self nilReadBuffer.  "to GC buffers"</body><body package="Swazoo-HTTP">closeResponse	"for chunked response: close it by sending null chunk"	"do a bit cleanup after response is sent"	self flush.	self isChunked ifTrue: 		[self writeBuffer closeChunkTo: self socket.		self resetChunked].	self socket notNil "not simulation" ifTrue: [self nilWriteBuffer]. "to release memory"</body><body package="Swazoo-HTTP">flush	"actually write to the tcp socket and clear write buffer"	self socket isNil ifTrue: [^nil]. "for simulations and tests"	self isChunked		ifTrue: [self writeBuffer flushChunkTo: self socket]		ifFalse: [	self writeBuffer flushTo: self socket].</body><body package="Swazoo-HTTP">initReadBuffer	"temporary read buffer"	readBuffer := SwazooBuffer newRead</body><body package="Swazoo-HTTP">initWriteBuffer	"temporary write buffer. flush it to socket ocassionaly!"	writeBuffer := SwazooBuffer newWrite</body><body package="Swazoo-HTTP">nilReadBuffer	"to release memory"	readBuffer := nil</body><body package="Swazoo-HTTP">nilWriteBuffer	"to release memory"	writeBuffer := nil</body></methods><methods><class-id>Swazoo.SwazooStream</class-id> <category>accessing-writing</category><body package="Swazoo-HTTP">cr	self nextPut: Character cr asInteger</body><body package="Swazoo-HTTP">crlf	self cr; lf.</body><body package="Swazoo-HTTP">lf	self nextPut: Character lf asInteger</body><body package="Swazoo-HTTP">next: anInteger put: aCharacterOrInteger 	"Make aCharacterOrInteger be the next anInteger number of objects accessible by the 	receiver. Answer anObject."	anInteger timesRepeat: [self nextPut: aCharacterOrInteger].	^aCharacterOrInteger</body><body package="Swazoo-HTTP">next: anInteger putAll: aByteStringOrArray	"Store the next anInteger elements from the given collection."	^self next: anInteger putAll: aByteStringOrArray startingAt: 1</body><body package="Swazoo-HTTP">next: anInteger putAll: aByteStringOrArray startingAt: startIndex	"Store the next anInteger elements from the given collection."	(startIndex = 1 and: [anInteger = aByteStringOrArray size])		ifTrue:[^self nextPutAll: aByteStringOrArray].	^self nextPutAll: (aByteStringOrArray copyFrom: startIndex to: startIndex+anInteger-1)</body><body package="Swazoo-HTTP">nextNumber: n put: v 	"copied from PositionableStream, needed for WebSocket support"	1 to: n do: [:i | self nextPut: (v digitAt: n+1-i)].	^ v</body><body package="Swazoo-HTTP">nextPut: aCharacterOrInteger	self nextPutByte: aCharacterOrInteger asInteger.	^aCharacterOrInteger</body><body package="Swazoo-HTTP">nextPutAll: aByteStringOrArray	self nextPutBytes: aByteStringOrArray asByteArray.	^aByteStringOrArray</body><body package="Swazoo-HTTP">nextPutLine: aByteStringOrArray 	self nextPutAll: aByteStringOrArray.	self crlf.</body><body package="Swazoo-HTTP">space	self nextPut: Character space</body></methods><methods><class-id>Swazoo.SwazooStream</class-id> <category>accessing-reading</category><body package="Swazoo-HTTP">anyDataReady	"wait for data and return true if any data ready. On VW somethimes happen that data       receipt is signaled but no data is actually received"	"VW specific"	self readBuffer atEnd ifFalse: [^true]. "data is there from before"	[self fillBuffer]		on: SwazooStreamNoDataError, SpSocketShutDownByPeer "VW specific?"		do: [:ex | "do nothing"].	^self readBuffer atEnd not</body><body package="Swazoo-HTTP">atEnd	"TCP socket data never ends!"	^false</body><body package="Swazoo-HTTP">next	^self nextByte asCharacter</body><body package="Swazoo-HTTP">next: anInteger 	^(self nextBytes: anInteger) asByteString</body><body package="Swazoo-HTTP">nextLine	| stream |	stream := WriteStream on: (String new: 50).	self writeNextLineTo: stream.	^stream contents</body><body package="Swazoo-HTTP">nextUnfoldedLine	| stream ch |	stream := WriteStream on: (String new: 50).	self writeNextLineTo: stream.	stream contents isEmpty ifFalse: [		[ch := self peek.		ch notNil and: [ch == Character space or: [ch == Character tab]]] 			whileTrue: [self writeNextLineTo: stream]		].	^stream contents</body><body package="Swazoo-HTTP">peek	| byte |	byte := self peekByte.	^byte notNil 		ifTrue: [byte asCharacter] 		ifFalse: [nil]</body><body package="Swazoo-HTTP">skip: anInteger	anInteger timesRepeat: [self nextByte].</body><body package="Swazoo-HTTP">upTo: aCharacterOrByte	| targetByte ws byte |	targetByte := aCharacterOrByte asInteger.	ws := ByteArray new writeStream.	[byte := self nextByte.	byte = targetByte] whileFalse: [ws nextPut: byte].	^ws contents</body><body package="Swazoo-HTTP">writeNextLineTo: aStream 	aStream nextPutAll: (self upTo: Character cr asInteger) asByteString.	^self peekByte = Character lf asInteger 		ifTrue: [self nextByte]  "skip remaining linefeed"		ifFalse: [SwazooHTTPParseError raiseSignal: 'CR without LF']</body></methods><methods><class-id>Swazoo.SwazooStream</class-id> <category>private-bytes</category><body package="Swazoo-HTTP">nextByte	self syncBuffer.	^self readBuffer next.</body><body package="Swazoo-HTTP">nextBytes: aNumber 	| array |	array := ByteArray new: aNumber.	1 to: aNumber do: [:index |  array at: index put: self nextByte].	^array</body><body package="Swazoo-HTTP">nextPutByte: aByte 	self writeBuffer nextPut: aByte.	self writeBuffer isFull ifTrue: [self flush].	^aByte</body><body package="Swazoo-HTTP">nextPutBytes: aByteArray 	self writeBuffer nextPutAll: aByteArray.	self writeBuffer isFull ifTrue: [self flush]. 	^aByteArray</body><body package="Swazoo-HTTP">peekByte	self syncBuffer.	^self readBuffer peek</body></methods><methods><class-id>Swazoo.SwazooStream class</class-id> <category>instance creation</category><body package="Swazoo-HTTP">connectedPair	^SwazooSocket connectedPair collect: [:each | self socket: each]</body><body package="Swazoo-HTTP">on: aString 	"use only for testing!"	^self new readBuffer: (SwazooBuffer on: aString)</body><body package="Swazoo-HTTP">socket: aSwazooSocket 	^self new setSocket: aSwazooSocket</body></methods><methods><class-id>Swazoo.URIResolution</class-id> <category>private</category><body package="Swazoo-HTTP">advance	self position: self position + 1</body><body package="Swazoo-HTTP">currentIdentifier	^self currentPath last</body><body package="Swazoo-HTTP">currentPath	^self request uri identifierPath copyFrom: 1 to: self position</body><body package="Swazoo-HTTP">getAnswerFrom: aResource	^aResource answerTo: self request</body><body package="Swazoo-HTTP">position: anInteger	position := anInteger</body><body package="Swazoo-HTTP">request: aRequest	request := aRequest</body><body package="Swazoo-HTTP">retreat	self position: self position - 1.	^nil</body><body package="Swazoo-HTTP">siteMatch: aSite 	| siteIdentifier hostName |	hostName := self request headers 				fieldOfClass: HTTPHostField				ifPresent: [:field | field hostName]				ifAbsent: [self request requestLine requestURI hostname].	siteIdentifier := SiteIdentifier 				host: (hostName notNil ifTrue: [hostName] ifFalse: [''])				ip: self request ip				port: self request port.	^aSite match: siteIdentifier</body><body package="Swazoo-HTTP">stringMatch: aResource 	^aResource uriPattern = self currentIdentifier</body><body package="Swazoo-HTTP">tailStream	^ReadStream on: self tailPath</body></methods><methods><class-id>Swazoo.URIResolution</class-id> <category>private-initialize</category><body package="Swazoo-HTTP">initializeRequest: aRequest 	self request: aRequest.	self request resolution: self.	self position: 1</body></methods><methods><class-id>Swazoo.URIResolution</class-id> <category>accessing</category><body package="Swazoo-HTTP">atEnd	^self position = self request uri identifierPath size</body><body package="Swazoo-HTTP">fullPath	^self request uri identifierPath</body><body package="Swazoo-HTTP">position	^position</body><body package="Swazoo-HTTP">request	^request</body><body package="Swazoo-HTTP">resourcePath	^self request uri identifierPath copyFrom: 1 to: self position</body><body package="Swazoo-HTTP">tailPath	| fullPath |	fullPath := self fullPath.	^fullPath copyFrom: self position + 1 to: fullPath size</body></methods><methods><class-id>Swazoo.URIResolution</class-id> <category>resolving</category><body package="Swazoo-HTTP">resolveCompositeResource: aResource 	(aResource canAnswer and: [aResource match: self currentIdentifier]) 		ifFalse: [^nil].	^self visitChildrenOf: aResource advancing: true</body><body package="Swazoo-HTTP">resolveLeafResource: aResource 	(aResource canAnswer and: [self stringMatch: aResource]) ifFalse: [^nil].	^self getAnswerFrom: aResource</body><body package="Swazoo-HTTP">resolveServerRoot: aServerRoot 	^self resolveTransparentComposite: aServerRoot</body><body package="Swazoo-HTTP">resolveSite: aSite 	(aSite canAnswer and: [self siteMatch: aSite]) ifFalse: [^nil].	^self visitChildrenOf: aSite advancing: false</body><body package="Swazoo-HTTP">resolveTransparentComposite: aCompositeResource 	^self visitChildrenOf: aCompositeResource advancing: false</body><body package="Swazoo-HTTP">visitChildrenOf: aResource advancing: aBoolean 	| response |	self atEnd &amp; aBoolean ifTrue: [^self getAnswerFrom: aResource].	aBoolean ifTrue: [self advance].	aResource children do: 			[:each | 			response := self visitResource: each.			response isNil ifFalse: [^response]].	^aBoolean ifTrue: [self retreat] ifFalse: [nil]</body><body package="Swazoo-HTTP">visitResource: aResource 	^aResource helpResolve: self</body></methods><methods><class-id>Swazoo.URIResolution class</class-id> <category>instance creation</category><body package="Swazoo-HTTP">resolveRequest: aRequest startingAt: aResource 	^(self new initializeRequest: aRequest) visitResource: aResource</body></methods><methods><class-id>Swazoo.HTTPResponse</class-id> <category>accessing-headers</category><body package="Swazoo-Messages">addHeaderName: aNameString value: aValueString	^self headers 		addField: (GenericHeaderField newForFieldName: aNameString withValueFrom: aValueString)</body><body package="Swazoo-Messages">cacheControl: aString	"example: 'no-store, no-cache, must-revalidate'"	self headers addField: (HTTPCacheControlField new directives: aString).</body><body package="Swazoo-Messages">contentLength: anInteger	self headers addField: (HTTPContentLengthField new contentLength: anInteger).	^self</body><body package="Swazoo-Messages">contentType	"^a StringReturn the media type from my Content-Type header field."	^self headers 		fieldOfClass: ContentTypeField		ifPresent: [:field | field mediaType]		ifAbsent: ['application/octet-stream']</body><body package="Swazoo-Messages">contentType: aString 	self headers addField: (ContentTypeField new mediaType: aString).	^self</body><body package="Swazoo-Messages">cookie: aString 	| newField |	newField := HTTPSetCookieField new.	newField addCookie: aString.	self headers addField: newField.	^self</body><body package="Swazoo-Messages">expires: aSpTimestamp  "from SPort "	self headers addField: (HTTPExpiresField new timestamp: aSpTimestamp ).	^self</body><body package="Swazoo-Messages">gzipEncoded	"Content will be compressed with gzip before sending to the client"	"Currently compression must be done manually before sending to the response. Use class methods for that"	"http://en.wikipedia.org/wiki/HTTP_compression"	self addHeaderName: 'Content-Encoding' value: 'gzip'</body><body package="Swazoo-Messages">lastModified: aSpTimestamp "from SPort "	self headers addField: (HTTPLastModifiedField new timestamp: aSpTimestamp).	^self</body><body package="Swazoo-Messages">location: aString 	self headers addField: (HTTPLocationField new uriString: aString).	^self</body></methods><methods><class-id>Swazoo.HTTPResponse</class-id> <category>initialize-release</category><body package="Swazoo-Messages">addDateHeader	"^selfNote that the server must have it's clock set to GMT"	self headers addField: (HTTPDateField new date: SpTimestamp now).	^self</body><body package="Swazoo-Messages">addDefaultBody	self entity: '&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;', self statusLine, '&lt;/TITLE&gt;&lt;/HEAD&gt;  &lt;BODY&gt;   &lt;H2&gt;', self statusLine, '&lt;/H2&gt;   &lt;P&gt;The server experienced an error while processing this request. &lt;BR&gt;   If this problem persists, please contact the webmaster.&lt;/P&gt;  &lt;P&gt;Swazoo Smalltalk Web Server&lt;/P&gt;  &lt;/BODY&gt;&lt;/HTML&gt;'</body><body package="Swazoo-Messages">addInitialHeaders	self addServerHeader.	self addDateHeader</body><body package="Swazoo-Messages">addServerHeader	^self headers 		addField: (HTTPServerField new productTokens: SwazooServer swazooVersion)</body></methods><methods><class-id>Swazoo.HTTPResponse</class-id> <category>private</category><body package="Swazoo-Messages">informConnectionClose	self headers 		fieldOfClass: HTTPConnectionField		ifPresent: [:field | field setToClose]		ifAbsent: [self headers addField: HTTPConnectionField new setToClose].	^self</body><body package="Swazoo-Messages">informConnectionKeepAlive	self headers addField: HTTPConnectionField new setToKeepAlive.</body><body package="Swazoo-Messages">setStatusText	^self statusText: (self class statusTextForCode: self statusCode)</body><body package="Swazoo-Messages">statusCode: anInteger 	statusCode := anInteger.	(#(200) includes: statusCode) ifFalse: [self addDefaultBody].</body><body package="Swazoo-Messages">statusText: aString	"test in status line of response"	statusText := aString</body></methods><methods><class-id>Swazoo.HTTPResponse</class-id> <category>private-sending</category><body package="Swazoo-Messages">crlfOn: aStream 	aStream		nextPut: Character cr;		nextPut: Character lf</body><body package="Swazoo-Messages">endHeaderOn: aStream 	self crlfOn: aStream</body><body package="Swazoo-Messages">printChunkedTransferEncodingOn: aStream 	aStream nextPutAll: 'Transfer-Encoding: chunked'.	self crlfOn: aStream</body><body package="Swazoo-Messages">printContentLengthOn: aSwazooStream 	"it is also added to headers. It is added so late because to be printed last, just before body starts"	self contentLength: self contentSize.	(self headers fieldNamed: 'Content-length') printOn: aSwazooStream.	self crlfOn: aSwazooStream</body><body package="Swazoo-Messages">printEntityOn: aStream 	self entity isNil ifFalse: [aStream nextPutBytes: self entity]</body><body package="Swazoo-Messages">printHeadersOn: aSwazooStream 	"^selfWrite the headers (key-value pairs) to aStream.  The keymust be a String."	self headers fields do: 			[:aField | 			aField printOn: aSwazooStream.			self crlfOn: aSwazooStream]</body><body package="Swazoo-Messages">printStatusOn: aSwazooStream 	| version |	StatusCodes at: self statusCode ifAbsent: [self class initialize]. "if some new status codes was added           													with #postInitialize method later"	version := (self task isNil or: [self task request isNil or: [self task request isHttp11]]) 		ifTrue: ['HTTP/1.1 '] ifFalse: ['HTTP/1.0 '].	aSwazooStream		nextPutAll: version;		nextPutAll: self statusLine.	self crlfOn: aSwazooStream</body><body package="Swazoo-Messages">writeHeaderTo: aSwazooStream 	self printStatusOn: aSwazooStream.	self printHeadersOn: aSwazooStream.	(self isStreamed and: [self shouldBeChunked])		ifTrue: [self printChunkedTransferEncodingOn: aSwazooStream]		ifFalse: [self printContentLengthOn: aSwazooStream].	self endHeaderOn: aSwazooStream</body></methods><methods><class-id>Swazoo.HTTPResponse</class-id> <category>testing</category><body package="Swazoo-Messages">isBadRequest	^self statusCode = 400</body><body package="Swazoo-Messages">isFound	^self statusCode = 302</body><body package="Swazoo-Messages">isGzipEncoded	| value |	value := self headerValueAt: 'Content-Encoding'.	^value notNil and: [value = 'gzip']</body><body package="Swazoo-Messages">isHttp10	"we are responding by old HTTP/1.0 protocol"	^self task request isHttp10</body><body package="Swazoo-Messages">isHttp11	"we are responding by HTTP/1.1 protocol"	^self task request isHttp11</body><body package="Swazoo-Messages">isInternalServerError	^self statusCode = 500</body><body package="Swazoo-Messages">isMovedPermanently	^self statusCode = 301</body><body package="Swazoo-Messages">isNotFound	^self statusCode = 404</body><body package="Swazoo-Messages">isNotImplemented	^self statusCode = 501</body><body package="Swazoo-Messages">isNotModified	^self statusCode = 304</body><body package="Swazoo-Messages">isOk	^self statusCode = 200</body><body package="Swazoo-Messages">isRedirectLink	^self statusCode = 302</body><body package="Swazoo-Messages">isSeeOther	^self statusCode = 303</body><body package="Swazoo-Messages">isStreamed	^false</body><body package="Swazoo-Messages">isUnauthorized	^self statusCode = 401</body><body package="Swazoo-Messages">isWebSocketHandshake	^self statusCode = 101 		and: [self statusText = 'WebSocket Protocol Handshake'] "because default 101 is different!"</body></methods><methods><class-id>Swazoo.HTTPResponse</class-id> <category>sending</category><body package="Swazoo-Messages">writeTo: aSwazooStream 	self writeTo: aSwazooStream inResponseTo: nil</body><body package="Swazoo-Messages">writeTo: aSwazooStream inResponseTo: aRequest	aSwazooStream isNil ifTrue: [ ^self ].	[self writeHeaderTo: aSwazooStream.	(aRequest isNil or: [ aRequest isHead not ])		ifTrue: [ self printEntityOn: aSwazooStream ].	aSwazooStream closeResponse]		on: Error		do: [:ex | "ignore" ]</body></methods><methods><class-id>Swazoo.HTTPResponse</class-id> <category>accessing</category><body package="Swazoo-Messages">contentSize	^self entity notNil 		ifTrue: [self entity size] 		ifFalse: [0]</body><body package="Swazoo-Messages">entity	^self body</body><body package="Swazoo-Messages">entity: anEntity 	self body: anEntity asByteArray "if not already"</body><body package="Swazoo-Messages">statusCode	^statusCode</body><body package="Swazoo-Messages">statusLine	^self statusCode printString, ' ', self statusText</body><body package="Swazoo-Messages">statusText	statusText isNil ifTrue: [^''].	^statusText</body></methods><methods><class-id>Swazoo.HTTPResponse</class-id> <category>private-obsolete</category><body package="Swazoo-Messages">code	^self statusCode</body><body package="Swazoo-Messages">code: anInteger	^self statusCode: anInteger</body></methods><methods><class-id>Swazoo.HTTPResponse class</class-id> <category>accessing</category><body package="Swazoo-Messages">statusTextForCode: aNumber	^StatusCodes at: aNumber ifAbsent: ['']</body></methods><methods><class-id>Swazoo.HTTPResponse class</class-id> <category>class initialization</category><body package="Swazoo-Messages">initialize	"self initialize"	StatusCodes := (Dictionary new)				add: 100 -&gt; 'Continue';				add: 101 -&gt; 'Switching Protocols';				add: 200 -&gt; 'OK';				add: 201 -&gt; 'Created';				add: 202 -&gt; 'Accepted';				add: 203 -&gt; 'Non-Authoritative Information';				add: 204 -&gt; 'No Content';				add: 205 -&gt; 'Reset Content';				add: 206 -&gt; 'Partial Content';				add: 300 -&gt; 'Multiple Choices';				add: 301 -&gt; 'Moved Permanently';				add: 302 -&gt; 'Found';				add: 303 -&gt; 'See Other';				add: 304 -&gt; 'Not Modified';				add: 305 -&gt; 'Use Proxy';				add: 307 -&gt; 'Temporary Redirect';				add: 400 -&gt; 'Bad Request';				add: 401 -&gt; 'Unauthorized';				add: 402 -&gt; 'Payment Required';				add: 403 -&gt; 'Forbidden';				add: 404 -&gt; 'Not Found';				add: 405 -&gt; 'Method Not Allowed';				add: 406 -&gt; 'Not Acceptable';				add: 407 -&gt; 'Proxy Authentication Required';				add: 408 -&gt; 'Request Time-out';				add: 409 -&gt; 'Conflict';				add: 410 -&gt; 'Gone';				add: 411 -&gt; 'Length Required';				add: 412 -&gt; 'Precondition Failed';				add: 413 -&gt; 'Request Entity Too Large';				add: 414 -&gt; 'Request-URI Too Large';				add: 415 -&gt; 'Unsupported Media Type';				add: 416 -&gt; 'Requested range not satisfiable';				add: 417 -&gt; 'Expectation Failed';				add: 500 -&gt; 'Internal Server Error';				add: 501 -&gt; 'Not Implemented';				add: 502 -&gt; 'Bad Gateway';				add: 503 -&gt; 'Service Unavailable';				add: 504 -&gt; 'Gateway Time-out';				add: 505 -&gt; 'HTTP Version not supported';				yourself.	self postInitialize.</body><body package="Swazoo-Messages">postInitialize	"extend it with your own codes"</body></methods><methods><class-id>Swazoo.HTTPResponse class</class-id> <category>response types</category><body package="Swazoo-Messages">badRequest	^super new statusCode: 400; setStatusText</body><body package="Swazoo-Messages">forbidden	^super new		statusCode: 403; setStatusText;		entity: '&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;Forbidden&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;&lt;H1&gt;403 Forbidden&lt;/H1&gt;&lt;P&gt;Access to the requested resource is forbidden.&lt;/P&gt;&lt;/BODY&gt;&lt;/HTML&gt;'</body><body package="Swazoo-Messages">found	^super new statusCode: 302; setStatusText</body><body package="Swazoo-Messages">internalServerError	^super new		statusCode: 500; setStatusText;		entity: '&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;Not Found&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;&lt;H1&gt;500 Internal Server Error&lt;/H1&gt;&lt;P&gt;The server experienced an error while processing this request.  If this problem persists, please contact the webmaster.&lt;/P&gt;&lt;/BODY&gt;&lt;/HTML&gt;'</body><body package="Swazoo-Messages">methodNotAllowed"c.f. RFC 2616  10.4.6   The method specified in the Request-Line is not allowed for the   resource identified by the Request-URI. The response MUST include an   Allow header containing a list of valid methods for the requested   resource. "	^super new statusCode: 405; setStatusText</body><body package="Swazoo-Messages">movedPermanently	^super new statusCode: 301; setStatusText</body><body package="Swazoo-Messages">notFound	^super new		statusCode: 404; setStatusText;		entity: '&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;Not Found&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;&lt;H1&gt;404 Not Found&lt;/H1&gt;&lt;P&gt;The requested resource was not found on this server.&lt;/P&gt;&lt;/BODY&gt;&lt;/HTML&gt;'</body><body package="Swazoo-Messages">notImplemented	^super new statusCode: 501; setStatusText</body><body package="Swazoo-Messages">notModified	^super new statusCode: 304; setStatusText</body><body package="Swazoo-Messages">ok	^super new statusCode: 200; setStatusText</body><body package="Swazoo-Messages">redirectLink	"^an HTTPResponseNote that 302 is really the 'found' response.  This code should really be 303 (&gt;&gt;seeOther).  However, because many clients take 302 &amp; 303 to be the same and because older clients don't understand 303, 302 is commonly used in this case.  See RFC 2616 10.3.4."	^super new statusCode: 302; setStatusText</body><body package="Swazoo-Messages">seeOther	"^an HTTPResponseThe response to the request can be found under a different URI and SHOULD be retrieved using a GET method on that resource. This method exists primarily to allow the output of a POST-activated script to redirect the user agent to a selected resource.See RFC 2616 10.3.4."	^super new statusCode: 303; setStatusText</body><body package="Swazoo-Messages">unauthorized	^super new statusCode: 401; setStatusText</body><body package="Swazoo-Messages">webSocketHandshake	^super new 		statusCode: 101;		statusText: 'WebSocket Protocol Handshake'</body></methods><methods><class-id>Swazoo.HTTPResponse class</class-id> <category>private-compression</category><body package="Swazoo-Messages">gzipCompress: aByteStringOrArray	| output |	output := WriteStream on: ByteArray new.	(self newGzipStreamOn: output)		nextPutAll: aByteStringOrArray asByteArray readStream;		close.	^output contents"HTTPResponse gzipCompress: 'div div div' "</body><body package="Swazoo-Messages">isGzipSupported	"Does Gzip suport exists in this image?"	"VW specific"	^OS.ZLib.GZipWriteStream</body><body package="Swazoo-Messages">newGzipStreamOn: anOutputStream	"VW specific"	^OS.ZLib.GZipWriteStream bestCompressionOn: anOutputStream</body></methods><methods><class-id>Swazoo.HTTPPost</class-id> <category>private</category><body package="Swazoo-Messages">applicationOctetStreamFrom: aStream 	"^self rfc 2046 says:The recommended action for an implementation that receives an 'application/octet-stream' entity is to simply offer to put the data in a file, with any Content-Transfer-Encoding undone, or perhaps to use it as input to a user-specified process.This method used to do a crlf -&gt; cr conversion on the octet-stream, but was not clear why."	self entityBody: (HTTPString 				stringFromBytes: (aStream nextBytes: self contentLength)).	^self</body><body package="Swazoo-Messages">entityBody: aString	entityBody := aString</body><body package="Swazoo-Messages">incReadPosition	self readPosition: self readPosition + 1</body><body package="Swazoo-Messages">incReadPosition: anInteger	self readPosition: self readPosition + anInteger</body><body package="Swazoo-Messages">postData	^postData</body><body package="Swazoo-Messages">readPosition	"position in a read stream. just temporary"	readPosition isNil ifTrue: [^1].	^readPosition</body><body package="Swazoo-Messages">readPosition: aNumber	readPosition := aNumber</body></methods><methods><class-id>Swazoo.HTTPPost</class-id> <category>accessing</category><body package="Swazoo-Messages">emptyData	self ensureFullRead.	^self postData select: [:each | each value isEmpty]</body><body package="Swazoo-Messages">entityBody	^entityBody</body><body package="Swazoo-Messages">postDataAt: aKey 	^self postDataAt: aKey ifAbsent: [nil]</body><body package="Swazoo-Messages">postDataAt: aKey beforeStreamingDo: aBlockClosure	"announce that you want to receive post data directly to a binary stream, which will be set	by aBlockClosure. That block must receive and argument, which is a HTTPostDatum and 	here it can set a writeStream"	"Fails if post data is already read"	self postData isParsed 		ifTrue: [^self error: 'HTTPost already parsed, streaming not possible anymore!'].	^self postDataAt: aKey put: (HTTPPostDatum new writeBlock: aBlockClosure)</body><body package="Swazoo-Messages">postDataAt: aKey do: aBlock 	| val |	self ensureFullRead. "defered parsing of postData"	val := self postData at: aKey ifAbsent: [nil].	val isNil ifFalse: [aBlock value: val]</body><body package="Swazoo-Messages">postDataAt: aKey ifAbsent: aBlock 	self ensureFullRead. "defered parsing of postData"	^self postData at: aKey ifAbsent: aBlock</body><body package="Swazoo-Messages">postDataAt: aKey put: aPostDatum 	"for testing purposes"	self postData at: aKey put: aPostDatum</body><body package="Swazoo-Messages">postDataAt: aKey putString: aString 	"for testing purposes"	self postDataAt: aKey put: (HTTPPostDatum new value: aString)</body><body package="Swazoo-Messages">postDataAt: aKey streamTo: aWriteStream	"announce that you want to receive post data directly to aWriteStream, which must be binary"	"Fails if post data is already read"	self postData isParsed 		ifTrue: [^self error: 'HTTPost already parsed, streaming not possible anymore!'].	^self postDataAt: aKey put: (HTTPPostDatum new writeStream: aWriteStream)</body><body package="Swazoo-Messages">postDataKeys	self ensureFullRead. "defered parsing of postData"	^self postData keys</body><body package="Swazoo-Messages">postDataStringAt: aKey 	^(self postDataAt: aKey ifAbsent: [^nil]) value</body><body package="Swazoo-Messages">postKeysAndValuesDo: aTwoArgBlock 	self ensureFullRead. "defered parsing of postData"	self postData 		keysAndValuesDo: [:key :each | aTwoArgBlock value: key value: each value]</body></methods><methods><class-id>Swazoo.HTTPPost</class-id> <category>testing</category><body package="Swazoo-Messages">isPost	^true</body><body package="Swazoo-Messages">isPostDataEmpty	self ensureFullRead.	^self postData isEmpty</body><body package="Swazoo-Messages">isPostDataStreamedAt: aKey	^(self postData at: aKey ifAbsent: [^false]) isStreamed</body></methods><methods><class-id>Swazoo.HTTPPost</class-id> <category>initialize-release</category><body package="Swazoo-Messages">initPostDataFor: aSwazooStream	postData := HTTPPostDataArray newOn: aSwazooStream</body></methods><methods><class-id>Swazoo.HTTPPost</class-id> <category>parsing</category><body package="Swazoo-Messages">ensureFullRead	"that is, everything is read from a socket stream. Important because of defered parsing	of postData"	self postData isParsed ifFalse: 		[self parsePostDataFrom: self postData stream.		self postData setParsed]</body><body package="Swazoo-Messages">for: aRequestLine readFrom: aSwazooStream 	super for: aRequestLine readFrom: aSwazooStream.	self initPostDataFor: aSwazooStream."	self parsePostDataFrom: aSwazooStream." "defered until first access of postData! "</body><body package="Swazoo-Messages">parsePostDataFrom: aSwazooStream 	| contentType |	self containsHeaderNecessaryFields ifFalse: 		[^SwazooHTTPPostError raiseSignal: 'Content-Type and Content-Length or chunked needed'].	contentType := self headers fieldOfClass: ContentTypeField.	contentType notNil ifTrue: 		[contentType mediaType = 'application/x-www-form-urlencoded' 			ifTrue: [^self urlencodedDataFrom: aSwazooStream].		contentType mediaType = 'multipart/form-data' 			ifTrue: [^self multipartDataFrom: aSwazooStream] ].	^self applicationOctetStreamFrom: aSwazooStream.</body></methods><methods><class-id>Swazoo.HTTPPost</class-id> <category>private-parsing support</category><body package="Swazoo-Messages">blockStreamingFrom: aSwazooStream to: outStream until: aBoundaryBytes "detected"	"copy by 8k blocks for optimal performance until a boundary of MIME part is detected"	"Finish appropriatelly streaming at the end (skip crlf etc.)"	| boundary start nrOfBoundary contents inPrevious remainingBoundary boundaryIndex |	boundary := aSwazooStream readBuffer isBinary 		ifTrue: [aBoundaryBytes asByteArray] ifFalse: [aBoundaryBytes asByteString].	start := self readPosition.	[true] whileTrue:		[nrOfBoundary := 0.		[nrOfBoundary = 0] whileTrue:			[nrOfBoundary := aSwazooStream readBuffer signsOfBoundary: boundary.			nrOfBoundary = 0 ifTrue: "no boundary in current buffer content"				[contents := aSwazooStream readBuffer readContents.				outStream nextPutAll: contents. 				self incReadPosition: contents size.				self checkToEnlargeBufferIn: aSwazooStream from: start.  "for effective streaming"				aSwazooStream fillBuffer.				"Processor yield"] ].  "do we need this?" 		"copy and stream out content up to potential boundary"		boundaryIndex := aSwazooStream readBuffer indexOfBoundary: boundary.		inPrevious := aSwazooStream readBuffer copyBufferTo: boundaryIndex-1.		outStream nextPutAll: 			(inPrevious copyFrom: 1 to: (inPrevious size-2 max: 0) "without potential crlf"). 		self incReadPosition: inPrevious size. "potential crlf included!"		nrOfBoundary = boundary size ifTrue: "full boundary detected, lets finish here"			[aSwazooStream skip: boundary size. "skip boundary"			self incReadPosition: boundary size.			^true].  "streaming complete"		self incReadPosition: nrOfBoundary.		aSwazooStream fillBuffer. "let's get next buffer"		remainingBoundary := boundary copyFrom: nrOfBoundary+1 to: boundary size.		(aSwazooStream readBuffer startsWith:  remainingBoundary) ifTrue: "bound. ends in next buff?"			[aSwazooStream skip: remainingBoundary size+2.  "skip remaining bound. and crlf"			self incReadPosition: remainingBoundary size+2.			^true]. "streaming complete"		outStream 			nextPutAll: (inPrevious copyFrom: inPrevious size-1 to: inPrevious size);  "potential crlf"			nextPutAll: (boundary copyFrom: 1 to: nrOfBoundary).  "boundary part in prev.buff."		] "continue from the start"</body><body package="Swazoo-Messages">checkToEnlargeBufferIn: aSwazooStream from: startPosition	"enlarge buffer to 1MB (if not already) if more than 100KB already read"	aSwazooStream readBuffer isEnlarged ifTrue: [^nil].	(self readPosition - startPosition) &gt; 100000 "about 100KB" 		ifTrue: [aSwazooStream readBuffer resizeEnlarge].</body><body package="Swazoo-Messages">containsHeaderNecessaryFields	"content type and (content length or chunked transfer encoding)"	(self headers includesFieldOfClass: HTTPContentLengthField) ifTrue: [^true].	(self headers includesFieldOfClass: ContentTypeField) ifFalse: [^false].	^(self headers fieldNamed: 'Transfer-encoding' ifNone: [^false]) value = 'chunked'</body><body package="Swazoo-Messages">skipMimeEpilogueFrom: aSwazooStream	"skip a mime epilogue until end of post data defined by contentLength"	"example:		--boundary--		This is the epilogue.  It is also to be ignored	"	[self readPosition &lt; self contentLength] whileTrue: 		[aSwazooStream next. "just skip"		self incReadPosition].</body><body package="Swazoo-Messages">skipMimePreambleAndBoundary: aBoundaryBytes from: aSwazooStream	"skip a mime preamble until first boundary starts then skip that boundary too"	"example:		Content-type: multipart/mixed; boundary=''boundary''		This is the preamble.  It is to be ignored, though it is		a handy place to include an explanatory note to non-MIME compliant readers.		--boundary		..."	| dummy |	dummy := WriteStream on: ByteArray new.	self blockStreamingFrom: aSwazooStream to: dummy until: ('--', aBoundaryBytes)</body></methods><methods><class-id>Swazoo.HTTPPost</class-id> <category>private-parsing</category><body package="Swazoo-Messages">multipartDataFrom: aSwazooStream	"read all mime parts and put them in postData" 	"read directly from stream, without intermediate buffers"	| contentTypeField boundary part |	contentTypeField := self headers fieldOfClass: ContentTypeField				ifNone: [^aSwazooStream nextBytes: self contentLength]. "just skip"	boundary := contentTypeField transferCodings at: 'boundary'				ifAbsent: [^aSwazooStream nextBytes: self contentLength]. "just skip"	self skipMimePreambleAndBoundary: boundary from: aSwazooStream. 	part := #something. 	[part notNil] whileTrue: 		[part := self partFromStream: aSwazooStream boundary: boundary.		part notNil ifTrue: [self postDataAt: part key put: part value]].	self skipMimeEpilogueFrom: aSwazooStream. "all to the end  as defined by contentLegth"	aSwazooStream readBuffer isEnlarged  "if MIME part larger that 100KB was read"		ifTrue: [aSwazooStream readBuffer resizeShrink].  "that is, release memory"</body><body package="Swazoo-Messages">partFromStream: aSwazooStream boundary: aBoundaryBytes	"one mime part from a stream. Nil if no more multipart data"	"VW specific"	| bytes name filename datum contentType |	bytes := aSwazooStream nextBytes: 2. self incReadPosition: 2.  	bytes = '--' asByteArray  ifTrue: [^nil].    "end of multipart data"			name := nil. datum := nil. contentType := nil. "just to avoid compilation warning"	[true] whileTrue: [| line |  "read all lines and at the end a body of that part"		line := [(aSwazooStream upTo: Character cr asInteger) asByteString] "VW specific"			on: Error do: [:ex | ^nil].  "usually nothing to read anymore, why happen this?"		self readPosition: self readPosition+line size+1 "cr".		line := bytes asString, line. bytes := ''.		aSwazooStream peekByte = Character lf asInteger ifTrue: [| field | "this is a name line"			aSwazooStream nextByte.  self incReadPosition. "skip linefeed"			line isEmpty 	ifTrue: [| | "empty line indicates start of entity"				name isNil ifTrue: [^nil].  "name must be read in previous circle"				self readEntityFrom: aSwazooStream datum: datum        				boundary: aBoundaryBytes. "fullfils the datum"				datum contentType: contentType. "completes datum's contentType read in a prev step"                		^name -&gt; datum].			field := HeaderField fromLine: line.			field isContentDisposition ifTrue: 					[name := (field parameterAt: 'name') copyWithout: $". 					datum := (self isPostDataStreamedAt: name)						ifTrue: [self postData at: name]  "streamed datum must exist before"						ifFalse: [HTTPPostDatum new].					contentType notNil ifTrue: [datum contentType: contentType]. "if read in prev.circle"					filename := field parameterAt: 'filename' .   "only for file uploads"					filename notNil ifTrue: [datum filename: (filename copyWithout: $")] ].			field isContentType ifTrue: [contentType := field mediaType ] ] ]</body><body package="Swazoo-Messages">readEntityFrom: aSwazooStream datum: aDatum boundary: aBoundaryBytes	"read one entity from a stream and put into datum. Stream it if streamed. Also call a block 	(if any) just before start of streaming, with a datum as parameter. This block can then set 	a write stream in datum (for instance open a output file and stream on it)"	| outStream |	aDatum writeBlock notNil 		ifTrue: [aDatum writeBlock value: aDatum]. "this should set writeStream if not already!" 	outStream := (aDatum isStreamed and: [aDatum writeStream notNil])		ifTrue: [aDatum writeStream] ifFalse: [WriteStream on: ByteArray new].	self blockStreamingFrom: aSwazooStream to: outStream until: ('--', aBoundaryBytes). "efficient streaming"	aDatum isStreamed not ifTrue: "otherwise entity is already streamed to the output"		[aDatum value: outStream contents asString].	^aDatum</body><body package="Swazoo-Messages">urlencodedDataFrom: aStream 	| entity tokens |	(self headers includesFieldOfClass: HTTPContentLengthField) ifFalse: [^self].	entity := aStream nextBytes: self contentLength.	tokens := HTTPString subCollectionsFrom: (HTTPString stringFromBytes: entity) delimitedBy: $&amp;.	(tokens collect: [:each | HTTPString subCollectionsFrom: each delimitedBy: $=]) 		do: 	[:keyVal | | datum key |			datum := HTTPPostDatum new.			datum value: (HTTPString decodedHTTPFrom:  				(keyVal last collect: [:char | char = $+ ifTrue: [Character space] ifFalse: [char]])).			key := (HTTPString decodedHTTPFrom:  				(keyVal first collect: [:char | char = $+ ifTrue: [Character space] ifFalse: [char]])).			self postDataAt: key put: datum]</body></methods><methods><class-id>Swazoo.HTTPPost class</class-id> <category>accessing</category><body package="Swazoo-Messages">methodName	^'POST'</body></methods><methods><class-id>Swazoo.HTTPUserAgentField</class-id> <category>private</category><body package="Swazoo-Headers">parseValueFrom: aString 	"^selfI could try and parse out the product name and version numbers, but there is no need to worry about this at the moment, so I just record the string."	productTokens := HTTPString trimBlanksFrom: aString.	^self</body></methods><methods><class-id>Swazoo.HTTPUserAgentField</class-id> <category>accessing</category><body package="Swazoo-Headers">productTokens	^productTokens</body></methods><methods><class-id>Swazoo.HTTPUserAgentField</class-id> <category>printing</category><body package="Swazoo-Headers">valuesAsStringOn: aStream 	aStream nextPutAll: productTokens.	^self</body></methods><methods><class-id>Swazoo.HTTPUserAgentField class</class-id> <category>accessing</category><body package="Swazoo-Headers">fieldName	^'User-Agent'</body></methods><methods><class-id>Swazoo.HTTPAllowField</class-id> <category>printing</category><body package="Swazoo-Headers">valuesAsStringOn: targetStream 	self methods isEmpty 		ifFalse: 			[targetStream nextPutAll: self methods first.			2 to: self methods size				do: 					[:methodIndex | 					targetStream						nextPut: $,;						nextPutAll: (self methods at: methodIndex)]].	^self</body></methods><methods><class-id>Swazoo.HTTPAllowField</class-id> <category>accessing</category><body package="Swazoo-Headers">methods	methods isNil ifTrue: [methods := OrderedCollection new].	^methods</body></methods><methods><class-id>Swazoo.HTTPAllowField class</class-id> <category>accessing</category><body package="Swazoo-Headers">fieldName	^'Allow'</body></methods><methods><class-id>Swazoo.SwazooMD5Digest class</class-id> <category>hashing for rfc2617</category><body package="Swazoo-Messages">a1FromUsername: aUsername realm: aRealm password: aPassword	"rfc2617 3.2.2.2 , algorithm directive unspecified		A1= unq(username-value) : unq(realm-value) : passwd"	^aUsername trimSeparators, ':', aRealm trimSeparators, ':', aPassword trimSeparators</body><body package="Swazoo-Messages">a2FromMethod: aMethod digestUri: anUri	"rfc2617 3.2.2.3 , qop directive unspecified		A2  = Method : digest-uri-value"	^aMethod trimSeparators, ':', anUri trimSeparators</body><body package="Swazoo-Messages">requestDigestFromMethod: aMethod uri: anUri nonce: aNonce username: aUsername realm: aRealm password: aPassword	"rfc2617 3.2.2.1 , qop directive not present		request-digest  =  KD ( H(A1), unq(nonce-value) : H(A2) )"	| a1 a2 |	a1 := self a1FromUsername: aUsername realm: aRealm password: aPassword.	a2 := self a2FromMethod: aMethod digestUri: anUri. 	^self hash: ((self hash: a1), ':', aNonce trimSeparators, ':', (self hash: a2))"MD5Digest requestDigestFromMethod: 'Digest'	uri: 'http://www.nowhere.org/dir/index.html' nonce: 'dcd98b7102dd2f0e8b11d0f600bfb0c093'	username: 'Musafa' realm: 'testrealm@host.com' password: 'Circle Of Life'"</body></methods><methods><class-id>Swazoo.SwazooMD5Digest class</class-id> <category>hashing-md5</category><body package="Swazoo-Messages">hash: aString	"return a 128bit digest as 32 char hex string, see rfc2617 3.1.3 "	"MD5Digest hash: '1234' "	| hash |	hash := Security.MD5 hash: aString asByteArray.	^hash asHexString asLowercase.</body></methods><methods><class-id>Swazoo.HTTPException</class-id> <category>accessing</category><body package="Swazoo-Exceptions">response	^response</body><body package="Swazoo-Exceptions">response: aHTTPResponse	response := aHTTPResponse</body></methods><methods><class-id>Swazoo.HTTPException class</class-id> <category>responses-client error</category><body package="Swazoo-Exceptions">badRequest	^self raiseResponse: (HTTPResponse new code: 400)</body><body package="Swazoo-Exceptions">conflict	^self raiseResponse: (HTTPResponse new code: 409)</body><body package="Swazoo-Exceptions">expectationFailed	^self raiseResponse: (HTTPResponse new code: 416)</body><body package="Swazoo-Exceptions">forbidden	^self raiseResponse: (HTTPResponse new code: 403)</body><body package="Swazoo-Exceptions">gone	^self raiseResponse: (HTTPResponse new code: 410)</body><body package="Swazoo-Exceptions">lengthRequired	^self raiseResponse: (HTTPResponse new code: 411)</body><body package="Swazoo-Exceptions">methodNotAllowed	^self raiseResponse: (HTTPResponse new code: 405)</body><body package="Swazoo-Exceptions">notAcceptable	^self raiseResponse: (HTTPResponse new code: 406)</body><body package="Swazoo-Exceptions">notFound	^self raiseResponse: (HTTPResponse new code: 404)</body><body package="Swazoo-Exceptions">paymentRequired	^self raiseResponse: (HTTPResponse new code: 402)</body><body package="Swazoo-Exceptions">preconditionFailed	^self raiseResponse: (HTTPResponse new code: 412)</body><body package="Swazoo-Exceptions">proxyAuthenticationRequired	^self raiseResponse: (HTTPResponse new code: 407)</body><body package="Swazoo-Exceptions">requestEntityTooLarge	^self raiseResponse: (HTTPResponse new code: 413)</body><body package="Swazoo-Exceptions">requestTimeout	^self raiseResponse: (HTTPResponse new code: 408)</body><body package="Swazoo-Exceptions">requestURITooLong	^self raiseResponse: (HTTPResponse new code: 414)</body><body package="Swazoo-Exceptions">requestedRangeNotSatisfiable	^self raiseResponse: (HTTPResponse new code: 416)</body><body package="Swazoo-Exceptions">unathorized	^self raiseResponse: (HTTPResponse new code: 401)</body><body package="Swazoo-Exceptions">unsupportedMediaType	^self raiseResponse: (HTTPResponse new code: 415)</body></methods><methods><class-id>Swazoo.HTTPException class</class-id> <category>responses-succesfull</category><body package="Swazoo-Exceptions">accepted	^self raiseResponse: (HTTPResponse new code: 202)</body><body package="Swazoo-Exceptions">created	^self raiseResponse: (HTTPResponse new code: 201)</body><body package="Swazoo-Exceptions">noContent	^self raiseResponse: (HTTPResponse new code: 204)</body><body package="Swazoo-Exceptions">nonAuthorativeInformation	^self raiseResponse: (HTTPResponse new code: 203)</body><body package="Swazoo-Exceptions">ok	^self raiseResponse: HTTPResponse ok</body><body package="Swazoo-Exceptions">partialContent	^self raiseResponse: (HTTPResponse new code: 206)</body><body package="Swazoo-Exceptions">resetContent	^self raiseResponse: (HTTPResponse new code: 205)</body></methods><methods><class-id>Swazoo.HTTPException class</class-id> <category>responses-redirection</category><body package="Swazoo-Exceptions">found	^self raiseResponse: (HTTPResponse new code: 302)</body><body package="Swazoo-Exceptions">movedPermanently	^self raiseResponse: (HTTPResponse new code: 301)</body><body package="Swazoo-Exceptions">multipleChoices	^self raiseResponse: (HTTPResponse new code: 300)</body><body package="Swazoo-Exceptions">notModified	^self raiseResponse: (HTTPResponse new code: 304)</body><body package="Swazoo-Exceptions">seeOther	^self raiseResponse: (HTTPResponse new code: 303)</body><body package="Swazoo-Exceptions">temporaryRedirect	^self raiseResponse: (HTTPResponse new code: 307)</body><body package="Swazoo-Exceptions">useProxy	^self raiseResponse: (HTTPResponse new code: 305)</body></methods><methods><class-id>Swazoo.HTTPException class</class-id> <category>signalling</category><body package="Swazoo-Exceptions">raiseResponse: aHTTPResponse	"Raise an exception to immediatelly return that response."	^self new 		response: aHTTPResponse;		raiseSignal.</body><body package="Swazoo-Exceptions">raiseResponseCode: aNumber	"Raise an exception to immediatelly return http response with that code"	^self raiseResponse: (HTTPResponse new code: aNumber)</body></methods><methods><class-id>Swazoo.HTTPException class</class-id> <category>responses-server error</category><body package="Swazoo-Exceptions">badGateway	^self raiseResponse: (HTTPResponse new code: 502)</body><body package="Swazoo-Exceptions">gatewayTimeout	^self raiseResponse: (HTTPResponse new code: 504)</body><body package="Swazoo-Exceptions">httpVersionNotSupported	^self raiseResponse: (HTTPResponse new code: 505)</body><body package="Swazoo-Exceptions">internalServerError	^self raiseResponse: (HTTPResponse new code: 500)</body><body package="Swazoo-Exceptions">notImplemented	^self raiseResponse: (HTTPResponse new code: 501)</body><body package="Swazoo-Exceptions">serviceUnavailable	^self raiseResponse: (HTTPResponse new code: 503)</body></methods><methods><class-id>Swazoo.HTTPException class</class-id> <category>responses-informational</category><body package="Swazoo-Exceptions">continue	^self raiseResponse: (HTTPResponse new code: 100)</body><body package="Swazoo-Exceptions">switchingProtocols	^self raiseResponse: (HTTPResponse new code: 101)</body></methods><methods><class-id>Swazoo.HTTPIfUnmodifiedSinceField</class-id> <category>testing</category><body package="Swazoo-Headers">isCacheHitFor: anEntity 	"^a BooleanI return true if an anEntity is a cache hit given the conditional I represent. anEntity *must* respond to &gt;&gt;entutyTag"	1 halt.	^self</body><body package="Swazoo-Headers">isConditional	^true</body></methods><methods><class-id>Swazoo.HTTPIfUnmodifiedSinceField</class-id> <category>accessing</category><body package="Swazoo-Headers">date	^date</body></methods><methods><class-id>Swazoo.HTTPIfUnmodifiedSinceField</class-id> <category>private</category><body package="Swazoo-Headers">parseValueFrom: aString 	date := SpTimestamp fromRFC1123String: aString.	^self</body></methods><methods><class-id>Swazoo.HTTPIfUnmodifiedSinceField</class-id> <category>printing</category><body package="Swazoo-Headers">valuesAsStringOn: aStream 	self date notNil ifTrue: [self date asRFC1123StringOn: aStream].	^self</body></methods><methods><class-id>Swazoo.HTTPIfUnmodifiedSinceField class</class-id> <category>accessing</category><body package="Swazoo-Headers">fieldName	^'If-Unmodified-Since'</body></methods><methods><class-id>Swazoo.HTTPHostField</class-id> <category>private</category><body package="Swazoo-Headers">parseValueFrom: aString 	| sourceStream portNumberString |	sourceStream := ReadStream on: aString.	hostName := sourceStream upTo: $:.	portNumberString := sourceStream atEnd 				ifTrue: [String new]				ifFalse: [sourceStream upToEnd].	portNumberString notEmpty 		ifTrue: [portNumber := portNumberString asNumber].	^self</body></methods><methods><class-id>Swazoo.HTTPHostField</class-id> <category>printing</category><body package="Swazoo-Headers">valuesAsStringOn: aStream 	aStream nextPutAll: self hostName.	portNumber notNil 		ifTrue: 			[aStream nextPut: $:.			self portNumber printOn: aStream].	^self</body></methods><methods><class-id>Swazoo.HTTPHostField</class-id> <category>accessing</category><body package="Swazoo-Headers">hostName	^hostName</body><body package="Swazoo-Headers">portNumber	^portNumber isNil ifTrue: [80] ifFalse: [portNumber]</body></methods><methods><class-id>Swazoo.HTTPHostField class</class-id> <category>accessing</category><body package="Swazoo-Headers">fieldName	^'Host'</body></methods><methods><class-id>Swazoo.MimeObject</class-id> <category>accessing</category><body package="Swazoo-Messages">contentType	^contentType isNil ifTrue: [self defaultContentType] ifFalse: [contentType]</body><body package="Swazoo-Messages">contentType: anObject	contentType := anObject</body><body package="Swazoo-Messages">value	^value</body><body package="Swazoo-Messages">value: anObject	value := anObject</body></methods><methods><class-id>Swazoo.MimeObject</class-id> <category>private-accessing</category><body package="Swazoo-Messages">defaultContentType	^'application/octet-stream'</body></methods><methods><class-id>Swazoo.HTTPPostDatum</class-id> <category>accessing</category><body package="Swazoo-Messages">filename	^filename</body><body package="Swazoo-Messages">filename: aString	filename := aString</body><body package="Swazoo-Messages">filenameWithoutPath	"M$ Internet Explorer includes full path in filename of uploaded file! "	self filename isNil ifTrue: [^nil].	^(self filename includes: $\ ) 		ifTrue: [self filename copyFrom: (self filename lastIndexOf: $\ )+1 to: self filename size]		ifFalse: [self filename]</body><body package="Swazoo-Messages">writeBlock	^writeBlock</body><body package="Swazoo-Messages">writeBlock: aBlockClosure	"this block will be called just before start of streaming to writeStream. It can be used to 	open the writeStream, because on that time we already know the filename of uploaded file. 	As a parameter this postDatum is sent"	writeBlock := aBlockClosure</body><body package="Swazoo-Messages">writeStream	^writeStream</body><body package="Swazoo-Messages">writeStream: aWriteStream	"a binary stream where to put directly a post data"	writeStream := aWriteStream</body></methods><methods><class-id>Swazoo.HTTPPostDatum</class-id> <category>private-accessing</category><body package="Swazoo-Messages">defaultContentType	^'text/plain'</body></methods><methods><class-id>Swazoo.HTTPPostDatum</class-id> <category>testing</category><body package="Swazoo-Messages">isStreamed	"this postDatum is streamed - it has an output stream to receive data into or a block which 	will set it"	^self writeStream notNil or: [self writeBlock notNil]</body></methods><methods><class-id>Swazoo.URIResolutionTest</class-id> <category>testing</category><body package="Swazoo-Tests">testCompositeAnswer	| resource request response |	resource := CompositeResource uriPattern: 'base'.	resource addResource: (HelloWorldResource uriPattern: 'hi').	request := HTTPGet request: 'base/hi'.	response := URIResolution resolveRequest: request startingAt: resource.	self assert: response statusCode = 200.	self assert: request resourcePath size = 2.	self assert: request resourcePath first = 'base'.	self assert: request resourcePath last = 'hi'</body><body package="Swazoo-Tests">testCompositeItselfCannotAnswer	| resource request response |	resource := CompositeResource uriPattern: 'base'.	request := HTTPGet request: 'base'.	response := URIResolution resolveRequest: request startingAt: resource.	self assert: response isNil</body><body package="Swazoo-Tests">testCompositeNoAnswer	| resource request response |	resource := CompositeResource uriPattern: 'base'.	resource addResource: (HelloWorldResource uriPattern: 'hi').	request := HTTPGet request: 'tail/hi'.	response := URIResolution resolveRequest: request startingAt: resource.	self assert: response isNil</body><body package="Swazoo-Tests">testLeafAnswer	| resource request response |	resource := HelloWorldResource uriPattern: 'hi'.	request := HTTPGet request: 'hi'.	response := URIResolution resolveRequest: request startingAt: resource.	self assert: response statusCode = 200.	self assert: request resourcePath size = 1.	self assert: request resourcePath first = 'hi'</body><body package="Swazoo-Tests">testNoAnswerWhenDisabled	| resource request response |	resource := HelloWorldResource uriPattern: 'hi'.	resource disable.	request := HTTPGet request: 'hi'.	response := URIResolution resolveRequest: request startingAt: resource.	self assert: response isNil</body><body package="Swazoo-Tests">testResourcePath	| request resolution |	request := HTTPGet 				request: 'foo/bar/baz/quux'				from: 'localhost:1234'				at: '1.2.3.4'.	resolution := URIResolution new initializeRequest: request.	self assert: resolution resourcePath = #('foo') asOrderedCollection.	resolution advance.	self assert: resolution resourcePath = #('foo' 'bar') asOrderedCollection.	resolution advance.	self 		assert: resolution resourcePath = #('foo' 'bar' 'baz') asOrderedCollection.	resolution advance.	self assert: resolution resourcePath = #('foo' 'bar' 'baz' 'quux') asOrderedCollection</body><body package="Swazoo-Tests">testSiteAnswer	| resource request response |	resource := SwazooSite new host: 'foo.com' ip: '1.2.3.4' port: 80.	resource addResource: (HelloWorldResource uriPattern: '/').	request := HTTPGet				request: '/'				from: 'foo.com'				at: '1.2.3.4'.	response := URIResolution resolveRequest: request startingAt: resource.	self assert: response statusCode = 200.	self assert: request resourcePath size = 1.	self assert: request resourcePath first = '/'</body><body package="Swazoo-Tests">testSiteMatch	| request site visitor |	request := HTTPGet 				request: 'foo'				from: 'myhosthost:1234'				at: '1.2.3.4'.	visitor := URIResolution new initializeRequest: request.	site := SwazooSite new host: 'myhosthost' ip: '1.2.3.4' port: 1234.	self assert: (visitor siteMatch: site)</body><body package="Swazoo-Tests">testSiteMismatch	| request site visitor |	request := HTTPGet 				request: 'foo'				from: 'localhost:1234'				at: '1.2.3.4'.	visitor := URIResolution new initializeRequest: request.	site := SwazooSite new host: 'remotehost' ip: '1.2.3.4' port: 1234.	self deny: (visitor siteMatch: site)</body><body package="Swazoo-Tests">testStringMatch	| request visitor resource |	request := HTTPGet request: 'foo'.	visitor := URIResolution new initializeRequest: request.	resource := HelloWorldResource uriPattern: 'foo'.	self assert: (visitor stringMatch: resource)</body><body package="Swazoo-Tests">testStringMismatch	| request visitor resource |	request := HTTPGet request: 'foo'.	visitor := URIResolution new initializeRequest: request.	resource := HelloWorldResource uriPattern: 'Foo'.	self deny: (visitor stringMatch: resource)</body><body package="Swazoo-Tests">testTailPath	| request resolution |	request := HTTPGet 				request: 'foo/bar/baz/quux'				from: 'localhost:1234'				at: '1.2.3.4'.	resolution := URIResolution new initializeRequest: request.	self 		assert: resolution tailPath = #('bar' 'baz' 'quux') asOrderedCollection.	resolution advance.	self assert: resolution tailPath = #('baz' 'quux') asOrderedCollection.	resolution advance.	self assert: resolution tailPath = #('quux') asOrderedCollection.	resolution advance.	self assert: resolution tailPath isEmpty</body></methods><methods><class-id>Swazoo.HTTPConnection</class-id> <category>private</category><body package="Swazoo-HTTP">loop	^loop</body><body package="Swazoo-HTTP">loop: aProcess	loop := aProcess</body><body package="Swazoo-HTTP">server	^server</body><body package="Swazoo-HTTP">server: aServer 	server := aServer</body><body package="Swazoo-HTTP">socket	^self stream socket</body><body package="Swazoo-HTTP">stream	^stream</body><body package="Swazoo-HTTP">stream: aSwazooStream 	stream := aSwazooStream</body><body package="Swazoo-HTTP">task	"request/response pair, current or last one (until next request)"	^task</body><body package="Swazoo-HTTP">task: aSwazooTask	"request/response pair, current or last one (until next request)"	task := aSwazooTask</body></methods><methods><class-id>Swazoo.HTTPConnection</class-id> <category>serving-responses</category><body package="Swazoo-HTTP">nextPutError: aResponse 	aResponse informConnectionClose.	aResponse writeTo: self stream.</body><body package="Swazoo-HTTP">nextPutResponse: aMessage toRequest: aRequest 	aMessage writeTo: self stream inResponseTo: aRequest</body></methods><methods><class-id>Swazoo.HTTPConnection</class-id> <category>testing</category><body package="Swazoo-HTTP">isHTTPConnection	^true</body><body package="Swazoo-HTTP">isOpen	"not yet closed"	^self stream notNil</body><body package="Swazoo-HTTP">isWebSocketConnection	^false</body><body package="Swazoo-HTTP">keepAliveTimeout	| seconds |	self task isNil ifTrue: [^false].	self task request isKeepAlive ifFalse: [^false].	seconds := self task request keepAlive notNil		ifTrue: [self task request keepAlive asInteger - 10 "to be sure"]		ifFalse: [20]. "probably enough?"	^(SpTimestamp now asSeconds - self task request timestamp asSeconds) &gt;= seconds</body></methods><methods><class-id>Swazoo.HTTPConnection</class-id> <category>initialize-release</category><body package="Swazoo-HTTP">initOther	other := Dictionary new</body></methods><methods><class-id>Swazoo.HTTPConnection</class-id> <category>upgrading</category><body package="Swazoo-HTTP">mustUpgrade	^self otherAt: #Upgrade ifAbsent: [false]</body><body package="Swazoo-HTTP">upgradeConnection	"from HTTP to some other protocol, like WebSocket"	self mustUpgradeToWebSocket 		ifTrue: [^self upgradeToWebSocket]</body><body package="Swazoo-HTTP">upgradeConnectionAfterResponse	"wait to finish sending response, then upgrade"	self otherAt: #Upgrade put: true</body></methods><methods><class-id>Swazoo.HTTPConnection</class-id> <category>websocket</category><body package="Swazoo-HTTP">mustUpgradeToWebSocket	^self otherAt: #UpgradeToWebSocket ifAbsent: [false]</body><body package="Swazoo-HTTP">upgradeToWebSocket	"Upgrade HTTP connection to a WebSocket one"	self become: (self swazooAs: WebSocketConnection).</body><body package="Swazoo-HTTP">upgradeToWebSocketAfterResponse	"let we first finish sending response, then upgrade"	self otherAt: #UpgradeToWebSocket put: true.	self upgradeConnectionAfterResponse</body><body package="Swazoo-HTTP">webSocket	"resource to hande incoming WebSocket messages. Only one WebSocket per connection!"	^self otherAt: #SwazooWebSocket ifAbsent: [nil]</body><body package="Swazoo-HTTP">webSocket: aWebSocektResource	"only one WebSocket per connection!"	self otherAt: #SwazooWebSocket put: aWebSocektResource</body></methods><methods><class-id>Swazoo.HTTPConnection</class-id> <category>private-other</category><body package="Swazoo-HTTP">other	^other</body><body package="Swazoo-HTTP">otherAt: aSymbol	"other values"	^self otherAt: aSymbol ifAbsent: [nil]</body><body package="Swazoo-HTTP">otherAt: aSymbol ifAbsent: aBlock	"other values"	self other isNil ifTrue: [^aBlock value].	^self other at: aSymbol ifAbsent: aBlock</body><body package="Swazoo-HTTP">otherAt: aSymbol ifAbsentPut: aBlock	self other isNil ifTrue: [self initOther].	^self other at: aSymbol ifAbsent: [self other at: aSymbol put: aBlock value]</body><body package="Swazoo-HTTP">otherAt: aSymbol put: anObject	self other isNil ifTrue: [self initOther].	^self other at: aSymbol put: anObject</body></methods><methods><class-id>Swazoo.HTTPConnection</class-id> <category>serving</category><body package="Swazoo-HTTP">close	self stream notNil ifTrue: [self stream close. stream := nil].	self server notNil ifTrue: 		[self server removeConnection: self.		self server: nil].	self loop notNil ifTrue: 		[ | process | 		process := loop. loop := nil. 		process terminate]</body><body package="Swazoo-HTTP">getAndDispatchMessages	self stream anyDataReady  "wait for data and if anything read, proceed"		ifTrue:			[self task: (SwazooTask newOn: self).			self readRequestFor: self task.			(self isAllowedRequest: self task request) ifFalse: [self close]. "filtering out malicious reqs"			self produceResponseFor: self task.			self task request wantsConnectionClose ifTrue: [self close].			(self task request isHttp10 and: [self task request isKeepAlive not] ) ifTrue: [self close].			self mustUpgrade ifTrue: [self upgradeConnection] ] "like to WebSocket"		ifFalse: 			[self keepAliveTimeout ifTrue: [^self close].			(Delay forMilliseconds: 100) wait. "to finish sending, if any"			self close].</body><body package="Swazoo-HTTP">interact	"longer description is below method"	| interactionBlock |	interactionBlock := 		[[ 	[  [true] whileTrue: 				[self getAndDispatchMessages.				Processor yield]			] 			on: Error 			do: [:ex | "true "(ex isKindOf: OsError) ifFalse: [ex defaultAction] ifTrue: ["just ignore"]] ] "TEMPORARY!""			do: [:ex | ""just ignore"" ]  "		ifCurtailed:  			[(Delay forMilliseconds: 50) wait. "to finish sending, if any"			self close] ].	self server isMultiThreading 		ifTrue: 			[self loop: interactionBlock newProcess.			self loop				priority: Processor userBackgroundPriority;				resume]		ifFalse: [interactionBlock value].	^self</body><body package="Swazoo-HTTP">produceResponseFor: aSwazooTask 	aSwazooTask request isNil ifTrue: [^nil].	aSwazooTask response: (self server answerTo: aSwazooTask request).	aSwazooTask request ensureFullRead. "in case if defered parsing not done in HTTPost"	aSwazooTask request wantsConnectionClose 		ifTrue: [aSwazooTask response informConnectionClose]		ifFalse: [aSwazooTask request isKeepAlive 			ifTrue: [aSwazooTask response informConnectionKeepAlive] ].	aSwazooTask response isStreamed 		ifFalse: "streamed ones did that by themselves"			[self nextPutResponse: aSwazooTask response toRequest: aSwazooTask request]		ifTrue: [aSwazooTask response waitClose]. "to be sure all is sent"	aSwazooTask request isGet ifFalse: [self close]  "to avoid strange 200 bad requests after two consecutive POSTs, but it is really a hack and original reason must be found!" "jan11: do we still need this?"</body><body package="Swazoo-HTTP">readRequestFor: aSwazooTask 	| request |	SpExceptionContext for: 		[request := HTTPRequest readFrom: self stream.		request uri port: self server port.		(request httpVersion last = 1 			and: [(request headers includesFieldOfClass: HTTPHostField) not]) 				ifTrue: [aSwazooTask response: HTTPResponse badRequest].		[request peer: self stream socket remoteAddress]			on: Error do: [:ex | "do nothing for now"].		request			ip: self stream socket localAddress;			setTimestamp.		aSwazooTask request: request]	on: SpError, HTTPException	do: [:ex | 	"	self halt. "		aSwazooTask response: HTTPResponse badRequest.		[self nextPutError: aSwazooTask response]			on: Error			do: [:ex2 | "ignore" ].		self close].</body></methods><methods><class-id>Swazoo.HTTPConnection</class-id> <category>filtering</category><body package="Swazoo-HTTP">isAllowedRequest: aHTTPRequest	 "Peer IP is not on blacklist or is on whitelist"	(self server isPeerIPAlwaysAllowed: self) ifTrue: [^true]. "from this IPs is kind of 'root' access"	^(self isUrlBlacklisted: aHTTPRequest) not</body><body package="Swazoo-HTTP">isUrlBlacklisted: aHTTPRequest	 "Absolute Url pattern"	| srv fullUrl |	srv := SwazooServer singleton.	srv urlBlacklist isEmpty ifTrue: [^false].  "in case there is no blacklist"	fullUrl := aHTTPRequest uri protocol, '://',      "warning, without port! "		aHTTPRequest host, aHTTPRequest uri asString. 	^srv urlBlacklist contains: [:ipString | ipString match: fullUrl]</body></methods><methods><class-id>Swazoo.HTTPConnection class</class-id> <category>instance creation</category><body package="Swazoo-HTTP">socket: aSocket 	^self new stream: aSocket stream</body></methods><methods><class-id>Swazoo.RedirectionResource</class-id> <category>private-initialize</category><body package="Swazoo-Resources">targetUri	^targetUri</body><body package="Swazoo-Resources">targetUri: aString 	targetUri := aString</body></methods><methods><class-id>Swazoo.RedirectionResource</class-id> <category>serving</category><body package="Swazoo-Resources">answerTo: aRequest 	| answer |	answer := HTTPResponse movedPermanently.	answer headers addField: (HTTPLocationField new uriString: self targetUri).	^answer</body></methods><methods><class-id>Swazoo.RedirectionResource class</class-id> <category>instance creation</category><body package="Swazoo-Resources">uriPattern: aString targetUri: bString 	^(self uriPattern: aString) targetUri: bString</body></methods><methods><class-id>Swazoo.SwazooSocket</class-id> <category>server accessing</category><body package="Swazoo-HTTP">accept	^self class accessor: self accessor acceptRetryingIfTransientErrors</body><body package="Swazoo-HTTP">listenFor: anInteger 	self accessor listenBackloggingUpTo: anInteger</body></methods><methods><class-id>Swazoo.SwazooSocket</class-id> <category>accessing</category><body package="Swazoo-HTTP">close	self accessor close</body><body package="Swazoo-HTTP">localAddress	^self accessor getSocketName hostAddressString</body><body package="Swazoo-HTTP">read: anInteger 	^self accessor read: anInteger.</body><body package="Swazoo-HTTP">read: anInteger timeout: aNumberOfMilliseconds 	^(self accessor waitForReadDataUpToMs: aNumberOfMilliseconds) 		ifTrue: [self read: anInteger]		ifFalse: [ByteArray new]</body><body package="Swazoo-HTTP">readInto: aByteArray startingAt: start for: length	^self accessor readInto: aByteArray startingAt: start for: length</body><body package="Swazoo-HTTP">remoteAddress	^self accessor getPeerName hostAddressString</body><body package="Swazoo-HTTP">stream	^SwazooStream socket: self</body><body package="Swazoo-HTTP">write: aByteArray 	^self accessor write: aByteArray</body><body package="Swazoo-HTTP">writeFrom: aByteArray startingAt: start for: length	^self accessor writeFrom: aByteArray startingAt: start for: length</body></methods><methods><class-id>Swazoo.SwazooSocket</class-id> <category>private</category><body package="Swazoo-HTTP">accessor	^accessor</body><body package="Swazoo-HTTP">accessor: aSocketAccessor 	accessor := aSocketAccessor.</body></methods><methods><class-id>Swazoo.SwazooSocket</class-id> <category>testing</category><body package="Swazoo-HTTP">isActive	^self accessor isActive</body></methods><methods><class-id>Swazoo.SwazooSocket class</class-id> <category>private</category><body package="Swazoo-HTTP">accessor: aSocketAccessor 	^self new accessor: aSocketAccessor</body></methods><methods><class-id>Swazoo.SwazooSocket class</class-id> <category>instance creation</category><body package="Swazoo-HTTP">connectTo: aHostString port: anInteger 	| newSocket |	newSocket := SpSocket newTCPSocket.	newSocket 		connectTo: (SpIPAddress hostName: aHostString port: anInteger).	^self accessor: newSocket</body><body package="Swazoo-HTTP">connectedPair	^SpSocket newSocketPair collect: [:each | self accessor: each]</body><body package="Swazoo-HTTP">serverOnIP: anIPString port: anInteger 	| newSocket |	newSocket := SpSocket newTCPSocket.	newSocket		setAddressReuse: true;		bindSocketAddress: (SpIPAddress hostName: anIPString port: anInteger).	^self accessor: newSocket</body></methods><methods><class-id>Swazoo.HTTPDelete</class-id> <category>testing</category><body package="Swazoo-Messages">isDelete	^true</body></methods><methods><class-id>Swazoo.HTTPDelete class</class-id> <category>accessing</category><body package="Swazoo-Messages">methodName	"HTTP method used for a request"	^'DELETE'</body></methods><methods><class-id>Swazoo.HTTPStreamedResponse</class-id> <category>private-state</category><body package="Swazoo-Messages">isClosed	"is response closed?. No streaming or anything else possible anymore"	^state = #closed</body><body package="Swazoo-Messages">isHeader	"is response in header state?. this is initial one"	^state = #header</body><body package="Swazoo-Messages">isStreaming	"is response in streaming state? All nextPut to stream is sent in chunked format to browser"	^state = #streaming</body><body package="Swazoo-Messages">setClosed	"response is closed. No streaming or anything else possible anymore"	state := #closed</body><body package="Swazoo-Messages">setHeader	"response in header state. this is initial one"	state := #header</body><body package="Swazoo-Messages">setStreaming	"response in streaming state. All nextPut to stream is sent in chunked format to browser"	state := #streaming</body></methods><methods><class-id>Swazoo.HTTPStreamedResponse</class-id> <category>initialize-release</category><body package="Swazoo-Messages">close	"mandatory! It signals that streaming is finished and response can end"	(self isCompressed and: [self gzStream notNil]) ifTrue: 		[self gzStream flush]. 	self testForUnderflow. "if streamed but not chunked: all data sent?"	self stream closeResponse.	(self isCompressed and: [self gzStream notNil]) ifTrue: 		[self gzStream close. 		self nilGzStream].	self setClosed.	self stream: nil. "to avoid unintential writing"	self semaphore signal. "to signal close to all waiting processes"</body><body package="Swazoo-Messages">initSemaphore	semaphore := Semaphore new</body><body package="Swazoo-Messages">initialize	self setHeader</body></methods><methods><class-id>Swazoo.HTTPStreamedResponse</class-id> <category>private</category><body package="Swazoo-Messages">count: aNumber	count := aNumber</body><body package="Swazoo-Messages">semaphore	"semahore to signal end of streaming = all data sent"	semaphore isNil ifTrue: [self initSemaphore].	^semaphore</body><body package="Swazoo-Messages">sendHeaderAndStartStreaming	self shouldSimulateStreaming ifTrue: [self error: 'simulated streaming not yet implemented!'].	self writeHeaderTo: self stream.	self stream flush. "to push sending of header immediately"	self shouldBeChunked ifTrue: [self stream setChunked]. 	self setStreaming.</body><body package="Swazoo-Messages">stream	^stream</body><body package="Swazoo-Messages">stream: aSwazooStream	stream := aSwazooStream</body><body package="Swazoo-Messages">testForOverflow	"if streaming but not chunking, then count must never be larger than announced length"	(self length notNil and: [self count &gt; self length]) 		ifTrue: [self error: 'streaming overflow']</body><body package="Swazoo-Messages">testForUnderflow	"if streaming but not chunking, then count must be exactly the announced length at the end"	(self length notNil and: [self count ~= self length]) 		ifTrue: [self error: 'not enough data streamed ']</body></methods><methods><class-id>Swazoo.HTTPStreamedResponse</class-id> <category>testing</category><body package="Swazoo-Messages">isCompressed	"gzip compressing the stream. Every nextPut: or nextPutAll: goes through gzipWriteStream, then to the client"	^compressed notNil and: [compressed]</body><body package="Swazoo-Messages">isStreamed	^true</body><body package="Swazoo-Messages">shouldBeChunked	^self isHttp11 and: [self length isNil]</body><body package="Swazoo-Messages">shouldSimulateStreaming	"stream to entity first then send all at once (because only now we know the length of response)"	^self isHttp10 and: [self length isNil]</body></methods><methods><class-id>Swazoo.HTTPStreamedResponse</class-id> <category>accessing-stream</category><body package="Swazoo-Messages">flush	"force sending to a TCP socket""	self isCompressed ifTrue: [self gzStream flush]. "	self stream flush</body><body package="Swazoo-Messages">nextPut: aCharacterOrByte	self isHeader ifTrue: [self sendHeaderAndStartStreaming].	self count: self count + 1.	self testForOverflow.	self isCompressed		ifTrue: 			[gzStream ifNil: [self initGzipStream]. 			self gzStream nextPut: aCharacterOrByte asInteger]		ifFalse: 			[self stream nextPut: aCharacterOrByte].	^aCharacterOrByte</body><body package="Swazoo-Messages">nextPutAll: aByteStringOrArray	self isHeader ifTrue: [self sendHeaderAndStartStreaming].	self count: self count + aByteStringOrArray size.	self testForOverflow.	self isCompressed		ifTrue: 			[gzStream ifNil: [self initGzipStream].  			self gzStream nextPutAll: aByteStringOrArray asByteArray]		ifFalse: 			[self stream nextPutAll: aByteStringOrArray].	^aByteStringOrArray</body></methods><methods><class-id>Swazoo.HTTPStreamedResponse</class-id> <category>accessing</category><body package="Swazoo-Messages">contentSize	self length notNil ifTrue: [^self length].	self entity notNil ifTrue: [self entity size].	^nil</body><body package="Swazoo-Messages">count	"how many bytes already streamed"	count isNil ifTrue: [self count: 0].	^count</body><body package="Swazoo-Messages">length	"how many bytes response is expected to have. 	This is optional, if set before streaming begin, then we stream without chunking (and 	therefore we can stream on HTTP 1.0 !)"	^length</body><body package="Swazoo-Messages">length: aNumber	length := aNumber</body></methods><methods><class-id>Swazoo.HTTPStreamedResponse</class-id> <category>waiting</category><body package="Swazoo-Messages">waitClose	"wait until all data is sent-streamed out and response is closed"	^self semaphore wait</body></methods><methods><class-id>Swazoo.HTTPStreamedResponse</class-id> <category>private-compression</category><body package="Swazoo-Messages">dontCompress	"disable gzip compressing the stream"	compressed := false</body><body package="Swazoo-Messages">enableCompression	"enable gzip compressing the stream"	compressed := true</body><body package="Swazoo-Messages">gzStream	"GZipWriteStream for gzip compressing"	^gzStream</body><body package="Swazoo-Messages">gzipEncoded	"Stream will be compressed with gzip before sending to the client"	"http://en.wikipedia.org/wiki/HTTP_compression"	super gzipEncoded.	self enableCompression</body><body package="Swazoo-Messages">initGzipStream	"GZipWriteStream for gzip compressing"	gzStream := HTTPResponse newGzipStreamOn: self stream.</body><body package="Swazoo-Messages">nilGzStream	gzStream := nil</body></methods><methods><class-id>Swazoo.HTTPStreamedResponse class</class-id> <category>instance creation</category><body package="Swazoo-Messages">on: aSwazooTask stream: aSwazooStream	^super ok		task: aSwazooTask;		stream: aSwazooStream;		initialize</body></methods><methods><class-id>Swazoo.SwazooURI</class-id> <category>testing</category><body package="Swazoo-HTTP">isDirectory	^self identifier last = $/</body></methods><methods><class-id>Swazoo.SwazooURI</class-id> <category>accessing</category><body package="Swazoo-HTTP">host	| ws |	ws := WriteStream on: String new.	ws nextPutAll: self hostname.	self port = self defaultPort 		ifFalse: 			[ws nextPut: $:.			self port printOn: ws].	^ws contents</body><body package="Swazoo-HTTP">host: aString 	| rs |	rs := ReadStream on: aString.	self hostname: (rs upTo: $: ).	rs atEnd ifFalse: [self port: rs upToEnd asNumber]</body><body package="Swazoo-HTTP">hostname	^hostname</body><body package="Swazoo-HTTP">hostname: aHostname 	hostname := aHostname</body><body package="Swazoo-HTTP">identifier	^identifier</body><body package="Swazoo-HTTP">identifier: anObject	identifier := anObject</body><body package="Swazoo-HTTP">identifierPath	| parts |	parts := (HTTPString subCollectionsFrom: self identifier delimitedBy: $/) 				collect: [:each | HTTPString decodedHTTPFrom: each].	(self identifier notEmpty and: [self identifier first = $/ ]) ifTrue: [parts addFirst: '/'].	^parts reject: [:each | each isEmpty]</body><body package="Swazoo-HTTP">identifierPathString	"^aStringI return the 'directory' part of the path name."	| sourceStream targetStream |	targetStream := WriteStream on: String new.	sourceStream := ReadStream on: self identifier.	[sourceStream atEnd] whileFalse: 			[| fragment |			fragment := sourceStream throughAll: '/'.			fragment last = $/ ifTrue: [targetStream nextPutAll: fragment]].	^targetStream contents</body><body package="Swazoo-HTTP">port	"^an IntegerThe port number defaults to 80 for HTTP."	^port isNil ifTrue: [80] ifFalse: [port]</body><body package="Swazoo-HTTP">port: anInteger 	port := anInteger</body><body package="Swazoo-HTTP">protocol	protocol isNil ifTrue: [self protocol: 'http'].	^protocol</body><body package="Swazoo-HTTP">protocol: aString	protocol := aString.</body><body package="Swazoo-HTTP">value	"1 halt: 'Use &gt;&gt;asString or &gt;&gt;printOn: instead'. "	^self asString</body></methods><methods><class-id>Swazoo.SwazooURI</class-id> <category>accessing-queries</category><body package="Swazoo-HTTP">includesQuery: aString 	| result |	result := self queries detect: [:aQuery | aQuery key = aString]				ifNone: [nil].	^result notNil</body><body package="Swazoo-HTTP">queries	"^an OrderedCollectionThis is an ordered colleciton of associations.  It can't be a dictionary, because it is legal to have many entries with the same key value."	queries isNil ifTrue: [queries := OrderedCollection new].	^queries</body><body package="Swazoo-HTTP">queries: anOrderedCollection 	"^selfThe queries must be an OrderedCollection of Associations c.f. &gt;&gt;queries"	queries := anOrderedCollection.	^self</body><body package="Swazoo-HTTP">queriesNamed: aString 	^self queries select: [:aQuery | aQuery key = aString]</body><body package="Swazoo-HTTP">queryAt: aString 	^self queryAt: aString ifAbsent: [nil]</body><body package="Swazoo-HTTP">queryAt: aString ifAbsent: aBlock 	"^aStringI return the value of the first query I find with the key aString.  If there are none I execute aBlock."	| result |	result := self queries detect: [:aQuery | aQuery key = aString]				ifNone: [aBlock].	^result == aBlock ifTrue: [aBlock value] ifFalse: [result value]</body></methods><methods><class-id>Swazoo.SwazooURI</class-id> <category>initialize-release</category><body package="Swazoo-HTTP">fromStream: sourceStream 	self readProtocolFrom: sourceStream.	self readHostFrom: sourceStream.	self readPortFrom: sourceStream.	self readIdentifierFrom: sourceStream.	self readQueryFrom: sourceStream.	^self</body><body package="Swazoo-HTTP">fromString: aString 	| sourceStream |	sourceStream := ReadStream on: (HTTPString decodedHTTPFrom: aString).	self fromStream: sourceStream.	^self</body></methods><methods><class-id>Swazoo.SwazooURI</class-id> <category>private</category><body package="Swazoo-HTTP">defaultPort	^80</body><body package="Swazoo-HTTP">readHostFrom: aStream 	"^selfI read the host name from the URI presumed to be in aStream.  The stream should be positioned right at the start, or just after the '//' of the protocol.  The host name is terminated by one of $:, $/, $? or the end of the stream depending on wether there is a port, path, query or nothing following the host.  If the host name is of zero length, I record a nil host name.  The stream is left positioned at the terminating character."	| hostnameStream |	aStream peek = $/ ifTrue: [^self]. "obivously no host in this stream"	hostnameStream := WriteStream on: String new.	[|nextCharacter| 	nextCharacter := aStream peek.	#($: $/ $? nil) includes: nextCharacter]		whileFalse: [hostnameStream nextPut: aStream next].	 hostnameStream contents isEmpty ifFalse: [hostname := hostnameStream contents].	^self</body><body package="Swazoo-HTTP">readIdentifierFrom: sourceStream 	self identifier: (sourceStream upTo: $?).	^self</body><body package="Swazoo-HTTP">readPortFrom: aStream 	"^selfI read the port nnumber from the URI presumed to be in aStream.  If a port number has been specified, the stream should be positioned right at before a $: charcter.  So, if the next chacter is a :, we have a port number.  I read up to one of $/, $? or the end of the stream depending on wether there is a path, query or nothing following the host.  The stream is left positioned at the terminating character."	| targetStream |	aStream peek = $/ ifTrue: [^self]. "obivously no port in this stream"	targetStream := WriteStream on: String new.	aStream peek == $: 		ifTrue: 			[| terminators |			terminators := Array 						with: $/						with: $?						with: nil.			aStream next.						[| nextCharacter |			nextCharacter := aStream peek.			terminators includes: nextCharacter] 					whileFalse: 						[| nextDigit |						nextDigit := aStream next.						nextDigit isDigit ifTrue: [targetStream nextPut: nextDigit]].			targetStream contents isEmpty 				ifFalse: [port := targetStream contents asNumber]].	^self</body><body package="Swazoo-HTTP">readProtocolFrom: aStream 	"^selfI read the protocol from the URI presumed to be in aStream.  The protocol preceeds '://' in the URI.  I leave the stream position either right after the '//' if there is a protocol, otherwise I reset the position to the start of the stream."	| candidateProtocol |	self protocol: 'http'. "by default"	aStream peek = $/ ifTrue: [^self]. "obviously no protocol in this stream"	candidateProtocol := aStream upTo: $:.	(aStream size - aStream position &gt;= 2 		and: [aStream next == $/ and: [aStream next == $/]]) 			ifTrue: [self protocol: candidateProtocol]			ifFalse: [aStream reset].	^self</body><body package="Swazoo-HTTP">readQueryFrom: sourceStream 	[sourceStream atEnd] whileFalse: 		[| nameValue name value |		nameValue := sourceStream upTo: $&amp; .		name := nameValue copyUpTo: $= .		value := nameValue readStream upTo: $= "if any"; upToEnd.		self queries add: name -&gt; (HTTPString decodedHTTPFrom: value)].	^self</body></methods><methods><class-id>Swazoo.SwazooURI</class-id> <category>printing</category><body package="Swazoo-HTTP">asString	| targetStream |	targetStream := WriteStream on: String new.	self printOn: targetStream.	^targetStream contents</body><body package="Swazoo-HTTP">printOn: targetStream 	(self hostname notNil and: [self protocol notNil]) 		ifTrue: 			[targetStream				nextPutAll: self protocol;				nextPutAll: '://'].	self hostname notNil ifTrue: [targetStream nextPutAll: self hostname].	(self hostname notNil and: [self port notNil and: [self port ~= 80]]) 		ifTrue: 			[targetStream				nextPut: $:;				nextPutAll: self port printString].	self identifier notNil ifTrue: [targetStream nextPutAll: self identifier].	self printQueriesOn: targetStream.	^self</body><body package="Swazoo-HTTP">printQueriesOn: targetStream 	| firstQuery |	self queries isEmpty 		ifFalse: 			[firstQuery := self queries at: 1.			targetStream				nextPut: $?;				nextPutAll: firstQuery key;				nextPut: $=;				nextPutAll: firstQuery value.			2 to: self queries size				do: 					[:queryIndex | 					| aQuery |					aQuery := self queries at: queryIndex.					targetStream						nextPut: $&amp;;						nextPutAll: aQuery key;						nextPut: $=;						nextPutAll: aQuery value]].	^self</body></methods><methods><class-id>Swazoo.SwazooURI class</class-id> <category>instance creation</category><body package="Swazoo-HTTP">fromString: aString	^self new fromString: aString</body><body package="Swazoo-HTTP">value: aString	^self new value: aString</body></methods><methods><class-id>Swazoo.HTTPGet</class-id> <category>testing</category><body package="Swazoo-Messages">isGet	^true</body></methods><methods><class-id>Swazoo.HTTPGet class</class-id> <category>accessing</category><body package="Swazoo-Messages">methodName	^'GET'</body></methods><methods><class-id>Swazoo.HTTPAuthenticationChallenge</class-id> <category>accessing</category><body package="Swazoo-Messages">resource	^resource</body><body package="Swazoo-Messages">resource: aResource	resource := aResource</body></methods><methods><class-id>Swazoo.HTTPAuthenticationChallenge</class-id> <category>challenging</category><body package="Swazoo-Messages">prepareAuthenticationChallenge	self subclassResponsibility</body></methods><methods><class-id>Swazoo.HTTPAuthenticationChallenge class</class-id> <category>instance creation</category><body package="Swazoo-Messages">newForResource: aResource	^aResource authenticationScheme = #Basic 		ifTrue: [HTTPAuthenticationBasicChallenge newForResource: aResource]		ifFalse: [aResource authenticationScheme = #Digest			ifTrue: [HTTPAuthenticationDigestChallenge newForResource: aResource]			ifFalse: [HTTPResponse unauthorized] ]</body></methods><methods><class-id>Swazoo.HTTPCookieField class</class-id> <category>accessing</category><body package="Swazoo-Headers">fieldName	^'Cookie'</body></methods><methods><class-id>Swazoo.HTTPCacheControlField</class-id> <category>printing</category><body package="Swazoo-Headers">valuesAsStringOn: aStream 	aStream nextPut: Character space.	self directives notNil ifTrue: [aStream nextPutAll: self directives].	self private notNil 		ifTrue: 			[self writePublicOrPrivateTo: aStream.			self maxAge notNil ifTrue: [aStream nextPutAll: ', ']].	self maxAge notNil ifTrue: [self writeMaxAgeTo: aStream].	^self</body><body package="Swazoo-Headers">writeMaxAgeTo: aStream 	"^selfI write the maxAge directive to aStream"	aStream nextPutAll: 'max-age='.	self maxAge printOn: aStream.	^self</body><body package="Swazoo-Headers">writePublicOrPrivateTo: aStream 	"^selfI write the either the public or the private directive to aStream"	self private 		ifTrue: [aStream nextPutAll: 'private']		ifFalse: [aStream nextPutAll: 'public'].	^self</body></methods><methods><class-id>Swazoo.HTTPCacheControlField</class-id> <category>accessing</category><body package="Swazoo-Headers">directives	"for easy setting directives in one string"	^directives</body><body package="Swazoo-Headers">directives: aString 	"for easy setting directives in one string"	"example: 'no-store, no-cache, must-revalidate'"	directives := aString</body><body package="Swazoo-Headers">maxAge	"^an Integer or nilI return my max age which is either an integer number of seconds for which the entity can be considdered fresh, or nil, in which case other headers such as Expires can be used by a cache to determine the expiration time of the entity."	^maxAge</body><body package="Swazoo-Headers">private	"^a Boolean or nilThere are three possible values for private.  Explicity true (the entity can only be cached in private caches), explicity false (this is a public entity and can be held in a shared/public cache perhaps even when stale) or nil (the default which means that the entity may be held in a public shared cache, but only until it goes stale)."	^private</body></methods><methods><class-id>Swazoo.HTTPCacheControlField</class-id> <category>services</category><body package="Swazoo-Headers">maxAge: anIntegerOrNil 	"^selfI record the number of seconds for which the resource is 'fresh' and after which will expire and become 'stale' for caching purposes.  Setting this to nil means the max age is unspecified, and this is the default.  This directive takes presidence over any Expires header when a cache or client is handling an HTTP message."	maxAge := anIntegerOrNil.	^self</body><body package="Swazoo-Headers">setNotPublicOrPrivate	"^selfI am being told that the entity in my message is not explicity public or private.  This is the default and means that public caches may retain copies of the resource, but should not be as relaxed about the rules as with an explicitly public resource. c.f &gt;&gt;setPublic &amp; &gt;&gt;setPrivate."	private := nil.	^self</body><body package="Swazoo-Headers">setPrivate	"^selfI am being told that the entity in my message is a private one that can only be cached on private caches, i.e. caches that can be drawn upon a single clients.  An example of a private cache is the one *inside* your web browser.   This is probably what you want if the entity contains personal information."	private := true.	^self</body><body package="Swazoo-Headers">setPublic	"^selfI am being told that the entity in my message is a public one that can be cached on public caches, i.e. caches that can be drawn upon by many clients.  This is probably not what you want if the entity contains personal information!  c.f. &gt;&gt;setPrivate  Note that expicitly setting cache-control public actually loosens some other rules and means resources can be used by cached beyond their normal life."	private := false.	^self</body></methods><methods><class-id>Swazoo.HTTPCacheControlField class</class-id> <category>accessing</category><body package="Swazoo-Headers">fieldName	^'Cache-Control'</body></methods><methods><class-id>Swazoo.WebSocketTest</class-id> <category>testing</category><body package="Swazoo-Tests">testWebSocket	"Shows a most common usage. More on http://www.swazoo.org/websocket"	| request webSocket response |	request := self upgradeRequest.	request isWebSocketRequest ifTrue:		["put here a check if allowed to upgrade, if not: ^HTTPResponse unauthorized"		webSocket := request webSocket.		response := webSocket answerTo: request].	self assert: request isWebSocketRequest.	self assert: response isWebSocketHandshake.</body></methods><methods><class-id>Swazoo.WebSocketTest</class-id> <category>testing-internals</category><body package="Swazoo-Tests">testChallengeCalculation	| challenge |	challenge  := SwazooWebSocket new calculateAcceptValueFrom: self challengeRequest.	self assert: challenge = 's3pPLMBiTxaQ9kYGzzhZRbK+xOo='</body><body package="Swazoo-Tests">testConnectionUpgrade	| connection |	connection := HTTPConnection new.	connection upgradeToWebSocket.	self assert: connection isWebSocketConnection.</body><body package="Swazoo-Tests">testFraming	| connection frame |	connection := WebSocketConnection new.	frame := connection frameString: '1234'.	self assert: frame = ((String with: 16r81 asCharacter with: 4 asCharacter), '1234')</body><body package="Swazoo-Tests">testHandshake	| response |	response := SwazooWebSocket new answerTo: self upgradeRequest.	self assert: response isWebSocketHandshake.	self assert: response statusLine = '101 WebSocket Protocol Handshake'.	self assert: (response headerValueAt: 'Upgrade') = 'websocket'.	self assert: (response headerValueAt: 'Connection') connectionToken = 'Upgrade'.</body></methods><methods><class-id>Swazoo.WebSocketTest</class-id> <category>support</category><body package="Swazoo-Tests">arrayFromHexString: aString	| array stream lookup |	lookup := '123456789ABCDEF'.	array := ByteArray new: aString size // 2.	stream := aString readStream.	1 to: array size do: [ :i || h l |		h := stream next.		h := h = $0 ifTrue: [0] ifFalse: [lookup indexOf: h].		l := stream next.		l := l = $0 ifTrue: [0] ifFalse: [lookup indexOf: l].		array at: i put: ((h bitShift: 4) bitOr: l) ].	^array</body><body package="Swazoo-Tests">challengeRequest	"to test challenge calculation"	| requestStream |	requestStream := SwazooStream on: String new.	requestStream		nextPutLine: 'GET / HTTP/1.1';		nextPutLine: 'Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==';		crlf.	^HTTPRequest readFrom: (SwazooStream on: requestStream writeBuffer contents)</body><body package="Swazoo-Tests">upgradeRequest	"first request is a HTTP one to upgrade connection from HTTP to WebSocket protocol"	"exact request from protocol standard https://tools.ietf.org/html/rfc6455"	| requestStream request |	requestStream := SwazooStream on: String new.	requestStream		nextPutLine: 'GET /chat HTTP/1.1';		nextPutLine: 'Host: server.example.com';		nextPutLine: 'Upgrade: websocket';		nextPutLine: 'Connection: Upgrade';		nextPutLine: 'Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==';		nextPutLine: 'Origin: http://example.com';		nextPutLine: 'Sec-WebSocket-Protocol: chat, superchat';		nextPutLine: 'Sec-WebSocket-Version: 13';		crlf.	request := HTTPRequest readFrom: (SwazooStream on: requestStream writeBuffer contents).	request task: (SwazooTask newOn: request).	request task connection: HTTPConnection new.	^request</body></methods><methods><class-id>Swazoo.SwazooURITest</class-id> <category>running</category><body package="Swazoo-Tests">setUp	fooURI := SwazooURI fromString: 'www.foo.com/index.html'.	queryURI := SwazooURI fromString: 'www.foo.com/index.html?foo=1&amp;bar=hi'.	barURI := SwazooURI fromString: 'www.bar.com:8080/files/'</body><body package="Swazoo-Tests">testHostname	self assert: fooURI hostname = 'www.foo.com'.	self assert: queryURI hostname = 'www.foo.com'.	self assert: barURI hostname = 'www.bar.com'</body><body package="Swazoo-Tests">testIdentifier	self assert: fooURI identifier = '/index.html'.	self assert: queryURI identifier = '/index.html'.	self assert: barURI identifier = '/files/'</body><body package="Swazoo-Tests">testIdentifierPath	self assert: fooURI identifierPath 				= (OrderedCollection with: '/' with: 'index.html').	self assert: queryURI identifierPath 				= (OrderedCollection with: '/' with: 'index.html').	self 		assert: barURI identifierPath = (OrderedCollection with: '/' with: 'files')</body><body package="Swazoo-Tests">testIsDirectory	self deny: fooURI isDirectory.	self deny: queryURI isDirectory.	self assert: barURI isDirectory</body><body package="Swazoo-Tests">testPort	self assert: fooURI port = 80.	self assert: queryURI port = 80.	self assert: barURI port = 8080</body><body package="Swazoo-Tests">testQueries	self deny: (queryURI includesQuery: 'hi').	self assert: (queryURI includesQuery: 'foo').	self assert: (queryURI includesQuery: 'bar').	self assert: (queryURI queryAt: 'foo') = '1'.	self assert: (queryURI queryAt: 'bar') = 'hi'</body><body package="Swazoo-Tests">testValue	self assert: fooURI value = 'http://www.foo.com/index.html'.	self assert: queryURI value = 'http://www.foo.com/index.html?foo=1&amp;bar=hi'.	self assert: barURI value = 'http://www.bar.com:8080/files/'</body></methods><methods><class-id>Swazoo.HTTPSetCookieField</class-id> <category>printing</category><body package="Swazoo-Headers">valuesAsStringOn: aStream 	aStream nextPutAll: (self cookies at: 1).	2 to: self cookies size		do: 			[:cookieIndex | 			aStream				nextPutAll: ', ';				nextPutAll: (self cookies at: cookieIndex)].	^self</body></methods><methods><class-id>Swazoo.HTTPSetCookieField</class-id> <category>services</category><body package="Swazoo-Headers">addCookie: aCookieString	^self cookies add: aCookieString</body><body package="Swazoo-Headers">combineWith: aSetCookieField 	"^selfI add the cookies of aSetCookieField to my own collection of cookies."	self cookies addAll: aSetCookieField cookies.	^self</body></methods><methods><class-id>Swazoo.HTTPSetCookieField</class-id> <category>accessing</category><body package="Swazoo-Headers">cookies	cookies isNil ifTrue: [cookies := OrderedCollection new].	^cookies</body></methods><methods><class-id>Swazoo.HTTPSetCookieField class</class-id> <category>accessing</category><body package="Swazoo-Headers">fieldName	^'Set-Cookie'</body></methods><methods><class-id>Swazoo.HelloWorldResourceTest</class-id> <category>running</category><body package="Swazoo-Tests">setUp	hello := HelloWorldResource uriPattern: 'hello.html'</body></methods><methods><class-id>Swazoo.HelloWorldResourceTest</class-id> <category>testing</category><body package="Swazoo-Tests">testResponse	| request response |	request := HTTPGet request: 'hello.html'.	response := URIResolution resolveRequest: request startingAt: hello.	self assert: response statusCode = 200.	self assert: request resourcePath size = 1.	self assert: request resourcePath first = 'hello.html'</body></methods><methods><class-id>Swazoo.SwazooBuffer</class-id> <category>writing-chunked</category><body package="Swazoo-HTTP">closeChunkTo: aSocket	"a zero sized chunk determine and end of chunked data and also response"	"pack all together to send one TCP packet ony"	| chunk written |	chunk := ByteString new: 5.	chunk at: 1 put: $0 .	chunk at: 2 put: Character cr. "first crlf ends 0 length line "	chunk at: 3 put: Character lf.	chunk at: 4 put: Character cr. "second crlf ends whole response"	chunk at: 5 put: Character lf.	written := aSocket writeFrom: chunk asByteArray startingAt: 1 for: chunk size.	written = chunk size ifFalse: [self error: 'socket write error'].</body><body package="Swazoo-HTTP">flushChunkTo: aSocket	"a buffer will be sent as a chunk, with hex size in first line then crlf, then a buffer, then crlf"	"send a complete chunk in one piece, don't partition TCP sending in too many packets!"	| length |	 self size &gt; 16rFFFF ifTrue: [self error: 'chunk too long!']. "preamble has no room for bigger"	length := self size printStringRadix: 16.	SpEnvironment isSqueak ifTrue: [length := length copyFrom: 4 to: length size]. "trim 16r"	1 to: length size do: [:inx | collection at: inx put: (length at: inx) asInteger].	 (length size+1) to: 4 do: [:inx | collection at: inx put: $ asInteger]. "add spaces"	collection at: 5 put: Character cr asInteger.	collection at: 6 put: Character lf asInteger.	"add finishing crlf to buffer"	self nextPut: Character cr asInteger.	self nextPut: Character lf asInteger.	self flushTo: aSocket chunked: true. "flush all at once"</body></methods><methods><class-id>Swazoo.SwazooBuffer</class-id> <category>initialize-release</category><body package="Swazoo-HTTP">initDefaultBuffer	"VW specific"	| size |	size := self isWrite		ifTrue: [self class defaultBufferSize + self class preambleSize + 2] "possible chunk crlf"		ifFalse: [self class defaultBufferSize].	collection := ByteArray new: size.	self isWrite ifTrue: [self initPreamble].</body><body package="Swazoo-HTTP">initLargeBuffer	"VW specific"	| size |	size := self isWrite		ifTrue: [self class largeBufferSize + self class preambleSize + 2] "possible chunk crlf"		ifFalse: [self class largeBufferSize].	collection := ByteArray new: size.	self isWrite ifTrue: [self initPreamble].</body><body package="Swazoo-HTTP">initPreamble	"make room for possible chunk 'preamble' = length line"	position := self class preambleSize.</body><body package="Swazoo-HTTP">readClear	"reset as you'd make another one, just don't replace content array"	position := 0.	readLimit := self class defaultBufferSize.</body><body package="Swazoo-HTTP">setRead	type := #read</body><body package="Swazoo-HTTP">setWrite	type := #write</body><body package="Swazoo-HTTP">writeClear	"reset as you'd make another one, just don't replace content array"	self reset.	readLimit := 0.	self initPreamble.</body></methods><methods><class-id>Swazoo.SwazooBuffer</class-id> <category>writing</category><body package="Swazoo-HTTP">flushTo: aSocket	"actually write to the tcp socket as direclty as possible"	self flushTo: aSocket chunked: false.</body></methods><methods><class-id>Swazoo.SwazooBuffer</class-id> <category>accessing</category><body package="Swazoo-HTTP">contents	"Answer a copy of the receiver's collection, skipping preamble."	readLimit := readLimit max: position.	^collection copyFrom: self class preambleSize+1 to: readLimit</body><body package="Swazoo-HTTP">readContents	^(position = 0 and: [readLimit = self class defaultBufferSize]) "whole buffer?"		ifTrue: [collection] "avoid copying for performance"		ifFalse: [collection copyFrom: position+1 to: readLimit]</body><body package="Swazoo-HTTP">size	"how many elements is currently in buffer"	^position-self class preambleSize</body></methods><methods><class-id>Swazoo.SwazooBuffer</class-id> <category>testing</category><body package="Swazoo-HTTP">atEnd	^super atEnd "for now"</body><body package="Swazoo-HTTP">isBinary	^collection class == ByteArray</body><body package="Swazoo-HTTP">isFull	"buffer full or even more"	^position &gt;= self class defaultBufferSize</body><body package="Swazoo-HTTP">isRead	^type = #read</body><body package="Swazoo-HTTP">isWrite	^type = #write</body></methods><methods><class-id>Swazoo.SwazooBuffer</class-id> <category>mime boundary</category><body package="Swazoo-HTTP">copyBufferTo: anIndex	"from current position to desired index"	| start |	start := position+1.	position := anIndex.	^collection copyFrom: start to: anIndex.</body><body package="Swazoo-HTTP">indexOfBoundary: aBoundaryBytes	"index of boundary start, beeing full boundary or part at the end of buffer. 0 if not found"	| inx innerInx firstInx |	inx := position+1.	[inx &lt;= readLimit] whileTrue:		[innerInx := 1. firstInx := inx.		[(aBoundaryBytes at: innerInx) = (collection at: inx)] whileTrue:			[innerInx = aBoundaryBytes size ifTrue: [^firstInx]. "full boundary found"			inx = readLimit ifTrue: [^firstInx].  "partial boundary at the edge of buffer found"			inx := inx+1. innerInx := innerInx+1].		inx := inx+1].	^0</body><body package="Swazoo-HTTP">signsOfBoundary: aBoundaryBytes	"detect as fast as possible if any if not all MIME part boundary is present in buffer contents"	"return number of bundary bytes detected, 0 = no boundary"	| first index |	first := aBoundaryBytes first.	"fast test"	((self position+1 to: readLimit) contains: [:inx | (collection at: inx) = first]) ifFalse: [^0].	"full or partial boundary on the edge of buffer test"	index := self indexOfBoundary: aBoundaryBytes. "index of full, or partial boundary at the edge"	index = 0 ifTrue: [^0]. "no boundary found"	readLimit-index &gt;= aBoundaryBytes size ifTrue: [^aBoundaryBytes size]. "full boundary detected"	^readLimit-index+1  "partial boundary at the end of buffer"</body><body package="Swazoo-HTTP">startsWith: aPartialBoundaryBytes	"is remaining part of MIME part boundary at the start of buffer?"	1 to: aPartialBoundaryBytes size do: [:inx |		(collection at: position+inx) = (aPartialBoundaryBytes at: inx) ifFalse: [^false] ].	^true</body></methods><methods><class-id>Swazoo.SwazooBuffer</class-id> <category>private-resizing</category><body package="Swazoo-HTTP">isEnlarged	^collection size &gt; self class defaultBufferSize</body><body package="Swazoo-HTTP">resizeBuffer	"actually do a buffer resize"	self shouldEnlarge ifTrue: [^self initLargeBuffer].	self shouldShrink ifTrue: [^self initDefaultBuffer].</body><body package="Swazoo-HTTP">resizeEnlarge	"request resizing buffer to larger size at the next fill or flush"	resize := #enlarge</body><body package="Swazoo-HTTP">resizeNil	"nil resizing command"	resize := nil</body><body package="Swazoo-HTTP">resizeShrink	"request shrinking buffer to default size at the next fill or flush"	resize := #shrink</body><body package="Swazoo-HTTP">shouldEnlarge	"should be resized buffer to larger size?"	^resize = #enlarge</body><body package="Swazoo-HTTP">shouldResize	^resize notNil</body><body package="Swazoo-HTTP">shouldShrink	"should be resized buffer to default size?"	^resize = #shrink</body></methods><methods><class-id>Swazoo.SwazooBuffer</class-id> <category>reading</category><body package="Swazoo-HTTP">refillFrom: aSocket	"reset and read from to the tcp socket as direclty as possible 	(directly from stream's instvar collection)"	| actuallyRead pastPos pastReadLimit |	aSocket isNil ifTrue: [^self]. "if SwazooStream is used for tests only"	pastPos := position. pastReadLimit := readLimit. "for debugging purposes only!"	self readClear. "just reset pointers, not a collection! "	self shouldResize ifTrue: [self resizeBuffer; resizeNil]. "enlarge or shrink buffer if requested"	actuallyRead := 0.  "this localvar is temporary, for debugging hard to find bug"	actuallyRead "nr. of actuall bytes read ":= aSocket		readInto: collection startingAt: 1 for: collection size.	readLimit := actuallyRead.	self atEnd ifTrue: 		[SwazooStreamNoDataError raiseSignal: 'No data available.  Socket probably closed']</body></methods><methods><class-id>Swazoo.SwazooBuffer</class-id> <category>private-sending</category><body package="Swazoo-HTTP">flushTo: aSocket chunked: chunkedBoolean	"actually write to the tcp socket as direclty as possible 	(directly from stream's instvar collection)"	| remaining start written |	remaining := chunkedBoolean 		ifTrue: [position]  "ensure to send preamble too"		ifFalse: [position-self class preambleSize]. "skip preamble"	[remaining &gt; 0] whileTrue: 		[start := position-remaining+1.		written := aSocket 			writeFrom: collection startingAt: start for: (position-start+1).		remaining := remaining-written].	self writeClear.	self shouldResize ifTrue: [self resizeBuffer; resizeNil]. "enlarge or shrink buffer if requested"</body></methods><methods><class-id>Swazoo.SwazooBuffer class</class-id> <category>defaults</category><body package="Swazoo-HTTP">defaultBufferSize	"length of buffer at creation. Later not nessesary exactly this number! "	^8000 "about 8KB-preamble"</body><body package="Swazoo-HTTP">largeBufferSize	"size of buffer for large uploads/downloads"	^1000000	"about 1MB"</body><body package="Swazoo-HTTP">preambleSize	"chunk size line (fixed to 4 hex characters) + crlf"	^6</body></methods><methods><class-id>Swazoo.SwazooBuffer class</class-id> <category>instance creation</category><body package="Swazoo-HTTP">newRead	^(super on: Array new) setRead; initDefaultBuffer</body><body package="Swazoo-HTTP">newWrite	^(super on: Array new) setWrite;  initDefaultBuffer</body><body package="Swazoo-HTTP">on: aByteStringOrArray	^(self with: aByteStringOrArray) position: 0</body></methods><methods><class-id>Swazoo.ContentDispositionField</class-id> <category>private</category><body package="Swazoo-Headers">parseValueFrom: aString 	| sourceStream |	sourceStream := aString readStream.	type := HTTPString trimBlanksFrom: (sourceStream upTo: $;).	parameters := self readParametersFrom: sourceStream.	^self</body></methods><methods><class-id>Swazoo.ContentDispositionField</class-id> <category>testing</category><body package="Swazoo-Headers">isContentDisposition	^true</body></methods><methods><class-id>Swazoo.ContentDispositionField</class-id> <category>services</category><body package="Swazoo-Headers">parameterAt: aString 	^parameters at: aString ifAbsent: [nil]</body></methods><methods><class-id>Swazoo.ContentDispositionField class</class-id> <category>accessing</category><body package="Swazoo-Headers">fieldName	^'Content-Disposition'</body></methods><methods><class-id>Swazoo.SwazooWebSocket</class-id> <category>private</category><body package="Swazoo-HTTP">answerTo: aHTTPRequest	aHTTPRequest isConnectionUpgrade ifFalse: [^HTTPResponse forbidden].	connection := aHTTPRequest task connection.	self connection: connection.	connection webSocket: self.	connection upgradeToWebSocketAfterResponse.	^self handshakeResponseTo: aHTTPRequest.</body><body package="Swazoo-HTTP">asByteArray: anInteger	"32bit integer into 4 bytes, big endian"	"Implemented here because VW 7.8 depreceate that method because it is ambigious. Agreed!"	| stream |	stream := ByteArray new writeStream.	anInteger digitLength to: 1 by: -1 do: [:digitIndex |		stream nextPut: (anInteger digitAt: digitIndex)].	^ stream contents"(SwazooWebSocket new asByteArray: 420453648) = #[25 15 157 16] "</body><body package="Swazoo-HTTP">connection: aWebSocketConnection	connection := aWebSocketConnection</body><body package="Swazoo-HTTP">receiveBlock	recBlock ifNil: [self receiveBlock: self defaultReceiveBlock].	^recBlock</body><body package="Swazoo-HTTP">version: aNumber	"WebSocket protocol version"	version := aNumber</body></methods><methods><class-id>Swazoo.SwazooWebSocket</class-id> <category>private-handshake</category><body package="Swazoo-HTTP">base64From: aByteArray 	"VW specific"	^FastBase64Encoding encodeAsBase64String: aByteArray"SwazooWebSocket new base64From: (SwazooWebSocket new shaHashFrom: ' 258EAFA5')"</body><body package="Swazoo-HTTP">calculateAcceptValueFrom:  aHTTPRequest	| key string hash |	key := (aHTTPRequest headerAt: 'Sec-WebSocket-Key' ifAbsent: []) value.	key = nil ifTrue: [^nil].	string := key, '258EAFA5-E914-47DA-95CA-C5AB0DC85B11'.	hash := self shaHashFrom: string.	^self base64From: hash</body><body package="Swazoo-HTTP">handshakeResponseTo: aHTTPRequest	"this implementation only supports version 13"	| response header |	header := (aHTTPRequest headerValueAt: 'Sec-WebSocket-Version').	header notNil ifTrue: [self version:  header asNumber].	self version = 13 ifFalse: [  "only version 13 (final RFC) currently supported!" 		response := HTTPResponse badRequest.		response addHeaderName: 'Sec-WebSocket-Version' value: '13'.		^response].	response := HTTPResponse webSocketHandshake.	response addHeaderName: 'Upgrade' value: 'websocket'.	response headers addField: (HTTPConnectionField new setToUpgrade)."	response addHeaderName: 'Sec-WebSocket-Origin' value: (aHTTPRequest headerValueAt: 'Origin'). ""	response addHeaderName: 'Sec-WebSocket-Location' value: (self prepareLocationFrom: aHTTPRequest).  "	header := aHTTPRequest headerValueAt: 'Sec-WebSocket-Protocol'.	header notNil ifTrue: 		[response addHeaderName: 'Sec-WebSocket-Protocol' value: header value].	response addHeaderName: 'Sec-WebSocket-Accept' value: (self calculateAcceptValueFrom: aHTTPRequest).	response body: ''.	^response</body><body package="Swazoo-HTTP"> prepareLocationFrom: aHTTPRequest	| portString |	portString := (aHTTPRequest port ~= 80)		ifTrue: [':', aHTTPRequest port printString]		ifFalse: [''].	^'ws://', aHTTPRequest host, portString, aHTTPRequest urlString.</body><body package="Swazoo-HTTP">shaHashFrom: aByteString	"VW specific"	^Security.SHA hashFrom: aByteString asByteArray readStream."SwazooWebSocket new shaHashFrom: '258EAFA5-E914-47DA-95CA-C5AB0DC85B11' "</body></methods><methods><class-id>Swazoo.SwazooWebSocket</class-id> <category>accessing</category><body package="Swazoo-HTTP">connection	"a WebSocket connection to send and receive messages"	^connection</body><body package="Swazoo-HTTP">version	"WebSocket protocol version"	^version</body></methods><methods><class-id>Swazoo.SwazooWebSocket</class-id> <category>testing</category><body package="Swazoo-HTTP">isOpen	"is WebSocket connection open?"	^self connection notNil and: [self connection isOpen]</body></methods><methods><class-id>Swazoo.SwazooWebSocket</class-id> <category>defaults</category><body package="Swazoo-HTTP">defaultReceiveBlock	"echo every message received"	^[:message | self send: message]</body></methods><methods><class-id>Swazoo.SwazooWebSocket</class-id> <category>sending-receiving</category><body package="Swazoo-HTTP">close	self connection notNil ifTrue: 		[self connection close. 		self connection: nil].	self receiveBlock: nil.</body><body package="Swazoo-HTTP">receiveBlock: aBlock	"register a block to handle a message received"	" [:message | do something with that message, plain Unicode text string]"	recBlock := aBlock</body><body package="Swazoo-HTTP">send: aString 	"an Unicode string (don't UTF8 encode it in advance!)"	^self connection sendMessage: aString</body></methods><methods><class-id>Swazoo.HTTPLocationField</class-id> <category>printing</category><body package="Swazoo-Headers">valuesAsStringOn: aStream 	self uri printOn: aStream.	^self</body></methods><methods><class-id>Swazoo.HTTPLocationField</class-id> <category>accessing</category><body package="Swazoo-Headers">uri	^uri</body><body package="Swazoo-Headers">uri: aSwazooURI 	uri := aSwazooURI.	^self</body><body package="Swazoo-Headers">uriString: aString 	uri := SwazooURI fromString: aString.	^self</body></methods><methods><class-id>Swazoo.HTTPLocationField class</class-id> <category>accessing</category><body package="Swazoo-Headers">fieldName	^'Location'</body></methods><methods><class-id>Swazoo.SwazooCacheControlTest</class-id> <category>testing</category><body package="Swazoo-Tests">testIfModifiedSinceModified	| response timestampInThePast |	request := HTTPGet request: 'foo/abc.html'.	timestampInThePast := SpTimestamp fromDate: (Date today subtractDays: 1)				andTime: Time now.	request headers addField: (HTTPIfModifiedSinceField new 				valueFrom: timestampInThePast asRFC1123String).	cacheControl := SwazooCacheControl new request: request				cacheTarget: cacheTarget.	self assert: cacheControl isNotModified not.	self assert: cacheControl isIfModifiedSince.	response := HTTPResponse ok.	cacheControl addResponseHeaders: response.	self 		assert: (response headers fieldNamed: 'ETag') entityTag = cacheTarget etag.	self assert: (response headers fieldNamed: 'Last-Modified') timestamp 				= cacheTarget lastModified</body><body package="Swazoo-Tests">testIfModifiedSinceNot	| response |	request headers addField: (HTTPIfModifiedSinceField new 				valueFrom: cacheTarget lastModified asRFC1123String).	self assert: cacheControl isNotModified.	self assert: cacheControl isIfModifiedSince not.	response := HTTPResponse notModified.	cacheControl addResponseHeaders: response.	self 		assert: (response headers fieldNamed: 'ETag') entityTag = cacheTarget etag.	self assert: (response headers fieldNamed: 'Last-Modified') timestamp 				= cacheTarget lastModified</body><body package="Swazoo-Tests">testIfNoneMatchHeaderMatch	"same etag"	| response |	request headers addField: (HTTPIfNoneMatchField new addEntityTag: cacheTarget etag).	self assert: cacheControl isNotModified.	self deny: cacheControl isIfNoneMatch.	"do NOT include last-modified"	response := HTTPResponse notModified.	cacheControl addResponseHeaders: response.	self assert: (response headers fieldNamed: 'ETag') entityTag = cacheTarget etag.	self assert: (response headers fieldNamed: 'Last-Modified' ifNone: [nil])  isNil</body><body package="Swazoo-Tests">testIfNoneMatchHeaderNone	"same etag"	| response |	request := HTTPGet request: 'foo/abc.html'.	request headers addField: (HTTPIfNoneMatchField new valueFrom: 'blah').	cacheControl := SwazooCacheControl new request: request				cacheTarget: cacheTarget.	self assert: cacheControl isNotModified not.	self assert: cacheControl isIfNoneMatch.	response := HTTPResponse ok.	cacheControl addResponseHeaders: response.	self 		assert: (response headers fieldNamed: 'ETag') entityTag = cacheTarget etag.	self assert: (response headers fieldNamed: 'Last-Modified') timestamp 				= cacheTarget lastModified</body><body package="Swazoo-Tests">testNoHeaders	| response |	self assert: cacheControl isNotModified not.	self assert: cacheControl isIfNoneMatch.	self assert: cacheControl isIfModifiedSince.	"add both"	response := HTTPResponse ok.	cacheControl addResponseHeaders: response.	self 		assert: (response headers fieldNamed: 'ETag') entityTag = cacheTarget etag.	self assert: (response headers fieldNamed: 'Last-Modified') timestamp 				= cacheTarget lastModified</body></methods><methods><class-id>Swazoo.SwazooCacheControlTest</class-id> <category>running</category><body package="Swazoo-Tests">setUp	| directory firstFile ws |	directory := SpFilename named: 'fResTest'.	directory exists ifFalse: [directory makeDirectory].	firstFile := directory construct: 'abc.html'.	ws := firstFile writeStream.	[ws nextPutAll: 'hello'] ensure: [ws close].	resource := FileResource uriPattern: 'foo' filePath: 'fResTest'.	request := HTTPGet request: 'foo/abc.html'.	URIResolution resolveRequest: request startingAt: resource.	cacheControl := SwazooCacheControl new request: request				cacheTarget: (cacheTarget := resource fileFor: request)</body><body package="Swazoo-Tests">tearDown	((SpFilename named: 'fResTest') construct: 'abc.html') delete.	(SpFilename named: 'fResTest') delete</body></methods><methods><class-id>Swazoo.HTTPETagField</class-id> <category>printing</category><body package="Swazoo-Headers">valuesAsStringOn: aStream 	aStream		nextPut: $";		nextPutAll: self entityTag;		nextPut: $".	^self</body></methods><methods><class-id>Swazoo.HTTPETagField</class-id> <category>accessing</category><body package="Swazoo-Headers">entityTag	^entityTag</body><body package="Swazoo-Headers">entityTag: aString 	entityTag := aString.	^self</body></methods><methods><class-id>Swazoo.HTTPETagField class</class-id> <category>accessing</category><body package="Swazoo-Headers">fieldName	^'ETag'</body></methods><methods><class-id>Swazoo.WebSocketConnection</class-id> <category>testing</category><body package="Swazoo-HTTP">isHTTPConnection	^false</body><body package="Swazoo-HTTP">isWebSocketConnection	^true</body></methods><methods><class-id>Swazoo.WebSocketConnection</class-id> <category>private-serving</category><body package="Swazoo-HTTP">getAndDispatchMessages	self stream anyDataReady  "wait for data and if anything read, proceed"		ifTrue:			[self receiveMessage]		ifFalse: 			[(Delay forMilliseconds: 100) wait. "to finish sending, if any"			self close].</body></methods><methods><class-id>Swazoo.WebSocketConnection</class-id> <category>private-framing</category><body package="Swazoo-HTTP">frameString: aString	"This is currently only used to satisfy the unit test, actual framing is done differently (which should be reflected in the test soon)"	| out len utf8String |	utf8String := self toUtf8: aString.	out := WriteStream on: (String new: utf8String size + 16).	out nextPut: 129 asCharacter.	"text frame, FIN=1, RSV1,RSV2,RSV3 all zero"	len := utf8String size.	len &lt;= 125		ifTrue: [out nextPut: len asCharacter.	"7 bits, MASK = 0"]		ifFalse: [			len &lt; 65536				ifTrue: [out nextPut: 126 asCharacter; nextNumber: 2 put: len]				ifFalse: [out nextPut: 127 asCharacter; nextNumber: 8 put: len]].	out nextPutAll: utf8String.	^out contents</body><body package="Swazoo-HTTP">fromUtf8: aString	"VW specific"	^(EncodedStream 		on: aString asIntegerArray readStream 		encodedBy: (StreamEncoder new: #'UTF_8')) 			contents</body><body package="Swazoo-HTTP">toUtf8: aString	"VW specific"	^([aString asByteArrayEncoding: #'UTF_8'] 		on: Error do: [:ex | ^aString]) 			asByteString</body></methods><methods><class-id>Swazoo.WebSocketConnection</class-id> <category>sending-receiving</category><body package="Swazoo-HTTP">handleBinaryMessage: aByteString	self webSocket receiveBlock value: aByteString asByteArray</body><body package="Swazoo-HTTP">handleCloseMessage: aByteString	"not used right now"</body><body package="Swazoo-HTTP">handleContinuationMessage: aByteString	"not used right now"</body><body package="Swazoo-HTTP">handlePingMessage: aByteString	self sendFramedData: aByteString opcode: 10</body><body package="Swazoo-HTTP">handlePongMessage: aByteString	"not used right now"</body><body package="Swazoo-HTTP">handleTextMessage: aByteString	self webSocket receiveBlock value: (self fromUtf8: aByteString)</body><body package="Swazoo-HTTP">receiveMessage	| message flags maskingKey mask len b opc |	[		flags := self stream next asInteger.		len := self stream next asInteger.		mask := len &gt;= 128.		len := len bitAnd: 127.		len &gt; 125 ifTrue: [len := self stream nextNumber: (len = 126 ifTrue: [2] ifFalse: [8])].		mask ifTrue: [maskingKey := self stream next: 4].		flags &lt; 128 ifTrue: [self close. self halt: 'FIN not set'].		message := self stream next: len.		mask ifTrue: [			1 to: len do: [:i |				b := message byteAt: i.				b := b bitXor: (maskingKey byteAt: i-1\\4+1).				message byteAt: i put: b]].		opc := flags bitAnd: 15.		opc = 0 ifTrue: [self handleContinuationMessage: message].		opc = 1 ifTrue: [self handleTextMessage: message].		opc = 2 ifTrue: [self handleBinaryMessage: message].		opc = 8 ifTrue: [self handleCloseMessage: message].		opc = 9 ifTrue: [self handlePingMessage: message].		opc = 10 ifTrue: [self handlePongMessage: message]	] 		on: Error 		do: [:ex | self close]</body><body package="Swazoo-HTTP">sendFramedData: data opcode: opc	| len |	[self stream nextPut: 128 + opc.	len := data size.	len &lt;= 125		ifTrue: [self stream nextPut: len]		ifFalse: [			len &lt; 65536				ifTrue: [self stream nextPut: 126; nextNumber: 2 put: len]				ifFalse: [self stream nextPut: 127; nextNumber: 8 put: len]].	[self stream nextPutAll: data; flush]		on: Error		do: [:ex | "ignore"]	]		ifCurtailed: [self close]</body><body package="Swazoo-HTTP">sendMessage: aStringOrByteArray	aStringOrByteArray isString		ifTrue: [self sendFramedData: (self toUtf8: aStringOrByteArray) opcode: 1]		ifFalse: [self sendFramedData: aStringOrByteArray opcode: 2]</body></methods><methods><class-id>Swazoo.HTTPRequestTest</class-id> <category>private</category><body package="Swazoo-Tests">crlfOn: aStream 	aStream		nextPut: Character cr;		nextPut: Character lf</body></methods><methods><class-id>Swazoo.HTTPRequestTest</class-id> <category>testing-gets</category><body package="Swazoo-Tests">testBasicGet	request := self basicGet.	self assert: request isGet.	self assert: request isHttp11.	self deny: request isHead.	self deny: request isPost.	self deny: request isPut</body><body package="Swazoo-Tests">testBasicGetHTTP10	request := self basicGetHTTP10.	self assert: request isGet.	self assert: request isHttp10.	self deny: request isHead.	self deny: request isPost.	self deny: request isPut</body><body package="Swazoo-Tests">testBasicGetHost	request := self basicGet.	self assert: request host = 'foo.com'</body><body package="Swazoo-Tests">testBasicGetPort	request := self basicGet.	self assert: request port = 80</body><body package="Swazoo-Tests">testBasicHead	request := self basicHead.	self assert: request isHead.	self deny: request isGet.	self deny: request isPost.	self deny: request isPut</body><body package="Swazoo-Tests">testGetMultiValueHeader	| header |	request := self getMultiValueHeader.	header := request headerAt: 'Content-Type' ifAbsent: [nil].	self assert: header mediaType = 'multipart/form-data'.	self assert: (header transferCodings at: 'boundary') = '--boundary'.	self assert: header valuesAsString = 'multipart/form-data; boundary=--boundary'." 'Content-Type: multipart/form-data; boundary= --boundary'; "</body><body package="Swazoo-Tests">testPortedGetPort	request := self portedGet.	self assert: request port = 8888</body></methods><methods><class-id>Swazoo.HTTPRequestTest</class-id> <category>requests-gets</category><body package="Swazoo-Tests">basicGet	| requestStream |	requestStream := SwazooStream on: String new.	requestStream		nextPutLine: 'GET / HTTP/1.1';		nextPutLine: 'Host: foo.com';		crlf.	^HTTPRequest readFrom: (SwazooStream on: requestStream writeBuffer contents)</body><body package="Swazoo-Tests">basicGetHTTP10	| requestStream |	requestStream := SwazooStream on: String new.	requestStream		nextPutLine: 'GET / HTTP/1.0';		crlf.	^HTTPRequest readFrom: (SwazooStream on: requestStream writeBuffer contents)</body><body package="Swazoo-Tests">basicGetHTTP10Keepalive	| requestStream |	requestStream := SwazooStream on: String new.	requestStream		nextPutLine: 'GET / HTTP/1.0';		nextPutLine: 'Connection: Keep-Alive';		crlf.	^HTTPRequest readFrom: (SwazooStream on: requestStream writeBuffer contents)</body><body package="Swazoo-Tests">basicHead	| requestStream |	requestStream := SwazooStream on: String new.	requestStream		nextPutLine: 'HEAD / HTTP/1.1';		nextPutLine: 'Host: foo.com';		crlf.	^HTTPRequest readFrom: (SwazooStream on: requestStream writeBuffer contents)</body><body package="Swazoo-Tests">fullGet	| requestStream |	requestStream := SwazooStream on: String new.	requestStream		nextPutLine: 'GET /aaa/bbb/ccc.html?foo=bar&amp;baz=quux HTTP/1.1';		nextPutLine: 'Connection: Keep-Alive';		nextPutLine: 'User-Agent: Mozilla/4.72 [en] (X11; I; Linux 2.3.51 i686)';		nextPutLine: 'Host: foo.com:8888';		nextPutLine: 'Referer: http://www.bar.com/takeMeThere.html';		crlf.	^HTTPRequest readFrom: (SwazooStream on: requestStream writeBuffer contents)</body><body package="Swazoo-Tests">getMultiValueHeader	| requestStream |	requestStream := SwazooStream on: String new.	requestStream		nextPutLine: 'GET /aaa/bbb/ccc.html?foo=bar&amp;baz=quux HTTP/1.1';		nextPutLine: 'Content-Type: multipart/form-data; boundary= --boundary';		crlf.	^HTTPRequest readFrom: (SwazooStream on: requestStream writeBuffer contents)</body><body package="Swazoo-Tests">portedGet	| requestStream |	requestStream := SwazooStream on: String new.	requestStream		nextPutLine: 'GET / HTTP/1.1';		nextPutLine: 'Host: foo.com:8888';		crlf.	^HTTPRequest readFrom: (SwazooStream on: requestStream writeBuffer contents)</body></methods><methods><class-id>Swazoo.HTTPRequestTest</class-id> <category>testing-other</category><body package="Swazoo-Tests">test10ConnectionClose	request := self basicGetHTTP10.	self assert: request wantsConnectionClose</body><body package="Swazoo-Tests">test10KeepAliveConnectionClose	request := self basicGetHTTP10Keepalive.	self deny: request wantsConnectionClose</body><body package="Swazoo-Tests">testConnection	request := self fullGet.	self assert: request connection = 'Keep-Alive'</body><body package="Swazoo-Tests">testHeaderAtIfPresent	request := self basicGet.	self assert: (request headers 				fieldOfClass: HTTPIfRangeField				ifPresent: [:header | header == (request headers fieldOfClass: HTTPIfRangeField)]				ifAbsent: [true]).	self assert: (request headers 				fieldOfClass: HTTPHostField				ifPresent: [:header | header == (request headers fieldOfClass: HTTPHostField)]				ifAbsent: [false])</body><body package="Swazoo-Tests">testNo11ConnectionClose	request := self basicGet.	self deny: request wantsConnectionClose</body><body package="Swazoo-Tests">testNoEqualsQueries	"The last assert here used to check that 'request queryAt: 'WSDL'' is nil, but a test for an empty string is more consistent with query argument formats."	| requestStream |	requestStream := SwazooStream on: String new.	requestStream		nextPutLine: 'GET /test/typed.asmx?WSDL HTTP/1.1';		nextPutLine: 'Host: foo.com:8888';		crlf.	request := HTTPRequest readFrom: (SwazooStream on: requestStream writeBuffer contents).	self assert: (request includesQuery: 'WSDL').	self assert: (request queryAt: 'WSDL') isEmpty</body><body package="Swazoo-Tests">testReferer	request := self fullGet.	self 		assert: request referer asString = 'http://www.bar.com/takeMeThere.html'</body><body package="Swazoo-Tests">testRequestWithCRButNoLF	| requestStream result |"	requestStream := SwazooStream on: String new.	requestStream		nextPutAll: 'GET / HTTP/1.1';		cr.	result := SpExceptionContext 				for: [HTTPRequest readFrom: (SwazooStream on: requestStream writeBuffer contents)]				on: SpError				do: [:ex | ex].	self assert: result class == SwazooHTTPParseError.	^self"</body><body package="Swazoo-Tests">testUserAgent	request := self fullGet.	self 		assert: request userAgent = 'Mozilla/4.72 [en] (X11; I; Linux 2.3.51 i686)'</body></methods><methods><class-id>Swazoo.CompositeResource</class-id> <category>accessing</category><body package="Swazoo-Core">children	children isNil ifTrue: [self initChildren].	^children</body><body package="Swazoo-Core">currentUrl	| string |	string := super currentUrl.	^string last = $/		ifTrue: [string]		ifFalse: [string , '/']</body><body package="Swazoo-Core">helpResolve: aResolution 	^aResolution resolveCompositeResource: self</body><body package="Swazoo-Core">printUrlOn: aWriteStream 	super printUrlOn: aWriteStream.	self isRootPath ifFalse: [aWriteStream nextPut: $/]</body></methods><methods><class-id>Swazoo.CompositeResource</class-id> <category>testing</category><body package="Swazoo-Core">hasNoResources	^self children isEmpty</body><body package="Swazoo-Core">includesResource: aResource	^self children includes: aResource.</body><body package="Swazoo-Core">isRootPath	^self uriPattern = '/'</body></methods><methods><class-id>Swazoo.CompositeResource</class-id> <category>initialize-release</category><body package="Swazoo-Core">initChildren	children := OrderedCollection new.</body><body package="Swazoo-Core">initialize	super initialize.	self initChildren</body></methods><methods><class-id>Swazoo.CompositeResource</class-id> <category>adding/removing</category><body package="Swazoo-Core">addResource: aResource	self children add: aResource.	aResource parent: self.	aResource onResourceCreated.	^aResource</body><body package="Swazoo-Core">addResources: anOrderedCollection	anOrderedCollection do: [ :each |		self addResource: each].	^anOrderedCollection</body><body package="Swazoo-Core">removeResource: aResource	self children remove: aResource ifAbsent: [nil]</body></methods><methods><class-id>Swazoo.ServerRootComposite</class-id> <category>accessing</category><body package="Swazoo-HTTP">helpResolve: aResolution 	^aResolution resolveServerRoot: self</body></methods><methods><class-id>Swazoo.FileResponse</class-id> <category>accessing-headers</category><body package="Swazoo-Fileserver">contentType	^self entity contentType</body></methods><methods><class-id>Swazoo.FileResponse</class-id> <category>accessing</category><body package="Swazoo-Fileserver">entity: aMimeObject 	self body: aMimeObject</body></methods><methods><class-id>Swazoo.FileResponse</class-id> <category>private-printing</category><body package="Swazoo-Fileserver">printContentLengthOn: aStream 	self entity isNil 		ifFalse: 			[aStream				nextPutAll: 'Content-Length: ';				print: self entity value fileSize.			self crlfOn: aStream]</body><body package="Swazoo-Fileserver">printEntityOn: aStream 	| rs |	self entity isNil 		ifFalse: 			[rs := self entity value readStream.			rs binary.			SpExceptionContext 				for: 					[[[rs atEnd] whileFalse: [aStream nextPutAll: (rs nextAvailable: 4096)]] 						ensure: [rs close]]				on: SpError				do: [:ex | ex return]]</body><body package="Swazoo-Fileserver">printHeadersOn: aStream 	self contentType: self entity contentType.	super printHeadersOn: aStream</body></methods><methods><class-id>Swazoo.HTTPPut</class-id> <category>testing</category><body package="Swazoo-Messages">isPut	^true</body></methods><methods><class-id>Swazoo.HTTPPut</class-id> <category>private</category><body package="Swazoo-Messages">putData: aString	putData := aString</body></methods><methods><class-id>Swazoo.HTTPPut</class-id> <category>accessing</category><body package="Swazoo-Messages">putData	^putData</body></methods><methods><class-id>Swazoo.HTTPPut</class-id> <category>reading</category><body package="Swazoo-Messages">for: aRequestLine readFrom: aSwazooStream 	super for: aRequestLine readFrom: aSwazooStream .	self octetDataFrom: aSwazooStream.</body><body package="Swazoo-Messages">octetDataFrom: aStream 	self headers fieldOfClass: HTTPContentLengthField		ifNone: [^SwazooHTTPPutError raiseSignal: 'Missing Content-Length'].	self putData: (aStream nextBytes: self contentLength)</body></methods><methods><class-id>Swazoo.HTTPPut class</class-id> <category>accessing</category><body package="Swazoo-Messages">methodName	^'PUT'</body></methods><methods><class-id>TCPAnalyser</class-id> <category>private</category><body package="Swazoo-Tests">binFromHexFile: aFilenameString	"from hex like like:	00000000  47 45 54 20 2f 32 30 30  37 2f 31 32 2d 31 35 2f GET /200 7/12-15/"	"TCPAnalyser new binFromHexFile: '/home/mivsek/projekti/aida/swazoo/tcp-traces/pingo1-17dec07-siska-priprava-jaslic-chunks-hex.tcp-stream'"	"TCPAnalyser new binFromHexFile: '/home/mivsek/projekti/aida/swazoo/tcp-traces/pingo1-17dec07-siska-priprava-jaslic-ok-chunks-hex.tcp-stream'"	^self binFromHexPrint: aFilenameString asFilename contentsOfEntireFile</body><body package="Swazoo-Tests">binFromHexPrint: aString	"from hex output like:	00000000  47 45 54 20 2f 32 30 30  37 2f 31 32 2d 31 35 2f GET /200 7/12-15/	00000010  64 6f 63 33 39 36 2d 76  31 2f 70 72 69 70 72 61 doc396-v 1/pripra"	| stream out count hbyte |	stream := aString readStream.	out := WriteStream on: ByteArray new.	[stream atEnd] whileFalse: 		[[stream peek = Character space] whileTrue: [stream next]. "skip white space"		stream upToSeparator. "skip address"		count := 0.		[stream peek isSeparator ifTrue: [stream next].stream peek isSeparator ifTrue: [stream next].		stream peek isSeparator not and: [count &lt; 16] ] 			whileTrue:				[hbyte := String with: stream next with: stream next.				count := count + 1.				out nextPut: (Integer readFrom: hbyte readStream radix: 16)].		stream upTo: Character cr. 		stream peek = Character cr ifTrue: [stream next]. stream peek = Character lf ifTrue: [stream next]  ].	^out contents"TCPAnalyser new binFromHexPrint:'    00000000  47 45 54 20 2f 32 30 30  37 2f 31 32 2d 31 35 2f GET /200 7/12-15/     00000010  64 6f 63 33 39 36 2d 76  31 2f 70 72                 doc396-v 1/pripra'"</body><body package="Swazoo-Tests">compareBin: aByteArray to: aByteArray2	"TCPAnalyser new compareBin: (TCPAnalyser new binFromHexFile: '/home/mivsek/projekti/aida/swazoo/tcp-traces/pingo1-17dec07-siska-priprava-jaslic-chunks-hex.tcp-stream') to: (TCPAnalyser new binFromHexFile: '/home/mivsek/projekti/aida/swazoo/tcp-traces/pingo1-17dec07-siska-priprava-jaslic-ok-chunks-hex.tcp-stream')"	^aByteArray = aByteArray2</body></methods><methods><class-id>Swazoo.SwazooAuthNonce</class-id> <category>accessing</category><body package="Swazoo-Messages">hashed	"md5 hashed nonce, see rfc2617 3.2.1"	"AuthenticationNonce new hashed"	^SwazooMD5Digest hash: (self timestamp printString, ':', self secret)</body><body package="Swazoo-Messages">secret	^secret</body><body package="Swazoo-Messages">timestamp	^timestamp</body></methods><methods><class-id>Swazoo.SwazooAuthNonce</class-id> <category>testing</category><body package="Swazoo-Messages">sameAs: aHashedNonce	"check if this nonce has same values as other one"	^self hashed = aHashedNonce</body></methods><methods><class-id>Swazoo.SwazooAuthNonce</class-id> <category>private</category><body package="Swazoo-Messages">setSecret	secret := self hash printString</body><body package="Swazoo-Messages">setTimestamp	timestamp := Timestamp new</body></methods><methods><class-id>Swazoo.SwazooAuthNonce</class-id> <category>initialize-release</category><body package="Swazoo-Messages">initialize	self setTimestamp.	self setSecret</body></methods><methods><class-id>Swazoo.SwazooAuthNonce class</class-id> <category>instance creation</category><body package="Swazoo-Messages">new	^super new initialize</body></methods><methods><class-id>Swazoo.HTTPServerField</class-id> <category>accessing</category><body package="Swazoo-Headers">productTokens	^productTokens</body><body package="Swazoo-Headers">productTokens: aString 	productTokens := aString.	^self</body></methods><methods><class-id>Swazoo.HTTPServerField</class-id> <category>printing</category><body package="Swazoo-Headers">valuesAsStringOn: aStream 	aStream nextPutAll: self productTokens.	^self</body></methods><methods><class-id>Swazoo.HTTPServerField class</class-id> <category>accessing</category><body package="Swazoo-Headers">fieldName	^'Server'</body></methods><methods><class-id>Swazoo.SwazooSite</class-id> <category>accessing</category><body package="Swazoo-Core">addAlias: aSiteIdentifier 	self ip isNil "initial uriPattern not yet setup"		ifTrue: [self host: aSiteIdentifier host ip: aSiteIdentifier ip port: aSiteIdentifier port]		ifFalse: [self uriPattern add: aSiteIdentifier]</body><body package="Swazoo-Core">aliases	^self uriPattern</body><body package="Swazoo-Core">host	"hostname of this site. Example: www.ibm.com. 	hostname must be unique on that server.	Don't mix with ip, which also can be something like www.ibm.com. 	There can be many sites with different hostnames on the same ip ! "	self uriPattern isEmpty ifTrue: [^''].	^self uriPattern first host</body><body package="Swazoo-Core">host: aHostString ip: anIPString port: aNumber 	"see comments in methods host and ip ! "	"hostname must be unique! "	| site |	site := SwazooServer singleton siteHostnamed: aHostString.	(site notNil and: [site ~= self])		ifTrue: [^SwazooSiteError error: 'Site with that hostname already exist!'].	self uriPattern isEmpty ifTrue: [self uriPattern add: SiteIdentifier new].	self uriPattern first 		host: aHostString ip: anIPString port: aNumber</body><body package="Swazoo-Core">host: aHostString port: aNumber 	"run on all ip interfaces on specified port"	"hostname must be unique! "	self host: aHostString ip: '*' port: aNumber</body><body package="Swazoo-Core">ip	"IP address of this site. Swazoo can have virtual sites, that is, more than one 	site can share the same ip and port!	IP can be a number or full DNS name. For example: server.ibm.com or 234.12.45.66"	^self uriPattern first ip</body><body package="Swazoo-Core">name	"a short name of that site. Example: for host www.ibm.com, name it ibm"	name isNil ifTrue: [^''].	^name</body><body package="Swazoo-Core">name: aString	"a short name of that site. Example: for host www.ibm.com, name it ibm"	"name must be unique"	(SwazooServer singleton siteNamed: aString) notNil 		ifTrue: [^SwazooSiteError error: 'Site with that name already exist!'].	name := aString</body><body package="Swazoo-Core">port	^self uriPattern first port</body></methods><methods><class-id>Swazoo.SwazooSite</class-id> <category>private</category><body package="Swazoo-Core">helpResolve: aResolution 	^aResolution resolveSite: self</body><body package="Swazoo-Core">host: aString	self uriPattern first host: aString</body><body package="Swazoo-Core">ip: aString	self uriPattern first  ip: aString</body><body package="Swazoo-Core">match: aSiteIdentifier 	self uriPattern detect: [:each | each match: aSiteIdentifier]		ifNone: [^false].	^true</body><body package="Swazoo-Core">port: aNumber	self uriPattern first port: aNumber</body><body package="Swazoo-Core">printUrlOn: aWriteStream 	self uriPattern first printUrlOn: aWriteStream</body><body package="Swazoo-Core">serving: aBoolean	serving := aBoolean</body><body package="Swazoo-Core">uriPattern	uriPattern isNil ifTrue: [self initUriPattern].	^uriPattern</body><body package="Swazoo-Core">watchdogAction	"override in your subclass"</body></methods><methods><class-id>Swazoo.SwazooSite</class-id> <category>start/stop</category><body package="Swazoo-Core">start	| swazoo |	swazoo := SwazooServer singleton.	[self aliases do: [:each | | httpServer |		httpServer := swazoo serverFor: each. "it will also create and start it if needed"		httpServer addSite: self].	] ifCurtailed: [self stop].	self serving: true.</body><body package="Swazoo-Core">stop	| swazoo |	swazoo := SwazooServer singleton.	self aliases do: [:each | | httpServer |		httpServer := swazoo serverFor: each.		(swazoo servers includes: httpServer) 			ifTrue: 				[httpServer removeSite: self.				httpServer hasNoSites ifTrue: 					[swazoo removeServer: httpServer.					httpServer stop]]].		self serving: false.</body></methods><methods><class-id>Swazoo.SwazooSite</class-id> <category>testing</category><body package="Swazoo-Core">isRootPath	^false</body><body package="Swazoo-Core">isServing	"is this site on-line?"	^serving notNil and: [serving]</body><body package="Swazoo-Core">onAllInterfaces	"site is running on all machine's IP interfaces"	^self ip = '*' or: [self ip = '0.0.0.0']</body><body package="Swazoo-Core">onAnyHost	"site don't care about host name during url resolution"	^self host = '*'</body></methods><methods><class-id>Swazoo.SwazooSite</class-id> <category>initialize-release</category><body package="Swazoo-Core">initUriPattern	self uriPattern: OrderedCollection new.	self uriPattern add: SiteIdentifier new.</body><body package="Swazoo-Core">initialize	super initialize.	self stop. "in case you initialize working site"	self initUriPattern</body></methods><methods><class-id>Swazoo.SwazooSite</class-id> <category>config-from-file</category><body package="Swazoo-Core">compile: tag 	^SwazooCompiler evaluate: tag</body><body package="Swazoo-Core">nextTagFrom: aStream 	aStream upTo: $&lt;.	^aStream atEnd ifTrue: [nil] ifFalse: [aStream upTo: $&gt;]</body><body package="Swazoo-Core">readCompositeFrom: aStream storingInto: aComposite 	| tag |		[tag := self nextTagFrom: aStream.	tag = '/CompositeResource']		whileFalse: 			[| thingy |			thingy := self compile: tag.			aComposite addResource: thingy.			(thingy isKindOf: CompositeResource)				ifTrue: [self readCompositeFrom: aStream storingInto: thingy]]</body><body package="Swazoo-Core">readFrom: aStream 	"read configuration from an XML file, see sites.cnf"	| tag |	tag := self nextTagFrom: aStream.	tag isNil ifTrue: [^nil].	tag = 'Site' ifFalse: [^SwazooSiteError error: 'invalid site specification!'].	[tag := self nextTagFrom: aStream.	tag = '/Site'] 	whileFalse: 			[| thingy |			thingy := self compile: tag.			(thingy isKindOf: SiteIdentifier)				ifTrue: [self addAlias: thingy]				ifFalse: 					[self addResource: thingy.					(thingy isKindOf: CompositeResource) 						ifTrue: [self readCompositeFrom: aStream storingInto: thingy]]]</body></methods><methods><class-id>Swazoo.SwazooSite class</class-id> <category>accessing</category><body package="Swazoo-Core">named: aString	"return a website with that name"	^Swazoo.SwazooServer singleton siteNamed: aString</body></methods><methods><class-id>Swazoo.SwazooSite class</class-id> <category>instance creation</category><body package="Swazoo-Core">newNamed: aString	| site |	site := self new name: aString.	Swazoo.SwazooServer singleton addSite: site.	site initialize.	^site</body></methods><methods><class-id>Swazoo.SwazooDemoSite</class-id> <category>serving</category><body package="Swazoo-Resources">answerTo: aRequest 	aRequest urlString = '/websocket' ifTrue: [^self answerWebSocketTo: aRequest].	^self answerToHelloWorld</body><body package="Swazoo-Resources">answerToHelloWorld	| response |	response := HTTPResponse ok.	response		contentType: 'text/html';		entity: '&lt;html&gt;&lt;head&gt;&lt;title&gt;Hello World&lt;/title&gt;&lt;/head&gt;&lt;body&gt;Hello World!&lt;/body&gt;&lt;/html&gt;'.	^response</body><body package="Swazoo-Resources">answerWebSocketTo: aRequest	"upgrade HTTP connection to WebSocket to establish bidirectional messaging to and from browser"	aRequest isWebSocketRequest ifFalse: [^HTTPResponse forbidden].	self webSocket: aRequest webSocket.	^webSocket answerTo: aRequest</body></methods><methods><class-id>Swazoo.SwazooDemoSite</class-id> <category>accessing</category><body package="Swazoo-Resources">webSocket	^webSocket</body><body package="Swazoo-Resources">webSocket: aWebSocketResource	webSocket := aWebSocketResource</body></methods><methods><class-id>Swazoo.SwazooDemoSite</class-id> <category>private</category><body package="Swazoo-Resources">helpResolve: aResolution 	(self canAnswer and: [aResolution siteMatch: self]) ifFalse: [^nil].	^self answerTo: aResolution request</body></methods><methods><class-id>Swazoo.SwazooTask</class-id> <category>accessing</category><body package="Swazoo-Messages">connection	^connection</body><body package="Swazoo-Messages">connection: aHTTPConnection	connection := aHTTPConnection</body><body package="Swazoo-Messages">request	^request</body><body package="Swazoo-Messages">request: aHTTPRequest	request := aHTTPRequest.	aHTTPRequest task: self.</body><body package="Swazoo-Messages">response	^response</body><body package="Swazoo-Messages">response: aHTTPResponse	response := aHTTPResponse.	aHTTPResponse notNil ifTrue: [aHTTPResponse task: self].</body></methods><methods><class-id>Swazoo.SwazooTask class</class-id> <category>instance creation</category><body package="Swazoo-Messages">newOn: aHTTPConnection	^super new connection: aHTTPConnection</body></methods><methods><class-id>Swazoo.SwazooServerTest</class-id> <category>testing</category><body package="Swazoo-Tests">testAccessingSite	| site |	self removeTestSiteIfAny.	site := SwazooSite new name: self testSiteName;		host: 'test.org' ip: 'localhost' port: 8543.	[SwazooServer singleton addSite: site.	self assert: (SwazooServer siteNamed: self testSiteName) notNil.	site := SwazooServer siteNamed: self testSiteName.	self assert: (site name = self testSiteName).	self assert: (SwazooServer siteHostnamed: 'test.org') notNil.	site := SwazooServer siteHostnamed: 'test.org'.	self assert: (site host = 'test.org')]		ensure: [SwazooServer singleton removeSite: site].</body><body package="Swazoo-Tests">testStartingOnAPort	"and all ip interfaces, any host"	| site server nrServers |	server := SwazooServer singleton.	nrServers := server servers size.	[site := server startOn: 4924.	self assert: site isServing.	self assert: server servers size = (nrServers+1).	server stopOn: 4924.	self assert: site isServing not.	self assert: server servers size = nrServers]		ensure: [site stop. server removeSite: site].</body><body package="Swazoo-Tests">testStartingOnTwoPorts	"and all ip interfaces, any host"	| server nrServers site1 site2 |	server := SwazooServer singleton.	nrServers := server servers size.	[site1 := server startOn: 4924.	site2 := server startOn: 4925.	self assert: site1 isServing. self assert: site2 isServing.	self assert: server servers size = (nrServers+2).	server stopOn: 4924. server stopOn: 4925.	self assert: site1 isServing not. self assert: site2 isServing not.	self assert: server servers size = nrServers]		ensure: 			[site1 stop. site2 stop. 			server removeSite: site1;  removeSite: site2 ].</body><body package="Swazoo-Tests">testStartingSite	| site server nrServers |	self removeTestSiteIfAny.	server := SwazooServer singleton.	nrServers := server servers size.	site := SwazooSite new name: self testSiteName; host: 'test.org' ip: 'localhost' port: 8765.	[server addSite: site.	self assert: site isServing not.	SwazooServer startSite: self testSiteName.	self assert: server servers size = (nrServers+1).	self assert: site isServing.	SwazooServer stopSite: self testSiteName.	self assert: site isServing not.	self assert: server servers size = nrServers]		ensure: [site stop. server removeSite: site].</body></methods><methods><class-id>Swazoo.SwazooServerTest</class-id> <category>testing-adding sites</category><body package="Swazoo-Tests">testAddingAllInterfacesSite	"site to listen on all IP interfaces but on specified port"	| site server |	self removeTestSiteIfAny.	server := SwazooServer singleton.	self assert: (server siteNamed: self testSiteName) isNil.	site := SwazooSite new name: self testSiteName;		host: '*' ip: '*' port: 7261.	[server addSite: site.	self assert: (server siteNamed: self testSiteName) notNil]		ensure: [server removeSite: site].</body><body package="Swazoo-Tests">testAddingSite	| site server nrSites |	self removeTestSiteIfAny.	server := SwazooServer singleton.	nrSites := server sites size.	self assert: (server siteNamed: self testSiteName) isNil.	self assert: (server siteHostnamed: self testSiteName) isNil.	site := SwazooSite new name: self testSiteName;		host: 'test.org' ip: 'localhost' port: 5798.	server addSite: site.	self assert: (server siteNamed: self testSiteName) notNil.	self assert: (server siteHostnamed: 'test.org') notNil.	server removeSite: site.	self assert: server sites size = nrSites.</body><body package="Swazoo-Tests">testAllInterfacesTwoPortSites	"two sites can run on all IP interfaces and different port"	| server site1 site2 |	server := SwazooServer singleton.	site1 := SwazooSite new name: 'allInterfaces1'; host: '*' ip: '*' port: 7261.	site2 := SwazooSite new name: 'allInterfaces2'; host: '*' ip: '*' port: 7262.	[server addSite: site1.	self shouldnt: [server addSite: site2] raise: Error]		ensure: [server removeSite: site1; removeSite: site2].</body><body package="Swazoo-Tests">testAllStarsThenExactOnOtherPort	| server site1 site2 |	server := SwazooServer singleton.	site1 := SwazooSite new name: 'allstar232'; host: '*' ip: '*' port: 7261.	site2 := SwazooSite new name: 'exactdfdf'; host: 'localhost' ip: 'localhost' port: 7262.	[server addSite: site1.	self shouldnt: [server addSite: site2; removeSite: site2] raise: Error]		ensure: [server removeSite: site1].</body><body package="Swazoo-Tests">testDuplicateAllInterfacesSite	"two sites cannot run on all IP interfaces and same port"	| server site1 site2 |	server := SwazooServer singleton.	site1 := SwazooSite new name: 'allInterfaces1'; host: '*' ip: '*' port: 7261.	site2 := SwazooSite new name: 'allInterfaces2'; host: '*' ip: '*' port: 7261.	[server addSite: site1.	self should: [server addSite: site2] raise: Error]		ensure: [server removeSite: site1].</body><body package="Swazoo-Tests">testDuplicateNames	| site server |	self removeTestSiteIfAny.	server := SwazooServer singleton.	site := SwazooSite new name: self testSiteName;		host: 'test.org' ip: 'localhost' port: 6376.	[server addSite: site.	self should: [site name: self testSiteName] raise: Error.	self shouldnt: [site host: 'test.org'] raise: Error.	self should: [SwazooSite new name: self testSiteName;		host: 'test.org' ip: 'localhost' port: 6376] raise: Error]			ensure: [server removeSite: site].</body></methods><methods><class-id>Swazoo.SwazooServerTest</class-id> <category>support</category><body package="Swazoo-Tests">removeTestSiteIfAny	| site |	site := SwazooServer siteNamed: self testSiteName.	site notNil ifTrue: [SwazooServer singleton removeSite: site].</body><body package="Swazoo-Tests">testSiteName	^'aaabbcc987'</body></methods><methods><class-id>Swazoo.HTTPServerTest</class-id> <category>tests</category><body package="Swazoo-Tests">testServing	self assert: server isServing</body><body package="Swazoo-Tests">testStopServing	server stop.	self deny: server isServing</body></methods><methods><class-id>Swazoo.HTTPServerTest</class-id> <category>running</category><body package="Swazoo-Tests">setUp	| socket |	(Delay forMilliseconds: 100) wait.	server := HTTPServer new.	[server ip: 'localhost'; port: 8123.	server start]		fork.	(Delay forMilliseconds: 100) wait."	stream := (SocketAccessor newTCPclientToHost: 'localhost' port: 8123) 				readAppendStream"	socket := SpSocket connectToServerOnHost:  'localhost' port: 8123.	stream := SwazooStream socket: socket</body><body package="Swazoo-Tests">tearDown	server stop.	stream close.	stream := nil.	Delay forMilliseconds: 500.</body></methods><methods><class-id>Swazoo.HTTPPostTest</class-id> <category>requests</category><body package="Swazoo-Tests">crlf	^String with: Character cr with: Character lf.</body><body package="Swazoo-Tests">fileContents	"HTTPRequestTest new fileContents"	| stream |	stream := SwazooStream on: String new.	stream		nextPutLine: 'BEGIN:VCALENDAR';		nextPutLine: 'PRODID:-//Squeak-iCalendar//-';		nextPutLine: 'VERSION:2.0';		nextPutLine: 'X-WR-CALNAME:test';		nextPutLine: 'METHOD:PUBLISH';		nextPutLine: 'BEGIN:VEVENT';		nextPutLine: 'UID:an event with a start date and not date and time';		nextPutLine: 'CATEGORIES:category1,category2';		nextPutLine: 'CREATED:20050501T110231Z';		nextPutLine: 'SEQUENCE:0';		nextPutLine: 'SUMMARY:aTitle';		nextPutLine: 'PRIORITY:5';		nextPutLine: 'DTSTART;VALUE=DATE:20050425';		nextPutLine: 'END:VEVENT';		nextPutLine: 'END:VCALENDAR'.	^stream writeBuffer contents asByteString</body><body package="Swazoo-Tests">postDashes	| requestStream |	requestStream := SwazooStream on: String new.	requestStream		nextPutLine: 'POST  /document/aab.html HTTP/1.1';		nextPutLine: 'Host: biart.eranova.si';		nextPutLine: 'Content-Type: multipart/form-data; boundary= boundary';		nextPutLine: 'Content-Length: 149';            crlf;		nextPutLine: '--boundary';		nextPutLine: 'Content-Disposition: form-data; name="id5273"';		crlf; 		nextPutLine: '----';		nextPutLine: '--boundary';		nextPutLine: 'Content-Disposition: form-data; name="field2"';		crlf; 		nextPutLine: '- --';		nextPutLine: '--boundary--'.	^HTTPRequest readFrom: (SwazooStream on: requestStream writeBuffer contents)</body><body package="Swazoo-Tests">postEmpty	"post entity with empty value"	| requestStream |	requestStream := SwazooStream on: String new.	requestStream		nextPutLine: 'POST  /document/aab.html HTTP/1.1';		nextPutLine: 'Host: biart.eranova.si';		nextPutLine: 'Content-Type: multipart/form-data; boundary= boundary';		nextPutLine: 'Content-Length: 75';            crlf;		nextPutLine: '--boundary';		nextPutLine: 'Content-Disposition: form-data; name="id5273"';		crlf; 		nextPutLine: '';		nextPutLine: '--boundary--'.	^HTTPRequest readFrom: (SwazooStream on: requestStream writeBuffer contents)</body><body package="Swazoo-Tests">postFile	| requestStream |	requestStream := SwazooStream on: String new.	requestStream		nextPutLine: 'POST  /document/aab.html HTTP/1.1';		nextPutLine: 'Connection: Keep-Alive';		nextPutLine: 'User-Agent: Mozilla/4.72 [en] (X11; I; Linux 2.3.51 i686)';		nextPutLine: 'Host: biart.eranova.si';		nextPutLine: 'Referer: http://www.bar.com/takeMeThere.html';		nextPutLine: 'Content-Type: multipart/form-data; boundary= -----------------20752836116568320241700153999';		nextPutLine: 'Content-Length: ', (527+self fileContents size) printString;            crlf;		nextPutLine: '-------------------20752836116568320241700153999';		nextPutLine: 'Content-Disposition: form-data; name="id5273"';		crlf; 		nextPutLine: 'main';		nextPutLine: '-------------------20752836116568320241700153999';		nextPutLine: 'Content-Disposition: form-data; name="field2"';		crlf; crlf;		nextPutLine: '-------------------20752836116568320241700153999';		nextPutLine: 'Content-Disposition: form-data; name="field7"; filename="event.ical"';		nextPutLine: 'Content-Type: application/octet-stream';		crlf;		nextPutAll: self fileContents;		crlf;		nextPutLine: '-------------------20752836116568320241700153999';		nextPutLine: 'Content-Disposition: form-data; name="attach"';		crlf;		nextPutLine: 'Attach';		nextPutLine: '-------------------20752836116568320241700153999--'.	^HTTPRequest readFrom: (SwazooStream on: requestStream writeBuffer contents)</body><body package="Swazoo-Tests">postPreambleEpilogue	| requestStream |	requestStream := SwazooStream on: String new.	requestStream		nextPutLine: 'POST  /document/aab.html HTTP/1.1';		nextPutLine: 'Host: biart.eranova.si';		nextPutLine: 'Content-Type: multipart/form-data; boundary= boundary';		nextPutLine: 'Content-Length: 146';            crlf;		nextPutLine: 'This is a multi-part message in MIME format';		nextPutLine: '--boundary';		nextPutLine: 'Content-Disposition: form-data; name="id5273"';		crlf; 		nextPutLine: 'main';		nextPutLine: '--boundary--';		nextPutLine: 'This is the epilogue'.	^HTTPRequest readFrom: (SwazooStream on: requestStream writeBuffer contents)</body><body package="Swazoo-Tests">postSimple	| requestStream |	requestStream := SwazooStream on: String new.	requestStream		nextPutLine: 'POST  /document/aab.html HTTP/1.1';		nextPutLine: 'Host: biart.eranova.si';		nextPutLine: 'Content-Type: multipart/form-data; boundary= boundary';		nextPutLine: 'Content-Length: 79';            crlf;		nextPutLine: '--boundary';		nextPutLine: 'Content-Disposition: form-data; name="id5273"';		crlf; 		nextPutLine: 'main';		nextPutLine: '--boundary--'.	^HTTPRequest readFrom: (SwazooStream on: requestStream writeBuffer contents)</body><body package="Swazoo-Tests">postUrlEncoded	| requestStream |	requestStream := SwazooStream on: String new.	requestStream		nextPutLine: 'POST  /document/aab.html HTTP/1.1';		nextPutLine: 'Host: biart.eranova.si';		nextPutLine: 'Content-Type: application/x-www-form-urlencoded';		nextPutLine: 'Content-Length: 36';            crlf;		nextPutAll: 'home=Cosby+one&amp;favorite+flavor=flies'.	^HTTPRequest readFrom: (SwazooStream on: requestStream writeBuffer contents)</body></methods><methods><class-id>Swazoo.HTTPPostTest</class-id> <category>testing-posts</category><body package="Swazoo-Tests">testPost10Simple	"just one entity"	| post |	post := self postSimple.	self assert: post isPostDataEmpty not.	self assert: (post postDataStringAt: 'id5273') = 'main'.</body><body package="Swazoo-Tests">testPost2Empty	"post entity with empty value"	| post |	post := self postEmpty.	self assert: post isPostDataEmpty not.	self assert: (post postDataStringAt: 'id5273') = ''.</body><body package="Swazoo-Tests">testPost3Dashes	"some ---- inside post data"	| post |	post := self postDashes.	self assert: post isPostDataEmpty not.	self assert: (post postDataStringAt: 'id5273') = '----'.	self assert: (post postDataStringAt: 'field2') = '- --'.</body><body package="Swazoo-Tests">testPost5UrlEncoded	"just one entity"	| post |	post := self postUrlEncoded.	self assert: post isPostDataEmpty not.	self assert: (post postDataStringAt: 'home') = 'Cosby one'.	self assert: (post postDataStringAt: 'favorite flavor') = 'flies'.</body><body package="Swazoo-Tests">testPostPreambleEpilogue	"mime preamble before first part and epilogue at the end. See #postPreambleEpilogue"	| post |	post := self postPreambleEpilogue.	self assert: post isPostDataEmpty not.	self assert: (post postDataStringAt: 'id5273') = 'main'.</body><body package="Swazoo-Tests">testPostRawEntity	| requestStream post |	requestStream := SwazooStream on: String new.	requestStream		nextPutLine: 'POST /foobar HTTP/1.0';		nextPutLine: 'Host: foo.com';		nextPutLine: 'Content-Type: text/plain';		nextPutLine: 'Content-Length: 12';		crlf;		nextPutLine: 'Hello, World'.	post := HTTPRequest readFrom: (SwazooStream on: requestStream writeBuffer contents).	self assert: post isPostDataEmpty.	self assert: post entityBody = 'Hello, World'</body><body package="Swazoo-Tests">testPostUrlEncodedData	| requestStream post |	requestStream := SwazooStream on: String new.	requestStream		nextPutLine: 'POST / HTTP/1.1';		nextPutLine: 'Host: foo.com';		nextPutLine: 'Content-Type: application/x-www-form-urlencoded';		nextPutLine: 'Content-Length: 31';		crlf;		nextPutLine: 'address=+fs&amp;product=&amp;quantity=1'.	post := HTTPRequest readFrom: (SwazooStream on: requestStream writeBuffer contents).	self assert: (post postDataAt: 'address') value = ' fs'.	self assert: (post postDataAt: 'product') value = ''.	self assert: (post postDataAt: 'quantity') value = '1'</body></methods><methods><class-id>Swazoo.HTTPPostTest</class-id> <category>testing-file posts</category><body package="Swazoo-Tests">testPost40File	| post |	post := self postFile.	self assert: post isPostDataEmpty not.	self assert: (post postDataStringAt: 'id5273') = 'main'.	self assert: (post postDataStringAt: 'field2') = ''.	self assert: (post postDataAt: 'field7') filename = 'event.ical'.	self assert: ((post postDataStringAt: 'field7') readStream upTo: Character cr) = 'BEGIN:VCALENDAR'.	self assert: (post postDataStringAt: 'field7') = self fileContents.	self assert: (post postDataStringAt: 'attach') = 'Attach'.</body><body package="Swazoo-Tests">testPost41FileStreamed	| post stream |	post := self postFile.	stream := WriteStream on: ByteArray new.	post postDataAt: 'field7' streamTo: stream.	self assert: (post isPostDataStreamedAt: 'field7').	self deny: post postData isParsed. "post data read from socket defered"	self assert: (post postDataStringAt: 'id5273') = 'main'. 	self assert: post postData isParsed.  "first access to post data trigger full read and parse"	self assert: (post postDataAt: 'field7') filename = 'event.ical'.	self assert: (stream contents asByteString readStream upTo: Character cr) = 'BEGIN:VCALENDAR'.	self assert: stream contents asByteString = self fileContents.	self assert: (post postDataStringAt: 'attach') = 'Attach'.</body><body package="Swazoo-Tests">testPost42FileContentType	| post |	post := self postFile. "set the data to the post"	self assert: post isPostDataEmpty not. "read the content of the stream"	self assert: (post postDataAt: 'field7') contentType = 'application/octet-stream'.</body></methods><methods><class-id>Swazoo.HTTPPostTest</class-id> <category>testing-mime parsing</category><body package="Swazoo-Tests">testBlockCopy	"streaming with 8k blocks for performance"	"this is just a basic test with content shorter that one block"	| boundary message in out |	boundary := '--boundary--'.	message := 'just something'. 	in := SwazooStream on: message, self crlf, boundary.	out := WriteStream on: String new.	HTTPPost new blockStreamingFrom: in to: out until: boundary.	self assert: out contents = message.</body></methods><methods><class-id>Swazoo.SwazooConfigurationTest</class-id> <category>testing</category><body package="Swazoo-Tests">testCompositeResourceSite	| rs site composite howdy duh hithere |	rs := ReadStream 				on: '&lt;Site&gt; &lt;CompositeResource uriPattern: ''/''&gt;  &lt;HelloWorldResource uriPattern: ''howdy''&gt;  &lt;CompositeResource uriPattern: ''duh''&gt;   &lt;HelloWorldResource uriPattern: ''hithere''&gt;  &lt;/CompositeResource&gt; &lt;/CompositeResource&gt;&lt;/Site&gt;'.	site := SwazooSite new readFrom: rs.	self assert: site children size = 1.	composite := site children first.	self assert: composite class == CompositeResource.	self assert: composite uriPattern = '/'.	self assert: composite children size = 2.	self assert: composite parent == site.	howdy := composite children first.	self assert: howdy class == HelloWorldResource.	self assert: howdy uriPattern = 'howdy'.	self assert: howdy parent == composite.	duh := composite children last.	self assert: duh children size = 1.	self assert: duh class == CompositeResource.	self assert: duh uriPattern = 'duh'.	self assert: duh parent == composite.	hithere := duh children first.	self assert: hithere class == HelloWorldResource.	self assert: hithere uriPattern = 'hithere'.	self assert: hithere parent == duh.</body><body package="Swazoo-Tests">testEmptySite	| rs site alias |	rs := ReadStream 				on: '&lt;Site&gt; &lt;SiteIdentifier host: ''swazoo.org'' ip: ''192.168.1.66'' port: 80&gt;&lt;/Site&gt;'.	site := SwazooSite new readFrom: rs.	self assert: site aliases size = 1.	self assert: site currentUrl = 'http://swazoo.org/'.	alias := site aliases first.	self assert: alias host = 'swazoo.org'.	self assert: alias ip = '192.168.1.66'.	self assert: alias port = 80</body><body package="Swazoo-Tests">testFileResourceSite	| rs site resource |	rs := ReadStream 				on: '&lt;Site&gt;&lt;SiteIdentifier host: ''swazoo.org'' ip: ''192.168.1.66'' port: 80&gt; &lt;FileResource uriPattern: ''/'' filePath: ''files''&gt;&lt;/Site&gt;'.	site := SwazooSite new readFrom: rs.	self assert: site children size = 1.	resource := site children first.	self assert: resource class == FileResource.	self assert: resource uriPattern = '/'.	self assert: resource filePath = 'files'.	self assert: resource parent == site.	self assert: resource currentUrl = 'http://swazoo.org/'.</body><body package="Swazoo-Tests">testMultipleResourcesSite	| rs site resource1 resource2 |	rs := ReadStream 				on: '&lt;Site&gt; &lt;HelloWorldResource uriPattern: ''/''&gt; &lt;HelloWorldResource uriPattern: ''/''&gt;&lt;/Site&gt;'.	site := SwazooSite new readFrom: rs.	self assert: site children size = 2.	resource1 := site children first.	self assert: resource1 class == HelloWorldResource.	self assert: resource1 uriPattern = '/'.	resource2 := site children last.	self assert: resource2 class == HelloWorldResource.	self assert: resource2 uriPattern = '/'</body><body package="Swazoo-Tests">testMultipleSites	| rs sites site alias1 alias2 |	rs := ReadStream 				on: '&lt;Site&gt; &lt;SiteIdentifier host: ''swazoo.org'' ip: ''192.168.1.66'' port: 80&gt; &lt;SiteIdentifier host: ''swazoo.org'' ip: ''192.168.1.66'' port: 81&gt;&lt;/Site&gt;&lt;Site&gt;&lt;/Site&gt;'.	sites := SwazooServer readSitesFrom: rs.	self assert: sites size = 2.	site := sites first.	self assert: site aliases size = 2.	alias1 := site aliases first.	self assert: alias1 host = 'swazoo.org'.	self assert: alias1 ip = '192.168.1.66'.	self assert: alias1 port = 80.	alias2 := site aliases last.	self assert: alias2 host = 'swazoo.org'.	self assert: alias2 ip = '192.168.1.66'.	self assert: alias2 port = 81</body><body package="Swazoo-Tests">testSingleResourceSite	| rs site resource |	rs := ReadStream on: '&lt;Site&gt;&lt;SiteIdentifier host: ''swazoo.org'' ip: ''192.168.1.66'' port: 80&gt; &lt;HelloWorldResource uriPattern: ''/''&gt;&lt;/Site&gt;'.	site := SwazooSite new readFrom: rs.	self assert: site children size = 1.	resource := site children first.	self assert: resource class == HelloWorldResource.	self assert: resource uriPattern = '/'.	self assert: resource parent == site.	self assert: resource currentUrl = 'http://swazoo.org/'.</body><body package="Swazoo-Tests">testSiteTag	| rs config tag |	rs := ReadStream on: '  &lt;Site&gt;  &lt;/Site&gt;   '.	config := SwazooSite new.	tag := config nextTagFrom: rs.	self assert: tag = 'Site'.	tag := config nextTagFrom: rs.	self assert: tag = '/Site'.	self assert: (config nextTagFrom: rs) isNil</body></methods><methods><class-id>Swazoo.HTTPHeaders</class-id> <category>private</category><body package="Swazoo-Headers">fields	fields isNil ifTrue: [fields := Dictionary new].	^fields</body><body package="Swazoo-Headers">printOn: aStream	aStream nextPutAll: 'a HTTPHeaders'; cr.	self fields values do: [:each | aStream nextPutAll: '   ', each printString; cr]</body></methods><methods><class-id>Swazoo.HTTPHeaders</class-id> <category>services</category><body package="Swazoo-Headers">addField: aField 	"HTTPSpec1.1 Sec4.2Multiple message-header fields with the same field-name MAY be present in a message if and only if the entire field-value for that header field is defined as a comma-separated list [i.e., #(values)]. It MUST be possible to combine the multiple header fields into one 'field-name: field-value' pair, without changing the semantics of the message, by appending each subsequent field-value to the first, each separated by a comma. The order in which header fields with the same field-name are received is therefore significant to the interpretation of the combined field value, and thus a proxy MUST NOT change the order of these field values when a message is forwarded.Note that we have to use the field name here as we may be adding a field for which there is no class, i.e. it's a GenericHeaderField."	(self includesFieldNamed: aField name) 		ifTrue: [(self fieldNamed: aField name) combineWith: aField]		ifFalse: [self fields at: aField name asUppercase put: aField].	^self</body><body package="Swazoo-Headers">fieldNamed: aString 	"^aStringIf I contain a field named aString, I return it.  Otherwise an exception is thrown.This is a bad way of getting a field.  Use &gt;&gt; fieldOfClass: instead."	| targetString |	targetString := aString asUppercase.	^self fields detect: [:aField | aField name asUppercase = targetString]</body><body package="Swazoo-Headers">fieldNamed: aString ifNone: aBlock 	"^aStringIf I contain a field named aString, I return it.  Otherwise I evaluate aBlock."	^self fields at: aString asUppercase ifAbsent: aBlock</body><body package="Swazoo-Headers">fieldNamed: aFieldName ifPresent: presentBlock ifAbsent: absentBlock 	"^an ObjectI look for a field named aFieldName among my fields.  If I find it, I return the result of evaluating presentBlock with the found field as an argument, otherwise I return the result of evaluate the absentBlock"	| foundField |	foundField := self fieldNamed: aFieldName ifNone: [nil].	^foundField isNil 		ifTrue: [absentBlock value]		ifFalse: [presentBlock value: foundField]</body><body package="Swazoo-Headers">fieldOfClass: aClass 	"^aStringIf I contain a field of class aClass, I return it.   Otherwise an exception is thrown."	^self fields detect: [:aField | aField class == aClass] ifNone: [^nil]</body><body package="Swazoo-Headers">fieldOfClass: aClass ifNone: aBlock 	"^aStringIf I contain a field of class aClass, I return it.   Otherwise I evaluate aBlock."	^self fields detect: [:aField | aField class == aClass] ifNone: aBlock</body><body package="Swazoo-Headers">fieldOfClass: fieldClass ifPresent: presentBlock ifAbsent: absentBlock 	"^an ObjectI look for a field of class fieldClass among my fields.  If I find it, I return the result of evaluating presentBlock with the found field as an argument, otherwise I return the result of evaluate the absentBlock"	| foundField |	foundField := self fieldOfClass: fieldClass ifNone: [nil].	^foundField isNil 		ifTrue: [absentBlock value]		ifFalse: [presentBlock value: foundField]</body><body package="Swazoo-Headers">getOrMakeFieldOfClass: aClass 	"^a HeaderFieldIf I contain a field of class aClass, I return it.   Otherwise I create a new instance if the field class and add it to my collection of headers."	^self fieldOfClass: aClass		ifNone: 			[| newField |			newField := aClass new.			self addField: newField.			newField]</body></methods><methods><class-id>Swazoo.HTTPHeaders</class-id> <category>emitting</category><body package="Swazoo-Headers">crlfOn: aStream 	aStream		nextPut: Character cr;		nextPut: Character lf</body><body package="Swazoo-Headers">writeOn: aStream 	"^selfI write all my fields to aStream."	self fields do: 			[:aField | 			aField printOn: aStream.			self crlfOn: aStream]</body></methods><methods><class-id>Swazoo.HTTPHeaders</class-id> <category>testing</category><body package="Swazoo-Headers">includesFieldNamed: aString 	"^a BooleanI return true if one of my fields has the name aString."	| targetField |	targetField := self fieldNamed: aString ifNone: [nil].	^targetField notNil</body><body package="Swazoo-Headers">includesFieldOfClass: aClass 	"^a BooleanI return true if one of my fields is of class aClass."	^self 		fieldOfClass: aClass		ifPresent: [:aField | true]		ifAbsent: [false]</body></methods><methods><class-id>Swazoo.HTTPHeaders</class-id> <category>initialize-release</category><body package="Swazoo-Headers">readFieldFromString: aString 	"^selfFirst I get the field parsed from aString, then I add the new field to my collection of fields.  Adding the new field may involve merging field values if I already have a field of that class."	self addField: (HeaderField fromLine: aString).	^self</body><body package="Swazoo-Headers">readFrom: aSwazooStream 	"^an HTTPHeadersI return a new instance of myself which contains fields parsed from aStream.  Everything upto the next blank line is a header field."		| nextLine |	[nextLine := aSwazooStream nextUnfoldedLine.	nextLine isEmpty]		whileFalse: [self readFieldFromString: nextLine].	^self</body></methods><methods><class-id>Swazoo.HTTPHeaders class</class-id> <category>instance creation</category><body package="Swazoo-Headers">readFrom: aSwazooStream 	"^an HTTPHeadersI return a new instance of myself which contains fields parsed from aStream."	^self new readFrom: aSwazooStream</body></methods><methods><class-id>Swazoo.GenericHeaderField</class-id> <category>accessing</category><body package="Swazoo-Headers">fieldName1 halt: 'use &gt;&gt;name instead'.	^self name</body><body package="Swazoo-Headers">name	^name</body><body package="Swazoo-Headers">value	^value</body><body package="Swazoo-Headers">values	^(HTTPString subCollectionsFrom: self value delimitedBy: $,) 		collect: [:each | HTTPString trimBlanksFrom: each]</body></methods><methods><class-id>Swazoo.GenericHeaderField</class-id> <category>services</category><body package="Swazoo-Headers">combineWith: aHeaderField 	"^selfI simply take my values and concatenate the values of aHeaderField."	value := self value , ', ' , aHeaderField value.	^self</body></methods><methods><class-id>Swazoo.GenericHeaderField</class-id> <category>printing</category><body package="Swazoo-Headers">valuesAsStringOn: aStream 	aStream nextPutAll: value.	^self</body></methods><methods><class-id>Swazoo.GenericHeaderField</class-id> <category>initialize-release</category><body package="Swazoo-Headers">forFieldName: fieldNameString andValue: fieldValueString 	name := fieldNameString.	value := fieldValueString.	^self</body></methods><methods><class-id>Swazoo.GenericHeaderField class</class-id> <category>instance creation</category><body package="Swazoo-Headers">newForFieldName: fieldNameString withValueFrom: fieldValueString 	^self new forFieldName: fieldNameString andValue: fieldValueString</body></methods><methods><class-id>Swazoo.HTTPLastModifiedField</class-id> <category>accessing</category><body package="Swazoo-Headers">timestamp	^timestamp</body><body package="Swazoo-Headers">timestamp: aTimestamp	timestamp := aTimestamp.</body></methods><methods><class-id>Swazoo.HTTPLastModifiedField</class-id> <category>printing</category><body package="Swazoo-Headers">valuesAsStringOn: aStream 	self timestamp asRFC1123StringOn: aStream.	^self</body></methods><methods><class-id>Swazoo.HTTPLastModifiedField class</class-id> <category>accessing</category><body package="Swazoo-Headers">fieldName	^'Last-Modified'</body></methods><methods><class-id>Swazoo.HTTPServer</class-id> <category>testing</category><body package="Swazoo-HTTP">isServing	^self loop notNil</body></methods><methods><class-id>Swazoo.HTTPServer</class-id> <category>private-initialize</category><body package="Swazoo-HTTP">initConnections	connections := OrderedCollection new.</body><body package="Swazoo-HTTP">initSites	sites := ServerRootComposite new</body><body package="Swazoo-HTTP">initialize	self initConnections.	self initSites</body><body package="Swazoo-HTTP">ip	^ip</body><body package="Swazoo-HTTP">ip: anIPString 	ip := anIPString</body><body package="Swazoo-HTTP">ipCorrected	"in case of '*' always return '0.0.0.0'"	^self ip = '*' 		ifTrue: ['0.0.0.0'] 		ifFalse: [self ip]</body><body package="Swazoo-HTTP">port	^port</body><body package="Swazoo-HTTP">port: aNumber	port := aNumber</body></methods><methods><class-id>Swazoo.HTTPServer</class-id> <category>serving</category><body package="Swazoo-HTTP">answerTo: aRequest 	| response |	response := URIResolution resolveRequest: aRequest startingAt: self sites.	^response isNil		ifTrue: [HTTPResponse notFound]		ifFalse: [response]</body></methods><methods><class-id>Swazoo.HTTPServer</class-id> <category>private</category><body package="Swazoo-HTTP">acceptConnection	| clientConnection |	clientConnection := SpExceptionContext 		for: [HTTPConnection socket: self socket accept]		on: SpError		do: [:ex | 			Transcript cr; cr; show: '*** HTTPServer accept error: ' , ex errorString, 				', restarting on ', self ip, ':', self port printString; cr; cr. 			(Delay forMilliseconds: 1000) wait. "to avoid endless loop"			[(Delay forSeconds: 1) wait. 			self restart]   "in case of broken socket"				fork.			^self].	(self isAllowedConnection: clientConnection) "IP is not on blacklist or is on whitelist"		ifTrue: 			[self addConnection: clientConnection.			clientConnection interact]		ifFalse: [clientConnection close].</body><body package="Swazoo-HTTP">addConnection: aConnection 	self connections add: aConnection.	aConnection server: self</body><body package="Swazoo-HTTP">connections	connections isNil ifTrue: [self initConnections].	^connections</body><body package="Swazoo-HTTP">loop	^loop</body><body package="Swazoo-HTTP">loop: aProcess	loop := aProcess</body><body package="Swazoo-HTTP">printString	^'aHTTPServer	ip: ', self ip printString, '	port: ', self port printString, ' 	serving: ', self isServing printString</body><body package="Swazoo-HTTP">removeConnection: aConnection 	self connections remove: aConnection ifAbsent: [nil]</body><body package="Swazoo-HTTP">server	"a SwazooServer on which we are running"	^SwazooServer singleton</body><body package="Swazoo-HTTP">sites	sites isNil ifTrue: [self initSites].	^sites</body><body package="Swazoo-HTTP">socket	^socket</body><body package="Swazoo-HTTP">socket: aSocket	socket := aSocket</body></methods><methods><class-id>Swazoo.HTTPServer</class-id> <category>start/stop</category><body package="Swazoo-HTTP">restart	"usefull after image startup, when socket is probably not valid anymore"	self stop.	self start.</body><body package="Swazoo-HTTP">start	self loop isNil ifTrue: 		[self socket: 			(SwazooSocket serverOnIP: self ipCorrected port: self port).		self socket listenFor: 128.		self loop: 			[ [self acceptConnection] repeat]  				newProcess.		self loop			priority: Processor userBackgroundPriority;			resume		]</body><body package="Swazoo-HTTP">stop	self loop isNil 		ifFalse: 			[self connections copy do: [:each | each close].			self loop terminate.			self loop: nil.			self socket close.			self socket: nil]</body></methods><methods><class-id>Swazoo.HTTPServer</class-id> <category>multithreading</category><body package="Swazoo-HTTP">isMultiThreading	"^a BooleanI return true if each inbound HTTP connection will be handled in its own thread.  See the senders of this message to see where that is important.  Note that the default mode is mult-threaded because this is how Swazoo has worked so far.  This is tricky for the application programmer, though, as they must ensure that they work in a thread safe way (e.g. avoid the many threads updating the same object).  For those deploying to GemStone, you wil find things much easier if you do *not* run multithreaded, but rather run many gems each with a single-threaded Swazoo instance (and your app logic) in each.  Also in GemStone, run the main loop in the foreground, c.f. &gt;&gt;mainLoopInForeground"	isMultiThreading isNil ifTrue: [self setMultiThreading].	^isMultiThreading</body><body package="Swazoo-HTTP">setMultiThreading	isMultiThreading := true.	^self</body><body package="Swazoo-HTTP">setSingleThreading	isMultiThreading := false.	^self</body></methods><methods><class-id>Swazoo.HTTPServer</class-id> <category>sites</category><body package="Swazoo-HTTP">addSite: aSite	(self sites includesResource: aSite) ifFalse: [^self sites addResource: aSite]</body><body package="Swazoo-HTTP">hasNoSites	^self sites hasNoResources</body><body package="Swazoo-HTTP">removeSite: aSite 	aSite parent: nil.	^self sites removeResource: aSite</body></methods><methods><class-id>Swazoo.HTTPServer</class-id> <category>filtering</category><body package="Swazoo-HTTP">isAllowedConnection: aHTTPConnection	 "Peer IP is not on blacklist or is on whitelist"	(self isPeerIPAlwaysAllowed: aHTTPConnection) ifTrue: [^true]. "from this IPs is kind of 'root' access"	^(self isPeerIPWhitelisted: aHTTPConnection) and:		[(self isPeerIPBlacklisted: aHTTPConnection) not]</body><body package="Swazoo-HTTP">isPeerIPAlwaysAllowed: aHTTPConnection	 "Peer IP is on always allowed list (a collection of IP patterns like '222.123.*' "	| peerIP |	self server ipAllowedList isEmpty ifTrue: [^false].  "in case there is noone on allowed list"	peerIP := [aHTTPConnection socket remoteAddress]		on: Error		do: [:ex | ^false]. "mailformed requests are blacklisted by default"	^self server ipAllowedList contains: [:ipString | ipString match: peerIP]</body><body package="Swazoo-HTTP">isPeerIPBlacklisted: aHTTPConnection	 "Peer IP is on blacklist (a collection of IP patterns like '222.123.*' "	| peerIP |	self server ipBlacklist isEmpty ifTrue: [^false].  "in case there is no blacklist"	peerIP := [aHTTPConnection socket remoteAddress] 		on: Error		do: [:ex | ^true]. "mailformed requests are blacklisted by default"	^self server ipBlacklist contains: [:ipString | ipString match: peerIP]</body><body package="Swazoo-HTTP">isPeerIPWhitelisted: aHTTPConnection	 "Peer IP is on whitelist (a collection of IP patterns like '222.123.*' "	| peerIP |	self server ipWhitelist isEmpty ifTrue: [^true].  "in case there is no whitelist"	peerIP := [aHTTPConnection socket remoteAddress]		on: Error		do: [:ex | ^false]. "mailformed requests are blacklisted by default"	^(self server ipWhitelist contains: [:ipString | ipString match: peerIP]) not</body></methods><methods><class-id>Swazoo.HTTPServer class</class-id> <category>instance creation</category><body package="Swazoo-HTTP">new	^super new initialize</body></methods><methods><class-id>Swazoo.HTTPServer class</class-id> <category>intialize-release</category><body package="Swazoo-HTTP">initialize	SpEnvironment addImageShutdownTask: [self shutDown] for: self</body><body package="Swazoo-HTTP">shutDown 	"HTTPServer shutDown"	self allInstances do: [:each | each stop].	SpEnvironment removeShutdownActionFor: self.</body></methods><methods><class-id>Swazoo.HTTPAuthenticationBasicChallenge</class-id> <category>challenging</category><body package="Swazoo-Messages">prepareAuthenticationChallenge	self addHeaderName: 'WWW-Authenticate' 		value: 'Basic realm="', self resource authenticationRealm, '"'</body></methods><methods><class-id>Swazoo.HTTPAuthenticationBasicChallenge class</class-id> <category>instance creation</category><body package="Swazoo-Messages">newForResource: aResource	^self unauthorized 		resource: aResource;		entity: aResource unauthorizedResponsePage;		prepareAuthenticationChallenge</body></methods><methods><class-id>Swazoo.HTTPAcceptField</class-id> <category>printing</category><body package="Swazoo-Headers">valuesAsStringOn: targetStream 	self mediaTypes isEmpty 		ifFalse: 			[targetStream nextPutAll: self mediaTypes first.			2 to: self mediaTypes size				do: 					[:methodIndex | 					targetStream						nextPut: $,;						nextPutAll: (self mediaTypes at: methodIndex)]].	^self</body></methods><methods><class-id>Swazoo.HTTPAcceptField</class-id> <category>private</category><body package="Swazoo-Headers">parseValueFrom: aString 	mediaTypes := HTTPString subCollectionsFrom: aString delimitedBy: $,.	^self</body></methods><methods><class-id>Swazoo.HTTPAcceptField</class-id> <category>accessing</category><body package="Swazoo-Headers">mediaTypes	mediaTypes isNil ifTrue: [mediaTypes := OrderedCollection new].	^mediaTypes</body></methods><methods><class-id>Swazoo.HTTPAcceptField</class-id> <category>services</category><body package="Swazoo-Headers">combineWith: aHeaderField 	"^selfI simply take my values and concatenate the values of aHeaderField."	self mediaTypes addAll: aHeaderField mediaTypes.	^self</body></methods><methods><class-id>Swazoo.HTTPAcceptField class</class-id> <category>accessing</category><body package="Swazoo-Headers">fieldName	^'Accept'</body></methods><methods><class-id>Swazoo.SwazooSocketTest</class-id> <category>running</category><body package="Swazoo-Tests">setUp	| pair |	pair := SwazooSocket connectedPair.	input := pair first.	output := pair last</body><body package="Swazoo-Tests">tearDown	input close.	output close</body></methods><methods><class-id>Swazoo.SwazooSocketTest</class-id> <category>testing</category><body package="Swazoo-Tests">testConnectedPair	(Array with: input with: output) 		do: [:each | self assert: (each isKindOf: SwazooSocket)]</body><body package="Swazoo-Tests">testNetworkConnection	| server sem |	input close.	output close.	sem := Semaphore new.		[server := SwazooSocket serverOnIP: '127.0.0.1' port: 65423.	server listenFor: 50.		[input := server accept.	sem signal] fork.	output := SwazooSocket connectTo: 'localhost' port: 65423.	sem wait.	self testReadWrite] 			ensure: [server close]</body><body package="Swazoo-Tests">testPartialRead	| bytes |	bytes := ByteArray withAll: #(5 4 3).	self assert: (input write: bytes) = 3.	self assert: (output read: 5) = bytes</body><body package="Swazoo-Tests">testReadTimeout	input write: (ByteArray withAll: #(1 2 3)).	self assert: (output read: 3 timeout: 40) = (ByteArray withAll: #(1 2 3)).	self assert: (output read: 3 timeout: 40) = ByteArray new</body><body package="Swazoo-Tests">testReadWrite	| bytes |	bytes := ByteArray withAll: #(1 2 3 4 5).	self assert: (input write: bytes) = 5.	self assert: (output read: 5) = bytes.	bytes := ByteArray with: 4.	self assert: (input write: bytes) = 1.	self assert: (output read: 1) = bytes</body></methods><methods><class-id>Swazoo.HTTPIfModifiedSinceField</class-id> <category>testing</category><body package="Swazoo-Headers">isCacheHitFor: anEntity 	"^a BooleanI return true if an anEntity is a cache hit given the conditional I represent.  So in my case, I'm looking to see that the entity has not changed since my date.anEntity *must* respond to &gt;&gt;lastModified"	^anEntity lastModified &lt;= self date</body><body package="Swazoo-Headers">isConditional	^true</body></methods><methods><class-id>Swazoo.HTTPIfModifiedSinceField</class-id> <category>accessing</category><body package="Swazoo-Headers">date	^date</body></methods><methods><class-id>Swazoo.HTTPIfModifiedSinceField</class-id> <category>private</category><body package="Swazoo-Headers">parseValueFrom: aString 	date := SpTimestamp fromRFC1123String: aString.	^self</body></methods><methods><class-id>Swazoo.HTTPIfModifiedSinceField</class-id> <category>printing</category><body package="Swazoo-Headers">valuesAsStringOn: aStream 	self date notNil ifTrue: [self date asRFC1123StringOn: aStream].	^self</body></methods><methods><class-id>Swazoo.HTTPIfModifiedSinceField class</class-id> <category>accessing</category><body package="Swazoo-Headers">fieldName	^'If-Modified-Since'</body></methods><methods><class-id>Swazoo.HomeResourceTest</class-id> <category>running</category><body package="Swazoo-Tests">setUp	resource := HomeResource uriPattern: '/' filePath: 'home'</body><body package="Swazoo-Tests">testRootFileFor	| request |	request := HTTPGet request: '/~someUser'.	URIResolution new initializeRequest: request.	self assert: (resource rootFileFor: request) asString				= (((SpFilename named: 'home') construct: 'someUser') construct: 'html') asString</body><body package="Swazoo-Tests">testValidateHomePath	self assert: (resource validateHomePath: '~somebody').	self assert: (resource validateHomePath: '~somebodyElse').	self deny: (resource validateHomePath: 'someplace').	self deny: (resource validateHomePath: 'some~body')</body></methods><methods><class-id>Swazoo.HTTPContentLengthField</class-id> <category>accessing</category><body package="Swazoo-Headers">contentLength	^contentLength</body><body package="Swazoo-Headers">contentLength: anInteger	contentLength := anInteger</body></methods><methods><class-id>Swazoo.HTTPContentLengthField</class-id> <category>printing</category><body package="Swazoo-Headers">valuesAsStringOn: aStream 	self contentLength printOn: aStream.	^self</body></methods><methods><class-id>Swazoo.HTTPContentLengthField</class-id> <category>private</category><body package="Swazoo-Headers">parseValueFrom: aString	contentLength := aString asNumber.	^self</body></methods><methods><class-id>Swazoo.HTTPContentLengthField class</class-id> <category>accessing</category><body package="Swazoo-Headers">fieldName	^'Content-Length'</body></methods><methods><class-id>Swazoo.HTTPResponseTest</class-id> <category>private</category><body package="Swazoo-Tests">crlf	^String with: Character cr with: Character lf</body></methods><methods><class-id>Swazoo.HTTPResponseTest</class-id> <category>testing</category><body package="Swazoo-Tests">testInternalServerError	| ws rs |	response := HTTPResponse internalServerError.	ws := SwazooStream on: String new.	response printStatusOn: ws.	rs := SwazooStream on: ws writeBuffer contents.	self assert: rs nextLine = 'HTTP/1.1 500 Internal Server Error'</body><body package="Swazoo-Tests">testOK	| ws rs |	response := HTTPResponse ok.	ws := SwazooStream on: String new.	response printStatusOn: ws.	rs := SwazooStream on: ws writeBuffer contents.	self assert: rs nextLine = 'HTTP/1.1 200 OK'</body><body package="Swazoo-Tests">testResponseTypes	self assert: (HTTPResponse badRequest) isBadRequest.	self assert: (HTTPResponse found) isFound.	self assert: (HTTPResponse internalServerError) isInternalServerError.	self assert: (HTTPResponse movedPermanently) isMovedPermanently.	self assert: (HTTPResponse notFound) isNotFound.	self assert: (HTTPResponse notImplemented) isNotImplemented.	self assert: (HTTPResponse notModified) isNotModified.	self assert: (HTTPResponse ok) isOk.	self assert: (HTTPResponse redirectLink) isRedirectLink.	self assert: (HTTPResponse seeOther) isSeeOther.</body></methods><methods><class-id>Swazoo.URIIdentifier</class-id> <category>comparing</category><body package="Swazoo-HTTP">= anIdentifier 	^self match: anIdentifier</body><body package="Swazoo-HTTP">hash	^1</body></methods><methods><class-id>Swazoo.URIIdentifier</class-id> <category>testing</category><body package="Swazoo-HTTP">match: anotherIdentifier 	^(self typeMatch: anotherIdentifier) 		and: [self valueMatch: anotherIdentifier]</body></methods><methods><class-id>Swazoo.URIIdentifier</class-id> <category>private</category><body package="Swazoo-HTTP">typeMatch: anotherIdentifier 	^self class == anotherIdentifier class</body><body package="Swazoo-HTTP">valueMatch: anotherIdentifier 	^self subclassResponsibility</body></methods><methods><class-id>Swazoo.SiteIdentifier</class-id> <category>accessing</category><body package="Swazoo-HTTP">currentUrl	| stream |	stream := WriteStream on: String new.	self printUrlOn: stream.	^stream contents</body><body package="Swazoo-HTTP">host	^host</body><body package="Swazoo-HTTP">ip	^ip</body><body package="Swazoo-HTTP">port	^port</body></methods><methods><class-id>Swazoo.SiteIdentifier</class-id> <category>initialize-release</category><body package="Swazoo-HTTP">host:  hostName ip: anIP port: aPort	self host: hostName.	self ip: anIP.	self port: aPort.</body><body package="Swazoo-HTTP">newServer	^ HTTPServer new ip: self ip;  port: self port</body></methods><methods><class-id>Swazoo.SiteIdentifier</class-id> <category>private</category><body package="Swazoo-HTTP">host: aString	host := aString</body><body package="Swazoo-HTTP">ip: aString	ip := aString</body><body package="Swazoo-HTTP">port: aNumber	port := aNumber</body><body package="Swazoo-HTTP">printHostPortStringOn: stream 	stream nextPutAll: (self host notNil ifTrue: [self host] ifFalse: ['']).	self port = 80 ifFalse: [stream nextPut: $:; nextPutAll: self port printString]</body><body package="Swazoo-HTTP">printString	^'a Swazoo.SiteIndentifier	host: ', (self host isNil ifTrue: [''] ifFalse: [self host]), '	ip: ', (self ip isNil ifTrue: [''] ifFalse: [self ip]), '	port: ', self port printString</body><body package="Swazoo-HTTP">printUrlOn: aWriteStream 	aWriteStream nextPutAll: 'http://'.	self printHostPortStringOn: aWriteStream</body></methods><methods><class-id>Swazoo.SiteIdentifier</class-id> <category>private-comparing</category><body package="Swazoo-HTTP">hostMatch: aSiteIdentifier	(self host asLowercase = aSiteIdentifier host asLowercase) ifTrue: [^true].	(self host = '*' or: [aSiteIdentifier host = '*']) ifTrue: [^true]. "is this always good?" 	^false</body><body package="Swazoo-HTTP">ipMatch: aSiteIdentifier	"ip can be in numbers or named!"	| myIP otherIP |	self ip = aSiteIdentifier ip ifTrue: [^true].	(self ip = '*' or: [self ip = '0.0.0.0']) ifTrue: [^true].	(aSiteIdentifier ip = '*' or: [aSiteIdentifier ip = '0.0.0.0']) ifTrue: [^true]. "is this always good?"	myIP := SpIPAddress hostName: self ip port: self port.	otherIP := SpIPAddress hostName: aSiteIdentifier ip port: aSiteIdentifier port.	^myIP hostAddress = otherIP hostAddress</body><body package="Swazoo-HTTP">portMatch: aSiteIdentifier	"ih host can be anything then same goes for the port of request too"	self port = aSiteIdentifier port ifTrue: [^true].	(self host = '*' or: [aSiteIdentifier host = '*']) ifTrue: [^true]. 	^false</body><body package="Swazoo-HTTP">valueMatch: aSiteIdentifier	^(self portMatch: aSiteIdentifier)		and: [(self ipMatch: aSiteIdentifier) "on second place because it is slower"			and: [self hostMatch: aSiteIdentifier] ]</body></methods><methods><class-id>Swazoo.SiteIdentifier</class-id> <category>testing</category><body package="Swazoo-HTTP">isEmpty	"host ip port empty or nil"	(host isNil or: [host isEmpty]) ifTrue: [^true].	(ip isNil or: [ip isEmpty]) ifTrue: [^true].	port isNil ifTrue: [^true].	^false</body></methods><methods><class-id>Swazoo.SiteIdentifier class</class-id> <category>instance creation</category><body package="Swazoo-HTTP">host: hostName ip: anIP port: aPort 	^self new 		host: hostName ip: anIP port: aPort</body></methods><methods><class-id>Swazoo.HTTPExpiresField</class-id> <category>printing</category><body package="Swazoo-Headers">valuesAsStringOn: aStream 	self timestamp asRFC1123StringOn: aStream.	^self</body></methods><methods><class-id>Swazoo.HTTPExpiresField</class-id> <category>accessing</category><body package="Swazoo-Headers">timestamp	^timestamp</body><body package="Swazoo-Headers">timestamp: aTimestamp	timestamp := aTimestamp.</body></methods><methods><class-id>Swazoo.HTTPExpiresField class</class-id> <category>accessing</category><body package="Swazoo-Headers">fieldName	^'Expires'</body></methods><methods><class-id>Swazoo.HTTPString class</class-id> <category>tokens</category><body package="Swazoo-HTTP">subCollectionsFrom: aCollection delimitedBy: anObject 	"^an OrderedCollectionI return the ordered collection of sub-collections from aCollection, delimitedby anObject."	"HTTPString subCollectionsFrom: 'aaa/bbb/' delimitedBy: $/"	| subCollections sourceStream |	subCollections := OrderedCollection new.	sourceStream := ReadStream on: aCollection.	[sourceStream atEnd] 		whileFalse: [subCollections add: (sourceStream upTo: anObject)].	(aCollection isEmpty 		or: [(sourceStream				skip: -1;				next) == anObject]) 			ifTrue: [subCollections add: aCollection class new].	^subCollections</body></methods><methods><class-id>Swazoo.HTTPString class</class-id> <category>decoding</category><body package="Swazoo-HTTP">decodedHTTPFrom: aCharacterArray 	"Code taken from the swazoo specific extention to the CharacterArray class"	| targetStream sourceStream |	targetStream := WriteStream on: aCharacterArray class new.	sourceStream := ReadStream on: aCharacterArray.	[sourceStream atEnd] whileFalse: 			[| char |			char := sourceStream next.			char = $% 				ifTrue: 					[targetStream 						nextPut: (SpEnvironment integerFromString: '16r' , (sourceStream next: 2)) 								asCharacter]				ifFalse: 					[char == $+ 						ifTrue: [targetStream nextPut: Character space]						ifFalse: [targetStream nextPut: char]]].	^targetStream contents</body><body package="Swazoo-HTTP">encodedHTTPFrom: aCharacterArray 	"Code taken from the swazoo specific extention to the CharacterArray class"	| targetStream |	targetStream := WriteStream on: aCharacterArray class new.	aCharacterArray do: 			[:char | 			(self isHTTPReservedCharacter: char) 				ifTrue: 					[targetStream nextPut: $%.					char asInteger 						printOn: targetStream						paddedWith: $0						to: 2						base: 16]				ifFalse: [targetStream nextPut: char]].	^targetStream contents</body><body package="Swazoo-HTTP">isHTTPReservedCharacter: aCharacter 	"Code taken from the swazoo specific extention to the Character class"	^(aCharacter isAlphaNumeric or: ['-_.!~*''()' includes: aCharacter]) not</body><body package="Swazoo-HTTP">stringFromBytes: aByteArray 	"^a StringIn GemStone ['Hello, World' asByteArray asString] returns the string 'aByteArray' !This is the boring long way of getting a string from a ByteArray - but it does workin GemStone."	"HTTPString stringFromBytes: ('Hello, World' asByteArray)"	| targetStream |	targetStream := WriteStream on: String new.	aByteArray do: [:aByte | targetStream nextPut: aByte asCharacter].	^targetStream contents</body><body package="Swazoo-HTTP">trimBlanksFrom: aString 	"^a StringI return a copy of aString with all leading and trailing blanks removed."	| first last |	first := 1.	last := aString size.	[last &gt; 0 and: [(aString at: last) isSeparator]] 		whileTrue: [last := last - 1].	^last == 0 		ifTrue: [String new]		ifFalse: 			[[first &lt; last and: [(aString at: first) isSeparator]] 				whileTrue: [first := first + 1].			aString copyFrom: first to: last]</body></methods><methods><class-id>Swazoo.HTTPString class</class-id> <category>instance creation</category><body package="Swazoo-HTTP">newRandomString: anInteger 	| numbersThroughAlphas targetStream char random |	numbersThroughAlphas := (48 to: 122) collect: [:each | each asCharacter].	targetStream := WriteStream on: (String new: anInteger).	random := Random new.	[targetStream contents size &lt; anInteger] whileTrue: 			[char := numbersThroughAlphas 						at: (random next * (numbersThroughAlphas size - 1)) rounded + 1.			char isAlphaNumeric ifTrue: [targetStream nextPut: char]].	^targetStream contents</body></methods><methods><class-id>Swazoo.HTTPWWWAuthenticateDigestField</class-id> <category>testing</category><body package="Swazoo-Headers">isDigest	"^a BooleanI return true if I represent a header for digest authentication. c.f. RFC 2617 sec 3."	^true</body></methods><methods><class-id>Swazoo.HTTPIfMatchField</class-id> <category>testing</category><body package="Swazoo-Headers">isCacheHitFor: anEntity 	"^a BooleanI return true if an anEntity is a cache hit given the conditional I represent. anEntity *must* respond to &gt;&gt;entutyTag"	1 halt.	^self</body></methods><methods><class-id>Swazoo.HTTPIfMatchField class</class-id> <category>accessing</category><body package="Swazoo-Headers">fieldName	^'If-Match'</body></methods><methods><class-id>Swazoo.SwazooBenchmarks</class-id> <category>socket performance</category><body package="Swazoo-Tests">contentSize	^10000000</body><body package="Swazoo-Tests">serverLoop	| socket clientSocket |	socket := SpSocket newTCPSocket.	socket		setAddressReuse: true;		bindSocketAddress: (SpIPAddress hostName: 'localhost' port: 9999).	[	socket listenBackloggingUpTo: 50.		[true] whileTrue: 			[ 	clientSocket := socket accept.				[ [true] whileTrue: 					[clientSocket read: 60. "HTTP request"					clientSocket write: self content] ]				on: Error "probably connection close by peer"				do: [:ex | "nothing"]			]	] ensure: [clientSocket notNil ifTrue: [clientSocket close]. socket close]</body><body package="Swazoo-Tests">startSocketServer	"SwazooBenchmarks singleton startSocketServer"	"SwazooBenchmarks singleton stopSocketServer"	"testing raw socket performance.	it will start a server on localhost:9999 to receive a request       and respond with 10K response as drirectly as possible."	self stopSocketServer. 	self server: [self serverLoop] fork.</body><body package="Swazoo-Tests">stopSocketServer	"SwazooBenchmarks singleton stopSocketServer"	self server notNil ifTrue: [self server terminate. self server: nil].	self content: nil.	(Delay forMilliseconds: 1000) wait.	ObjectMemory garbageCollect.</body></methods><methods><class-id>Swazoo.SwazooBenchmarks</class-id> <category>accessing</category><body package="Swazoo-Tests">content	"test content to be writen to the socket"	content isNil ifTrue: [self initContent].	^content</body><body package="Swazoo-Tests">content: aByteArray	content := aByteArray</body><body package="Swazoo-Tests">server	"TCP server loop"	^server</body><body package="Swazoo-Tests">server: aProcess	"TCP server loop"	server := aProcess</body></methods><methods><class-id>Swazoo.SwazooBenchmarks</class-id> <category>initialize-release</category><body package="Swazoo-Tests">initContent	| response ws |	response := HTTPResponse ok.	response entity: (ByteArray new: self contentSize withAll: 16r55).	ws := SwazooStream on: String new.	response writeTo: ws.	content := ws writeBuffer contents.</body></methods><methods><class-id>Swazoo.SwazooBenchmarks class</class-id> <category>accessing</category><body package="Swazoo-Tests">singleton	Singleton isNil ifTrue: [Singleton := self new].	^Singleton</body></methods><methods><class-id>Swazoo.URIParsingTest</class-id> <category>testing</category><body package="Swazoo-Tests">test05SimpleFullURI|uri|uri := SwazooURI fromString: 'http://abc.com:8080/smith/home.html'.self assert: (uri protocol = 'http').self assert: (uri hostname = 'abc.com'). self assert: (uri port = 8080).self assert: (uri identifier = '/smith/home.html').self assert: (uri asString = 'http://abc.com:8080/smith/home.html').</body><body package="Swazoo-Tests">test10SimpleFullURIWithQuery|uri|uri := SwazooURI fromString: 'http://abc.com:8080/smith/home.html?a=1&amp;b=2'.self assert: (uri protocol = 'http').self assert: (uri hostname = 'abc.com'). self assert: (uri port = 8080).self assert: (uri identifier = '/smith/home.html').self assert: (uri asString = 'http://abc.com:8080/smith/home.html?a=1&amp;b=2').</body><body package="Swazoo-Tests">test15SimpleFullURIWithPort80|uri|uri := SwazooURI fromString: 'http://abc.com:80/smith/home.html?a=1&amp;b=2'.self assert: (uri protocol = 'http').self assert: (uri hostname = 'abc.com'). self assert: (uri port = 80).self assert: (uri identifier = '/smith/home.html').self assert: (uri asString = 'http://abc.com/smith/home.html?a=1&amp;b=2').</body><body package="Swazoo-Tests">test20SimpleFullURIWithNoPort|uri|uri := SwazooURI fromString: 'http://abc.com/smith/home.html?a=1&amp;b=2'.self assert: (uri protocol = 'http').self assert: (uri hostname = 'abc.com'). self assert: (uri port = 80).self assert: (uri identifier = '/smith/home.html').self assert: (uri asString = 'http://abc.com/smith/home.html?a=1&amp;b=2').</body></methods><methods><class-id>Swazoo.SwazooServer</class-id> <category>private-servers</category><body package="Swazoo-Core">addServer: aHTTPServer	^self servers add: aHTTPServer</body><body package="Swazoo-Core">newServerFor: aSiteIdentifier	^ aSiteIdentifier newServer.</body><body package="Swazoo-Core">removeServer: aHTTPServer	^self servers remove: aHTTPServer</body><body package="Swazoo-Core">restartServers	"do that after image restart, because TCP sockets are probably not valid anymore"	self servers do: [:each | each restart].</body><body package="Swazoo-Core">serverFor: aSiteIdentifier 	| httpServer |	aSiteIdentifier isEmpty ifTrue: [^nil]. "in case of new one  initializing"	^self servers 		detect: [:each | (each ip = aSiteIdentifier ip) &amp; (each port = aSiteIdentifier port)]		ifNone: [			httpServer := self newServerFor: aSiteIdentifier.						self addServer: httpServer.			httpServer start.			^httpServer]</body><body package="Swazoo-Core">servers	servers isNil ifTrue: [self initServers].	^servers</body></methods><methods><class-id>Swazoo.SwazooServer</class-id> <category>private</category><body package="Swazoo-Core">allowedHostIPPortFor: aSite	"is host:ip:port combination of aSite allowed regarding to existing sites?"	"rules:		1. host name must be unique, except if it is * (anyHost)  		2. only one site per port can run on any host and all IP interfaces (ip = * or 0.0.0.0)		3. if there is a site runing on all IP interfaces, then no one can run on specific ip, per port		4. 3 vice versa		5. there is no site with the same host ip port combination	"	(self siteHostnamed: aSite host) notNil ifTrue: [^false]. 	(aSite onAllInterfaces and: [self hasSiteOnPort: aSite port]) ifTrue: [^false].	(aSite onAllInterfaces not and: [self hasSiteOnAllInterfacesOnPort: aSite port]) ifTrue: [^false]. 	(self hasSiteHostnamed: aSite host ip: aSite ip port: aSite port) ifTrue: [^false].	^true</body><body package="Swazoo-Core">hasSiteHostnamed: aHostname ip: ipString port: aNumber	^self sites contains: [:each | 		each host = aHostname and: [each ip = ipString and: [each port = aNumber ] ] ]</body><body package="Swazoo-Core">hasSiteOnAllInterfacesOnPort: aNumber	"only one site per port is allowed when listening to all interfaces"	^self sites contains: [:each | each onAllInterfaces and: [each port = aNumber] ]</body><body package="Swazoo-Core">hasSiteOnPort: aNumber	^self sites contains: [:each | each port = aNumber ]</body><body package="Swazoo-Core">prepareDemoSite	"on http://localhost:8888 to return 'Hello Word' "	"on http://localhost:8888/websocket to upgrade to WebSocket bidirectional 	messaging (echo by default)"	| site |	site := SwazooDemoSite newNamed: 'swazoodemo'. "which is now also added to SwazoServer"	site host: '*' ip: '*' port: 8888.	^site</body><body package="Swazoo-Core">prepareDemoSiteOnPort: aNumber	"this site will run on all IP interfaces on that port, returning 'Hello Word' "	| name site |	name := 'port', aNumber printString.	site := SwazooDemoSite newNamed: name. "which is now also added to SwazoServer"	site host: '*' ip: '*' port: aNumber.	^site</body><body package="Swazoo-Core">removeAllSites	self sites copy do: [:each | self removeSite: each]</body><body package="Swazoo-Core">siteAnyHostAllInterfacesOnPort: aNumber	"for host: * ip: * sites"	^self sites 		detect: [:each | each onAnyHost and: [each onAllInterfaces and: [each port = aNumber] ] ]		ifNone: [nil]</body><body package="Swazoo-Core">sites	sites isNil ifTrue: [self initSites].	^sites</body></methods><methods><class-id>Swazoo.SwazooServer</class-id> <category>private-watchdog</category><body package="Swazoo-Core">watchdogOther	"override for other"</body><body package="Swazoo-Core">watchdogSites	self sites do: [:each | 		each isServing ifTrue: [each watchdogAction] ]</body></methods><methods><class-id>Swazoo.SwazooServer</class-id> <category>initialize-release</category><body package="Swazoo-Core">initOther	other := Dictionary new.</body><body package="Swazoo-Core">initServers	servers := Set new.</body><body package="Swazoo-Core">initSites	sites := OrderedCollection new.</body><body package="Swazoo-Core">initialize	self initSites.	self initServers.</body></methods><methods><class-id>Swazoo.SwazooServer</class-id> <category>accessing</category><body package="Swazoo-Core">allSites	^self sites copy</body><body package="Swazoo-Core">siteHostnamed: aString	"find a site with that host name"	| string |	aString = '*' ifTrue: [^nil]. "what else should we return?"	string := aString isNil ifTrue: [''] ifFalse: [aString asLowercase].	^self sites detect: [:each | 		each host notNil and: [each host asLowercase = string]] ifNone: [nil].</body><body package="Swazoo-Core">siteNamed: aString	"find a site with that short name"	| string |	string := aString isNil ifTrue: [''] ifFalse: [aString asLowercase].	^self sites detect: [:each | each name asLowercase = string] ifNone: [nil].</body></methods><methods><class-id>Swazoo.SwazooServer</class-id> <category>adding/removing</category><body package="Swazoo-Core">addSite: aSite	(self siteNamed: aSite name) notNil 		ifTrue: [^SwazooSiteError error: 'Site with that name already exist!'].	(self siteHostnamed: aSite host) notNil 		ifTrue: [^SwazooSiteError error: 'Site host name must be unique!'].	(self hasSiteHostnamed: aSite host ip: aSite ip port: aSite port) 		ifTrue: [^SwazooSiteError error: 'Site with that host:ip:port combination already exist!'].	(self allowedHostIPPortFor: aSite) 		ifFalse: [^SwazooSiteError error: 'Site with such host:ip:port combination not allowed!'].	self sites add: aSite</body><body package="Swazoo-Core">removeSite: aSite 	aSite stop.	self sites remove: aSite</body></methods><methods><class-id>Swazoo.SwazooServer</class-id> <category>start/stop</category><body package="Swazoo-Core">restart	self stop; start</body><body package="Swazoo-Core">start	self sites do: [:site | site start].	self startWatchdog.</body><body package="Swazoo-Core">startOn: aPortNumber	"start a site on that port, on all ip interfaces and accepting all hosts.	It also created a site if there is any site on that port yet"	"opening http://localhost:portNumber will return a simple 'Hello world' "	| site |	site := self siteAnyHostAllInterfacesOnPort: aPortNumber.	site isNil ifTrue: [site := self prepareDemoSiteOnPort: aPortNumber].	site start.	^site</body><body package="Swazoo-Core">startSite: aString	"start site with that name"	| site |	site := self siteNamed: aString.	^site notNil 		ifTrue: [site start. self isWatchdogRunning ifFalse: [self startWatchdog]. site] 		ifFalse: [nil]</body><body package="Swazoo-Core">stop	self sites do: [:site | site stop].	self servers do: [:server | server stop].	self initServers.	self stopWatchdog.	HTTPServer allInstances do: [:each | each stop; initSites] "to be sure"</body><body package="Swazoo-Core">stopOn: aPortNumber	"stop a site on that port, if any running on all ip interfaces and accepting all hosts"	| site |	site := self siteAnyHostAllInterfacesOnPort: aPortNumber.	^site notNil ifTrue: [site stop. site] ifFalse: [nil].</body><body package="Swazoo-Core">stopSite: aString	"stop site with that name"	| site |	site := self siteNamed: aString.	^site notNil ifTrue: [site stop. site] ifFalse: [nil].</body></methods><methods><class-id>Swazoo.SwazooServer</class-id> <category>private-watchdog</category><body package="Swazoo-Core">startWatchdog	"SwazooServer singleton startWatchdog"	self isWatchdogRunning ifTrue: [self stopWatchdog].	self watchdog: ([ [true] whileTrue:		[(self respondsTo: #watchdogSites) ifTrue: [self watchdogSites].		(self respondsTo: #watchdogOther) ifTrue: [self watchdogOther]. "if any"		(Delay forSeconds: self watchdogPeriod) wait. ]	] forkAt: Processor lowIOPriority)</body><body package="Swazoo-Core">stopWatchdog	self watchdog notNil ifTrue: 		[self watchdog terminate.		self watchdog: nil].</body><body package="Swazoo-Core">watchdog	^self otherAt: #Watchdog</body><body package="Swazoo-Core">watchdog: aProcess	^self otherAt: #Watchdog put: aProcess</body><body package="Swazoo-Core">watchdogPeriod	^10  "seconds"</body></methods><methods><class-id>Swazoo.SwazooServer</class-id> <category>testing</category><body package="Swazoo-Core">isServing	"any site running currently?"	^self servers notEmpty</body></methods><methods><class-id>Swazoo.SwazooServer</class-id> <category>filtering</category><body package="Swazoo-Core">ipAllowedList	"A list of IP address patterns from where access is always allowed, not to mix with ipWhitelist! "	"these IP patterns have kind of  'root' access, they overpass all other filters"	^self otherAt: #ipAllowedList ifAbsentPut: [OrderedCollection new]</body><body package="Swazoo-Core">ipBlacklist	"A list of IP addresses to deny opening a connection"	"A collection of strings,  also with * pattern like: '89.112.*' "	^self otherAt: #IPBlacklist ifAbsentPut: [OrderedCollection new]</body><body package="Swazoo-Core">ipWhitelist	"A list of IP addresses to allow opening a connection. Other are denied"	"A collection of strings, also with * pattern like: '89.112.*' "	^self otherAt: #IPWhitelist ifAbsentPut: [OrderedCollection new]</body><body package="Swazoo-Core">urlBlacklist	"A list of absolute Url patterns (host included) to deny access - close connection immediatelly"	"Example: 'http://www.swazoo.org/admin*' "	^self otherAt: #UrlBlacklist ifAbsentPut: [OrderedCollection new]</body></methods><methods><class-id>Swazoo.SwazooServer</class-id> <category>private-other</category><body package="Swazoo-Core">other	^other</body><body package="Swazoo-Core">otherAt: aSymbol	"other values"	^self otherAt: aSymbol ifAbsent: [nil]</body><body package="Swazoo-Core">otherAt: aSymbol ifAbsent: aBlock	"other values"	self other isNil ifTrue: [^aBlock value].	^self other at: aSymbol ifAbsent: aBlock</body><body package="Swazoo-Core">otherAt: aSymbol ifAbsentPut: aBlock	self other isNil ifTrue: [self initOther].	^self other at: aSymbol ifAbsent: [self other at: aSymbol put: aBlock value]</body><body package="Swazoo-Core">otherAt: aSymbol put: anObject	self other isNil ifTrue: [self initOther].	^self other at: aSymbol put: anObject</body></methods><methods><class-id>Swazoo.SwazooServer class</class-id> <category>private</category><body package="Swazoo-Core">initSingleton	Singleton := super new.</body><body package="Swazoo-Core">new	^self shouldNotImplement</body><body package="Swazoo-Core">readSitesFrom: aStream 	| sites instance |	sites := OrderedCollection new.	[instance := SwazooSite new readFrom: aStream.	instance notNil] whileTrue: [sites add: instance].	^sites</body></methods><methods><class-id>Swazoo.SwazooServer class</class-id> <category>accessing</category><body package="Swazoo-Core">singleton	Singleton isNil ifTrue: [self initSingleton].	^Singleton</body><body package="Swazoo-Core">siteHostnamed: aString	^self singleton siteHostnamed: aString</body><body package="Swazoo-Core">siteNamed: aString	^self singleton siteNamed: aString</body><body package="Swazoo-Core">swazooVersion	^'Swazoo 2.3 Smalltalk Web Server'</body></methods><methods><class-id>Swazoo.SwazooServer class</class-id> <category>start/stop</category><body package="Swazoo-Core">demoStart	"on http://localhost:8888/ will return simple 'Hello World'"	| site |	site := self singleton siteNamed: 'swazoodemo'.	site isNil ifTrue: [site := self singleton prepareDemoSite].	site start</body><body package="Swazoo-Core">demoStop	self stopSite: 'swazoodemo'</body><body package="Swazoo-Core">restart	self singleton restart</body><body package="Swazoo-Core">start	"start all sites"	self singleton start</body><body package="Swazoo-Core">startOn: aPortNumber	"start a site on that port, on all ip interfaces and accepting all hosts.	It also created a site if there is any site on that port yet"	^self singleton startOn: aPortNumber</body><body package="Swazoo-Core">startSite: aString	"start site with that name"	^self singleton startSite: aString</body><body package="Swazoo-Core">stop	"stop all sites"	self singleton stop</body><body package="Swazoo-Core">stopOn: aPortNumber	"stop a site on that port, if any runingon all ip interfaces and accepting all hosts."	^self singleton stopOn: aPortNumber</body><body package="Swazoo-Core">stopSite: aString	"stop site with that name"	^self singleton stopSite: aString</body></methods><methods><class-id>Swazoo.SwazooServer class</class-id> <category>config-from-file</category><body package="Swazoo-Core">configureFrom: aFilenameString 	"To configure from an XML file like sites.cnf, see method #exampleConfigurationFile"	"Recomended if you use Swazoo for serving static web sites"	"Beware that all existing sites are removed first! "	| sites stream |	self singleton removeAllSites.	stream := aFilenameString asFilename readStream.	[sites := self readSitesFrom: stream] ensure: [stream close].	sites do: [:each | 		self singleton addSite: each.		each start]</body><body package="Swazoo-Core">exampleConfigurationFile	"example sites.cnf, which will serve static files from current directory and respond with	'Hello Worlrd' from url http://localhost:8888/foo/Howdy""&lt;Site&gt; 	&lt;SiteIdentifier ip: '127.0.0.1' port: 8888 host: 'localhost' &gt; 	&lt;CompositeResource uriPattern: '/'&gt;  		&lt;CompositeResource uriPattern: 'foo'&gt;   			&lt;HelloWorldResource uriPattern: 'Howdy'&gt;  		&lt;/CompositeResource&gt; 	&lt;/CompositeResource&gt; 	&lt;FileResource uriPattern: '/' filePath: '.'&gt;&lt;/Site&gt;"</body></methods><methods><class-id>Swazoo.SwazooServer class</class-id> <category>initialize</category><body package="Swazoo-Core">initialize	"self initialize"	SpEnvironment addImageStartupTask: [self singleton restartServers] for: self singleton.</body></methods><methods><class-id>Swazoo.CompositeResourceTest</class-id> <category>testing</category><body package="Swazoo-Tests">sampleInSite	| site |	site := SwazooSite new.	site host: 'swazoo.org' ip: '127.0.0.1' port: 8200.	site addResource: composite</body><body package="Swazoo-Tests">testAddResource	| child |	composite addResource: (child := HelloWorldResource uriPattern: 'hello.html').	self assert: composite children size = 1.	self assert: composite children first == child.	self assert: child parent == composite</body><body package="Swazoo-Tests">testAddResources	| child1 child2 |	child1 := HelloWorldResource uriPattern: 'hello1.html'.	child2 := HelloWorldResource uriPattern: 'hello2.html'.	composite addResources: (Array with: child1 with: child2).	self assert: composite children size = 2.	composite children		do: 			[:each | 			self assert: (composite children includes: each).			self assert: each parent == composite]</body><body package="Swazoo-Tests">testCurrentUrl	| child leaf |		self sampleInSite.	self assert: composite currentUrl = 'http://swazoo.org:8200/'.	composite addResource: (child := CompositeResource uriPattern: 'foo').	self assert: child currentUrl = 'http://swazoo.org:8200/foo/'.	child addResource: (leaf := HelloWorldResource uriPattern: 'hi.html').	self assert: leaf currentUrl = 'http://swazoo.org:8200/foo/hi.html'.</body><body package="Swazoo-Tests">testEmptyURIPatternInvalid	composite uriPattern: ''.	self deny: composite isValidlyConfigured</body><body package="Swazoo-Tests">testNilURIPatternDoesNothing	| pattern |	pattern := composite uriPattern.	composite uriPattern: nil.	self assert: composite uriPattern = pattern</body><body package="Swazoo-Tests">testValidlyConfigured	self assert: composite isValidlyConfigured</body></methods><methods><class-id>Swazoo.CompositeResourceTest</class-id> <category>running</category><body package="Swazoo-Tests">setUp	composite := CompositeResource uriPattern: '/'</body></methods><methods><class-id>Swazoo.SiteTest</class-id> <category>testing</category><body package="Swazoo-Tests">testCurrentUrl	site currentUrl = 'http://swazoo.org:8200'.	self addSecondAlias.	site currentUrl = 'http://swazoo.org:8200'.</body><body package="Swazoo-Tests">testCurrentUrl80	| aSite |	aSite := SwazooSite new.	aSite addAlias: (SiteIdentifier			host: 'swazoo.org'			ip: '127.0.0.1'			port: 80).	aSite currentUrl = 'http://swazoo.org'.	aSite currentUrl = 'http://swazoo.org'</body></methods><methods><class-id>Swazoo.SiteTest</class-id> <category>running</category><body package="Swazoo-Tests">addSecondAlias	site addAlias: (SiteIdentifier 				host: 'swazoo2.org'				ip: '127.0.0.2'				port: 8202).</body><body package="Swazoo-Tests">setUp	super setUp.	site := SwazooSite new.	site addAlias: (SiteIdentifier 				host: 'swazoo.org'				ip: '127.0.0.1'				port: 8200)</body></methods><methods><class-id>Swazoo.HTTPIfRangeField</class-id> <category>accessing</category><body package="Swazoo-Headers">tagOrDate	^tagOrDate</body><body package="Swazoo-Headers">tagOrDate: aString	tagOrDate := aString</body></methods><methods><class-id>Swazoo.HTTPIfRangeField</class-id> <category>private</category><body package="Swazoo-Headers">parseValueFrom: aString 	self tagOrDate: aString.</body></methods><methods><class-id>Swazoo.HTTPIfRangeField class</class-id> <category>accessing</category><body package="Swazoo-Headers">fieldName	^'If-Range'</body></methods><methods><class-id>Swazoo.HTTPConnectionField</class-id> <category>printing</category><body package="Swazoo-Headers">valuesAsStringOn: aStream 	aStream nextPutAll: connectionToken.	^self</body></methods><methods><class-id>Swazoo.HTTPConnectionField</class-id> <category>private</category><body package="Swazoo-Headers">parseValueFrom: aString 	connectionToken := HTTPString trimBlanksFrom: aString.	^self</body></methods><methods><class-id>Swazoo.HTTPConnectionField</class-id> <category>services</category><body package="Swazoo-Headers">combineWith: aConnectionHeaderField	self connectionToken: 		self connectionToken, ', ' , aConnectionHeaderField connectionToken.</body><body package="Swazoo-Headers">setToClose	self connectionToken: 'close'.	^self</body><body package="Swazoo-Headers">setToKeepAlive	self connectionToken: 'keep-alive'.	^self</body><body package="Swazoo-Headers">setToUpgrade	self connectionToken: 'Upgrade'.	^self</body></methods><methods><class-id>Swazoo.HTTPConnectionField</class-id> <category>accessing</category><body package="Swazoo-Headers">connectionToken	"^a StringCommon values are 'close' and 'keep-alive'."	^connectionToken</body><body package="Swazoo-Headers">connectionToken: aString 	"^self"	connectionToken := aString.	^self</body></methods><methods><class-id>Swazoo.HTTPConnectionField</class-id> <category>testing</category><body package="Swazoo-Headers">connectionTokenIsClose	^self connectionToken = 'close'</body></methods><methods><class-id>Swazoo.HTTPConnectionField class</class-id> <category>accessing</category><body package="Swazoo-Headers">fieldName	^'Connection'</body></methods><methods><class-id>Swazoo.HTTPAuthenticationDigestChallenge</class-id> <category>initialize-release</category><body package="Swazoo-Messages">initialize	super initialize.	self setNonce.	self setOpaque.</body></methods><methods><class-id>Swazoo.HTTPAuthenticationDigestChallenge</class-id> <category>private</category><body package="Swazoo-Messages">nonce: anAuthenticationNonce	nonce := anAuthenticationNonce</body><body package="Swazoo-Messages">opaque: aString	opaque := aString</body><body package="Swazoo-Messages">setNonce	self nonce: SwazooAuthNonce new.</body><body package="Swazoo-Messages">setOpaque	self opaque: (SwazooMD5Digest hash: self hash printString)</body></methods><methods><class-id>Swazoo.HTTPAuthenticationDigestChallenge</class-id> <category>accessing</category><body package="Swazoo-Messages">nonce	^nonce</body><body package="Swazoo-Messages">opaque	^opaque</body></methods><methods><class-id>Swazoo.HTTPAuthenticationDigestChallenge</class-id> <category>challenging</category><body package="Swazoo-Messages">prepareAuthenticationChallenge	self addHeaderName: 'WWW-Authenticate' 		value: 'Digest realm="', self resource authenticationRealm, '", ',			'nonce="', self nonce hashed, '", ',			'opaque="', self opaque, '"'</body></methods><methods><class-id>Swazoo.HTTPAuthenticationDigestChallenge class</class-id> <category>instance creation</category><body package="Swazoo-Messages">newForResource: aResource	^self unauthorized 		resource: aResource;		entity: aResource unauthorizedResponsePage;		prepareAuthenticationChallenge</body></methods><methods><class-id>Swazoo.TestPseudoSocket</class-id> <category>socket stuff</category><body package="Swazoo-Tests">acceptRetryingIfTransientErrors	"^another TestSocketThing	The sender expects me to block until a request comes in 'over the socket'.  What I really do is wait for someone to ask me to 'send in' a Byte array and then I return myself.  Note that I will only handle one request at a time!"	self serverWaitSemaphore wait.	^self</body><body package="Swazoo-Tests">bindSocketAddress: anOSkIPAddress 	"^selfThis is a no-op for me."	ipAddress := anOSkIPAddress.	^self</body><body package="Swazoo-Tests">close	"^selfThe server has finished with us at this point, so we signal the semaphore to give the client end chance to grab the response."	self clientWaitSemaphore signal.	^self</body><body package="Swazoo-Tests">flush	^self</body><body package="Swazoo-Tests">getPeerName	^ipAddress</body><body package="Swazoo-Tests">getSocketName	^ipAddress</body><body package="Swazoo-Tests">isActive	"^selfI am pretending to be a socket, and the sender wants to know if I am active.  Of course I am!."	^true</body><body package="Swazoo-Tests">listenBackloggingUpTo: anInteger 	"^selfThis is a no-op for me."	^self</body><body package="Swazoo-Tests">listenFor: anInteger 	"^selfThis is a no-op for now."	^self</body><body package="Swazoo-Tests">setAddressReuse: aBoolean 	"^selfThis is a no-op for me."	^self</body><body package="Swazoo-Tests">stream	"^selfI have to pretend to be a socket stream too."	^self</body></methods><methods><class-id>Swazoo.TestPseudoSocket</class-id> <category>stream-toServer</category><body package="Swazoo-Tests">next	^self byteStreamToServer next</body><body package="Swazoo-Tests">peek	"^a CharacterIt seems that the HTTP server is expecting Characters not Bytes - this will have to change."	^byteStreamToServer isNil 		ifTrue: [nil]		ifFalse: [self byteStreamToServer peek asCharacter]</body><body package="Swazoo-Tests">read: integerNumberOfBytes 	"^a ByteArrayI read the next numberOfBytes from my underlying stream."	^byteStreamToServer isNil 		ifTrue: [ByteArray new]		ifFalse: [self byteStreamToServer nextAvailable: integerNumberOfBytes]</body><body package="Swazoo-Tests">socket	"^selfI am being asked this as if I am a socket stream.  I return myself because I'm pretending to be both the socket and the socket stream."	^self</body><body package="Swazoo-Tests">upTo: aCharacter 	"a ByteStringFor some reason, we have to look for a character in a ByteStream - this is a Swazoo thing."	^(self byteStreamToServer upTo: aCharacter asInteger) asByteString</body></methods><methods><class-id>Swazoo.TestPseudoSocket</class-id> <category>accessing</category><body package="Swazoo-Tests">byteStreamFromServer	^byteStreamFromServer</body><body package="Swazoo-Tests">byteStreamFromServer: aByteStream 	byteStreamFromServer := aByteStream.	^self</body><body package="Swazoo-Tests">byteStreamToServer	^byteStreamToServer</body><body package="Swazoo-Tests">byteStreamToServer: aByteStream 	byteStreamToServer := aByteStream.	^self</body><body package="Swazoo-Tests">clientWaitSemaphore	"^a SemaphoreI return the semaphore I use to control 'client' activity."	clientWaitSemaphore isNil ifTrue: [clientWaitSemaphore := Semaphore new].	^clientWaitSemaphore</body><body package="Swazoo-Tests">serverWaitSemaphore	"^a SemaphoreI return the semaphore I use to control 'server' activity."	serverWaitSemaphore isNil ifTrue: [serverWaitSemaphore := Semaphore new].	^serverWaitSemaphore</body></methods><methods><class-id>Swazoo.TestPseudoSocket</class-id> <category>stream-fromServer</category><body package="Swazoo-Tests">nextPut: aCharacter 	self byteStreamFromServer nextPut: aCharacter asInteger</body><body package="Swazoo-Tests">nextPutAll: aCollection 	"^selfAt present it seems that aCollection will always be a string of chacters."	^self byteStreamFromServer nextPutAll: aCollection asByteArray</body><body package="Swazoo-Tests">nextPutBytes: aByteArray 	self byteStreamFromServer nextPutAll: aByteArray</body><body package="Swazoo-Tests">print: anObject 	self nextPutAll: anObject printString asByteArray.	^self</body><body package="Swazoo-Tests">space	self nextPut: Character space.	^self</body><body package="Swazoo-Tests">write: aByteArray 	"^an Integer	I write the contents of the sourceByteArray to my underlying Socket.	I return the number of bytes written."	self byteStreamFromServer nextPutAll: aByteArray.	^aByteArray size</body></methods><methods><class-id>Swazoo.TestPseudoSocket</class-id> <category>actions-client</category><body package="Swazoo-Tests">writeBytesToServer: aByteArray 	"^selfThis is where we make the bytes available over the pseudo socket.  Unlike a socket this is a one off thing (at least in this implementation of the pseudo socket).  Once the bytes are written, control passes to the server and stays there until the server sends a close to what it thinks is the client socket, but is really me."	| results |	self byteStreamToServer: (ReadStream on: aByteArray).	self byteStreamFromServer: (WriteStream on: (ByteArray new: 1000)).	self serverWaitSemaphore signal.	self clientWaitSemaphore wait.	results := self byteStreamFromServer contents.	self byteStreamToServer: nil.	self byteStreamFromServer: nil.	^results</body></methods><methods><class-id>Swazoo.TestPseudoSocket class</class-id> <category>instance creation</category><body package="Swazoo-Tests">newTCPSocket	"^a TestPseudoSocketI simply return a new instance of myself."	^self new</body><body package="Swazoo-Tests">serverOnIP: host port: port 	"^selfI'm only pretending to be a socket class, so I ignore the host and port."	^self new</body></methods><methods><class-id>Swazoo.SiteIdentifierTest</class-id> <category>running</category><body package="Swazoo-Tests">setUp	identifier := SiteIdentifier 				host: 'localhost'				ip: '127.0.0.1'				port: 80</body></methods><methods><class-id>Swazoo.SiteIdentifierTest</class-id> <category>testing</category><body package="Swazoo-Tests">testCaseInsensitiveMatch	| another |	another := SiteIdentifier 				host: 'lOCaLhOST'				ip: '127.0.0.1'				port: 80.	self assert: (identifier match: another)</body><body package="Swazoo-Tests">testCurrentUrl	self assert: identifier currentUrl = 'http://localhost'.		identifier := SiteIdentifier 				host: 'localhost'				ip: '127.0.0.1'				port: 81.	self assert: identifier currentUrl = 'http://localhost:81'</body><body package="Swazoo-Tests">testHostMismatch	| another |	another := SiteIdentifier 				host: 'thisIsMyMachine'				ip: '127.0.0.1'				port: 80.	self deny: (identifier match: another)</body><body package="Swazoo-Tests">testIPMismatch	| another |	another := SiteIdentifier 				host: 'localhost'				ip: '127.0.0.2'				port: 80.	self deny: (identifier match: another)</body><body package="Swazoo-Tests">testMatch	| another |	another := SiteIdentifier 				host: 'localhost'				ip: '127.0.0.1'				port: 80.	self assert: (identifier match: another)</body><body package="Swazoo-Tests">testPortMismatch	| another |	another := SiteIdentifier 				host: 'localhost'				ip: '127.0.0.1'				port: 81.	self deny: (identifier match: another)</body></methods><methods><class-id>Swazoo.RedirectionResourceTest</class-id> <category>running</category><body package="Swazoo-Tests">setUp	resource := RedirectionResource uriPattern: 'foo'				targetUri: 'http://abc.def.com'</body></methods><methods><class-id>Swazoo.RedirectionResourceTest</class-id> <category>testing</category><body package="Swazoo-Tests">testGetResource	| request response |	request := HTTPGet request: 'foo'.	response := URIResolution resolveRequest: request startingAt: resource.	self assert: response statusCode = 301.	self assert: (response headers fieldNamed: 'Location') uri asString 				= 'http://abc.def.com'.	self assert: request resourcePath size = 1.	self assert: request resourcePath first = 'foo'</body></methods><methods><class-id>Swazoo.SwazooBufferTest</class-id> <category>testing-mime boundary</category><body package="Swazoo-Tests">testBoundaryFull	| boundary buffer |	boundary := '--boundary--'.	buffer := SwazooBuffer on: 'just--boundary--something'.  "full boundary"	self assert: (buffer signsOfBoundary: boundary) = boundary size.</body><body package="Swazoo-Tests">testBoundaryMixed	| boundary buffer |	boundary := '--boundary--'.	buffer := SwazooBuffer on: 'yes,--just--boundary--something'.  "partial, later full boundary"	self assert: (buffer signsOfBoundary: boundary) = boundary size.</body><body package="Swazoo-Tests">testBoundaryOnEdge	"part of boundary at the end of this buffer, remaining probably in the next"	| boundary buffer |	boundary := '--boundary--'.	buffer := SwazooBuffer on: 'just something-'.  "just first char of boundary"	self assert: (buffer signsOfBoundary: boundary) = 1.	buffer := SwazooBuffer on: 'just something--'.  "two chars"	self assert: (buffer signsOfBoundary: boundary) = 2.	buffer := SwazooBuffer on: 'just something--bound'.  "half"	self assert: (buffer signsOfBoundary: boundary) = 7.	buffer := SwazooBuffer on: 'just something--boundary--'.  "full boundary at the edge"	self assert: (buffer signsOfBoundary: boundary) = boundary size.</body><body package="Swazoo-Tests">testBoundaryOnEdgeMixed	"signs of boundary in the middle part at the end of this buffer, remaining probably in the next"	| boundary buffer |	boundary := '--boundary--'.	buffer := SwazooBuffer on: 'just-something-'.  "sign in the middle, one char at the end"	self assert: (buffer signsOfBoundary: boundary) = 1.	buffer := SwazooBuffer on: 'just-something--'.  "two chars"	self assert: (buffer signsOfBoundary: boundary) = 2.	buffer := SwazooBuffer on: 'just-so--mething--bound'.  "even more mixed case"	self assert: (buffer signsOfBoundary: boundary) = 7.</body><body package="Swazoo-Tests">testBoundarySimple	| boundary buffer |	boundary := '--boundary--'.	buffer := SwazooBuffer on: 'just something'.  "no boundary"	self assert: (buffer signsOfBoundary: boundary) = 0.	buffer := SwazooBuffer on: 'just-something'.  "sign of boundary"	self assert: (buffer signsOfBoundary: boundary) = 0.	buffer := SwazooBuffer on: 'just--something'.  "more sign of boundary"	self assert: (buffer signsOfBoundary: boundary) = 0.	buffer := SwazooBuffer on: 'just--boundary--something'.  "full boundary"	self assert: (buffer signsOfBoundary: boundary) = boundary size.</body><body package="Swazoo-Tests">testIndexOfBoundary	"index of start of boundary in buffer, both full or partial at the edge/end of buffer"	| boundary buffer |	boundary := '--boundary--'.	buffer := SwazooBuffer on: 'just something'.  "no boundary"	self assert: (buffer indexOfBoundary: boundary) = 0.	buffer := SwazooBuffer on: 'just--boundary--something-'.  "full boundary"	self assert: (buffer indexOfBoundary: boundary) = 5.	buffer := SwazooBuffer on: 'just something--boun'.  "partial boundary at the edge"	self assert: (buffer indexOfBoundary: boundary) = 15.	buffer := SwazooBuffer on: 'just something-'.  "partial boundary, one char only"	self assert: (buffer indexOfBoundary: boundary) = 15.	buffer := SwazooBuffer on: 'just-som--ething--boun'.  "mixed case with partial at the edge"	self assert: (buffer indexOfBoundary: boundary) = 17.</body></methods><methods><class-id>Swazoo.HeaderFieldTest</class-id> <category>testing</category><body package="Swazoo-Tests">testCombine	"Entity tags must be quoted strings - RFC 2616 3.11"	| header1 header2 header3 |	header1 := HeaderField fromLine: 'If-Match: "a"'.	header2 := HeaderField fromLine: 'If-Match: "b","c"'.	header3 := HeaderField fromLine: 'If-Match: "d"'.	header1 combineWith: header2.	self assert: header1 valuesAsString = '"a","b","c"'.	header1 combineWith: header3.	self assert: header1 valuesAsString = '"a","b","c","d"'</body><body package="Swazoo-Tests">testContentTypeMultiple	"   HTTP/1.1 header field values can be folded onto multiple lines if the   continuation line begins with a space or horizontal tab. All linear   white space, including folding, has the same semantics as SP. A   recipient MAY replace any linear white space with a single SP before   interpreting the field value or forwarding the message downstream.       LWS            = [CRLF] 1*( SP | HT )"	| requestStream request field |	requestStream := SwazooStream on: String new.	requestStream		nextPutLine: 'GET / HTTP/1.1';		nextPutLine: 'Host: 127.0.0.1';		nextPutLine: 'Content-Type: text/html; ';		nextPutLine: ' charset=iso-8859-1';		crlf.	request := HTTPRequest readFrom: (SwazooStream on: requestStream writeBuffer contents).	field := request headers fieldNamed: 'content-type'.	self assert: field name = 'Content-Type'.	self assert: field mediaType = 'text/html'.	self assert: (field transferCodings at: 'charset') = 'iso-8859-1'</body><body package="Swazoo-Tests">testValues	"Entity tags are held internally as simple strings.  Any necessary leading and trailing double quotes are added by the header fields as needed.  Note that it is OK to have a comma in an entity tag - see the second of the group of 3 tags below."	| header |	header := HeaderField fromLine: 'If-Match: "xyzzy" '.	self assert: header name = 'If-Match'.	self assert: header entityTags first = 'xyzzy'.	header := HeaderField 				fromLine: 'If-Match: "xyzzy", "r2d2,xxxx", "c3piozzzz" '.	self assert: header name = 'If-Match'.	self assert: header entityTags first = 'xyzzy'.	self assert: (header entityTags at: 2) = 'r2d2,xxxx'.	self assert: header entityTags last = 'c3piozzzz'</body></methods><methods><class-id>Swazoo.ResourceTest</class-id> <category>private</category><body package="Swazoo-Tests">basicGet: uri	| ws |	ws := WriteStream on: String new.	ws nextPutAll: 'GET ', uri, ' HTTP/1.1'.	self crlfOn: ws.	ws nextPutAll: 'Host: swazoo.org'.	self crlfOn: ws.	self crlfOn: ws.	^HTTPRequest readFrom: (ReadStream on: ws contents)</body><body package="Swazoo-Tests">basicGetUri: uriString	| ws |	ws := WriteStream on: String new.	ws nextPutAll: 'GET ' , uriString , ' HTTP/1.1'.	self crlfOn: ws.	ws nextPutAll: 'Host: swazoo.org'.	self crlfOn: ws.	self crlfOn: ws.	^HTTPRequest readFrom: (ReadStream on: ws contents)</body><body package="Swazoo-Tests">basicGetUri: uriString host: hostname port: port 	| ws |	ws := WriteStream on: String new.	ws nextPutAll: 'GET ' , uriString , ' HTTP/1.1'.	self crlfOn: ws.	ws nextPutAll: 'Host: ' , hostname.	port notNil 		ifTrue: 			[ws				nextPut: $:;				print: port].	self crlfOn: ws.	self crlfOn: ws.	^HTTPRequest readFrom: (ReadStream on: ws contents)</body><body package="Swazoo-Tests">crlfOn: aStream 	aStream		nextPut: Character cr;		nextPut: Character lf</body></methods><methods><class-id>Swazoo.ResourceTest</class-id> <category>testing</category><body package="Swazoo-Tests">testEmptyURIPatternInvalid	resource uriPattern: ''.	self deny: resource isValidlyConfigured</body><body package="Swazoo-Tests">testEnabledByDefault	self assert: resource isEnabled</body><body package="Swazoo-Tests">testNilURIPatternDoesNothing	| pattern |	pattern := resource uriPattern.	resource uriPattern: nil.	self assert: resource uriPattern = pattern</body><body package="Swazoo-Tests">testValidlyConfigured	self assert: resource isValidlyConfigured</body></methods><methods><class-id>Swazoo.ResourceTest</class-id> <category>running</category><body package="Swazoo-Tests">setUp	resource := SwazooResource uriPattern: 'foo'</body></methods><methods><class-id>Swazoo.SwazooBaseExtensionsTest</class-id> <category>testing</category><body package="Swazoo-Tests">testCharacterArrayTrimBlanks	self 		assert: (HTTPString trimBlanksFrom: '   a b c d e f g') = 'a b c d e f g'.	self assert: (HTTPString trimBlanksFrom: 'no blanks') = 'no blanks'.	self assert: (HTTPString trimBlanksFrom: ' leading') = 'leading'.	self assert: (HTTPString trimBlanksFrom: 'trailing ') = 'trailing'.	self assert: (HTTPString trimBlanksFrom: '') = ''.	self 		assert: (HTTPString 				trimBlanksFrom: (String with: Character cr with: Character lf)) isEmpty</body><body package="Swazoo-Tests">testFilenameEtag	"The filename etag is a simple string and does not contain double quotes.  Header fields apply double quotes as necessary when writing themselves."	| fn etag1 etag2 |	fn := SpFilename named: 'etagTest'.	[fn writeStream nextPut: $-; close. "create file"	etag1 := fn etag.	(Delay forSeconds: 1) wait.	fn appendStream nextPut: $-; close. "modify file"	etag2 := fn etag.	self assert: (etag1 isKindOf: String).	self assert: (etag2 isKindOf: String).	self deny: etag1 = etag2] 		ensure: [fn delete]</body><body package="Swazoo-Tests">testStringNewRandom	| sizes strings |	sizes := #(5 20 6127 2 100).	strings := sizes collect: [:each |  HTTPString newRandomString: each].	strings with: sizes do: [:string :size | self assert: string size = size]</body></methods><methods><class-id>Swazoo.SwazooStreamTest</class-id> <category>testing</category><body package="Swazoo-Tests">testConnectedPair	(Array with: input with: output) 		do: [:each | self assert: (each isKindOf: SwazooStream)]</body><body package="Swazoo-Tests">testErrorOnInputClose	self should: 			[input close.			output next]		raise: Error</body><body package="Swazoo-Tests">testNextPut	#($A $M $Y $b $r $z) do: 			[:each | 			self assert: (input nextPut: each) = each. 			input flush.			self assert: output next = each]</body><body package="Swazoo-Tests">testNextPutAll	#('123' 'abc' 'swazoo') do: 			[:each | 			self assert: (input nextPutAll: each) = each. 			input flush.			self assert: (output next: each size) = each]</body><body package="Swazoo-Tests">testNextPutByte	| bytes |	bytes := ByteArray 				with: 6				with: 5				with: 0				with: 2.	bytes do: 			[:each | 			self assert: (input nextPutByte: each) = each. 			input flush.			self assert: output nextByte = each]</body><body package="Swazoo-Tests">testNextPutBytes	| bytes1 bytes2 bytes3 |	bytes1 := ByteArray withAll: #(1 2 3 4).	bytes2 := ByteArray withAll: #(5 4 3 2 1).	bytes3 := ByteArray withAll: #(1 1 2 3 5).	(Array 		with: bytes1		with: bytes2		with: bytes3) do: 				[:each | 				self assert: (input nextPutBytes: each) = each.				input flush.				self assert: (output nextBytes: each size) = each]</body><body package="Swazoo-Tests">testPeek	#($K $J $D $j $m $z) do: 			[:each | 			input nextPut: each.			input flush.			self assert: output peek = each.			output next]</body><body package="Swazoo-Tests">testPeekByte	| bytes |	bytes := ByteArray withAll: #(5 2 8 4 11 231).	bytes do: 			[:each | 			input nextPutByte: each.			input flush.			self assert: output peekByte = each.			output nextByte]</body></methods><methods><class-id>Swazoo.SwazooStreamTest</class-id> <category>running</category><body package="Swazoo-Tests">crlfOn: aSwazooStream	aSwazooStream		nextPut: Character cr;		nextPut: Character lf</body><body package="Swazoo-Tests">setUp	| pair |	pair := SwazooStream connectedPair.	input := pair first.	output := pair last</body><body package="Swazoo-Tests">tearDown	input close.	output close</body></methods><methods><class-id>Swazoo.SwazooStreamTest</class-id> <category>testing-lines</category><body package="Swazoo-Tests">testLinesWithDoubleCRLF	| ws rs comparisonString |	comparisonString := 'abcd'.	ws := SwazooStream on: String new.	ws nextPutAll: comparisonString.	self crlfOn: ws.	self crlfOn: ws.	rs := SwazooStream on: ws writeBuffer contents.	self assert: rs nextLine = comparisonString.	self assert: rs nextLine = ''</body><body package="Swazoo-Tests">testSingleLineWithCR	| ws rs comparisonString errored |	comparisonString := 'abcd' , (String with: Character cr) , 'efg'.	ws := SwazooStream on: String new.	ws nextPutAll: comparisonString.	ws nextPut: Character cr.	rs := SwazooStream on: ws writeBuffer contents.	errored := false.	SpExceptionContext 		for: [rs nextLine]		on: SpError		do: [:ex | errored := true].	self assert: errored</body><body package="Swazoo-Tests">testSingleLineWithCRLF	| ws rs comparisonString |	comparisonString := 'abcd'.	ws := SwazooStream on: String new.	ws nextPutAll: comparisonString.	self crlfOn: ws.	rs := SwazooStream on: ws writeBuffer contents.	self assert: rs nextLine = comparisonString</body></methods><methods><class-id>Swazoo.SwazooCacheControl</class-id> <category>operations</category><body package="Swazoo-Fileserver">addNotModifedHeaders: aResponse 	"RFC2616 10.3.5	If the conditional GET used a strong cache validator (see section 13.3.3), the response SHOULD NOT include other entity-headers. ... this prevents inconsistencies between cached entity-bodies and updated headers. "	self isRequestStrongValidator 		ifTrue: [aResponse headers addField: (HTTPETagField new entityTag: self etag)]		ifFalse: [self basicAddResponseHeaders: aResponse].	^aResponse</body><body package="Swazoo-Fileserver">addResponseHeaders: aResponse 	"Add response headers to the response.	We MUST differentiate between 200/302 responses"	^aResponse isNotModified 		ifTrue: [self addNotModifedHeaders: aResponse]		ifFalse: [self basicAddResponseHeaders: aResponse]</body><body package="Swazoo-Fileserver">basicAddResponseHeaders: aResponse 	"RFC 2616 13.3.4	HTTP/1.1 origin servers:       	- SHOULD send an entity tag validator unless it is not feasible to generate one.		- SHOULD send a Last-Modified value "	aResponse headers addField: (HTTPETagField new entityTag: self etag).	aResponse headers addField: (HTTPLastModifiedField new timestamp: self lastModified).	^aResponse</body><body package="Swazoo-Fileserver">generateETag	^self cacheTarget etag</body><body package="Swazoo-Fileserver">generateLastModified	^self cacheTarget lastModified</body></methods><methods><class-id>Swazoo.SwazooCacheControl</class-id> <category>accessing</category><body package="Swazoo-Fileserver">cacheTarget	^cacheTarget</body><body package="Swazoo-Fileserver">etag	etag isNil ifTrue: [etag := self generateETag].	^etag</body><body package="Swazoo-Fileserver">etag: aString 	etag := aString</body><body package="Swazoo-Fileserver">request: aHTTPGet cacheTarget: anObject 	request := aHTTPGet.	cacheTarget := anObject</body></methods><methods><class-id>Swazoo.SwazooCacheControl</class-id> <category>testing</category><body package="Swazoo-Fileserver">isIfModifiedSince	"Answers true if either 		- the request does not included the header		-or there is not a match"	| ifModifiedSince |	ifModifiedSince := request headers fieldOfClass: HTTPIfModifiedSinceField				ifNone: [nil].	^ifModifiedSince isNil or: [self lastModified &gt; ifModifiedSince date]</body><body package="Swazoo-Fileserver">isIfNoneMatch	"Answers true if either 		- the request does not included the header		-or there is not a match"	| field |	field := request headers fieldOfClass: HTTPIfNoneMatchField ifNone: [nil].	^field isNil or: [(field entityTags includes: self etag) not]</body><body package="Swazoo-Fileserver">isNotModified	"Compare the cacheTarget with the request headers and answer if the client's version is not modified.	Takes into account http version, and uses best practices defined by HTTP spec"	^self isIfNoneMatch not or: [self isIfModifiedSince not]</body><body package="Swazoo-Fileserver">isRequestStrongValidator	| field |	field := request headers fieldOfClass: HTTPIfNoneMatchField ifNone: [nil].	^field notNil and: [field entityTags isEmpty not]</body><body package="Swazoo-Fileserver">lastModified	lastModified isNil ifTrue: [lastModified := self generateLastModified].	^lastModified</body><body package="Swazoo-Fileserver">lastModified: aRFC1123TimeStampString 	lastModified := aRFC1123TimeStampString</body></methods><methods><class-id>Swazoo.HelloWorldResource</class-id> <category>serving</category><body package="Swazoo-Resources">answerTo: aRequest 	| response |	response := HTTPResponse ok.	response		contentType: 'text/html';		entity: '&lt;html&gt;&lt;head&gt;&lt;title&gt;Hello World&lt;/title&gt;&lt;/head&gt;&lt;body&gt;Hello World!&lt;/body&gt;&lt;/html&gt;'.	^response</body></methods><methods><class-id>Swazoo.HTTPRefererField</class-id> <category>accessing</category><body package="Swazoo-Headers">uri	^uri</body></methods><methods><class-id>Swazoo.HTTPRefererField</class-id> <category>private</category><body package="Swazoo-Headers">parseValueFrom: aString 	uri := SwazooURI fromString: aString.	^self</body></methods><methods><class-id>Swazoo.HTTPRefererField</class-id> <category>printing</category><body package="Swazoo-Headers">valuesAsStringOn: aStream 	self uri printOn: aStream.	^self</body></methods><methods><class-id>Swazoo.HTTPRefererField class</class-id> <category>accessing</category><body package="Swazoo-Headers">fieldName	^'Referer'</body></methods><methods><class-id>Swazoo.HTTPAuthorizationDigestField</class-id> <category>printing</category><body package="Swazoo-Headers">valuesAsStringOn: aStream 	aStream nextPutAll: 'Digest '.	super valuesAsStringOn: aStream.	^self</body></methods><methods><class-id>Swazoo.HTTPHead</class-id> <category>testing</category><body package="Swazoo-Messages">isHead	^true</body></methods><methods><class-id>Swazoo.HTTPHead class</class-id> <category>accessing</category><body package="Swazoo-Messages">methodName	^'HEAD'</body></methods><methods><class-id>Swazoo.WebSocketMessage</class-id> <category>accessing</category><body package="Swazoo-Messages">mask	"a 32 bit masking key to XOR every payload world if mask is true"	^mask</body><body package="Swazoo-Messages">mask: aNumber	"a 32 bit masking key to XOR every payload world if mask is true"	mask := aNumber</body><body package="Swazoo-Messages">masked	"should be payload masked with a mask? Default is yes"	masked ifNil: [self masked: true].	^masked</body><body package="Swazoo-Messages">masked: aBoolean	"should be payload masked with a mask?"	masked := aBoolean</body><body package="Swazoo-Messages">opcode	" #text #binary #terminate #continuation #ping #pong "	^opcode</body><body package="Swazoo-Messages">opcode: aSymbol	" #text #binary #terminate #continuation #ping #pong "	opcode := aSymbol</body><body package="Swazoo-Messages">payload	"unmasked and combined payload of this message. UTF8 encoded string or binary byte array"	^payload</body><body package="Swazoo-Messages">payload: aByteStringOrArray	"unmasked and combined payload of this message. UTF8 encoded string or binary byte array"	payload := aByteStringOrArray</body></methods><methods><class-id>Swazoo.HTTPRequestLine</class-id> <category>accessing</category><body package="Swazoo-Messages">httpVersion	^httpVersion</body><body package="Swazoo-Messages">method	^method</body><body package="Swazoo-Messages">requestURI	^requestURI</body></methods><methods><class-id>Swazoo.HTTPRequestLine</class-id> <category>private</category><body package="Swazoo-Messages">httpVersion: anArray 	httpVersion := anArray.	^self</body><body package="Swazoo-Messages">method: aString"For development testing only"	method := aString.	^self</body><body package="Swazoo-Messages">requestURI: aString 	"Development testing only!"	requestURI := aString.	^self</body><body package="Swazoo-Messages">skipLeadingBlankLinesIn: aSwazooStream 	"^selfRFC 2616:In the interest of robustness, servers SHOULD ignore any emptyline(s) received where a Request-Line is expected. In other words, ifthe server is reading the protocol stream at the beginning of amessage and receives a CRLF first, it should ignore the CRLF."	[aSwazooStream peek == Character cr asInteger] whileTrue: 			[(((aSwazooStream next: 2) at: 2) == Character lf asInteger) 				ifFalse: [SwazooHTTPParseError raiseSignal: 'CR without LF']].	^self</body><body package="Swazoo-Messages">skipSpacesIn: aSwazooStream 	[aSwazooStream peek = Character space] 		whileTrue: [aSwazooStream next].	^self</body></methods><methods><class-id>Swazoo.HTTPRequestLine</class-id> <category>parsing</category><body package="Swazoo-Messages">parseHTTPVersionFrom: aSwazooStream 	| major minor |	self skipSpacesIn: aSwazooStream.	aSwazooStream upTo: $/ asInteger.	major := (aSwazooStream upTo: $. asInteger) asByteString asNumber.	minor := (aSwazooStream upTo: Character cr asInteger) asByteString asNumber.	self httpVersion: (Array with: major with: minor).	aSwazooStream next.	^self</body><body package="Swazoo-Messages">parseURIFrom: aSwazooStream 	"^self	Really, we should parse the URI directly out of the stream."	self skipSpacesIn: aSwazooStream.	requestURI := SwazooURI fromString: 		(aSwazooStream upTo: Character space asInteger) asByteString.	^self</body><body package="Swazoo-Messages">readFrom: aSwazooStream 	"^selfI initialize myself to represents a request line read from aStream.  If no valid request line can be found, I throw an exception."	self skipLeadingBlankLinesIn: aSwazooStream.	method := (aSwazooStream upTo: Character space asInteger) asByteString.	self parseURIFrom: aSwazooStream.	self parseHTTPVersionFrom: aSwazooStream.	^self</body></methods><methods><class-id>Swazoo.HTTPRequestLine</class-id> <category>testing</category><body package="Swazoo-Messages">isHttp10	^self httpVersion last = 0</body><body package="Swazoo-Messages">isHttp11	^self httpVersion last = 1</body></methods><methods><class-id>Swazoo.HTTPRequestLine class</class-id> <category>instance creation</category><body package="Swazoo-Messages">readFrom: aSwazooStream 	^self new readFrom: aSwazooStream</body></methods><methods><class-id>SpEnvironment class</class-id> <category>testing</category><body package="Swazoo-Extensions">isHeadless	^self isVisualWorks and: 			[(Smalltalk bindingFor: #HeadlessImage) notNil 				and: [HeadlessImage default isHeadless]]</body><body package="Swazoo-Extensions">onUnix	"we are running on Unix, yes or no?"	^OSHandle currentOS = #unix.</body><body package="Swazoo-Extensions">onWindows	"we are running on Windows, yes or no?"	^OSHandle currentOS = #win32.</body></methods><methods><class-id>SpEnvironment class</class-id> <category>os commands</category><body package="Swazoo-Extensions">runShellCommandString: aCommandString 	^UnixProcess cshOne: aCommandString</body></methods><methods><class-id>SpEnvironment class</class-id> <category>queries</category><body package="Swazoo-Extensions">allSubclassesOf: aClass	"^an Array	I return the array of classes which are subclasses of aClass."	^aClass allSubclasses asArray</body></methods><methods><class-id>SpEnvironment class</class-id> <category>services</category><body package="Swazoo-Extensions">characterFromInteger: anInteger 	^Character value: anInteger</body><body package="Swazoo-Extensions">integerFromString: aString"^an IntegerWe need this because of what looks like a bug in GemStone's String&gt;&gt;asNumber (e.g. '16rFF' -&gt; 1.6000000000000000E+01, not 255)."	^aString asNumber</body><body package="Swazoo-Extensions">streamStartPosition	"^an IntegerStreams start at position 0 in VisualWorks, and position 1 in GemStone(!)."	^0</body><body package="Swazoo-Extensions">writeStackDumpForException: anException context: aContext to: targetStream 	"^selfIf the RuntimePackager dumper is available I use that."	'RuntimePackager.RuntimeImageDumper' asQualifiedReference isDefined 		ifTrue: 			[((RuntimePackager.RuntimeImageDumper new)				instVarAt: 1 put: targetStream;				yourself) dumpExceptionReport: anException context: aContext]		ifFalse: [aContext printSenderStackOn: targetStream max: 200].	^self</body></methods><methods><class-id>SpEnvironment class</class-id> <category>development</category><body package="Swazoo-Extensions">madeObsoleteBy: aBlock 	"^an ObjectI cause halt the code and ask the developer to use the code in aBlock, rather than the obsolete code."	(self isHeadless or: [self isGemStone]) 		ifFalse: 			[1 				halt: 'please use the code in the block, not the obsolete code - thanks.'].	^aBlock value</body><body package="Swazoo-Extensions">workInProgress	"^selfThis method does nothing, but can be used to 'mark' methods still needing work.  Simply send this message, and use browse senders to find things still in need of attention.A simpler way to do this is to add '#wip yourself' to the method.  Then you can look for all references to the Symbol #wip."	^self</body></methods><methods><class-id>SpEnvironment class</class-id> <category>compiling</category><body package="Swazoo-Extensions">evaluate: aString in: anEnvironment	^Compiler 		evaluate: aString		for: nil		in: anEnvironment		notifying: nil		logged: false</body><body package="Swazoo-Extensions">evaluate: aString receiver: anObject in: anEnvironment 	^Compiler new 		evaluate: aString		in: nil		allowReceiver: true		receiver: anObject		environment: anEnvironment		notifying: nil		ifFail: []</body></methods><methods><class-id>SpEnvironment class</class-id> <category>hex</category><body package="Swazoo-Extensions">byteArrayFromHexString: aString 	^ByteArray fromHexString: aString</body><body package="Swazoo-Extensions">hexStringFromByteArray: aByteArray 	^aByteArray asHexString</body></methods><methods><class-id>SpEnvironment class</class-id> <category>private</category><body package="Swazoo-Extensions">imageShutdownTaskBlocks	"self imageShutdownTaskBlocks"	ImageShutdownTaskBlocks isNil 		ifTrue: [ImageShutdownTaskBlocks := IdentityDictionary new].	^ImageShutdownTaskBlocks</body><body package="Swazoo-Extensions">imageStartupTaskBlocks	"self imageStartupTaskBlocks"	ImageStartupTaskBlocks isNil 		ifTrue: [ImageStartupTaskBlocks := IdentityDictionary new].	^ImageStartupTaskBlocks</body><body package="Swazoo-Extensions">initialize	"VW specific"	"self initialize"	ObjectMemory addDependent: self</body><body package="Swazoo-Extensions">update: aspect with: aParameter from: sender 	"VW specific! "	sender == ObjectMemory ifFalse: [^nil].	aspect = #returnFromSnapshot ifTrue: 		[self imageStartupTaskBlocks values do: [:startupTask | startupTask value] ].	aspect = #aboutToQuit ifTrue: 		[self imageShutdownTaskBlocks values do: [:shutdownTask | shutdownTask value] ].	^self</body></methods><methods><class-id>SpEnvironment class</class-id> <category>testing-dialects</category><body package="Swazoo-Extensions">isAmbraiSmalltalk	^false</body><body package="Swazoo-Extensions">isDolphin	^false</body><body package="Swazoo-Extensions">isGNUSmalltalk	^false</body><body package="Swazoo-Extensions">isGemStone	^false</body><body package="Swazoo-Extensions">isObjectStudio	^false</body><body package="Swazoo-Extensions">isSmalltalkX	^false</body><body package="Swazoo-Extensions">isSmalltalkXY	^false</body><body package="Swazoo-Extensions">isSqueak	^false</body><body package="Swazoo-Extensions">isVASmalltalk	^false</body><body package="Swazoo-Extensions">isVisualSmalltalk	^false</body><body package="Swazoo-Extensions">isVisualWorks	^true</body></methods><methods><class-id>SpEnvironment class</class-id> <category>image startup/shutdown</category><body package="Swazoo-Extensions">addImageShutdownTask: aBlock for: anObject 	"^self	I add aBlock to the list of actions and note that this is for anObject.  If there are	currenty no tasks, I add myself as an ObejctMemort dependant."	self imageShutdownTaskBlocks isEmpty 		ifTrue: [ObjectMemory addDependent: self].	self imageShutdownTaskBlocks at: anObject put: aBlock.	^self</body><body package="Swazoo-Extensions">addImageStartupTask: aBlock for: anObject 	"^self	I add aBlock to the list of actions and note that this is for anObject.  If there are	currenty no tasks, I add myself as an ObejctMemort dependant."	self imageStartupTaskBlocks isEmpty 		ifTrue: [ObjectMemory addDependent: self].	self imageStartupTaskBlocks at: anObject put: aBlock.	^self</body><body package="Swazoo-Extensions">removeShutdownActionFor: anObject 	"^self	I remove the task block for an object it it has one"	self imageShutdownTaskBlocks removeKey: anObject ifAbsent: [nil].	^self</body><body package="Swazoo-Extensions">removeStartupActionFor: anObject 	"^self	I remove the task block for an object it it has one"	self imageStartupTaskBlocks removeKey: anObject ifAbsent: [nil].	^self</body></methods><methods><class-id>Swazoo.HTTPPostDataArray</class-id> <category>private</category><body package="Swazoo-Messages">printOn: aStream	aStream nextPutAll: 'a Swazoo.HttpPostDataArray 	'.	self underlyingCollection do: [:each | aStream nextPutAll: each key printString , '-&gt;', 		each value value printString, '	'].</body><body package="Swazoo-Messages">stream	^stream</body><body package="Swazoo-Messages">stream: aSwazooStream	"needed for defered postData parsing"	stream := aSwazooStream</body><body package="Swazoo-Messages">underlyingCollection	underlyingCollection isNil 		ifTrue: [underlyingCollection := OrderedCollection new].	^underlyingCollection</body></methods><methods><class-id>Swazoo.HTTPPostDataArray</class-id> <category>accessing</category><body package="Swazoo-Messages">allAt: aKey 	| candidates |	candidates := self underlyingCollection 				select: [:anAssociation | anAssociation key = aKey].	^candidates collect: [:anAssociation| anAssociation value]</body><body package="Swazoo-Messages">allNamesForValue: aString 	| candidates |	candidates := self underlyingCollection 				select: [:anAssociation | anAssociation value value = aString].	^candidates collect: [:anAssociation| anAssociation key]</body><body package="Swazoo-Messages">associations	^self underlyingCollection</body><body package="Swazoo-Messages">at: aKey 	^(self allAt: aKey) last</body><body package="Swazoo-Messages">at: aKey ifAbsent: aBlock 	| candidates |	candidates := self underlyingCollection 				select: [:anAssociation | anAssociation key = aKey].	^candidates isEmpty ifTrue: [aBlock value] ifFalse: [candidates last value]</body><body package="Swazoo-Messages">at: key put: anObject 	self underlyingCollection add: (Association key: key value: anObject).	^anObject</body><body package="Swazoo-Messages">clearParsed	parsed := false</body><body package="Swazoo-Messages">includesKey: aKey 	| candidates |	candidates := self underlyingCollection 				select: [:anAssociation | anAssociation key = aKey].	^candidates notEmpty</body><body package="Swazoo-Messages">includesValue: aString 	| candidates |	candidates := self underlyingCollection 				select: [:anAssociation | anAssociation value value = aString].	^candidates notEmpty</body><body package="Swazoo-Messages">keys"^a SetI mimick the behavior of a Dictionay which I replace.  I return a set of the keys in my underlying collection of associations."	^(self underlyingCollection collect: [:anAssociation| anAssociation key]) asSet</body><body package="Swazoo-Messages">nameForValue: aString	^(self allNamesForValue: aString) last</body><body package="Swazoo-Messages">setParsed	parsed := true</body></methods><methods><class-id>Swazoo.HTTPPostDataArray</class-id> <category>enumerating</category><body package="Swazoo-Messages">keysAndValuesDo: aTwoArgumentBlock 	self underlyingCollection do: 		[:anAssociation | aTwoArgumentBlock value: anAssociation key value: anAssociation value]</body><body package="Swazoo-Messages">select: aBlock "^an ObjectI run the select on the values of the associations in my underlying collection.  This mimicks the behavior when a Dictionary was used in my place."	^self underlyingCollection select:  [:anAssociation| aBlock value: anAssociation value]</body></methods><methods><class-id>Swazoo.HTTPPostDataArray</class-id> <category>testing</category><body package="Swazoo-Messages">isEmpty	^self underlyingCollection isEmpty</body><body package="Swazoo-Messages">isParsed	"postdata is already read and parsed from a request"	^parsed</body></methods><methods><class-id>Swazoo.HTTPPostDataArray</class-id> <category>initialize-release</category><body package="Swazoo-Messages">initialize	self clearParsed</body></methods><methods><class-id>Swazoo.HTTPPostDataArray class</class-id> <category>instance creation</category><body package="Swazoo-Messages">newOn: aSwazooStream	^super new 		initialize;		stream: aSwazooStream</body></methods><methods><class-id>SpIPAddress class</class-id> <category>instance creation</category><body package="Swazoo-Extensions">connectToServerOnHost: hostName port: portNumber	"^an OSkSocket 	I return a new instance of myself which represents a socket connector	to a server listening on portNumber at hostName."	| newSocket |	newSocket := self newTCPSocket.	newSocket connectTo: (SpIPAddress hostName: hostName port: portNumber).	^ newSocket</body></methods><methods><class-id>SpDate class</class-id> <category>instance creation</category><body package="Swazoo-Extensions">newDay: aDay month: aMonthIndex year: aYear	^self newDay: aDay monthNumber: aMonthIndex year: aYear</body><body package="Swazoo-Extensions">newDay: aDay monthNumber: aMonthIndex year: aYear	^self onDate: (Date newDay: aDay monthNumber: aMonthIndex year: aYear)</body></methods><methods><class-id>SpDate</class-id> <category>accessing</category><body package="Swazoo-Extensions">day	^self underlyingDate day</body><body package="Swazoo-Extensions">dayOfYear	^self underlyingDate dayOfYear</body><body package="Swazoo-Extensions">daysInMonth	^self underlyingDate daysInMonth</body><body package="Swazoo-Extensions">monthIndex	^self underlyingDate monthIndex</body></methods><methods><class-id>SpDate</class-id> <category>services</category><body package="Swazoo-Extensions">subtractDays: anInteger 	"^a SpDate	I don't change the date I represent.  Rather, I create a new date which represents	my date offset by anInteger days."	^SpDate fromDays: self asDays - anInteger</body></methods><methods><class-id>SpDate</class-id> <category>accessing</category><body package="Swazoo-Extensions">weekdayIndex	"Sunday=1, ... , Saturday=7"	^self underlyingDate weekdayIndex</body><body package="Swazoo-Extensions">year	^self underlyingDate year</body></methods><methods><class-id>SpFilename</class-id> <category>accessing</category><body package="Swazoo-Extensions">asAbsoluteFilename	"Answer a Filename pointing to the same file using absolute path.	The method may answer the receiver it it is already absolute."	^self underlyingFilename asAbsoluteFilename</body><body package="Swazoo-Extensions">asFilename	^self</body></methods><methods><class-id>SpFilename</class-id> <category>private</category><body package="Swazoo-Extensions">construct: extraFn	"Make a new instance, treating the receiver as a directory, and	the string argument as a file within the pathname."	^self class named: (self underlyingFilename construct: extraFn) asString</body></methods><methods><class-id>SpFilename</class-id> <category>services</category><body package="Swazoo-Extensions">contentsOfEntireFile	^self underlyingFilename contentsOfEntireFile</body></methods><methods><class-id>SpFilename</class-id> <category>accessing</category><body package="Swazoo-Extensions">createdTimestamp	"a SpTimestamp	timestamp of file creation. "	^self underlyingFilename creationTimestamp</body></methods><methods><class-id>SpFilename</class-id> <category>services</category><body package="Swazoo-Extensions">delete	^self underlyingFilename delete</body></methods><methods><class-id>SpFilename</class-id> <category>accessing</category><body package="Swazoo-Extensions">directory	"a filename of the directory for this Filename."	^self underlyingFilename directory</body></methods><methods><class-id>SpFilename</class-id> <category>services</category><body package="Swazoo-Extensions">directoryContents	^self underlyingFilename directoryContents</body></methods><methods><class-id>SpFilename</class-id> <category>accessing</category><body package="Swazoo-Extensions">etag	"^a String	The etag of a file entity is taken to be the date last modified as a String.  We use the SpTimestamp in "	^self lastModified asRFC1123String</body><body package="Swazoo-Extensions">extension	"Answer the receiver's extension if any.  This is the characters from the	 last occurrence of a period to the end, inclusive. E.g. the extension of	 'squeak.image' is '.image'. Answer nil if none.  Note that e.g. .login has no	 extension."	^self underlyingFilename extension</body></methods><methods><class-id>SpFilename</class-id> <category>private</category><body package="Swazoo-Extensions">filename	 "^a String"	^self underlyingFilename filename</body></methods><methods><class-id>SpFilename</class-id> <category>accessing</category><body package="Swazoo-Extensions">fileSize	^self underlyingFilename fileSize</body><body package="Swazoo-Extensions">head	"Answer the directory prefix as a String."	^self underlyingFilename head</body></methods><methods><class-id>SpFilename</class-id> <category>testing</category><body package="Swazoo-Extensions">isAbsolute	"Answer true if this name is absolute (e.g. not relative to the	'current directory')."	^self underlyingFilename isAbsolute</body><body package="Swazoo-Extensions">isDirectory	^self underlyingFilename isDirectory</body><body package="Swazoo-Extensions">isRelative	"Answer true if this name must be interpreted relative to some directory."	^self isAbsolute not</body></methods><methods><class-id>SpFilename</class-id> <category>accessing</category><body package="Swazoo-Extensions">lastModified	^SpTimestamp fromSeconds: self modifiedTimestamp asSeconds</body></methods><methods><class-id>SpFilename</class-id> <category>private</category><body package="Swazoo-Extensions">lastSeparatorIndex	^self underlyingFilename lastSeparatorIndex</body></methods><methods><class-id>SpFilename</class-id> <category>services</category><body package="Swazoo-Extensions">makeDirectory	^self underlyingFilename makeDirectory</body></methods><methods><class-id>SpFilename</class-id> <category>accessing</category><body package="Swazoo-Extensions">modifiedTimestamp	"a SpTimestamp	timestamp of last file modification"	^self underlyingFilename modificationTimestamp</body></methods><methods><class-id>SpFilename</class-id> <category>private</category><body package="Swazoo-Extensions">separator	"Answer the platform's filename component separator."	^self underlyingFilename separator</body></methods><methods><class-id>SpFilename</class-id> <category>accessing</category><body package="Swazoo-Extensions">tail	"Answer the filename suffix as a String."	^self underlyingFilename tail</body></methods><methods><class-id>Core.Collection</class-id> <category>squeak-enumerating</category><body package="Swazoo-Extensions">count: aBlock 	| count |	count := 0.	self do: [:each | (aBlock value: each) ifTrue: [count := count + 1]].	^count</body></methods><methods><class-id>SpSocket</class-id> <category>services-options</category><body package="Swazoo-Extensions">setAddressReuse: aBoolean 	"^self	c.f. self class &gt;&gt;socketOptions and self &gt;&gt;setOptionForLevel:optionID:value:	If a boolean is true, I set address reuse on, otherwise I set address reuse off."	| optionValue |	optionValue := aBoolean ifTrue: [1] ifFalse: [0].	self "		setOptionForLevel: (self class socketOptionLevels at: #SOL_SOCKET) "		setOptionForLevel: SocketAccessor solSocket "result is OS specific!""		optionID: (self class socketOptions at: #SO_REUSEADDR) "		optionID: SocketAccessor soReuseaddr "result is OS specific!"		value: optionValue.	^self</body></methods><methods><class-id>SpSocket</class-id> <category>private</category><body package="Swazoo-Extensions">underlyingSocket: aSocket	underlyingSocket := aSocket</body></methods><methods><class-id>SpSocket</class-id> <category>services-io</category><body package="Swazoo-Extensions">writeFrom: aByteArray startingAt: startIndex for: length 	"^an Integer	I return the number of bytes actually written."	^SpExceptionContext 		for: [self underlyingSocket 			writeFrom: aByteArray			startingAt: startIndex			for: length]		on: Error		do: [:ex | SpSocketError signalWith: ex]</body></methods><methods><class-id>SpAbstractSocketReadRequest</class-id> <category>services</category><body package="Swazoo-Extensions">close	^self underlyingSocket close</body></methods><methods><class-id>SpTimestamp</class-id> <category>comparing</category><body package="Swazoo-Extensions">&lt; aSpTimeStamp 	^self underlyingTimestamp &lt; aSpTimeStamp underlyingTimestamp</body></methods><methods><class-id>SpTimestamp</class-id> <category>converting</category><body package="Swazoo-Extensions">asDate	^SpDate onDate: (self underlyingTimestamp asDate)</body><body package="Swazoo-Extensions">asSpTimestamp	^self</body><body package="Swazoo-Extensions">asTime	^self underlyingTimestamp asTime</body></methods><methods><class-id>SpTimestamp</class-id> <category>accessing</category><body package="Swazoo-Extensions">milliseconds	^self underlyingTimestamp milliseconds</body></methods><methods><class-id>SpTimestamp</class-id> <category>private</category><body package="Swazoo-Extensions">printString	^self underlyingTimestamp printString</body></methods><methods><class-id>Core.Object</class-id> <category>converting</category><body package="Swazoo-Extensions">swazooAs: aSimilarClass	"VW specific"	"copied and adapted from Squeak-Extensions"	"Create an object of class aSimilarClass that has similar contents to the receiver.""	^ aSimilarClass newFrom: self "	| new newInstVars selfInstVars match |	new := aSimilarClass isVariable		ifTrue: [aSimilarClass basicNew: self basicSize]		ifFalse: [aSimilarClass basicNew]."	new copySameFrom: self "	newInstVars := new class allInstVarNames.	selfInstVars := self class allInstVarNames.	newInstVars doWithIndex: [:each :index |		(match := selfInstVars indexOf: each) &gt; 0 ifTrue:			[new instVarAt: index put: (self instVarAt: match)]].	1 to: (new basicSize min: self basicSize) do: [:i |		new basicAt: i put: (self basicAt: i)].	^new</body></methods><methods><class-id>SpFileStream</class-id> <category>accessing</category><body package="Swazoo-Extensions">binary    underlyingStream binary</body></methods><methods><class-id>SpFileStream</class-id> <category>services</category><body package="Swazoo-Extensions">nextAvailable: aNumber    ^underlyingStream nextAvailable: aNumber</body></methods><initialize><class-id>Swazoo.FileResource</class-id></initialize><initialize><class-id>Swazoo.HTTPResponse</class-id></initialize><initialize><class-id>Swazoo.HTTPServer</class-id></initialize><initialize><class-id>Swazoo.SwazooServer</class-id></initialize><initialize><class-id>SpEnvironment</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>SpDate</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>underlyingDate </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpTimes</category><attributes><package>SpTimes</package></attributes></class><class><name>ReadWriteStream</name><environment>Core</environment><super>Core.WriteStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>SpAbstractSocketReadRequest</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>socket isComplete </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>OSkStreams</category><attributes><package>SpSockets</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>Collection</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>SpError</name><environment>Smalltalk</environment><super>SpAbstractError</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpExceptions</category><attributes><package>SpExceptions</package></attributes></class><class><name>SpSocket</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>communicationDomain socketType protocolNumber underlyingSocket sumOfStalledTime stalledTimeCeiling activeReadRequest </inst-vars><class-inst-vars>addressFamilies protocolFamilies socketTypes socketOptionLevels socketOptions fileControlOptions </class-inst-vars><imports></imports><category>SpSockets</category><attributes><package>SpSockets</package></attributes></class><class><name>SpTimestamp</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>underlyingTimestamp </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpTimes</category><attributes><package>SpTimes</package></attributes></class><class><name>SpFilename</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>underlyingFilename </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpFiles</category><attributes><package>SpFiles</package></attributes></class><class><name>SpFileStream</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>underlyingStream filename </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SpFiles</category><attributes><package>SpFiles</package></attributes></class><class><name>TestCase</name><environment>XProgramming.SUnit</environment><super>XProgramming.SUnit.TestAsserter</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnit</package></attributes></class></st-source>