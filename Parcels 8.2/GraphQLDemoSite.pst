<?xml version="1.0"?><st-source><!-- Name: GraphQLDemoSiteBundleName: GraphQLDemoSiteBundleStructure: a Store.BundleForParcelParcel: nilParcelName: GraphQLDemoSitePrerequisiteParcels: #()Date: 3:45:55 AM April 13, 2018 --><time-stamp>From VisualWorksÂ® Personal Use Edition, 8.2 of 15 de julio de 2016 on 13 de abril de 2018 at 3:45:55</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>Film</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name rating director </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GraphQLDemoSite</package></attributes></class><class><name>JSONEncoder</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream level pretty indent empty recursiveSet </inst-vars><class-inst-vars>characterMap </class-inst-vars><imports></imports><category></category><attributes><package>GraphQLDemoSite</package></attributes></class><comment><class-id>JSONEncoder</class-id><body>JSONEncoder supports encoding objects in JSON format on a stream.  It also supports serializing objects with 'type' hints so that copies of the original objects can be reconstituted.  See class JSONDecoder for the corresponding decode/deserialize operations.Instance Variables:	empty	&lt;OrderedCollection&gt;	stack of empty states per level	indent	&lt;Integer&gt;	number of spaces to indent each level when in 'pretty' mode	level	&lt;Integer&gt;	current indent level	pretty	&lt;Boolean&gt;	true to insert whitespace between entries, false to pack everything tightly together	stream	&lt;Stream&gt;	the output stream on which the encoded JSON is writtenExamples:	| s |	s := String new writeStream.	(JSONEncoder on: s) encode: (Dictionary new at: 'foo' put: 'bar'; at: 'baz' put: 42; yourself).	s contents	==&gt;  '{"foo":"bar","baz":42}'			| s |	s := String new writeStream.	(JSONEncoder on: s) serialize: (Dictionary new at: #foo put: 'bar'; at: 'baz' put: 42; yourself).	s contents	==&gt;  '{"&amp;class":"Dictionary","&amp;contents":[{"&amp;class":"Association","key":"baz","value":42},{"&amp;class":"Association","key":{"&amp;class":"ByteSymbol""&amp;contents":"foo"},"value":"bar"}]}'</body></comment><class><name>JSONError</name><environment>Smalltalk</environment><super>Core.Error</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category></category><attributes><package>GraphQLDemoSite</package></attributes></class><comment><class-id>JSONError</class-id><body>A JSONError represents a parsing error encountered by the JSONParser.</body></comment><class><name>GraphQLBetaDemoSite</name><environment>Smalltalk</environment><super>Swazoo.SwazooSite</super><private>false</private><indexed-type>none</indexed-type><inst-vars>webSocket graphql schema dataProvider </inst-vars><class-inst-vars></class-inst-vars><imports>			Swazoo.*			</imports><category></category><attributes><package>GraphQLDemoSite</package></attributes></class><comment><class-id>GraphQLBetaDemoSite</class-id><body>I am a class that creates a simple demo webapp that responds to requets and create the language of graphql</body></comment><methods><class-id>Film</class-id> <category>accessing</category><body package="GraphQLDemoSite">director	^director</body><body package="GraphQLDemoSite">director: anObject	director := anObject</body><body package="GraphQLDemoSite">name	^name</body><body package="GraphQLDemoSite">name: anObject	name := anObject</body><body package="GraphQLDemoSite">rating	^rating</body><body package="GraphQLDemoSite">rating: anObject	rating := anObject</body></methods><methods><class-id>Film</class-id> <category>initialize-release</category><body package="GraphQLDemoSite">initialize	"Initialize a newly created instance. This method must answer the receiver."	super initialize.	" *** Edit the following to properly initialize instance variables ***"	name := nil.	rating := nil.	director := nil.	" *** And replace this comment with additional initialization code *** "	^self</body></methods><methods><class-id>Film class</class-id> <category>instance creation</category><body package="GraphQLDemoSite">name: aName rating: aRating director: aDirector	| inst |	inst := self new.	inst name: aName;		rating: aRating;		director: aDirector.	^ inst</body><body package="GraphQLDemoSite">new	"Answer a newly created and initialized instance."	^super new initialize</body></methods><methods><class-id>JSONEncoder</class-id> <category>initialize-release</category><body package="GraphQLDemoSite">initialize	self		level: 0;		pretty: false;		indent: 0;		empty: OrderedCollection new;		newRecursiveSet.</body><body package="GraphQLDemoSite">newRecursiveSet	"Set the set used for recursion detection."	self recursiveSet: IdentitySet new.</body></methods><methods><class-id>JSONEncoder</class-id> <category>accessing</category><body package="GraphQLDemoSite">empty	^empty</body><body package="GraphQLDemoSite">empty: anObject	empty := anObject</body><body package="GraphQLDemoSite">indent	^indent</body><body package="GraphQLDemoSite">indent: anObject	indent := anObject</body><body package="GraphQLDemoSite">level	^level</body><body package="GraphQLDemoSite">level: anObject	level := anObject</body><body package="GraphQLDemoSite">pretty	^pretty</body><body package="GraphQLDemoSite">pretty: anObject	pretty := anObject</body><body package="GraphQLDemoSite">recursiveSet	^recursiveSet</body><body package="GraphQLDemoSite">recursiveSet: anObject	recursiveSet := anObject</body><body package="GraphQLDemoSite">stream	^stream</body><body package="GraphQLDemoSite">stream: anObject	stream := anObject</body></methods><methods><class-id>JSONEncoder</class-id> <category>encoding</category><body package="GraphQLDemoSite">beginArray	stream nextPut: $[.	level := level + 1.	empty add: true.</body><body package="GraphQLDemoSite">beginObject	(pretty and: [level &gt; 0]) 		ifTrue: 			[stream cr; space: level * indent. 			empty at: level put: false].				stream nextPut: ${.	level := level + 1.	empty add: true.</body><body package="GraphQLDemoSite">emit: aString	"just copy the string to my stream"		stream nextPutAll: aString.</body><body package="GraphQLDemoSite">emitClass: aClass	pretty ifTrue: [stream cr; space: level * indent].	empty at: level put: false.	stream nextPutAll: '"&amp;type"'.	self emitColon.	stream 		nextPut: $";		nextPutAll: aClass shortName;		nextPut: $".</body><body package="GraphQLDemoSite">emitColon	stream nextPutAll: (pretty ifTrue: [' : '] ifFalse: [':']).</body><body package="GraphQLDemoSite">emitComma	stream nextPutAll: (pretty ifTrue: [', '] ifFalse: [',']).</body><body package="GraphQLDemoSite">emitKey: aString	pretty ifTrue: [stream cr; space: level * indent].	self emitString: aString.</body><body package="GraphQLDemoSite">emitKey: aString value: anObject	self		emitKey: aString;		emitColon;		serialize: anObject</body><body package="GraphQLDemoSite">emitNil		stream nextPutAll: 'null'.</body><body package="GraphQLDemoSite">emitString: aString	level = 0		ifTrue: [			"If we're at level 0, we have to surround the string with an object definition, per the JSON spec..."			self				beginObject;				emitClass: aString class;				emitComma;				serializeKey: '&amp;value' value: aString;				endObject]		ifFalse: [			"as long as we're inside an object or array, we can just dump out the string."			empty at: level put: false.			stream nextPut: $".						aString do: [:char |				(self class characterMap at: char ifAbsent: [])					ifNotNil: [:replacementString | stream nextPutAll: replacementString]					ifNil: [stream nextPut: char]].								stream nextPut: $"].</body><body package="GraphQLDemoSite">encodeArray: aCollection	| index |	self beginArray.		index := 0.	aCollection do: [:each |		index := index + 1.		index &gt; 1 ifTrue: [self emitComma].		self encode: each].			self endArray.</body><body package="GraphQLDemoSite">encodeBasicContentsOf: anObject	self		emitKey: '&amp;contents';		emitColon;		beginArray.		1 to: anObject basicSize do: [:index |		index &gt; 1 ifTrue: [self emitComma].		self encode: (anObject basicAt: index)].			self endArray.</body><body package="GraphQLDemoSite">encodeKey: aString value: anObject	"The line aString asString below may seem redundant but we need to cover cases where senders pass in objects and not strings. (e.g. Dictionary keys that are not strings but numbers). Obviously this breaks down if the object does not have a meaningful string representation. The dictionary key example is the only use case we have run into thus far."	self		emitKey: aString asString; 		emitColon;		encode: anObject</body><body package="GraphQLDemoSite">endArray	(pretty and: [(empty at: level) not]) 		ifTrue: [stream cr; space: (level - 1) * indent].	level := level - 1.	empty removeLast.	stream nextPut: $].</body><body package="GraphQLDemoSite">endObject	(pretty and: [(empty at: level) not]) 		ifTrue: [stream cr; space: (level - 1) * indent].	level := level - 1.	empty removeLast.	stream nextPut: $}.</body><body package="GraphQLDemoSite">print: anObject		stream print: anObject.</body><body package="GraphQLDemoSite">serializeArray: aCollection	| index |	self beginArray.		index := 0.	aCollection do: [:each |		index := index + 1.		index &gt; 1 ifTrue: [self emitComma].		self serialize: each].			self endArray.</body><body package="GraphQLDemoSite">serializeBasicContentsOf: anObject	self		emitKey: '&amp;contents';		emitColon;		beginArray.		1 to: anObject basicSize do: [:index |		index &gt; 1 ifTrue: [self emitComma].		self serialize: (anObject basicAt: index)].			self endArray.</body><body package="GraphQLDemoSite">serializeContents: aCollection	| index |	self		emitKey: '&amp;contents';		emitColon;		beginArray.		index := 0.	aCollection do: [:each |		index := index + 1.		index &gt; 1 ifTrue: [self emitComma].		self serialize: each].			self endArray.</body><body package="GraphQLDemoSite">serializeKey: aString value: anObject	self		emitKey: aString;		emitColon;		serialize: anObject</body></methods><methods><class-id>JSONEncoder</class-id> <category>public interface</category><body package="GraphQLDemoSite">encode: anObject	"Encode anObject as JSON data on aStream."		(recursiveSet includes: anObject)		ifTrue: [			self newRecursiveSet.			JSONError raiseErrorString: 'Recursive structure encountered while encoding an instance of ', anObject class printString ].	recursiveSet add: anObject.	anObject encodeAsJSONDataUsing: self.	recursiveSet remove: anObject ifAbsent: [].</body><body package="GraphQLDemoSite">serialize: anObject	"Serialize anObject in a JSON format from which a copy of anObject can be reconstituted, on my stream."		(recursiveSet includes: anObject)		ifTrue: [			self newRecursiveSet.			JSONError raiseErrorString: 'Recursive structure encountered while serializing an instance of ', anObject class printString ].	recursiveSet add: anObject.	anObject serializeAsJSONUsing: self.	recursiveSet remove: anObject ifAbsent: [].</body></methods><methods><class-id>JSONEncoder class</class-id> <category>instance creation</category><body package="GraphQLDemoSite">new	^super new initialize</body><body package="GraphQLDemoSite">on: aStream	^self on: aStream pretty: false indent: 0</body><body package="GraphQLDemoSite">on: aStream pretty: aBoolean	^self on: aStream pretty: aBoolean indent: (aBoolean ifTrue: [4] ifFalse: [0]).</body><body package="GraphQLDemoSite">on: aStream pretty: aBoolean indent: anInteger	^self new		stream: aStream;		pretty: aBoolean;		indent: anInteger.</body></methods><methods><class-id>JSONEncoder class</class-id> <category>accessing</category><body package="GraphQLDemoSite">characterMap	^characterMap</body></methods><methods><class-id>JSONEncoder class</class-id> <category>class initialization</category><body package="GraphQLDemoSite">initialize	self initializeCharacterMap.</body><body package="GraphQLDemoSite">initializeCharacterMap	characterMap := Dictionary new		at: (Character value: 0) put: '\u0000';		at: (Character value: 1) put: '\u0001';		at: (Character value: 2) put: '\u0002';		at: (Character value: 3) put: '\u0003';		at: (Character value: 4) put: '\u0004';		at: (Character value: 5) put: '\u0005';		at: (Character value: 6) put: '\u0006';		at: (Character value: 7) put: '\u0007';		at: Character backspace put: '\b';		at: Character tab put: '\t';		at: Character lf put: '\n';		at: (Character value: 11) put: '\u000B';		at: Character newPage put: '\f';		at: Character cr put: '\r';		at: (Character value: 14) put: '\u000E';		at: (Character value: 15) put: '\u000F';		at: (Character value: 16) put: '\u0010';		at: (Character value: 17) put: '\u0011';		at: (Character value: 18) put: '\u0012';		at: (Character value: 19) put: '\u0013';		at: (Character value: 20) put: '\u0014';		at: (Character value: 21) put: '\u0015';		at: (Character value: 22) put: '\u0016';		at: (Character value: 23) put: '\u0017';		at: (Character value: 24) put: '\u0018';		at: (Character value: 25) put: '\u0019';		at: (Character value: 26) put: '\u001A';		at: (Character value: 27) put: '\u001B';		at: (Character value: 28) put: '\u001C';		at: (Character value: 29) put: '\u001D';		at: (Character value: 30) put: '\u001E';		at: (Character value: 31) put: '\u001F';		at: $" put: '\"';		at: $\ put: '\\';		yourself</body></methods><methods><class-id>JSONEncoder class</class-id> <category>utility</category><body package="GraphQLDemoSite">encode: anObject	"encode anObject on a String and return the result"	| s |	s := (String new: 256) writeStream.	(self on: s) encode: anObject.	^s contents</body><body package="GraphQLDemoSite">encode: anObject on: aStream	"encode anObject on aStream."	^(self on: aStream) encode: anObject.</body><body package="GraphQLDemoSite">encode: anObject onFileNamed: aString	"encode anObject on the file named aString."	| s |	s := aString asFilename writeStream.	[(self on: s) encode: anObject]		ensure: [s close].</body><body package="GraphQLDemoSite">encode: anObject onFileNamed: aString pretty: aBoolean	"encode anObject on the file named aString."	| s |	s := aString asFilename writeStream.	[(self on: s pretty: aBoolean) encode: anObject]		ensure: [s close].</body><body package="GraphQLDemoSite">serialize: anObject	"serialize anObject on a String and return the result"	| s |	s := (String new: 256) writeStream.	(self on: s) serialize: anObject.	^s contents</body><body package="GraphQLDemoSite">serialize: anObject on: aStream	^ (self on: aStream) serialize: anObject.</body><body package="GraphQLDemoSite">serialize: anObject onFileNamed: aString	"serialize anObject on the file named aString."	| s |	s := aString asFilename writeStream.	[self serialize: anObject on: s] ensure:[s close]</body><body package="GraphQLDemoSite">serialize: anObject onFileNamed: aString pretty: aBoolean	"serialize anObject on the file named aString. aBoolean controls pretty encoding"	| s |	s := aString asFilename writeStream.	[(self on: s pretty: aBoolean) serialize: anObject] ensure:[s close].</body></methods><methods><class-id>JSONError</class-id> <category>printing</category><body package="GraphQLDemoSite">description	"Answer the exception text."	^'JSON error: ', super description</body></methods><methods><class-id>GraphQLBetaDemoSite</class-id> <category>serving</category><body package="GraphQLDemoSite">answerTo: aRequest 	|query ans stream |	query :=''.	ans := ''.	(aRequest urlString beginsWith: '/?query') ifTrue: [ 		query := (aRequest queryAt: 'query' ifAbsent:['']) trimSeparators.		stream := String new writeStream.		(JSONEncoder on: stream pretty: true indent: 2) encode: (graphql handleRequest: query).		ans := stream contents.	].	^ self buildResponseWith: (ans) from: query.</body><body package="GraphQLDemoSite">configure	graphql := GraphQLBeta.GraphQL new.	graphql createSchema: GraphQLBeta.Query schema.</body></methods><methods><class-id>GraphQLBetaDemoSite</class-id> <category>private</category><body package="GraphQLDemoSite">buildResponseWith: result from: query	| response |	response := HTTPResponse ok.	response		contentType: 'text/html';		entity: '&lt;html&gt;&lt;head&gt;&lt;style&gt; .flex-container {    display: -webkit-flex;    display: flex;      -webkit-flex-flow: row wrap;    flex-flow: row wrap;    text-align: center;}.flex-container &gt; * {    padding: 15px;    -webkit-flex: 1 100%;    flex: 1 100%;}.article {    text-align: left;}header {background: black;color:white;}footer {background: #aaa;color:white;}.nav {background:#eee;}.nav ul {    list-style-type: none;    padding: 0;}.nav ul a {    text-decoration: none;}@media all and (min-width: 768px) {    .nav {text-align:left;-webkit-flex: 1 auto;flex:1 auto;-webkit-order:1;order:1;}    .article {-webkit-flex:5 0px;flex:5 0px;-webkit-order:2;order:2;}    footer {-webkit-order:3;order:3;}}&lt;/style&gt; &lt;/head&gt;&lt;body&gt;&lt;div class="flex-container"&gt;&lt;header&gt;  &lt;h1&gt;ProtoGraphQL in Smalltalk&lt;/h1&gt;&lt;/header&gt;&lt;nav class="nav"&gt;&lt;form method="get"&gt;&lt;textarea name="query" cols="50" rows="15"&gt;', query, '&lt;/textarea&gt;&lt;input type="submit" value="Submit"/&gt;&lt;/form&gt;&lt;/nav&gt;&lt;article class="article"&gt;  &lt;pre id="result"&gt;',result,'&lt;/pre&gt;&lt;/article&gt;&lt;footer&gt;SemanTICs S.R.L.&amp; Object Profile&lt;/footer&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;'.	^response</body><body package="GraphQLDemoSite">helpResolve: aResolution 	(self canAnswer and: [aResolution siteMatch: self]) ifFalse: [^nil].	^self answerTo: aResolution request</body></methods><methods><class-id>GraphQLBetaDemoSite class</class-id> <category>demo</category><body package="GraphQLDemoSite">demoStart	"on http://localhost:8888/ will return simple 'Hello World'"	| site |	site := Swazoo.SwazooServer singleton siteNamed: 'graphql'.	site isNil ifTrue: [site := self prepareDemoSite].	site configure.	site start</body><body package="GraphQLDemoSite">demoStop	| site |	site := Swazoo.SwazooServer singleton siteNamed: 'graphql'.	^site notNil ifTrue: [site stop. site] ifFalse: [nil].</body><body package="GraphQLDemoSite">prepareDemoSite	| site |	site := self newNamed: 'graphql'. "which is now also added to SwazoServer"	site host: '*' ip: '*' port: 8888.	^site</body></methods><methods><class-id>Core.Dictionary</class-id> <category>storage/retrieval</category><body package="GraphQLDemoSite">encodeAsJSONDataUsing: aJSONEncoder	| index |	aJSONEncoder beginObject.	index := 0.	self keysAndValuesDo: [:key :val |		index := index + 1.		index &gt; 1 ifTrue: [aJSONEncoder emitComma].		aJSONEncoder encodeKey: key value: val].	aJSONEncoder endObject.</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>storage/retrieval</category><body package="GraphQLDemoSite">encodeAsJSONDataUsing: aJSONEncoder	aJSONEncoder encodeArray: self.</body></methods><methods><class-id>Core.String</class-id> <category>storage/retrieval</category><body package="GraphQLDemoSite">encodeAsJSONDataUsing: aJSONEncoder	aJSONEncoder emitString: self.</body></methods><methods><class-id>Core.Boolean</class-id> <category>storage/retrieval</category><body package="GraphQLDemoSite">encodeAsJSONDataUsing: aJSONEncoder	aJSONEncoder print: self.</body></methods><methods><class-id>Core.Stream</class-id> <category>character writing</category><body package="GraphQLDemoSite">space: aNumber	aNumber timesRepeat: [ self space ].</body></methods><methods><class-id>Core.Object</class-id> <category>storage/retrieval</category><body package="GraphQLDemoSite">encodeAsJSONDataUsing: aJSONEncoder	"Append a representation of the receiver as data to aStream. This representation will be vanilla JSON, and thus will not contain type hints needed to reconstitute the original object."	| aClass variableSize |	aClass := self class.	variableSize := aClass isVariable ifTrue: [self basicSize] ifFalse: [0].		aJSONEncoder beginObject.			1 to: aClass instSize do: [:index | 		index &gt; 1 ifTrue: [aJSONEncoder emitComma].		aJSONEncoder encodeKey: (aClass instVarNameForIndex: index) value: (self instVarAt: index)].						variableSize &gt; 0		ifTrue:			[aClass instSize &gt; 0 ifTrue: [aJSONEncoder emitComma].			1 to: variableSize do: [:index |				index &gt; 1 ifTrue: [aJSONEncoder emitComma].				aJSONEncoder encodeKey: index printString value: (self basicAt: index)]].	aJSONEncoder endObject.</body></methods><methods><class-id>Core.Character</class-id> <category>storage/retrieval</category><body package="GraphQLDemoSite">encodeAsJSONDataUsing: aJSONEncoder	aJSONEncoder print: self.</body></methods><initialize><class-id>JSONEncoder</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Dictionary</name><environment>Core</environment><super>Core.Set</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>SwazooSite</name><environment>Swazoo</environment><super>Swazoo.CompositeResource</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name serving </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Swazoo-Core</category><attributes><package>Swazoo-Core</package></attributes></class><class><name>SequenceableCollection</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>Stream</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports>			private IOConstants.*			</imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>Character</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>immediate</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>Boolean</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Error</name><environment>Core</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>String</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class></st-source>