<?xml version="1.0"?><st-source><!-- Name: PetitTestsBundleName: PetitTestsBundleStructure: a Store.BundleForParcelDevelopmentPrerequisites: #(#(#any 'PetitParser' '') #(#any 'SUnitToo' '') #(#any 'SUnitToo(lsoverage)' ''))Parcel: nilParcelName: PetitTestsPrerequisiteDescriptions: #(#(#name 'PetitParser' #componentType #package) #(#name 'SUnitToo' #componentType #package) #(#name 'SUnitToo(lsoverage)' #componentType #package))PrerequisiteParcels: #(#('PetitParser' '') #('SUnitToo' '') #('SUnitToo(lsoverage)' ''))Date: 8:14:55 PM June 5, 2018 --><time-stamp>From VisualWorksÂ® Personal Use Edition, 8.2 of 15 de julio de 2016 on 5 de junio de 2018 at 20:14:55</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>PetitTests</name><environment>Smalltalk</environment><private>false</private><imports>			private PetitParser.*			private Smalltalk.*			</imports><category>PetitTests</category><attributes><package>PetitTests</package></attributes></name-space><class><name>PPAbstractParserTest</name><environment>PetitTests</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitTests-Core</category><attributes><package>PetitTests</package></attributes></class><class><name>PPObjectTest</name><environment>PetitTests</environment><super>PetitTests.PPAbstractParserTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitTests-Tests</category><attributes><package>PetitTests</package></attributes></class><class><name>PPArithmeticParser</name><environment>PetitTests</environment><super>PetitParser.PPCompositeParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>terms addition factors multiplication power primary parentheses number </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitTests-Examples</category><attributes><package>PetitTests</package></attributes></class><class><name>PPParserTest</name><environment>PetitTests</environment><super>PetitTests.PPAbstractParserTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitTests-Tests</category><attributes><package>PetitTests</package></attributes></class><class><name>PPExtensionTest</name><environment>PetitTests</environment><super>PetitTests.PPAbstractParserTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitTests-Tests</category><attributes><package>PetitTests</package></attributes></class><class><name>PPPredicateTest</name><environment>PetitTests</environment><super>PetitTests.PPAbstractParserTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitTests-Tests</category><attributes><package>PetitTests</package></attributes></class><class><name>PPCompositeParserTest</name><environment>PetitTests</environment><super>PetitTests.PPAbstractParserTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parser result debugResult </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitTests-Core</category><attributes><package>PetitTests</package></attributes></class><class><name>PPArithmeticParserTest</name><environment>PetitTests</environment><super>PetitTests.PPCompositeParserTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitTests-Tests</category><attributes><package>PetitTests</package></attributes></class><class><name>PPExpressionParserTest</name><environment>PetitTests</environment><super>PetitTests.PPArithmeticParserTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitTests-Tests</category><attributes><package>PetitTests</package></attributes></class><class><name>PPConditionalParserTests</name><environment>PetitTests</environment><super>PetitTests.PPAbstractParserTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>context </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitTests-Tests</category><attributes><package>PetitTests</package></attributes></class><class><name>PPContextMementoTest</name><environment>PetitTests</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>memento </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitTests-Tests</category><attributes><package>PetitTests</package></attributes></class><class><name>PPParserResource</name><environment>PetitTests</environment><super>SUnit.TestResource</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parsers </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitTests-Core</category><attributes><package>PetitTests</package></attributes></class><class><name>PPComposedTest</name><environment>PetitTests</environment><super>PetitTests.PPAbstractParserTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitTests-Tests</category><attributes><package>PetitTests</package></attributes></class><class><name>PPLambdaParser</name><environment>PetitTests</environment><super>PetitParser.PPCompositeParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>expression abstraction application variable </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitTests-Examples</category><attributes><package>PetitTests</package></attributes></class><class><name>PPScriptingTest</name><environment>PetitTests</environment><super>PetitTests.PPAbstractParserTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitTests-Tests</category><attributes><package>PetitTests</package></attributes></class><comment><class-id>PetitTests.PPScriptingTest</class-id><body>These are some simple demo-scripts of parser combinators for the compiler construction course.http://www.iam.unibe.ch/~scg/Teaching/CC/index.html</body></comment><class><name>PPLambdaParserTest</name><environment>PetitTests</environment><super>PetitTests.PPCompositeParserTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitTests-Tests</category><attributes><package>PetitTests</package></attributes></class><class><name>PPTokenTest</name><environment>PetitTests</environment><super>PetitTests.PPAbstractParserTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitTests-Tests</category><attributes><package>PetitTests</package></attributes></class><class><name>PPConditionalParserTest</name><environment>PetitTests</environment><super>PetitTests.PPAbstractParserTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>context </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitTests-Tests</category><attributes><package>PetitTests</package></attributes></class><class><name>PPMappingTest</name><environment>PetitTests</environment><super>PetitTests.PPAbstractParserTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitTests-Tests</category><attributes><package>PetitTests</package></attributes></class><class><name>PPContextTest</name><environment>PetitTests</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>context </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitTests-Tests</category><attributes><package>PetitTests</package></attributes></class><methods><class-id>PetitTests.PPAbstractParserTest</class-id> <category>utilities</category><body package="PetitTests">assert: aParser fail: aCollection	^ self assert: aParser fail: aCollection end: 0</body><body package="PetitTests">assert: aParser fail: aCollection end: anInteger	| stream result context |	self 		assert: aParser isPetitParser		description: 'Parser invalid'.	stream := aCollection asPetitStream.	context := self context.			result := aParser parse: stream withContext: context.	self 		assert: result isPetitFailure		description: 'Parser did not fail'.	self		assert: context position = anInteger		description: 'Parser failed at wrong position'.	^ result</body><body package="PetitTests">assert: string1 includesSubstring: string2	"Support portability by using ANSI search method"	self assert: (string1 notEmpty and: [string2 notEmpty and: [0 &lt; (string1 indexOfSubCollection: string2 startingAt: 1)]])</body><body package="PetitTests">assert: aParser parse: aCollection	^ self assert: aParser parse: aCollection to: nil end: aCollection size </body><body package="PetitTests">assert: aParser parse: aCollection end: anInteger	^ self assert: aParser parse: aCollection to: nil end: anInteger</body><body package="PetitTests">assert: aParser parse: aCollection to: anObject	^ self assert: aParser parse: aCollection to: anObject end: aCollection size </body><body package="PetitTests">assert: aParser parse: aCollection to: aTargetObject end: anInteger	| stream result context |	self assert: aParser isPetitParser description: 'Parser invalid'.	stream := aCollection asPetitStream.	context := self context.		result := aParser parse: stream withContext: context.	aTargetObject isNil		ifTrue: [ self deny: result isPetitFailure ]		ifFalse: [ self assert: result equals: aTargetObject ].	self assert: context position = anInteger description: 'Parser accepted at wrong position'.	^ result</body><body package="PetitTests">assert: aParser parse: aCollection toToken: aStartInteger stop: aStopInteger	^ self assert: aParser parse: aCollection toToken: aStartInteger stop: aStopInteger end: aCollection size</body><body package="PetitTests">assert: aParser parse: aParserObject toToken: aStartInteger stop: aStopInteger end: anEndInteger	| token |	token := self		assert: aParser		parse: aParserObject		to: nil		end: anEndInteger.	self assert: (token isKindOf: PPToken).	self assert: token start equals: aStartInteger.	self assert: token stop equals: aStopInteger.	^ token</body></methods><methods><class-id>PetitTests.PPAbstractParserTest</class-id> <category>context</category><body package="PetitTests">context	^ PPContext new</body></methods><methods><class-id>PetitTests.PPAbstractParserTest class</class-id> <category>testing</category><body package="PetitTests">isAbstract	^ self name = #PPAbstractParserTest</body></methods><methods><class-id>PetitTests.PPAbstractParserTest class</class-id> <category>accessing</category><body package="PetitTests">packageNamesUnderTest	^ #('PetitParser' 'PetitTests')</body></methods><methods><class-id>PetitTests.PPObjectTest</class-id> <category>testing</category><body package="PetitTests">testInteger	self assert: self integer parse: #(123) to: 123.	self assert: self integer fail: #('abc')</body><body package="PetitTests">testString	self assert: self string parse: #('abc') to: 'abc'.	self assert: self string fail: #(123)</body></methods><methods><class-id>PetitTests.PPObjectTest</class-id> <category>testing-operators</category><body package="PetitTests">testChoice	| parser |	parser := self integer / self string.	self assert: parser parse: #(123) to: 123.	self assert: parser parse: #('abc') to: 'abc'</body><body package="PetitTests">testSequence	| parser |	parser := self integer , self string.	self assert: parser parse: #(123 'abc') to: #(123 'abc').	self assert: parser fail: #(123 456).	self assert: parser fail: #('abc' 'def').	self assert: parser fail: #('abc' 123)	</body></methods><methods><class-id>PetitTests.PPObjectTest</class-id> <category>parsers</category><body package="PetitTests">integer	^ PPPredicateObjectParser		on: [ :each | each isKindOf: Integer ]		message: 'integer expected'</body><body package="PetitTests">string	^ PPPredicateObjectParser		on: [ :each | each isKindOf: String ]		message: 'string expected'</body></methods><methods><class-id>PetitTests.PPObjectTest</class-id> <category>testing-fancy</category><body package="PetitTests">testFibonacci	"This parser accepts fibonacci sequences with arbitrary start pairs."		| parser |	parser := ((self integer , self integer) end ==&gt; [ :pair | pair first + pair last ])		/ (self integer , (self integer , self integer) and &gt;=&gt; [ :stream :continuation |			| result |			result := continuation value.			(result isPetitFailure or: [ result first + result last first ~= result last last ])				ifFalse: [ parser parseOn: stream ]				ifTrue: [ PPFailure message: 'invalid fibonacci sequence' context: stream ] ]).	self assert: parser parse: #(1 1) to: 2.	self assert: parser parse: #(1 1 2) to: 3.	self assert: parser parse: #(1 1 2 3) to: 5.	self assert: parser parse: #(1 1 2 3 5) to: 8.	self assert: parser parse: #(1 1 2 3 5 8) to: 13.	self assert: parser parse: #(1 1 2 3 5 8 13) to: 21.	self assert: parser fail: #().	self assert: parser fail: #(1).	self assert: parser fail: #(1 2 3 4) end: 2	</body></methods><methods><class-id>PetitTests.PPArithmeticParser</class-id> <category>accessing</category><body package="PetitTests">start	^ terms end</body></methods><methods><class-id>PetitTests.PPArithmeticParser</class-id> <category>grammar</category><body package="PetitTests">addition	^ (factors separatedBy: ($+ asParser / $- asParser) trim) 		foldLeft: [ :a :op :b | a perform: op asSymbol with: b ]</body><body package="PetitTests">factors	^ multiplication / power</body><body package="PetitTests">multiplication	^ (power separatedBy: ($* asParser / $/ asParser) trim)		foldLeft: [ :a :op :b | a perform: op asSymbol with: b ]</body><body package="PetitTests">number	^ ($- asParser optional , #digit asParser plus , ($. asParser , #digit asParser plus) optional) flatten trim 		==&gt; [ :value | value asNumber ]</body><body package="PetitTests">parentheses	^ $( asParser trim , terms , $) asParser trim		==&gt; [ :nodes | nodes at: 2 ]</body><body package="PetitTests">power	^ (primary separatedBy: $^ asParser trim)		foldRight: [ :a :op :b | a raisedTo: b ]</body><body package="PetitTests">primary	^ number / parentheses</body><body package="PetitTests">terms	^ addition / factors</body></methods><methods><class-id>PetitTests.PPParserTest</class-id> <category>testing-mapping</category><body package="PetitTests">testAction	| block parser |	block := [ :char | char asUppercase ].	parser := #any asParser ==&gt; block.	self assert: parser block equals: block.	self assert: parser parse: 'a' to: $A.	self assert: parser parse: 'b' to: $B</body><body package="PetitTests">testAnswer	| parser |	parser := $a asParser answer: $b.		self assert: parser parse: 'a' to: $b.		self assert: parser fail: ''.	self assert: parser fail: 'b'</body><body package="PetitTests">testFlatten	| parser |	parser := $a asParser flatten.		self assert: parser parse: 'a' to: 'a'.	self assert: parser parse: #($a) to: #($a).		self assert: parser fail: ''.	self assert: parser fail: 'b'</body><body package="PetitTests">testFoldLeft2	| parser |	parser := #any asParser star 		foldLeft: [ :a :b | Array with: a with: b ].	self assert: parser parse: #(a) to: #a.	self assert: parser parse: #(a b) to: #(a b).	self assert: parser parse: #(a b c) to: #((a b) c).	self assert: parser parse: #(a b c d) to: #(((a b) c) d).	self assert: parser parse: #(a b c d e) to: #((((a b) c) d) e)</body><body package="PetitTests">testFoldLeft3	| parser |	parser := #any asParser star 		foldLeft: [ :a :b :c | Array with: a with: b with: c ].	self assert: parser parse: #(a) to: #a.	self assert: parser parse: #(a b c) to: #(a b c).	self assert: parser parse: #(a b c d e) to: #((a b c) d e)</body><body package="PetitTests">testFoldRight2	| parser |	parser := #any asParser star 		foldRight: [ :a :b | Array with: a with: b ].	self assert: parser parse: #(a) to: #a.	self assert: parser parse: #(a b) to: #(a b).	self assert: parser parse: #(a b c) to: #(a (b c)).	self assert: parser parse: #(a b c d) to: #(a (b (c d))).	self assert: parser parse: #(a b c d e) to: #(a (b (c (d e))))</body><body package="PetitTests">testFoldRight3	| parser |	parser := #any asParser star 		foldRight: [ :a :b :c | Array with: a with: b with: c ].	self assert: parser parse: #(a) to: #a.	self assert: parser parse: #(a b c) to: #(a b c).	self assert: parser parse: #(a b c d e) to: #(a b (c d e))</body><body package="PetitTests">testMap1	| parser |	parser := #any asParser 		map: [ :a | Array with: a ].	self assert: parser parse: #(a) to: #(a)</body><body package="PetitTests">testMap2	| parser |	parser := (#any asParser , #any asParser) 		map: [ :a :b | Array with: b with: a ].	self assert: parser parse: #(a b) to: #(b a)</body><body package="PetitTests">testMap3	| parser |	parser := (#any asParser , #any asParser , #any asParser)		map: [ :a :b :c | Array with: c with: b with: a ].	self assert: parser parse: #(a b c) to: #(c b a)</body><body package="PetitTests">testMapFail1	self		should: [ #any asParser map: [  ] ]		raise: Error.	self		should: [ #any asParser map: [ :a :b | ] ]		raise: Error</body><body package="PetitTests">testMapFail2	self		should: [ (#any asParser , #any asParser) map: [ :a | ] ]		raise: Error.	self		should: [ (#any asParser , #any asParser) map: [ :a :b :c | ] ]		raise: Error</body><body package="PetitTests">testPermutation	| parser |	parser := #any asParser , #any asParser , #any asParser.	self assert: (parser permutation: #()) parse: '123' to: #().	self assert: (parser permutation: #(1)) parse: '123' to: #($1).	self assert: (parser permutation: #(1 3)) parse: '123' to: #($1 $3).	self assert: (parser permutation: #(3 1)) parse: '123' to: #($3 $1).	self assert: (parser permutation: #(2 2)) parse: '123' to: #($2 $2).	self assert: (parser permutation: #(3 2 1)) parse: '123' to: #($3 $2 $1).		self should: [ parser permutation: #(0) ] raise: Error.	self should: [ parser permutation: #(4) ] raise: Error.	self should: [ parser permutation: #($2) ] raise: Error</body><body package="PetitTests">testToken	| parser |	parser := $a asParser token.	self assert: parser tokenClass equals: PPToken.	self		assert: parser		parse: 'a'		toToken: 1		stop: 1.	self assert: parser fail: 'b'.	self assert: parser fail: ''.	parser := $a asParser token: PPToken.	self assert: parser tokenClass equals: PPToken.	self		assert: parser		parse: 'a'		toToken: 1		stop: 1.	self assert: parser fail: ''.	self assert: parser fail: 'b'</body><body package="PetitTests">testTrim	| parser |	parser := $a asParser token trim.		self assert: parser parse: 'a' toToken: 1 stop: 1.	self assert: parser parse: 'a ' toToken: 1 stop: 1.	self assert: parser parse: 'a	' toToken: 1 stop: 1.	self assert: parser parse: 'a  ' toToken: 1 stop: 1.	self assert: parser parse: 'a 	 ' toToken: 1 stop: 1.			self assert: parser parse: 'a' toToken: 1 stop: 1.	self assert: parser parse: ' a' toToken: 2 stop: 2.	self assert: parser parse: '	a' toToken: 2 stop: 2.	self assert: parser parse: '    a' toToken: 5 stop: 5.	self assert: parser parse: '   a' toToken: 5 stop: 5.		self assert: parser parse: 'aa' toToken: 1 stop: 1 end: 1.	self assert: parser parse: 'a	a' toToken: 1 stop: 1 end: 2.	self assert: parser parse: 'a  a' toToken: 1 stop: 1 end: 3.		self assert: parser fail: ''.	self assert: parser fail: 'b'</body><body package="PetitTests">testTrimBlanks	| parser |	parser := $a asParser token trimBlanks.		self assert: parser parse: 'a' toToken: 1 stop: 1.	self assert: parser parse: 'a ' toToken: 1 stop: 1.	self assert: parser parse: 'a	' toToken: 1 stop: 1.	self assert: parser parse: 'a  ' toToken: 1 stop: 1.		self assert: parser parse: 'a' toToken: 1 stop: 1.	self assert: parser parse: ' a' toToken: 2 stop: 2.	self assert: parser parse: '	a' toToken: 2 stop: 2.	self assert: parser parse: '    a' toToken: 5 stop: 5.		self assert: parser parse: 'aa' toToken: 1 stop: 1 end: 1.	self assert: parser parse: 'a	a' toToken: 1 stop: 1 end: 2.	self assert: parser parse: 'a  a' toToken: 1 stop: 1 end: 3.		self assert: parser fail: ''.	self assert: parser fail: ''.	self assert: parser fail: 'a'.	self assert: parser fail: 'b'.</body><body package="PetitTests">testTrimCustom	| parser |	parser := $a asParser token trim: $b asParser.		self assert: parser parse: 'a' toToken: 1 stop: 1.	self assert: parser parse: 'ab' toToken: 1 stop: 1.	self assert: parser parse: 'abb' toToken: 1 stop: 1.			self assert: parser parse: 'a' toToken: 1 stop: 1.	self assert: parser parse: 'ba' toToken: 2 stop: 2.	self assert: parser parse: 'bba' toToken: 3 stop: 3.		self assert: parser parse: 'aa' toToken: 1 stop: 1 end: 1.	self assert: parser parse: 'ab' toToken: 1 stop: 1 end: 2.	self assert: parser parse: 'abba' toToken: 1 stop: 1 end: 3.		self assert: parser fail: ''.	self assert: parser fail: 'b'</body><body package="PetitTests">testTrimSpaces	| parser |	parser := $a asParser token trimSpaces.		self assert: parser parse: 'a' toToken: 1 stop: 1.	self assert: parser parse: 'a ' toToken: 1 stop: 1.	self assert: parser parse: 'a	' toToken: 1 stop: 1.	self assert: parser parse: 'a  ' toToken: 1 stop: 1.	self assert: parser parse: 'a 	 ' toToken: 1 stop: 1.			self assert: parser parse: 'a' toToken: 1 stop: 1.	self assert: parser parse: ' a' toToken: 2 stop: 2.	self assert: parser parse: '	a' toToken: 2 stop: 2.	self assert: parser parse: '    a' toToken: 5 stop: 5.	self assert: parser parse: '   a' toToken: 5 stop: 5.		self assert: parser parse: 'aa' toToken: 1 stop: 1 end: 1.	self assert: parser parse: 'a	a' toToken: 1 stop: 1 end: 2.	self assert: parser parse: 'a  a' toToken: 1 stop: 1 end: 3.		self assert: parser fail: ''.	self assert: parser fail: 'b'</body><body package="PetitTests">testWrapping	| parser result |	parser := #digit asParser plus &gt;=&gt; [ :stream :cc | Array with: stream position with: cc value with: stream position ].	self assert: parser parse: '1' to: #(0 #($1) 1).	self assert: parser parse: '12' to: #(0 #($1 $2) 2).	self assert: parser parse: '123' to: #(0 #($1 $2 $3) 3).	result := parser parse: 'a'.	self assert: result first equals: 0.	self assert: result second isPetitFailure.	self assert: result last equals: 0</body></methods><methods><class-id>PetitTests.PPParserTest</class-id> <category>testing</category><body package="PetitTests">testAnd	| parser |	parser := 'foo' asParser flatten , 'bar' asParser flatten and.	self		assert: parser		parse: 'foobar'		to: #('foo' 'bar')		end: 3.	self assert: parser fail: 'foobaz'.	parser := 'foo' asParser and.	self assert: parser and equals: parser</body><body package="PetitTests">testBlock	| parser |	parser := [ :s | s next ] asParser.		self assert: parser parse: 'ab' to: $a end: 1.	self assert: parser parse: 'b' to: $b.	self assert: parser parse: '' to: nil</body><body package="PetitTests">testChoice	| parser |	parser := $a asParser / $b asParser.		self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'b' to: $b.	self assert: parser parse: 'ab' to: $a end: 1.	self assert: parser parse: 'ba' to: $b end: 1.	self assert: parser fail: ''.	self assert: parser fail: 'c'.	self assert: parser fail: 'ca'</body><body package="PetitTests">testDelimitedBy	| parser |	parser := $a asParser delimitedBy: $b asParser.		self assert: parser parse: 'a' to: #($a).	self assert: parser parse: 'aba' to: #($a $b $a).	self assert: parser parse: 'ababa' to: #($a $b $a $b $a).	self assert: parser parse: 'ab' to: #($a $b).	self assert: parser parse: 'abab' to: #($a $b $a $b).	self assert: parser parse: 'ababab' to: #($a $b $a $b $a $b).		self assert: parser parse: 'ac' to: #($a) end: 1.	self assert: parser parse: 'abc' to: #($a $b) end: 2.	self assert: parser parse: 'abac' to: #($a $b $a) end: 3.	self assert: parser parse: 'ababc' to: #($a $b $a $b) end: 4.		self assert: parser fail: ''.	self assert: parser fail: 'b'.	self assert: parser fail: 'c'</body><body package="PetitTests">testDelimitedByWithoutSeparators	| parser |	parser := ($a asParser delimitedBy: $b asParser)		withoutSeparators.		self assert: parser parse: 'a' to: #($a).	self assert: parser parse: 'aba' to: #($a $a).	self assert: parser parse: 'ababa' to: #($a $a $a).	self assert: parser parse: 'ab' to: #($a).	self assert: parser parse: 'abab' to: #($a $a).	self assert: parser parse: 'ababab' to: #($a $a $a).		self assert: parser parse: 'ac' to: #($a) end: 1.	self assert: parser parse: 'abc' to: #($a) end: 2.	self assert: parser parse: 'abac' to: #($a $a) end: 3.	self assert: parser parse: 'ababc' to: #($a $a) end: 4.		self assert: parser fail: ''.	self assert: parser fail: 'b'.	self assert: parser fail: 'c'</body><body package="PetitTests">testEndOfInput	| parser |	parser := PPEndOfInputParser on: $a asParser.	self assert: parser end equals: parser.	self assert: parser parse: 'a' to: $a.	self assert: parser fail: ''.	self assert: parser fail: 'aa'</body><body package="PetitTests">testEndOfInputAfterMatch	| parser |	parser := 'stuff' asParser end.	self assert: parser parse: 'stuff' to: 'stuff'.	self assert: parser fail: 'stufff'.	self assert: parser fail: 'fluff'</body><body package="PetitTests">testEpsilon	| parser |	parser := nil asParser.		self assert: parser parse: '' to: nil.		self assert: parser parse: 'a' to: nil end: 0.	self assert: parser parse: 'ab' to: nil end: 0</body><body package="PetitTests">testFailing	| parser result |	parser := PPFailingParser message: 'Plonk'.	self assert: parser message equals: 'Plonk'.	self assert: parser fail: ''.	self assert: parser fail: 'a'.	self assert: parser fail: 'aa'.	result := parser parse: 'a'.	self assert: result message equals: 'Plonk'.	self assert: result printString equals: 'Plonk at 0'</body><body package="PetitTests">testLiteralObject	| parser |	parser := PPLiteralObjectParser on: $a message: 'letter "a" expected'.	self assert: parser literal equals: $a.	self assert: parser message equals: 'letter "a" expected'.	self assert: parser parse: 'a' to: $a.	self assert: parser fail: 'b'</body><body package="PetitTests">testLiteralObjectCaseInsensitive	| parser |	parser := $a asParser caseInsensitive.		self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'A' to: $A.	self assert: parser fail: ''.	self assert: parser fail: 'b'.	self assert: parser fail: 'B'	</body><body package="PetitTests">testLiteralSequence	| parser |	parser := PPLiteralSequenceParser on: 'abc' message: 'sequence "abc" expected'.	self assert: parser size equals: 3.	self assert: parser literal equals: 'abc'.	self assert: parser message equals: 'sequence "abc" expected'.	self assert: parser parse: 'abc' to: 'abc'.	self assert: parser fail: 'ab'.	self assert: parser fail: 'abd'</body><body package="PetitTests">testLiteralSequenceCaseInsensitive	| parser |	parser := 'abc' asParser caseInsensitive.		self assert: parser parse: 'abc' to: 'abc'.	self assert: parser parse: 'ABC' to: 'ABC'.	self assert: parser parse: 'abC' to: 'abC'.	self assert: parser parse: 'AbC' to: 'AbC'.		self assert: parser fail: 'ab'.	self assert: parser fail: 'abd'</body><body package="PetitTests">testMax	| parser printString suffix |	parser := $a asParser max: 2.	self assert: parser min equals: 0.	self assert: parser max equals: 2.	self assert: parser parse: '' to: #().	self assert: parser parse: 'a' to: #($a).	self assert: parser parse: 'aa' to: #($a $a).	self		assert: parser		parse: 'aaa'		to: #($a $a)		end: 2.	self		assert: parser		parse: 'aaaa'		to: #($a $a)		end: 2.	printString := parser printString.	suffix := printString copyFrom: printString size - 5 to: printString size.	self assert: suffix = '[0, 2]'</body><body package="PetitTests">testMaxGreedy	| parser |	parser := #word asParser max: 2 greedy: #digit asParser.		self assert: parser fail: ''.	self assert: parser fail: 'abc'.		self assert: parser parse: '1' to: #() end: 0.	self assert: parser parse: 'a1' to: #($a) end: 1.	self assert: parser parse: 'ab1' to: #($a $b) end: 2.	self assert: parser fail: 'abc1'.		self assert: parser parse: '12' to: #($1) end: 1.	self assert: parser parse: 'a12' to: #($a $1) end: 2.	self assert: parser parse: 'ab12' to: #($a $b) end: 2.	self assert: parser fail: 'abc12'.		self assert: parser parse: '123' to: #($1 $2) end: 2.	self assert: parser parse: 'a123' to: #($a $1) end: 2.	self assert: parser parse: 'ab123' to: #($a $b) end: 2.	self assert: parser fail: 'abc123'</body><body package="PetitTests">testMaxLazy	| parser |	parser := #word asParser max: 2 lazy: #digit asParser.		self assert: parser fail: ''.	self assert: parser fail: 'abc'.		self assert: parser parse: '1' to: #() end: 0.	self assert: parser parse: 'a1' to: #($a) end: 1.	self assert: parser parse: 'ab1' to: #($a $b) end: 2.	self assert: parser fail: 'abc1'.		self assert: parser parse: '12' to: #() end: 0.	self assert: parser parse: 'a12' to: #($a) end: 1.	self assert: parser parse: 'ab12' to: #($a $b) end: 2.	self assert: parser fail: 'abc12'.		self assert: parser parse: '123' to: #() end: 0.	self assert: parser parse: 'a123' to: #($a) end: 1.	self assert: parser parse: 'ab123' to: #($a $b) end: 2.	self assert: parser fail: 'abc123'</body><body package="PetitTests">testMemoized	| count parser twice |	count := 0.	parser := [ :s | 	count := count + 1.	s next ] asParser memoized.	twice := parser and , parser.	count := 0.	self assert: parser parse: 'a' to: $a.	self assert: count equals: 1.	count := 0.	self assert: twice parse: 'a' to: #($a $a).	self assert: count equals: 1.	self assert: parser memoized equals: parser</body><body package="PetitTests">testMin	| parser printString suffix |	parser := $a asParser min: 2.	self assert: parser min equals: 2.	self assert: parser max &gt; parser min.	self assert: parser fail: ''.	self assert: parser fail: 'a'.	self assert: parser parse: 'aa' to: #($a $a).	self assert: parser parse: 'aaa' to: #($a $a $a).	self assert: parser parse: 'aaaa' to: #($a $a $a $a).	printString := parser printString.	suffix := printString copyFrom: printString size - 5 to: printString size.	self assert: suffix = '[2, *]'</body><body package="PetitTests">testMinGreedy	| parser |	parser := #word asParser min: 2 greedy: #digit asParser.		self assert: parser fail: ''.	self assert: parser fail: 'abcde'.		self assert: parser fail: '1'.	self assert: parser fail: 'a1'.	self assert: parser parse: 'ab1' to: #($a $b) end: 2.	self assert: parser parse: 'abc1' to: #($a $b $c) end: 3.	self assert: parser parse: 'abcd1' to: #($a $b $c $d) end: 4.	self assert: parser parse: 'abcde1' to: #($a $b $c $d $e) end: 5.		self assert: parser fail: '12'.	self assert: parser parse: 'a12' to: #($a $1) end: 2.	self assert: parser parse: 'ab12' to: #($a $b $1) end: 3.	self assert: parser parse: 'abc12' to: #($a $b $c $1) end: 4.	self assert: parser parse: 'abcd12' to: #($a $b $c $d $1) end: 5.	self assert: parser parse: 'abcde12' to: #($a $b $c $d $e $1) end: 6.		self assert: parser parse: '123' to: #($1 $2) end: 2.	self assert: parser parse: 'a123' to: #($a $1 $2) end: 3.	self assert: parser parse: 'ab123' to: #($a $b $1 $2) end: 4.	self assert: parser parse: 'abc123' to: #($a $b $c $1 $2) end: 5.	self assert: parser parse: 'abcd123' to: #($a $b $c $d $1 $2) end: 6.	self assert: parser parse: 'abcde123' to: #($a $b $c $d $e $1 $2) end: 7.		self assert: parser parse: '1234' to: #($1 $2 $3) end: 3.	self assert: parser parse: 'a1234' to: #($a $1 $2 $3) end: 4.	self assert: parser parse: 'ab1234' to: #($a $b $1 $2 $3) end: 5.	self assert: parser parse: 'abc1234' to: #($a $b $c $1 $2 $3) end: 6.	self assert: parser parse: 'abcd1234' to: #($a $b $c $d $1 $2 $3) end: 7.	self assert: parser parse: 'abcde1234' to: #($a $b $c $d $e $1 $2 $3) end: 8</body><body package="PetitTests">testMinLazy	| parser |	parser := #word asParser min: 2 lazy: #digit asParser.		self assert: parser fail: ''.	self assert: parser fail: 'abcde'.		self assert: parser fail: '1'.	self assert: parser fail: 'a1'.	self assert: parser parse: 'ab1' to: #($a $b) end: 2.	self assert: parser parse: 'abc1' to: #($a $b $c) end: 3.	self assert: parser parse: 'abcd1' to: #($a $b $c $d) end: 4.	self assert: parser parse: 'abcde1' to: #($a $b $c $d $e) end: 5.		self assert: parser fail: '12'.	self assert: parser parse: 'a12' to: #($a $1) end: 2.	self assert: parser parse: 'ab12' to: #($a $b) end: 2.	self assert: parser parse: 'abc12' to: #($a $b $c) end: 3.	self assert: parser parse: 'abcd12' to: #($a $b $c $d) end: 4.	self assert: parser parse: 'abcde12' to: #($a $b $c $d $e) end: 5.		self assert: parser parse: '123' to: #($1 $2) end: 2.	self assert: parser parse: 'a123' to: #($a $1) end: 2.	self assert: parser parse: 'ab123' to: #($a $b) end: 2.	self assert: parser parse: 'abc123' to: #($a $b $c) end: 3.	self assert: parser parse: 'abcd123' to: #($a $b $c $d) end: 4.	self assert: parser parse: 'abcde123' to: #($a $b $c $d $e) end: 5.		self assert: parser parse: '1234' to: #($1 $2) end: 2.	self assert: parser parse: 'a1234' to: #($a $1) end: 2.	self assert: parser parse: 'ab1234' to: #($a $b) end: 2.	self assert: parser parse: 'abc1234' to: #($a $b $c) end: 3.	self assert: parser parse: 'abcd1234' to: #($a $b $c $d) end: 4.	self assert: parser parse: 'abcde1234' to: #($a $b $c $d $e) end: 5</body><body package="PetitTests">testMinMax	| parser printString suffix |	parser := $a asParser min: 2 max: 4.	self assert: parser min equals: 2.	self assert: parser max equals: 4.	self assert: parser fail: ''.	self assert: parser fail: 'a'.	self assert: parser parse: 'aa' to: #($a $a).	self assert: parser parse: 'aaa' to: #($a $a $a).	self assert: parser parse: 'aaaa' to: #($a $a $a $a).	self		assert: parser		parse: 'aaaaa'		to: #($a $a $a $a)		end: 4.	self		assert: parser		parse: 'aaaaaa'		to: #($a $a $a $a)		end: 4.	printString := parser printString.	suffix := printString copyFrom: printString size - 5 to: printString size.	self assert: suffix = '[2, 4]'</body><body package="PetitTests">testMinMaxGreedy	| parser |	parser := #word asParser min: 2 max: 4 greedy: #digit asParser.		self assert: parser fail: ''.	self assert: parser fail: 'abcde'.		self assert: parser fail: '1'.	self assert: parser fail: 'a1'.	self assert: parser parse: 'ab1' to: #($a $b) end: 2.	self assert: parser parse: 'abc1' to: #($a $b $c) end: 3.	self assert: parser parse: 'abcd1' to: #($a $b $c $d) end: 4.	self assert: parser fail: 'abcde1'.		self assert: parser fail: '12'.	self assert: parser parse: 'a12' to: #($a $1) end: 2.	self assert: parser parse: 'ab12' to: #($a $b $1) end: 3.	self assert: parser parse: 'abc12' to: #($a $b $c $1) end: 4.	self assert: parser parse: 'abcd12' to: #($a $b $c $d) end: 4.	self assert: parser fail: 'abcde12'.		self assert: parser parse: '123' to: #($1 $2) end: 2.	self assert: parser parse: 'a123' to: #($a $1 $2) end: 3.	self assert: parser parse: 'ab123' to: #($a $b $1 $2) end: 4.	self assert: parser parse: 'abc123' to: #($a $b $c $1) end: 4.	self assert: parser parse: 'abcd123' to: #($a $b $c $d) end: 4.	self assert: parser fail: 'abcde123'.		self assert: parser parse: '1234' to: #($1 $2 $3) end: 3.	self assert: parser parse: 'a1234' to: #($a $1 $2 $3) end: 4.	self assert: parser parse: 'ab1234' to: #($a $b $1 $2) end: 4.	self assert: parser parse: 'abc1234' to: #($a $b $c $1) end: 4.	self assert: parser parse: 'abcd1234' to: #($a $b $c $d) end: 4.	self assert: parser fail: 'abcde1234'</body><body package="PetitTests">testMinMaxLazy	| parser |	parser := #word asParser min: 2 max: 4 lazy: #digit asParser.		self assert: parser fail: ''.	self assert: parser fail: 'abcde'.		self assert: parser fail: '1'.	self assert: parser fail: 'a1'.	self assert: parser parse: 'ab1' to: #($a $b) end: 2.	self assert: parser parse: 'abc1' to: #($a $b $c) end: 3.	self assert: parser parse: 'abcd1' to: #($a $b $c $d) end: 4.	self assert: parser fail: 'abcde1'.		self assert: parser fail: '12'.	self assert: parser parse: 'a12' to: #($a $1) end: 2.	self assert: parser parse: 'ab12' to: #($a $b) end: 2.	self assert: parser parse: 'abc12' to: #($a $b $c) end: 3.	self assert: parser parse: 'abcd12' to: #($a $b $c $d) end: 4.	self assert: parser fail: 'abcde12'.		self assert: parser parse: '123' to: #($1 $2) end: 2.	self assert: parser parse: 'a123' to: #($a $1) end: 2.	self assert: parser parse: 'ab123' to: #($a $b) end: 2.	self assert: parser parse: 'abc123' to: #($a $b $c) end: 3.	self assert: parser parse: 'abcd123' to: #($a $b $c $d) end: 4.	self assert: parser fail: 'abcde123'.		self assert: parser parse: '1234' to: #($1 $2) end: 2.	self assert: parser parse: 'a1234' to: #($a $1) end: 2.	self assert: parser parse: 'ab1234' to: #($a $b) end: 2.	self assert: parser parse: 'abc1234' to: #($a $b $c) end: 3.	self assert: parser parse: 'abcd1234' to: #($a $b $c $d) end: 4.	self assert: parser fail: 'abcde1234'</body><body package="PetitTests">testNegate	| parser |	parser := 'foo' asParser negate.		self assert: parser parse: 'f' to: $f end: 1.	self assert: parser parse: 'fo' to: $f end: 1.	self assert: parser parse: 'fob' to: $f end: 1.	self assert: parser parse: 'ffoo' to: $f end: 1.		self assert: parser fail: ''.	self assert: parser fail: 'foo'</body><body package="PetitTests">testNot	| parser |	parser := 'foo' asParser flatten , 'bar' asParser flatten not.		self assert: parser parse: 'foobaz' to: #('foo' nil) end: 3.	self assert: parser fail: 'foobar'</body><body package="PetitTests">testOptional	| parser |	parser := $a asParser optional.		self assert: parser parse: '' to: nil.	self assert: parser parse: 'a' to: $a.		self assert: parser parse: 'aa' to: $a end: 1.	self assert: parser parse: 'ab' to: $a end: 1.	self assert: parser parse: 'b' to: nil end: 0.	self assert: parser parse: 'bb' to: nil end: 0.	self assert: parser parse: 'ba' to: nil end: 0</body><body package="PetitTests">testPluggable	| block parser |	block := [ :stream | stream position ].	parser := block asParser.	self assert: parser block equals: block</body><body package="PetitTests">testPlus	| parser |	parser := $a asParser plus.	self assert: parser min equals: 1.	self assert: parser max &gt; parser min.	self assert: parser parse: 'a' to: #($a).	self assert: parser parse: 'aa' to: #($a $a).	self assert: parser parse: 'aaa' to: #($a $a $a).	self		assert: parser		parse: 'ab'		to: #($a)		end: 1.	self		assert: parser		parse: 'aab'		to: #($a $a)		end: 2.	self		assert: parser		parse: 'aaab'		to: #($a $a $a)		end: 3.	self assert: parser fail: ''.	self assert: parser fail: 'b'.	self assert: parser fail: 'ba'</body><body package="PetitTests">testPlusGreedy	| limit parser |	limit := #digit asParser.	parser := #word asParser plusGreedy: limit.	self assert: parser min equals: 1.	self assert: parser max &gt; parser min.	self assert: parser limit equals: limit.	self assert: parser children size equals: 2.	self assert: parser children last equals: limit.	self assert: parser fail: ''.	self assert: parser fail: '1'.	self assert: parser fail: 'a'.	self assert: parser fail: 'ab'.	self		assert: parser		parse: 'a1'		to: #($a)		end: 1.	self		assert: parser		parse: 'ab1'		to: #($a $b)		end: 2.	self		assert: parser		parse: 'abc1'		to: #($a $b $c)		end: 3.	self		assert: parser		parse: 'a12'		to: #($a $1)		end: 2.	self		assert: parser		parse: 'ab12'		to: #($a $b $1)		end: 3.	self		assert: parser		parse: 'abc12'		to: #($a $b $c $1)		end: 4.	self		assert: parser		parse: 'a123'		to: #($a $1 $2)		end: 3.	self		assert: parser		parse: 'ab123'		to: #($a $b $1 $2)		end: 4.	self		assert: parser		parse: 'abc123'		to: #($a $b $c $1 $2)		end: 5</body><body package="PetitTests">testPlusLazy	| limit parser |	limit := #digit asParser.	parser := #word asParser plusLazy: limit.	self assert: parser min equals: 1.	self assert: parser max &gt; parser min.	self assert: parser limit equals: limit.	self assert: parser children size equals: 2.	self assert: parser children last equals: limit.	self assert: parser fail: ''.	self assert: parser fail: '1'.	self assert: parser fail: 'a'.	self assert: parser fail: 'ab'.	self		assert: parser		parse: 'a1'		to: #($a)		end: 1.	self		assert: parser		parse: 'ab1'		to: #($a $b)		end: 2.	self		assert: parser		parse: 'abc1'		to: #($a $b $c)		end: 3.	self		assert: parser		parse: 'a12'		to: #($a)		end: 1.	self		assert: parser		parse: 'ab12'		to: #($a $b)		end: 2.	self		assert: parser		parse: 'abc12'		to: #($a $b $c)		end: 3.	self		assert: parser		parse: 'a123'		to: #($a)		end: 1.	self		assert: parser		parse: 'ab123'		to: #($a $b)		end: 2.	self		assert: parser		parse: 'abc123'		to: #($a $b $c)		end: 3</body><body package="PetitTests">testSeparatedBy	| parser |	parser := $a asParser separatedBy: $b asParser.		self assert: parser parse: 'a' to: #($a).	self assert: parser parse: 'aba' to: #($a $b $a).	self assert: parser parse: 'ababa' to: #($a $b $a $b $a).		self assert: parser parse: 'ab' to: #($a) end: 1.	self assert: parser parse: 'abab' to: #($a $b $a) end: 3.	self assert: parser parse: 'ac' to: #($a) end: 1.	self assert: parser parse: 'abac' to: #($a $b $a) end: 3.		self assert: parser fail: ''.	self assert: parser fail: 'c'</body><body package="PetitTests">testSeparatedByWithoutSeparators	| parser |	parser := ($a asParser separatedBy: $b asParser)		withoutSeparators.		self assert: parser parse: 'a' to: #($a).	self assert: parser parse: 'aba' to: #($a $a).	self assert: parser parse: 'ababa' to: #($a $a $a).		self assert: parser parse: 'ab' to: #($a) end: 1.	self assert: parser parse: 'abab' to: #($a $a) end: 3.	self assert: parser parse: 'ac' to: #($a) end: 1.	self assert: parser parse: 'abac' to: #($a $a) end: 3.		self assert: parser fail: ''.	self assert: parser fail: 'c'</body><body package="PetitTests">testSequence	| parser |	parser := $a asParser , $b asParser.		self assert: parser parse: 'ab' to: #($a $b).		self assert: parser parse: 'aba' to: #($a $b) end: 2.	self assert: parser parse: 'abb' to: #($a $b) end: 2.		self assert: parser fail: ''.	self assert: parser fail: 'a'.	self assert: parser fail: 'aa'.	self assert: parser fail: 'ba'.	self assert: parser fail: 'bab'</body><body package="PetitTests">testStar	| parser |	parser := $a asParser star.	self assert: parser min equals: 0.	self assert: parser max &gt; parser min.	self assert: parser parse: '' to: #().	self assert: parser parse: 'a' to: #($a).	self assert: parser parse: 'aa' to: #($a $a).	self assert: parser parse: 'aaa' to: #($a $a $a).	self		assert: parser		parse: 'b'		to: #()		end: 0.	self		assert: parser		parse: 'ab'		to: #($a)		end: 1.	self		assert: parser		parse: 'aab'		to: #($a $a)		end: 2.	self		assert: parser		parse: 'aaab'		to: #($a $a $a)		end: 3</body><body package="PetitTests">testStarGreedy	| limit parser |	limit := #digit asParser.	parser := #word asParser starGreedy: limit.	self assert: parser min equals: 0.	self assert: parser max &gt; parser min.	self assert: parser limit equals: limit.	self assert: parser children size equals: 2.	self assert: parser children last equals: limit.	self assert: parser fail: ''.	self assert: parser fail: 'a'.	self assert: parser fail: 'ab'.	self		assert: parser		parse: '1'		to: #()		end: 0.	self		assert: parser		parse: 'a1'		to: #($a)		end: 1.	self		assert: parser		parse: 'ab1'		to: #($a $b)		end: 2.	self		assert: parser		parse: 'abc1'		to: #($a $b $c)		end: 3.	self		assert: parser		parse: '12'		to: #($1)		end: 1.	self		assert: parser		parse: 'a12'		to: #($a $1)		end: 2.	self		assert: parser		parse: 'ab12'		to: #($a $b $1)		end: 3.	self		assert: parser		parse: 'abc12'		to: #($a $b $c $1)		end: 4.	self		assert: parser		parse: '123'		to: #($1 $2)		end: 2.	self		assert: parser		parse: 'a123'		to: #($a $1 $2)		end: 3.	self		assert: parser		parse: 'ab123'		to: #($a $b $1 $2)		end: 4.	self		assert: parser		parse: 'abc123'		to: #($a $b $c $1 $2)		end: 5</body><body package="PetitTests">testStarLazy	| limit parser |	limit := #digit asParser.	parser := #word asParser starLazy: limit.	self assert: parser min equals: 0.	self assert: parser max &gt; parser min.	self assert: parser limit equals: limit.	self assert: parser children size equals: 2.	self assert: parser children last equals: limit.	self assert: parser fail: ''.	self assert: parser fail: 'a'.	self assert: parser fail: 'ab'.	self		assert: parser		parse: '1'		to: #()		end: 0.	self		assert: parser		parse: 'a1'		to: #($a)		end: 1.	self		assert: parser		parse: 'ab1'		to: #($a $b)		end: 2.	self		assert: parser		parse: 'abc1'		to: #($a $b $c)		end: 3.	self		assert: parser		parse: '12'		to: #()		end: 0.	self		assert: parser		parse: 'a12'		to: #($a)		end: 1.	self		assert: parser		parse: 'ab12'		to: #($a $b)		end: 2.	self		assert: parser		parse: 'abc12'		to: #($a $b $c)		end: 3.	self		assert: parser		parse: '123'		to: #()		end: 0.	self		assert: parser		parse: 'a123'		to: #($a)		end: 1.	self		assert: parser		parse: 'ab123'		to: #($a $b)		end: 2.	self		assert: parser		parse: 'abc123'		to: #($a $b $c)		end: 3</body><body package="PetitTests">testTimes	| parser |	parser := $a asParser times: 2.		self assert: parser fail: ''.	self assert: parser fail: 'a'.	self assert: parser parse: 'aa' to: #($a $a).	self assert: parser parse: 'aaa' to: #($a $a) end: 2</body><body package="PetitTests">testUnresolved	| parser |	parser := PPUnresolvedParser new.		self assert: parser isUnresolved.	self should: [ parser parse: '' ] raise: Error.	self should: [ parser parse: 'a' ] raise: Error.	self should: [ parser parse: 'ab' ] raise: Error.		parser := nil asParser.	self deny: parser isUnresolved</body><body package="PetitTests">testWrapped	| parser |	parser := $a asParser wrapped.		self assert: parser parse: 'a' to: $a.	self assert: parser fail: 'b'.		parser := (($a asParser , $b asParser ) wrapped , $c asParser).	self assert: parser parse: 'abc' to: #(#($a $b) $c)</body><body package="PetitTests">testXor	| parser |	parser := ($a asParser / $b asParser)			|  ($b asParser / $c asParser).		self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'c' to: $c.		self assert: parser fail: ''.	self assert: parser fail: 'b'.	self assert: parser fail: 'd'.		" truly symmetric "	parser := ($b asParser / $c asParser)			|  ($a asParser / $b asParser).		self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'c' to: $c.		self assert: parser fail: ''.	self assert: parser fail: 'b'.	self assert: parser fail: 'd'</body></methods><methods><class-id>PetitTests.PPParserTest</class-id> <category>testing-utilities</category><body package="PetitTests">testChildren	| p1 p2 p3 |	p1 := #lowercase asParser.	p2 := p1 ==&gt; #asUppercase.	p3 := PPUnresolvedParser new.	p3 def: p2 / p3.	self assert: p1 children isEmpty.	self assert: p2 children size equals: 1.	self assert: p3 children size equals: 2</body><body package="PetitTests">testFailure	| failure |	failure := PPFailure message: 'Error' context: PPContext new at: 3.	self assert: failure message equals: 'Error'.	self assert: failure position equals: 3.	self assert: failure isPetitFailure.	self deny: 4 isPetitFailure.	self deny: 'foo' isPetitFailure</body><body package="PetitTests">testListConstructor	| p1 p2 p3 |	p1 := PPChoiceParser with: $a asParser.	p2 := PPChoiceParser with: $a asParser with: $b asParser.	p3 := PPChoiceParser withAll: (Array with: $a asParser with: $b asParser with: $c asParser).	self assert: p1 children size equals: 1.	self assert: p2 children size equals: 2.	self assert: p3 children size equals: 3</body><body package="PetitTests">testMatches	| parser |	parser := $a asParser.		self assert: (parser matches: 'a').	self deny: (parser matches: 'b').		self assert: (parser matches: 'a' readStream).	self deny: (parser matches: 'b' readStream)</body><body package="PetitTests">testMatchesIn	| parser result |	parser := $a asParser.	result := parser matchesIn: 'abba'.	self assert: result size equals: 2.	self assert: result first equals: $a.	self assert: result last equals: $a.	result := parser matchesIn: 'baaah'.	self assert: result size equals: 3.	self assert: result first equals: $a.	self assert: result last equals: $a</body><body package="PetitTests">testMatchesInEmpty	"Empty matches should properly advance and match at each position and at the end."	| parser result |	parser := [ :stream | stream position ] asParser.	result := parser matchesIn: '123'.	self assert: result asArray equals: #(0 1 2 3)</body><body package="PetitTests">testMatchesInOverlapping	"Matches that overlap should be properly reported."	| parser result |	parser := #digit asParser , #digit asParser.	result := parser matchesIn: 'a123b'.	self assert: result size equals: 2.	self assert: result first equals: #($1 $2).	self assert: result last equals: #($2 $3)</body><body package="PetitTests">testMatchesSkipIn	| parser result |	parser := $a asParser.	result := parser matchesSkipIn: 'abba'.	self assert: result size equals: 2.	self assert: result first equals: $a.	self assert: result last equals: $a.	result := parser matchesSkipIn: 'baaah'.	self assert: result size equals: 3.	self assert: result first equals: $a.	self assert: result last equals: $a</body><body package="PetitTests">testMatchesSkipInOverlapping	"Matches that overlap should be properly reported."	| parser result |	parser := #digit asParser , #digit asParser.	result := parser matchesSkipIn: 'a123b'.	self assert: result size equals: 1.	self assert: result first equals: #($1 $2)</body><body package="PetitTests">testMatchingRangesIn	| input parser result |	input := 'a12b3'.	parser := #digit asParser plus.	result := parser matchingRangesIn: input.	result := result collect: [ :each | input copyFrom: each first to: each last ].	self assert: result size equals: 3.	self assert: result first equals: '12'.	self assert: result second equals: '2'.	self assert: result last equals: '3'</body><body package="PetitTests">testMatchingSkipRangesIn	| input parser result |	input := 'a12b3'.	parser := #digit asParser plus.	result := parser matchingSkipRangesIn: input.	result := result collect: [ :each | input copyFrom: each first to: each last ].	self assert: result size equals: 2.	self assert: result first equals: '12'.	self assert: result last equals: '3'</body><body package="PetitTests">testParse	| parser result |	parser := $a asParser.	self assert: (parser parse: 'a') equals: $a.	self assert: (result := parser parse: 'b') isPetitFailure.	self assert: result message includesSubstring: $a printString.	self assert: result message includesSubstring: 'expected'.	self assert: result position equals: 0.	self assert: (parser parse: 'a' readStream) equals: $a.	self assert: (result := parser parse: 'b' readStream) isPetitFailure.	self assert: result message includesSubstring: $a printString.	self assert: result message includesSubstring: 'expected'.	self assert: result position equals: 0</body><body package="PetitTests">testParseOnError0	| parser result seen |	parser := $a asParser.	result := parser parse: 'a' onError: [ self signalFailure: 'Not supposed to report an error' ].	self assert: result equals: $a.	result := parser parse: 'b' onError: [ seen := true ].	self assert: result.	self assert: seen</body><body package="PetitTests">testParseOnError1	| parser result seen |	parser := $a asParser.	result := parser parse: 'a' onError: [ self signalFailure: 'Not supposed to report an error' ].	self assert: result equals: $a.	result := parser		parse: 'b'		onError: [ :failure | 			self assert: failure position equals: 0.			self assert: failure message includesSubstring: $a printString.			self assert: failure message includesSubstring: 'expected'.			seen := true ].	self assert: result.	self assert: seen</body><body package="PetitTests">testParseOnError2	| parser result seen |	parser := $a asParser.	result := parser parse: 'a' onError: [ self signalFailure: 'Not supposed to report an error' ].	self assert: result equals: $a.	result := parser		parse: 'b'		onError: [ :msg :pos | 			self assert: msg includesSubstring: $a printString.			self assert: msg includesSubstring: 'expected'.			self assert: pos equals: 0.			seen := true ].	self assert: result.	self assert: seen</body><body package="PetitTests">testParser	| parser |	parser := PPParser new.		self assert: parser isPetitParser.	self deny: 4 isPetitParser.	self deny: 'foo' isPetitParser</body></methods><methods><class-id>PetitTests.PPParserTest</class-id> <category>testing-properties</category><body package="PetitTests">testHasProperty	| parser |	parser := PPParser new.	self deny: (parser hasProperty: #foo).	parser propertyAt: #foo put: 123.	self assert: (parser hasProperty: #foo)</body><body package="PetitTests">testPostCopy	| parser copy |	parser := PPParser new.	parser propertyAt: #foo put: true.	copy := parser copy.	copy propertyAt: #foo put: false.	self assert: (parser propertyAt: #foo).	self deny: (copy propertyAt: #foo)</body><body package="PetitTests">testPropertyAt	| parser |	parser := PPParser new.	self should: [ parser propertyAt: #foo ] raise: Error.	parser propertyAt: #foo put: true.	self assert: (parser propertyAt: #foo)</body><body package="PetitTests">testPropertyAtIfAbsent	| parser |	parser := PPParser new.	self assert: (parser propertyAt: #foo ifAbsent: [ true ]).	parser propertyAt: #foo put: true.	self assert: (parser propertyAt: #foo ifAbsent: [ false ])</body><body package="PetitTests">testPropertyAtIfAbsentPut	| parser |	parser := PPParser new.	self assert: (parser propertyAt: #foo ifAbsentPut: [ true ]).	self assert: (parser propertyAt: #foo ifAbsentPut: [ false ])</body><body package="PetitTests">testRemoveProperty	| parser |	parser := PPParser new.	self should: [ parser removeProperty: #foo ] raise: Error.	parser propertyAt: #foo put: true.	self assert: (parser removeProperty: #foo)</body><body package="PetitTests">testRemovePropertyIfAbsent	| parser |	parser := PPParser new.	self assert: (parser removeProperty: #foo ifAbsent: [ true ]).	parser propertyAt: #foo put: true.	self assert: (parser removeProperty: #foo ifAbsent: [ false ])</body></methods><methods><class-id>PetitTests.PPParserTest</class-id> <category>testing-accessing</category><body package="PetitTests">testNamed	| parser |	parser := PPSequenceParser new.	self assert: parser name isNil.	parser := PPChoiceParser named: 'choice'.	self assert: parser name equals: 'choice'.	parser := $* asParser name: 'star'.	self assert: parser name equals: 'star'</body><body package="PetitTests">testPrint	| parser |	parser := PPParser new.	self assert: parser printString includesSubstring: 'PPParser'.		parser := PPParser named: 'choice'.	self assert: parser printString includesSubstring: 'PPParser(choice'.		parser := PPLiteralObjectParser on: $a.	self assert: parser printString includesSubstring: $a printString.		parser := PPFailingParser message: 'error'.	self assert: parser printString includesSubstring: 'error'.		parser := PPPredicateObjectParser on: [ :c | true ] message: 'error'.	self assert: parser printString includesSubstring: 'error'</body></methods><methods><class-id>PetitTests.PPParserTest</class-id> <category>testing-fixtures</category><body package="PetitTests">testSideEffectChoice	"Adding another element to a choice should create a copy, otherwise we get unwanted side-effects."	| p1 p2 p3 |	p1 := $a asParser.	p2 := p1 / $b asParser.	p3 := p1 / $c asParser.		self assert: p1 parse: 'a'.	self assert: p1 fail: 'b'.	self assert: p1 fail: 'c'.		self assert: p2 parse: 'a'.	self assert: p2 parse: 'b'.	self assert: p2 fail: 'c'.		self assert: p3 parse: 'a'.	self assert: p3 fail: 'b'.	self assert: p3 parse: 'c'</body><body package="PetitTests">testSideEffectListCopy	| old new |	old := $a asParser , $b asParser.	new := old copy.		self deny: old == new.	self deny: old children == new children.	self assert: old children first == new children first.	self assert: old children last == new children last</body><body package="PetitTests">testSideEffectSequence	"Adding another element to a sequence should create a copy, otherwise we get unwanted side-effects."	| p1 p2 p3 |	p1 := $a asParser.	p2 := p1 , $b asParser.	p3 := p1 , $c asParser.		self assert: p1 parse: 'a'.		self assert: p1 parse: 'ab' end: 1.	self assert: p1 parse: 'ac' end: 1.		self assert: p2 fail: 'a'.		self assert: p2 parse: 'ab'.	self assert: p2 fail: 'ac'.	self assert: p3 fail: 'a'.		self assert: p3 fail: 'ab'.	self assert: p3 parse: 'ac'</body></methods><methods><class-id>PetitTests.PPExtensionTest</class-id> <category>testing-parser</category><body package="PetitTests">testCharacter	| parser |	parser := $a asParser.	self assert: parser parse: 'a' to: $a.	self assert: parser fail: 'b'</body><body package="PetitTests">testChoice	| parser |	parser := #(1 2) asChoiceParser.	self assert: parser parse: #(1) to: 1.	self assert: parser parse: #(2) to: 2.	self assert: parser parse: #(1 2) to: 1 end: 1.	self assert: parser parse: #(2 1) to: 2 end: 1.	self assert: parser fail: #().	self assert: parser fail: #(3)</body><body package="PetitTests">testClosure	| parser |	parser := [ :stream | stream upTo: $s ] asParser.	self assert: parser parse: '' to: ''.	self assert: parser parse: 'a' to: 'a'.	self assert: parser parse: 'aa' to: 'aa'.	self assert: parser parse: 's' to: ''.	self assert: parser parse: 'as' to: 'a'.	self assert: parser parse: 'aas' to: 'aa'.	self assert: parser parse: 'sa' to: '' end: 1.	self assert: parser parse: 'saa' to: '' end: 1.		parser := [ :stream | stream upTo: $s. PPFailure message: 'stream' context: stream ] asParser.	self assert: parser fail: ''.	self assert: parser fail: 's'.	self assert: parser fail: 'as'	</body><body package="PetitTests">testEpsilon	| parser |	parser := nil asParser.	self assert: parser asParser equals: parser</body><body package="PetitTests">testParser	| parser |	parser := $a asParser.	self assert: parser asParser equals: parser</body><body package="PetitTests">testRange	| parser |	parser := ($a to: $c) asParser.	self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'b' to: $b.	self assert: parser parse: 'c' to: $c.	self assert: parser fail: 'd'</body><body package="PetitTests">testSequence	| parser |	parser := #(1 2) asSequenceParser.	self assert: parser parse: #(1 2) to: #(1 2).	self assert: parser parse: #(1 2 3) to: #(1 2) end: 2.	self assert: parser fail: #().	self assert: parser fail: #(1).	self assert: parser fail: #(1 1).	self assert: parser fail: #(1 1 2)</body><body package="PetitTests">testString	| parser |	parser := 'ab' asParser.	self assert: parser parse: 'ab' to: 'ab'.	self assert: parser parse: 'aba' to: 'ab' end: 2.	self assert: parser parse: 'abb' to: 'ab' end: 2.	self assert: parser fail: 'a'.	self assert: parser fail: 'ac'</body><body package="PetitTests">testSymbol	| parser |	parser := #any asParser.	self assert: parser parse: 'a'.	self assert: parser fail: ''</body></methods><methods><class-id>PetitTests.PPExtensionTest</class-id> <category>testing-stream</category><body package="PetitTests">testStream	| dot stream |	dot := (Character codePoint: 183) asString.	stream := 'abc' readStream asPetitStream.	self assert: stream class equals: PPStream.	self assert: stream printString equals: dot , 'abc'.	self assert: stream peek equals: $a.	self assert: stream uncheckedPeek equals: $a.	self assert: stream next equals: $a.	self assert: stream printString equals: 'a' , dot , 'bc'.	self assert: stream asPetitStream equals: stream</body><body package="PetitTests">testText	| stream |	stream := 'abc' asText asPetitStream.	self assert: stream class equals: PPStream</body></methods><methods><class-id>PetitTests.PPPredicateTest</class-id> <category>testing-chars</category><body package="PetitTests">testBlank	| parser |	parser := #blank asParser.	self assertCharacterSets: parser.	self assert: parser parse: (String with: Character space) to: Character space.	self assert: parser parse: (String with: Character tab) to: Character tab.	self assert: parser fail: ''.	self assert: parser fail: '1'.	self assert: parser fail: (String with: Character cr)</body><body package="PetitTests">testChar	| parser |	parser := $* asParser.	self assertCharacterSets: parser.	self assert: parser parse: '*' to: $*.	self assert: parser parse: '**' to: $* end: 1.	self assert: parser fail: ''.	self assert: parser fail: '1'.	self assert: parser fail: 'a'</body><body package="PetitTests">testCr	| parser |	parser := #cr asParser.	self assertCharacterSets: parser.	self assert: parser parse: (String with: (Character codePoint: 13)) to: (Character codePoint: 13)</body><body package="PetitTests">testDigit	| parser |	parser := #digit asParser.	self assertCharacterSets: parser.	self assert: parser parse: '0' to: $0.	self assert: parser parse: '9' to: $9.	self assert: parser fail: ''.	self assert: parser fail: 'a'</body><body package="PetitTests">testEndOfFile	| parser |	parser := (#letter asParser / #blank asParser) star, #eof asParser.		self assert: parser parse: 'lorem ipsum'.		parser := #any asParser, #eof asParser, #any asParser star.	self assert: parser fail: 'a', Character cr asString, 'b'.	self assert: parser fail: Character cr asString , Character lf asString.	self assert: parser parse: 'a'.</body><body package="PetitTests">testEndOfLine	| cr crlf lf parser |	cr := Character cr asString.	crlf := Character cr asString , Character lf asString.	lf := Character lf asString.	parser := (#letter asParser / #blank asParser) star, #endOfLine asParser.		self assert: parser parse: 'lorem ipsum'.		parser := #any asParser, #endOfLine asParser, #any asParser star.	self assert: parser parse: 'a', cr, 'b'.	self assert: parser fail: crlf.	self assert: parser fail: 'lorem ipsum'.		parser := #endOfLine asParser, #any asParser, #endOfLine asParser negate star, #endOfLine asParser.	self assert: parser parse: cr, 'lorem ipsum'.	self assert: parser parse: lf, 'lorem ipsum'.		self assert: parser parse: crlf, 'lorem ipsum'.			self assert: parser parse: crlf.	self assert: parser parse: cr.	self assert: parser parse: lf.		parser := #endOfLine asParser negate star, #endOfLine asParser, #any asParser star.	self assert: parser parse: crlf, 'lorem ipsum'.	self assert: parser parse: crlf.</body><body package="PetitTests">testHex	| parser |	parser := #hex asParser.	self assertCharacterSets: parser.	self assert: parser parse: '0' to: $0.	self assert: parser parse: '5' to: $5.	self assert: parser parse: '9' to: $9.	self assert: parser parse: 'A' to: $A.	self assert: parser parse: 'D' to: $D.	self assert: parser parse: 'F' to: $F.	self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'e' to: $e.	self assert: parser parse: 'f' to: $f.	self assert: parser fail: ''.	self assert: parser fail: 'g'</body><body package="PetitTests">testLetter	| parser |	parser := #letter asParser.	self assertCharacterSets: parser.	self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'Z' to: $Z.	self assert: parser fail: ''.	self assert: parser fail: '0'</body><body package="PetitTests">testLf	| parser |	parser := #lf asParser.	self assertCharacterSets: parser.	self assert: parser parse: (String with: Character lf) to: Character lf</body><body package="PetitTests">testLowercase	| parser |	parser := #lowercase asParser.	self assertCharacterSets: parser.	self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'z' to: $z.	self assert: parser fail: ''.	self assert: parser fail: 'A'.	self assert: parser fail: '0'</body><body package="PetitTests">testNewline	| parser |	parser := #newline asParser.	self assertCharacterSets: parser.	self assert: parser parse: (String with: Character cr) to: Character cr.	self assert: parser parse: (String with: Character lf) to: Character lf.	self assert: parser fail: ' '</body><body package="PetitTests">testPunctuation	| parser |	parser := #punctuation asParser.	self assertCharacterSets: parser.	self assert: parser parse: '.' to: $..	self assert: parser parse: ',' to: $,.	self assert: parser fail: ''.	self assert: parser fail: 'a'.	self assert: parser fail: '1'</body><body package="PetitTests">testSpace	| parser |	parser := #space asParser.	self assertCharacterSets: parser.	self assert: parser parse: (String with: Character tab) to: Character tab.	self assert: parser parse: ' ' to: Character space.	self assert: parser fail: ''.	self assert: parser fail: 'a'</body><body package="PetitTests">testStartOfLine	| cr crlf lf parser |	cr := Character cr asString.	crlf := Character cr asString , Character lf asString.	lf := Character lf asString.	parser := #startOfLine asParser, #any asParser star.		self assert: parser parse: 'lorem ipsum'.		parser := #any asParser, #startOfLine asParser, #any asParser star.	self assert: parser fail: 'lorem ipsum'.		parser := #startOfLine asParser, #any asParser, #startOfLine asParser, #any asParser star.	self assert: parser parse: cr, 'lorem ipsum'.	self assert: parser parse: lf, 'lorem ipsum'.		self assert: parser fail: crlf, 'lorem ipsum'.			self assert: parser fail: crlf.	self assert: parser parse: cr.	self assert: parser parse: lf.		parser := #startOfLine asParser, #any asParser, #any asParser, #startOfLine asParser, #any asParser star.	self assert: parser parse: crlf, 'lorem ipsum'.	self assert: parser parse: crlf.</body><body package="PetitTests">testStartOfLogicalLine	| parser |	parser := #startOfLogicalLine asParser, #any asParser star.		self assert: parser parse: 'lorem'.	self assert: parser fail: ' lorem'.		parser := #any asParser, #startOfLogicalLine asParser, #any asParser star.	self assert: parser fail: 'lorem'.	self assert: parser fail: '        lorem'.	self assert: parser parse: ' lorem'.	self assert: parser parse: '	lorem'.</body><body package="PetitTests">testStartOfWord	| parser |	parser := #startOfWord asParser, #word asParser plus.		self assert: parser parse: 'lorem'.		parser := #any asParser, #startOfWord asParser, #word asParser plus.	self assert: parser fail: 'lorem'.	self assert: parser fail: '1234'.		self assert: parser parse: ' lorem'.		self assert: parser parse: ' 123'.	self assert: parser parse: ')lorem'.	self assert: parser parse: ':lorem'.		parser := #startOfWord asParser, #any asParser optional.	self assert: parser fail: ''.	self assert: parser parse: 'a'.	self assert: parser fail: '.'.</body><body package="PetitTests">testTab	| parser |	parser := #tab asParser.	self assertCharacterSets: parser.	self assert: parser parse: (String with: Character tab) to: Character tab</body><body package="PetitTests">testUppercase	| parser |	parser := #uppercase asParser.	self assertCharacterSets: parser.	self assert: parser parse: 'A' to: $A.	self assert: parser parse: 'Z' to: $Z.	self assert: parser fail: ''.	self assert: parser fail: 'a'.	self assert: parser fail: '0'</body><body package="PetitTests">testWord	| parser |	parser := #word asParser.	self assertCharacterSets: parser.	self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'A' to: $A.	self assert: parser parse: '0' to: $0.	self assert: parser fail: ''.	self assert: parser fail: '-'</body></methods><methods><class-id>PetitTests.PPPredicateTest</class-id> <category>testing-objects</category><body package="PetitTests">testAny	| parser |	parser := #any asParser.	self assertCharacterSets: parser.	self assert: parser parse: ' ' to: $ .	self assert: parser parse: '1' to: $1.	self assert: parser parse: 'a' to: $a.	self assert: parser fail: ''</body><body package="PetitTests">testAnyExceptAnyOf	| parser |	parser := PPPredicateObjectParser anyExceptAnyOf: #($: $,).	self assertCharacterSets: parser.	self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'z' to: $z.	self assert: parser fail: ':'.	self assert: parser fail: ','</body><body package="PetitTests">testAnyOf	| parser |	parser := PPPredicateObjectParser anyOf: #($a $z).	self assertCharacterSets: parser.	self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'z' to: $z.	self assert: parser fail: 'x'</body><body package="PetitTests">testBetweenAnd	| parser |	parser := PPPredicateObjectParser between: $b and: $d.	self assertCharacterSets: parser.	self assert: parser fail: 'a'.	self assert: parser parse: 'b' to: $b.	self assert: parser parse: 'c' to: $c.	self assert: parser parse: 'd' to: $d.	self assert: parser fail: 'e'</body><body package="PetitTests">testExpect	| parser |	parser := PPPredicateObjectParser expect: $a.	self assertCharacterSets: parser.	self assert: parser parse: 'a' to: $a.	self assert: parser fail: 'b'.	self assert: parser fail: ''</body></methods><methods><class-id>PetitTests.PPPredicateTest</class-id> <category>private</category><body package="PetitTests">charactersDo: aBlock	1 to: 256 do: [ :index | aBlock value: (Character codePoint: index) ]</body></methods><methods><class-id>PetitTests.PPPredicateTest</class-id> <category>testing-sequence</category><body package="PetitTests">testSequenceParser	| parser |	parser := PPPredicateSequenceParser		on: [ :value | value first isUppercase ]		message: 'uppercase 3 letter words'		size: 3.	self assert: parser size equals: 3.	self assert: parser parse: 'Abc'.	self assert: parser parse: 'ABc'.	self assert: parser parse: 'ABC'.	self assert: parser fail: 'abc'.	self assert: parser fail: 'aBC'.	self assert: parser fail: 'Ab'.	parser := parser negate.	self assert: parser size equals: 3.	self assert: parser fail: 'Abc'.	self assert: parser fail: 'ABc'.	self assert: parser fail: 'ABC'.	self assert: parser parse: 'abc'.	self assert: parser parse: 'aBC'.	self assert: parser fail: 'Ab'</body></methods><methods><class-id>PetitTests.PPPredicateTest</class-id> <category>testing</category><body package="PetitTests">testOnMessage	| block parser |	block := [ :char | char = $* ].	parser := PPPredicateObjectParser on: block message: 'starlet'.	self assert: parser block equals: block.	self assert: parser message equals: 'starlet'.	self assertCharacterSets: parser.	self assert: parser parse: '*' to: $*.	self		assert: parser		parse: '**'		to: $*		end: 1.	self assert: parser fail: ''.	self assert: parser fail: '1'.	self assert: parser fail: 'a'</body></methods><methods><class-id>PetitTests.PPPredicateTest</class-id> <category>utilities</category><body package="PetitTests">assertCharacterSets: aParser	"Assert the character set of aParser does not overlap with the character set with the negated parser, and that they both cover the complete character space."	| positives negatives |	positives := self parsedCharacterSet: aParser.	negatives := self parsedCharacterSet: aParser negate.	self charactersDo: [ :char | 		| positive negative |		positive := positives includes: char.		negative := negatives includes: char.		self 			assert: ((positive and: [ negative not ])				or: [ positive not and: [ negative ] ])			description: char printString , ' should be in exactly one set' ]</body><body package="PetitTests">parsedCharacterSet: aParser	| result |	result := WriteStream on: String new.	self charactersDo: [ :char |		(aParser matches: (char asString))			ifTrue: [ result nextPut: char ] ].	^ result contents</body></methods><methods><class-id>PetitTests.PPCompositeParserTest</class-id> <category>parsing</category><body package="PetitTests">debug: aString 	^ self debug: aString rule: #start</body><body package="PetitTests">debug: aString rule: aSymbol	| production context |	production := self parserInstanceFor: aSymbol.	context := self context.		debugResult := production end enableDebug parse: aString withContext: context.	result := debugResult children first result.		self		deny: result isPetitFailure		description: 'Unable to parse ' , aString printString.			^ debugResult</body><body package="PetitTests">fail: aString rule: aSymbol 	| production context |	production := self parserInstanceFor: aSymbol.	context := self context.		result := production end parse: aString withContext: context.		self		assert: result isPetitFailure		description: 'Able to parse ' , aString printString.	^ result</body><body package="PetitTests">parse: aString 	^ self parse: aString rule: #start</body><body package="PetitTests">parse: aString rule: aSymbol	| production context |	production := self parserInstanceFor: aSymbol.	context := self context.		result := production end parse: aString withContext: context.	self		deny: result isPetitFailure		description: 'Unable to parse ' , aString printString.	^ result</body><body package="PetitTests">parse: aString rule: aSymbol to: expectedResult end: end	| production context |	production := self parserInstanceFor: aSymbol.	context := self context.		result := production parse: aString withContext: context.	self		deny: result isPetitFailure		description: 'Unable to parse ' , aString printString.		self assert: expectedResult = result.	self assert: context position = end.	^ result</body></methods><methods><class-id>PetitTests.PPCompositeParserTest</class-id> <category>accessing</category><body package="PetitTests">parserClass	self subclassResponsibility</body><body package="PetitTests">parserInstance	^ PPParserResource current parserAt: self parserClass</body><body package="PetitTests">parserInstanceFor: aSymbol	^ aSymbol = #start		ifTrue: [ self parserInstance ]		ifFalse: [			self parserInstance				productionAt: aSymbol 				ifAbsent: [ self error: 'Production ' , self parserClass name , '&gt;&gt;' , aSymbol printString , ' not found.' ] ]</body></methods><methods><class-id>PetitTests.PPCompositeParserTest</class-id> <category>utilities</category><body package="PetitTests">assert: aCollection is: anObject	self parse: aCollection.	self		assert: result = anObject		description: 'Got: ' , result printString , '; Expected: ' , anObject printString		resumable: true</body></methods><methods><class-id>PetitTests.PPCompositeParserTest</class-id> <category>running</category><body package="PetitTests">setUp	super setUp.	parser := self parserInstance</body><body package="PetitTests">tearDown	super tearDown.	parser := result := nil</body></methods><methods><class-id>PetitTests.PPCompositeParserTest class</class-id> <category>testing</category><body package="PetitTests">isAbstract	^ self name = #PPCompositeParserTest</body></methods><methods><class-id>PetitTests.PPCompositeParserTest class</class-id> <category>accessing</category><body package="PetitTests">resources	^ Array with: PPParserResource</body></methods><methods><class-id>PetitTests.PPArithmeticParserTest</class-id> <category>accessing</category><body package="PetitTests">parserClass	^ PPArithmeticParser</body></methods><methods><class-id>PetitTests.PPArithmeticParserTest</class-id> <category>testing-operations</category><body package="PetitTests">testAdd	self assert: '1 + 2' is: 3.	self assert: '2 + 1' is: 3.	self assert: '1 + 2.3' is: 3.3.	self assert: '2.3 + 1' is: 3.3.	self assert: '1 + -2' is: -1.	self assert: '-2 + 1' is: -1</body><body package="PetitTests">testAddMany	self assert: '1' is: 1.	self assert: '1 + 2' is: 3.	self assert: '1 + 2 + 3' is: 6.	self assert: '1 + 2 + 3 + 4' is: 10.	self assert: '1 + 2 + 3 + 4 + 5' is: 15</body><body package="PetitTests">testDiv	self assert: '12 / 3' is: 4.	self assert: '-16 / -4' is: 4</body><body package="PetitTests">testDivMany	self assert: '100 / 2' is: 50.	self assert: '100 / 2 / 2' is: 25.	self assert: '100 / 2 / 2 / 5' is: 5.	self assert: '100 / 2 / 2 / 5 / 5' is: 1	</body><body package="PetitTests">testMul	self assert: '2 * 3' is: 6.	self assert: '2 * -4' is: -8</body><body package="PetitTests">testMulMany	self assert: '1 * 2' is: 2.	self assert: '1 * 2 * 3' is: 6.	self assert: '1 * 2 * 3 * 4' is: 24.	self assert: '1 * 2 * 3 * 4 * 5' is: 120</body><body package="PetitTests">testPow	self assert: '2 ^ 3' is: 8.	self assert: '-2 ^ 3' is: -8.	self assert: '-2 ^ -3' is: -0.125</body><body package="PetitTests">testPowMany	self assert: '4 ^ 3' is: 64.	self assert: '4 ^ 3 ^ 2' is: 262144.	self assert: '4 ^ 3 ^ 2 ^ 1' is: 262144.	self assert: '4 ^ 3 ^ 2 ^ 1 ^ 0' is: 262144</body><body package="PetitTests">testSub	self assert: '1 - 2' is: -1.	self assert: '1.2 - 1.2' is: 0.	self assert: '1 - -2' is: 3.	self assert: '-1 - -2' is: 1</body><body package="PetitTests">testSubMany	self assert: '1' is: 1.	self assert: '1 - 2' is: -1.	self assert: '1 - 2 - 3' is: -4.	self assert: '1 - 2 - 3 - 4' is: -8.	self assert: '1 - 2 - 3 - 4 - 5' is: -13</body></methods><methods><class-id>PetitTests.PPArithmeticParserTest</class-id> <category>testing-expression</category><body package="PetitTests">testBrackets	self assert: '(1)' is: 1.	self assert: '(1 + 2)' is: 3.		self assert: '((1))' is: 1.	self assert: '((1 + 2))' is: 3.	self assert: '2 * (3 + 4)' is: 14.	self assert: '(2 + 3) * 4' is: 20.	self assert: '6 / (2 + 4)' is: 1.	self assert: '(2 + 6) / 2' is: 4</body><body package="PetitTests">testPriority	self assert: '2 * 3 + 4' is: 10.	self assert: '2 + 3 * 4' is: 14.	self assert: '6 / 3 + 4' is: 6.	self assert: '2 + 6 / 2' is: 5</body></methods><methods><class-id>PetitTests.PPArithmeticParserTest</class-id> <category>testing</category><body package="PetitTests">testNum	self assert: '0' is: 0.	self assert: '0.0' is: 0.0.	self assert: '1' is: 1.	self assert: '1.2' is: 1.2.	self assert: '34' is: 34.	self assert: '56.78' is: 56.78.	self assert: '-9' is: -9.	self assert: '-9.9' is: -9.9</body></methods><methods><class-id>PetitTests.PPExpressionParserTest</class-id> <category>accessing</category><body package="PetitTests">parserInstance	| expression parens number |	expression := PPExpressionParser new.	parens := $( asParser trim , expression , $) asParser trim		==&gt; [ :value | value second ].	number := (#digit asParser plus , ($. asParser , #digit asParser plus) optional) flatten trim		==&gt; [ :value | value asNumber ].	expression term: parens / number.	expression		group: [ :g |			g prefix: $- asParser trim do: [ :op :a | a negated ] ];		group: [ :g |			g postfix: '++' asParser trim do: [ :a :op | a + 1 ].			g postfix: '--' asParser trim do: [ :a :op | a - 1 ] ];		group: [ :g |			g right: $^ asParser trim do: [ :a :op :b | a raisedTo: b ] ];		group: [ :g |			g left: $* asParser trim do: [ :a :op :b | a * b ].			g left: $/ asParser trim do: [ :a :op :b | a / b ] ];		group: [ :g |			g left: $+ asParser trim do: [ :a :op :b | a + b ].			g left: $- asParser trim do: [ :a :op :b | a - b ] ].	^ expression end</body></methods><methods><class-id>PetitTests.PPExpressionParserTest</class-id> <category>testing</category><body package="PetitTests">testPostfixAdd	self assert: '0++' is: 1.	self assert: '0++++' is: 2.	self assert: '0++++++' is: 3.	self assert: '0+++1' is: 2.	self assert: '0+++++1' is: 3.	self assert: '0+++++++1' is: 4</body><body package="PetitTests">testPostfixSub	self assert: '1--' is: 0.	self assert: '2----' is: 0.	self assert: '3------' is: 0.	self assert: '2---1' is: 0.	self assert: '3-----1' is: 0.	self assert: '4-------1' is: 0.</body><body package="PetitTests">testPrefixNegate	self assert: '1' is: 1.	self assert: '-1' is: -1.	self assert: '--1' is: 1.	self assert: '---1' is: -1</body></methods><methods><class-id>PetitTests.PPExpressionParserTest class</class-id> <category>testing</category><body package="PetitTests">shouldInheritSelectors	^ true</body></methods><methods><class-id>PetitTests.PPConditionalParserTests</class-id> <category>as yet unclassified</category><body package="PetitTests">context	^ context</body><body package="PetitTests">setUp	super setUp.	context := PPContext new</body><body package="PetitTests">testConditionCtxAccess	| parser |	parser := ('a' asParser if: [ :ctx | (ctx propertyAt: #foo) = #bar ]).		context propertyAt: #foo put: #bar.	self assert: parser parse: 'a' .	context propertyAt: #foo put: #zorg.	self assert: parser fail: 'a' .</body><body package="PetitTests">testConditionFalse	| parser |	parser := ('a' asParser if: [ :ctx | false ]).		self assert: parser fail: 'a'.	self assert: parser fail: 'b'.</body><body package="PetitTests">testConditionTrue	| parser |	parser := ('a' asParser if: [ :ctx | true ]).		self assert: parser parse: 'a'.	self assert: parser fail: 'b'.</body></methods><methods><class-id>PetitTests.PPContextMementoTest</class-id> <category>tests</category><body package="PetitTests">testEquality	| m1 m2  |	m1 := self memento.	m2 := self memento.		self assert: m1 = m2.		m1 propertyAt: #foo put: #bar.	self assert: (m1 = m2) not.		m2 propertyAt: #foo put: #bar.	self assert: m1 = m2.</body><body package="PetitTests">testEquality2	| m1 m2  |	m1 := self memento.	m2 := self memento.		self assert: m1 = m2.		m1 propertyAt: #foo put: #bar.	self assert: (m1 = m2) not.		m2 propertyAt: #bar put: #foo.	self assert: (m1 = m2) not.</body><body package="PetitTests">testGetProperty		| c retval retval2 |	c := OrderedCollection new.		memento propertyAt: #foo put: c.		retval := memento propertyAt: #foo.	self assert: retval size = c size.	self assert: (retval == c) not.	self assert: retval = c.		c add: #element.	self assert: (retval = c) not.	retval2 := memento propertyAt: #foo.	self assert: (retval = retval2).	self assert: (retval == retval2) not.		retval add: #element.	self assert: (retval = retval2) not.</body><body package="PetitTests">testKeysAndValuesDo	|   |	memento keysAndValuesDo: [ :key :value |		self signalFailure: 'Should not be called'	].</body><body package="PetitTests">testKeysAndValuesDo2	| c1 c2   |	c1 := OrderedCollection new.	c2 := OrderedCollection new.	memento propertyAt: #foo put: c1.	memento propertyAt: #bar put: c2.	memento keysAndValuesDo: [ :key :value |		self assert: (value == c1) not.		self assert: (value == c2) not.	].</body><body package="PetitTests">testPutProperty	| c retval  |	c := OrderedCollection new.	self assert: (memento hasProperty: #foo) not.	self assert: (memento hasProperty: #bar) not.			self should: [ memento propertyAt: #foo ] raise: Error.	self assert: (memento propertyAt: #foo ifAbsent: [ c ]) == c.		retval := memento propertyAt: #foo ifAbsentPut: [ c ].	self assert: retval size = c size.		self assert: (retval == c) not.	self assert: retval = c.	self assert: (memento hasProperty: #foo).		retval := memento propertyAt: #bar put: c.	self assert: retval size = c size.		self assert: (retval == c) not.	self assert: retval = c.	self assert: (memento hasProperty: #foo).	</body></methods><methods><class-id>PetitTests.PPContextMementoTest</class-id> <category>accessing</category><body package="PetitTests">memento	^ PPContextMemento new</body></methods><methods><class-id>PetitTests.PPContextMementoTest</class-id> <category>running</category><body package="PetitTests">setUp	super setUp.	memento := self memento.</body></methods><methods><class-id>PetitTests.PPParserResource</class-id> <category>accessing</category><body package="PetitTests">parserAt: aParserClass	"Answer a cached instance of aParserClass."		^ parsers at: aParserClass name ifAbsentPut: [ aParserClass new ]</body></methods><methods><class-id>PetitTests.PPParserResource</class-id> <category>running</category><body package="PetitTests">setUp	super setUp.	parsers := Dictionary new</body></methods><methods><class-id>PetitTests.PPComposedTest</class-id> <category>testing-examples</category><body package="PetitTests">testComment	self assert: self comment parse: '""' to: '""'.	self assert: self comment parse: '"a"' to: '"a"'.	self assert: self comment parse: '"ab"' to: '"ab"'.	self assert: self comment parse: '"abc"' to: '"abc"'.	self assert: self comment parse: '""a' to: '""' end: 2.	self assert: self comment parse: '"a"a' to: '"a"' end: 3.	self assert: self comment parse: '"ab"a' to: '"ab"' end: 4.	self assert: self comment parse: '"abc"a' to: '"abc"' end: 5.	self assert: self comment fail: '"'.	self assert: self comment fail: '"a'.	self assert: self comment fail: '"aa'.	self assert: self comment fail: 'a"'.	self assert: self comment fail: 'aa"'</body><body package="PetitTests">testIdentifier	self assert: self identifier parse: 'a' to: 'a'.	self assert: self identifier parse: 'a1' to: 'a1'.	self assert: self identifier parse: 'a12' to: 'a12'.	self assert: self identifier parse: 'ab' to: 'ab'.	self assert: self identifier parse: 'a1b' to: 'a1b'.	self assert: self identifier parse: 'a_' to: 'a' end: 1.	self assert: self identifier parse: 'a1-' to: 'a1' end: 2.	self assert: self identifier parse: 'a12+' to: 'a12' end: 3.	self assert: self identifier parse: 'ab^' to: 'ab' end: 2.	self assert: self identifier parse: 'a1b*' to: 'a1b' end: 3.	self assert: self identifier fail: ''.	self assert: self identifier fail: '1'.	self assert: self identifier fail: '1a'</body><body package="PetitTests">testNumber	self assert: self number parse: '1' to: '1'.	self assert: self number parse: '12' to: '12'.	self assert: self number parse: '12.3' to: '12.3'.	self assert: self number parse: '12.34' to: '12.34'.	self assert: self number parse: '1..' to: '1' end: 1.	self assert: self number parse: '12-' to: '12' end: 2.	self assert: self number parse: '12.3.' to: '12.3' end: 4.	self assert: self number parse: '12.34.' to: '12.34' end: 5.		self assert: self number parse: '-1' to: '-1'.	self assert: self number parse: '-12' to: '-12'.	self assert: self number parse: '-12.3' to: '-12.3'.	self assert: self number parse: '-12.34' to: '-12.34'.		self assert: self number fail: ''.	self assert: self number fail: '-'.	self assert: self number fail: '.'.	self assert: self number fail: '.1'</body><body package="PetitTests">testReturn	| number spaces return |	number := #digit asParser plus flatten.	spaces := #space asParser star.	return := (spaces , $^ asParser token , spaces , number)		==&gt; [ :nodes | Array with: #return with: (nodes at: 4) ].	self assert: return parse: '^1' to: #(return '1').	self assert: return parse: '^12' to: #(return '12').	self assert: return parse: '^ 123' to: #(return '123').	self assert: return parse: '^  1234' to: #(return '1234').		self assert: return fail: '1'.	self assert: return fail: '^'</body></methods><methods><class-id>PetitTests.PPComposedTest</class-id> <category>testing</category><body package="PetitTests">testDoubledString	| parser |	parser := ($' asParser , (($' asParser , $' asParser) / $' asParser negate) star flatten , $' asParser) 		==&gt; [ :nodes | nodes second copyReplaceAll: '''''' with: '''' ].	self assert: parser parse: '''''' to: ''.	self assert: parser parse: '''a''' to: 'a'.	self assert: parser parse: '''ab''' to: 'ab'.	self assert: parser parse: '''a''''b''' to: 'a''b'.	self assert: parser parse: '''a''''''''b''' to: 'a''''b'</body><body package="PetitTests">testEvenNumber	"Create a grammar that parses an even number of a's and b's."		| a as b bs s |	a := $a asParser ==&gt; [ :char | as := as + 1 ].	b := $b asParser ==&gt; [ :char | bs := bs + 1 ].	s := (a / b) star &gt;=&gt; [ :stream :cc |		as := bs := 0.		cc value.		(as even and: [ bs even ])			ifFalse: [ PPFailure message: 'Even number of a and b expected' context: stream at: 0 ] ].	self assert: s fail: 'a' end: 1.	self assert: s fail: 'b' end: 1.	self assert: s fail: 'ab' end: 2.	self assert: s fail: 'ba' end: 2.	self assert: s fail: 'aaa' end: 3.	self assert: s fail: 'bbb' end: 3.	self assert: s fail: 'aab' end: 3.	self assert: s fail: 'abb' end: 3.		self assert: s parse: ''.	self assert: s parse: 'aa'.	self assert: s parse: 'bb'.	self assert: s parse: 'aaaa'.	self assert: s parse: 'aabb'.	self assert: s parse: 'abab'.	self assert: s parse: 'baba'.	self assert: s parse: 'bbaa'.	self assert: s parse: 'bbbb'</body><body package="PetitTests">testIfThenElse	"S ::= if C then S else S | if C then S | X"	| start if then else cond expr parser |	start := PPDelegateParser new.	if := 'if' asParser token trim.	then := 'then' asParser token trim.	else := 'else' asParser token trim.	cond := 'C' asParser token trim.	expr := 'X' asParser token trim.	start setParser: (if , cond , then , start , else , start) / (if , cond , then , start) / expr.	parser := start end.	self assert: parser parse: 'X'.	self assert: parser parse: 'if C then X'.	self assert: parser parse: 'if C then X else X'.	self assert: parser parse: 'if C then if C then X'.	self assert: parser parse: 'if C then if C then X else if C then X'.	self assert: parser parse: 'if C then if C then X else X else if C then X'.	self assert: parser parse: 'if C then if C then X else X else if C then X else X'.	self assert: parser fail: 'if C'.	self assert: parser fail: 'if C else X'.	self assert: parser fail: 'if C then if C'</body><body package="PetitTests">testLeftRecursion	"S ::= S 'x' S / '1'"		| parser |	parser := PPDelegateParser new.	parser setParser: ((parser , $x asParser , parser) / $1 asParser) memoized flatten.	self assert: parser parse: '1' to: '1'.	self assert: parser parse: '1x1' to: '1x1'.	self assert: parser parse: '1x1x1' to: '1x1x1'.	self assert: parser parse: '1x1x1x1' to: '1x1x1x1'.	self assert: parser parse: '1x1x1x1x1' to: '1x1x1x1x1'.	self assert: parser parse: '1x1x1x1x1x1' to: '1x1x1x1x1x1'</body><body package="PetitTests">testListOfIntegers	"S ::= S , number | number"		| number list parser |	number := #digit asParser plus flatten trim		==&gt; [ :node | node asInteger ].	list := (number separatedBy: $, asParser token trim)		==&gt; [ :node | node select: [ :each | each isKindOf: Integer ] ].	parser := list end.	self assert: parser parse: '1' to: (1 to: 1) asArray.	self assert: parser parse: '1,2' to: (1 to: 2) asArray.	self assert: parser parse: '1,2,3' to: (1 to: 3) asArray.	self assert: parser parse: '1,2,3,4' to: (1 to: 4) asArray.	self assert: parser parse: '1,2,3,4,5' to: (1 to: 5) asArray.	self assert: parser parse: '1' to: (1 to: 1) asArray.	self assert: parser parse: '1, 2' to: (1 to: 2) asArray.	self assert: parser parse: '1, 2, 3' to: (1 to: 3) asArray.	self assert: parser parse: '1, 2, 3, 4' to: (1 to: 4) asArray.	self assert: parser parse: '1, 2, 3, 4, 5' to: (1 to: 5) asArray.	self assert: parser parse: '1' to: (1 to: 1) asArray.	self assert: parser parse: '1 ,2' to: (1 to: 2) asArray.	self assert: parser parse: '1 ,2 ,3' to: (1 to: 3) asArray.	self assert: parser parse: '1 ,2 ,3 ,4' to: (1 to: 4) asArray.	self assert: parser parse: '1 ,2 ,3 ,4 ,5' to: (1 to: 5) asArray.		self assert: parser fail: ''.	self assert: parser fail: ','.	self assert: parser fail: '1,'.	self assert: parser fail: '1,,2'</body><body package="PetitTests">testNestedComments	"C ::= B I* E"	"I ::= !E (C | T)"	"B ::= /*"	"E ::= */"	"T ::= ."		| begin end any inside parser |	begin := '/*' asParser.	end := '*/' asParser.	any := #any asParser.		parser := PPDelegateParser new.	inside := end not , (parser / any).	parser setParser: begin , inside star , end.		self assert: parser parse: '/*ab*/cd' end: 6.	self assert: parser parse: '/*a/*b*/c*/'.	self assert: parser fail: '/*a/*b*/c'</body><body package="PetitTests">testPalindrome	"S0 ::= a S1 a | b S1 b | ...	 S1 ::= S0 | epsilon"		| s0 s1 parser |	s0 := PPDelegateParser new.	s1 := PPDelegateParser new.	s0 setParser: ($a asParser , s1 , $a asParser)		/ ($b asParser , s1 , $b asParser)		/ ($c asParser , s1 , $c asParser).		s1 setParser: s0 / nil asParser.	parser := s0 flatten end.	self assert: parser parse: 'aa' to: 'aa'.	self assert: parser parse: 'bb' to: 'bb'.	self assert: parser parse: 'cc' to: 'cc'.		self assert: parser parse: 'abba' to: 'abba'.	self assert: parser parse: 'baab' to: 'baab'.	self assert: parser parse: 'abccba' to: 'abccba'.	self assert: parser parse: 'abaaba' to: 'abaaba'.	self assert: parser parse: 'cbaabc' to: 'cbaabc'.	self assert: parser fail: 'a'.	self assert: parser fail: 'ab'.	self assert: parser fail: 'aab'.	self assert: parser fail: 'abccbb'</body><body package="PetitTests">testParseAaaBbb	"S0 ::= a S1 b	 S1 ::= S0 | epsilon"		| s0 s1 parser |	s0 := PPDelegateParser new.	s1 := PPDelegateParser new.	s0 setParser: $a asParser , s1 , $b asParser.	s1 setParser: s0 / nil asParser.	parser := s0 flatten.	self assert: parser parse: 'ab' to: 'ab'.	self assert: parser parse: 'aabb' to: 'aabb'.	self assert: parser parse: 'aaabbb' to: 'aaabbb'.	self assert: parser parse: 'aaaabbbb' to: 'aaaabbbb'.	self assert: parser parse: 'abb' to: 'ab' end: 2.	self assert: parser parse: 'aabbb' to: 'aabb' end: 4.	self assert: parser parse: 'aaabbbb' to: 'aaabbb' end: 6.	self assert: parser parse: 'aaaabbbbb' to: 'aaaabbbb' end: 8.	self assert: parser fail: 'a'.	self assert: parser fail: 'b'.	self assert: parser fail: 'aab'.	self assert: parser fail: 'aaabb'</body><body package="PetitTests">testParseAaaaaa	"S ::= a a S | epsilon"		| s0 s1 parser |	s0 := PPDelegateParser new.	s1 := $a asParser , $a asParser , s0.	s0 setParser: s1 / nil asParser.	parser := s0 flatten.	self assert: parser parse: '' to: ''.	self assert: parser parse: 'aa' to: 'aa'.	self assert: parser parse: 'aaaa' to: 'aaaa'.	self assert: parser parse: 'aaaaaa' to: 'aaaaaa'.	self assert: parser parse: 'a' to: '' end: 0.	self assert: parser parse: 'aaa' to: 'aa' end: 2.	self assert: parser parse: 'aaaaa' to: 'aaaa' end: 4.	self assert: parser parse: 'aaaaaaa' to: 'aaaaaa' end: 6</body><body package="PetitTests">testParseAbAbAb	"S ::= (A B)+"		| parser |	parser := ($a asParser , $b asParser) plus flatten.	self assert: parser parse: 'ab' to: 'ab'.	self assert: parser parse: 'abab' to: 'abab'.	self assert: parser parse: 'ababab' to: 'ababab'.	self assert: parser parse: 'abababab' to: 'abababab'.	self assert: parser parse: 'abb' to: 'ab' end: 2.	self assert: parser parse: 'ababa' to: 'abab' end: 4.	self assert: parser parse: 'abababb' to: 'ababab' end: 6.	self assert: parser parse: 'ababababa' to: 'abababab' end: 8.		self assert: parser fail: ''.	self assert: parser fail: 'a'.	self assert: parser fail: 'bab'</body><body package="PetitTests">testParseAbabbb	"S ::= (A | B)+"	| parser |	parser := ($a asParser / $b asParser) plus flatten.	self assert: parser parse: 'a' to: 'a'.	self assert: parser parse: 'b' to: 'b'.	self assert: parser parse: 'ab' to: 'ab'.	self assert: parser parse: 'ba' to: 'ba'.	self assert: parser parse: 'aaa' to: 'aaa'.	self assert: parser parse: 'aab' to: 'aab'.	self assert: parser parse: 'aba' to: 'aba'.	self assert: parser parse: 'baa' to: 'baa'.	self assert: parser parse: 'abb' to: 'abb'.	self assert: parser parse: 'bab' to: 'bab'.	self assert: parser parse: 'bba' to: 'bba'.	self assert: parser parse: 'bbb' to: 'bbb'.	self assert: parser parse: 'ac' to: 'a' end: 1.	self assert: parser parse: 'bc' to: 'b' end: 1.	self assert: parser parse: 'abc' to: 'ab' end: 2.	self assert: parser parse: 'bac' to: 'ba' end: 2.		self assert: parser fail: ''.	self assert: parser fail: 'c'</body><body package="PetitTests">testParseAnBnCn	"PEGs for a non context- free language: 				a^n , b^n , c^n			S &lt;- &amp;P1 P2 	P1 &lt;- AB 'c' 	AB &lt;- 'a' AB 'b' / epsilon	P2 &lt;- 'a'* BC end	BC &lt;- 'b' BC 'c' / epsilon"		| s p1 ab p2 bc |	s := PPDelegateParser new.	p1 := PPDelegateParser new.	ab := PPDelegateParser new.	p2 := PPDelegateParser new.	bc := PPDelegateParser new.		s setParser: (p1 and , p2 end) flatten.	p1 setParser: ab , $c asParser.	ab setParser: ($a asParser , ab , $b asParser) optional.	p2 setParser: $a asParser star , bc.	bc setParser: ($b asParser , bc , $c asParser) optional.		self assert: s parse: 'abc' to: 'abc'.	self assert: s parse: 'aabbcc' to: 'aabbcc'.	self assert: s parse: 'aaabbbccc' to: 'aaabbbccc'.	self assert: s fail: 'bc'.	self assert: s fail: 'ac'.	self assert: s fail: 'ab'.	self assert: s fail: 'abbcc'.	self assert: s fail: 'aabcc'.	self assert: s fail: 'aabbc'</body></methods><methods><class-id>PetitTests.PPComposedTest</class-id> <category>accessing</category><body package="PetitTests">comment	^ ($" asParser , $" asParser negate star , $" asParser) flatten</body><body package="PetitTests">identifier	^ (#letter asParser , #word asParser star) flatten</body><body package="PetitTests">number	^ ($- asParser optional , #digit asParser plus , ($. asParser , #digit asParser plus) optional) flatten</body></methods><methods><class-id>PetitTests.PPLambdaParser</class-id> <category>accessing</category><body package="PetitTests">start	^ expression end</body></methods><methods><class-id>PetitTests.PPLambdaParser</class-id> <category>productions</category><body package="PetitTests">abstraction	^ $\ asParser trim , variable , $. asParser trim , expression 		==&gt; [ :node | Array with: (node at: 2) with: (node at: 4) ]</body><body package="PetitTests">application	^ $( asParser trim , expression , expression , $) asParser trim 			==&gt; [ :node | Array with: (node at: 2) with: (node at: 3) ]</body><body package="PetitTests">expression	^ variable / abstraction / application</body><body package="PetitTests">variable	^ (#letter asParser , #word asParser star) flatten trim</body></methods><methods><class-id>PetitTests.PPLambdaParser class</class-id> <category>curch-booleans</category><body package="PetitTests">and	^ self parse: '\p.\q.((p q) p)'</body><body package="PetitTests">false	^ self parse: '\x.\y.y'</body><body package="PetitTests">ifthenelse	^ self parse: '\p.p'</body><body package="PetitTests">not	^ self parse: '\p.\a.\b.((p b) a)'</body><body package="PetitTests">or	^ self parse: '\p.\q.((p p) q)'</body><body package="PetitTests">true	^ self parse: '\x.\y.x'</body></methods><methods><class-id>PetitTests.PPScriptingTest</class-id> <category>examples</category><body package="PetitTests">expressionInterpreter	"Same as #expressionInterpreter but with semantic actions."		| mul prim add dec |	add := PPUnresolvedParser new.	mul := PPUnresolvedParser new.	prim := PPUnresolvedParser new.	dec := ($0 to: $9) asParser ==&gt; [ :token | token codePoint - $0 codePoint ].	add def: ((mul , $+ asParser , add) ==&gt; [ :nodes | (nodes at: 1) + (nodes at: 3) ])		/ mul.	mul def: ((prim , $* asParser , mul) ==&gt; [ :nodes | (nodes at: 1) * (nodes at: 3) ])		/ prim.	prim def: (($( asParser , add , $) asParser) ==&gt; [ :nodes | nodes at: 2 ])		/ dec.	^ add end</body><body package="PetitTests">expressionParser	"Simple demo of scripting an expression parser."		| mul prim add dec |	add := PPUnresolvedParser new.	mul := PPUnresolvedParser new.	prim := PPUnresolvedParser new.	dec := ($0 to: $9) asParser.	add def: (mul , $+ asParser , add)		/ mul.	mul def: (prim , $* asParser , mul)		/ prim.	prim def: ($( asParser , add , $) asParser)		/ dec.	^ add end</body><body package="PetitTests">straightLineParser	| goal stm stmList id char dec exp expList mulExp primExp nonzero num lower upper |	goal := PPUnresolvedParser new.	stmList := PPUnresolvedParser new.	stm := PPUnresolvedParser new.	exp := PPUnresolvedParser new.	expList := PPUnresolvedParser new.	mulExp := PPUnresolvedParser new.	primExp := PPUnresolvedParser new.		lower := ($a to: $z) asParser.	upper := ($A to: $Z) asParser.	char := lower / upper.	nonzero := ($1 to: $9) asParser.	dec := ($0 to: $9) asParser.	id := char, ( char / dec ) star.	num := $0 asParser / ( nonzero, dec star).	goal def: stmList end.	stmList def: stm , ( $; asParser, stm ) star.	stm def: ( id, ':=' asParser, exp )		/ ( 'print' asParser, $( asParser, expList, $) asParser ). 	exp def: mulExp, ( ( $+ asParser / $- asParser ), mulExp ) star.	expList def: exp, ( $, asParser, exp ) star.	mulExp def: primExp, ( ( $* asParser / $/ asParser ), primExp ) star.	primExp def: id		/ num		/ ( $( asParser, stmList, $, asParser, exp, $) asParser ).	^ goal</body></methods><methods><class-id>PetitTests.PPScriptingTest</class-id> <category>tests</category><body package="PetitTests">testExpressionInterpreter	self 		assert: self expressionInterpreter		parse: '2*(3+4)'		to: 14</body><body package="PetitTests">testExpressionParser	self		assert: self expressionParser		parse: '2*(3+4)'		to: #($2 $* ($( ($3 $+ $4) $)))</body><body package="PetitTests">testSLassign		self assert: self straightLineParser		parse: 'abc:=1'		to: #(#($a #($b $c) ':=' #(#(#($1 #()) #()) #())) #())</body><body package="PetitTests">testSLprint	self 		assert: self straightLineParser		parse: 'print(3,4)'		to: #(('print' $( ((($3 ()) ()) () (($, ((($4 ()) ()) ())))) $)) ())</body></methods><methods><class-id>PetitTests.PPLambdaParserTest</class-id> <category>accessing</category><body package="PetitTests">parserClass	^ PPLambdaParser</body></methods><methods><class-id>PetitTests.PPLambdaParserTest</class-id> <category>testing-curch</category><body package="PetitTests">testAnd	self assert: self parserClass and equals: #('p' #('q' #(#('p' 'q') 'p')))</body><body package="PetitTests">testFalse	self assert: self parserClass false equals: #('x' #('y' 'y'))</body><body package="PetitTests">testIfThenElse	self assert: self parserClass ifthenelse equals: #('p' 'p')</body><body package="PetitTests">testNot	self assert: self parserClass not equals: #('p' #('a' #('b' #(#('p' 'b') 'a'))))</body><body package="PetitTests">testOr	self assert: self parserClass or equals: #('p' #('q' #(#('p' 'p') 'q')))</body><body package="PetitTests">testTrue	self assert: self parserClass true equals: #('x' #('y' 'x'))</body></methods><methods><class-id>PetitTests.PPLambdaParserTest</class-id> <category>testing</category><body package="PetitTests">testAbstraction	self assert: '\x.y' is: #('x' 'y').	self assert: '\x.\y.z' is: #('x' ('y' 'z'))</body><body package="PetitTests">testApplication	self assert: '(x x)' is: #('x' 'x').	self assert: '(x y)' is: #('x' 'y').	self assert: '((x y) z)' is: #(('x' 'y') 'z').	self assert: '(x (y z))' is: #('x' ('y' 'z'))</body><body package="PetitTests">testVariable	self assert: 'x' is: 'x'.	self assert: 'xy' is: 'xy'.	self assert: 'x12' is: 'x12'</body></methods><methods><class-id>PetitTests.PPLambdaParserTest</class-id> <category>testing-utilities</category><body package="PetitTests">testParseOnError	| beenHere |	result := self parserClass parse: '\x. y' onError: [ self fail ].	self assert: result equals: #('x' 'y').	beenHere := false.	result := self parserClass parse: '\x.' onError: [ beenHere := true ].	self assert: beenHere.	beenHere := false.	result := self parserClass		parse: '\x. '		onError: [ :fail | 			beenHere := true.			fail ].	self assert: beenHere.	self assert: result message includesSubstring: 'letter'.	self assert: result message includesSubstring: 'expected'.	self assert: result position equals: 4.	beenHere := false.	result := self parserClass		parse: '\x. '		onError: [ :msg :pos | 			self assert: msg includesSubstring: 'letter'.			self assert: msg includesSubstring: 'expected'.			self assert: pos equals: 4.			beenHere := true ].	self assert: result.	self assert: beenHere</body><body package="PetitTests">testParseStartingAtOnError	| beenHere |	result := self parserClass parse: 'x' startingAt: #variable onError: [ self fail ].	self assert: result equals: 'x'.	beenHere := false.	result := self parserClass parse: '\' startingAt: #variable onError: [ beenHere := true ].	self assert: beenHere.	beenHere := false.	result := self parserClass		parse: '\ '		startingAt: #variable		onError: [ :fail | 			beenHere := true.			fail ].	self assert: beenHere.	self assert: result message equals: 'letter expected'.	self assert: result position equals: 0.	beenHere := false.	result := self parserClass		parse: '\ '		startingAt: #variable		onError: [ :msg :pos | 			self assert: msg equals: 'letter expected'.			self assert: pos equals: 0.			beenHere := true ].	self assert: beenHere</body><body package="PetitTests">testProductionAt	self assert: (parser productionAt: #foo) isNil.	self assert: (parser productionAt: #foo ifAbsent: [ true ]).		self assert: (parser productionAt: #start) notNil.	self assert: (parser productionAt: #start ifAbsent: [ true ]) notNil.		self assert: (parser productionAt: #variable) notNil.	self assert: (parser productionAt: #variable ifAbsent: [ true ]) notNil</body></methods><methods><class-id>PetitTests.PPTokenTest</class-id> <category>testing</category><body package="PetitTests">testCollection	| input result |	input := 'foo    '.	result := self parse: input using: self identifier.	self assert: result collection equals: input.	self assert: result collection == input</body><body package="PetitTests">testInitialize	PPToken initialize</body><body package="PetitTests">testNew	self should: [ PPToken new ] raise: Error.	</body><body package="PetitTests">testPrinting	| result |	result := PPToken on: 'var'.	self assert: result printString includesSubstring: 'PPToken[1,3]'</body><body package="PetitTests">testSize	| result |	result := self parse: 'foo' using: self identifier.	self assert: result size equals: 3</body><body package="PetitTests">testStart	| result |	result := self parse: 'foo' using: self identifier.	self assert: result start equals: 1</body><body package="PetitTests">testStop	| result |	result := self parse: 'foo' using: self identifier.	self assert: result stop equals: 3</body></methods><methods><class-id>PetitTests.PPTokenTest</class-id> <category>testing-querying</category><body package="PetitTests">testColumn	| input parser result |	input := '1' , (String with: (Character codePoint: 13)) , '12' , (String with: (Character codePoint: 13) with: (Character codePoint: 10)) , '123'		, (String with: (Character codePoint: 10)) , '1234'.	parser := #any asParser token star.	result := parser parse: input.	result with: #(1 2 1 2 3 4 1 2 3 4 1 2 3 4) do: [ :token :line | self assert: token column equals: line ]</body><body package="PetitTests">testLine	| input parser result |	input := '1' , (String with: (Character codePoint: 13)) , '12' , (String with: (Character codePoint: 13) with: (Character codePoint: 10)) , '123'		, (String with: (Character codePoint: 10)) , '1234'.	parser := #any asParser token star.	result := parser parse: input.	result with: #(1 1 2 2 2 2 3 3 3 3 4 4 4 4) do: [ :token :line | self assert: token line equals: line ]</body></methods><methods><class-id>PetitTests.PPTokenTest</class-id> <category>testing-copying</category><body package="PetitTests">testCopyFromTo	| result other |	result := PPToken on: 'abc'.	other := result copyFrom: 2 to: 2.	self assert: other size equals: 1.	self assert: other start equals: 2.	self assert: other stop equals: 2.	self assert: other collection equals: result collection</body></methods><methods><class-id>PetitTests.PPTokenTest</class-id> <category>testing-values</category><body package="PetitTests">testInputValue	| input result |	input := 'foo'.	result := self parse: input using: self identifier.	self assert: result inputValue equals: input.	self deny: result inputValue == input</body><body package="PetitTests">testParsedValue	| input result |	input := 'foo'.	result := self parse: input using: self identifier.	self assert: result parsedValue equals: #($f $o $o)</body></methods><methods><class-id>PetitTests.PPTokenTest</class-id> <category>utilities</category><body package="PetitTests">parse: aString using: aParser	^ aParser parse: aString</body></methods><methods><class-id>PetitTests.PPTokenTest</class-id> <category>accessing</category><body package="PetitTests">identifier	^ #word asParser plus token</body></methods><methods><class-id>PetitTests.PPTokenTest</class-id> <category>testing-comparing</category><body package="PetitTests">testEquality	| token1 token2 |	token1 := self parse: 'foo' using: self identifier.	token2 := self parse: 'foo' using: self identifier.	self deny: token1 == token2.	self assert: token1 equals: token2.	self assert: token1 hash equals: token2 hash</body></methods><methods><class-id>PetitTests.PPConditionalParserTest</class-id> <category>as yet unclassified</category><body package="PetitTests">context	^ context</body><body package="PetitTests">setUp	super setUp.	context := PPContext new</body><body package="PetitTests">testConditionCtxAccess	| parser |	parser := ('a' asParser if: [ :ctx | (ctx propertyAt: #foo) = #bar ]).		context propertyAt: #foo put: #bar.	self assert: parser parse: 'a' .	context propertyAt: #foo put: #zorg.	self assert: parser fail: 'a' .</body><body package="PetitTests">testConditionFalse	| parser |	parser := ('a' asParser if: [ :ctx | false ]).		self assert: parser fail: 'a'.	self assert: parser fail: 'b'.</body><body package="PetitTests">testConditionTrue	| parser |	parser := ('a' asParser if: [ :ctx | true ]).		self assert: parser parse: 'a'.	self assert: parser fail: 'b'.</body></methods><methods><class-id>PetitTests.PPMappingTest</class-id> <category>as yet unclassified</category><body package="PetitTests">testFoldLeft2	| parser |	parser := #any asParser star 		foldLeft: [ :a :b | Array with: a with: b ].	self assert: parser parse: #(a) to: #a.	self assert: parser parse: #(a b) to: #(a b).	self assert: parser parse: #(a b c) to: #((a b) c).	self assert: parser parse: #(a b c d) to: #(((a b) c) d).	self assert: parser parse: #(a b c d e) to: #((((a b) c) d) e)</body><body package="PetitTests">testFoldLeft3	| parser |	parser := #any asParser star 		foldLeft: [ :a :b :c | Array with: a with: b with: c ].	self assert: parser parse: #(a) to: #a.	self assert: parser parse: #(a b c) to: #(a b c).	self assert: parser parse: #(a b c d e) to: #((a b c) d e)</body><body package="PetitTests">testFoldRight2	| parser |	parser := #any asParser star 		foldRight: [ :a :b | Array with: a with: b ].	self assert: parser parse: #(a) to: #a.	self assert: parser parse: #(a b) to: #(a b).	self assert: parser parse: #(a b c) to: #(a (b c)).	self assert: parser parse: #(a b c d) to: #(a (b (c d))).	self assert: parser parse: #(a b c d e) to: #(a (b (c (d e))))</body><body package="PetitTests">testFoldRight3	| parser |	parser := #any asParser star 		foldRight: [ :a :b :c | Array with: a with: b with: c ].	self assert: parser parse: #(a) to: #a.	self assert: parser parse: #(a b c) to: #(a b c).	self assert: parser parse: #(a b c d e) to: #(a b (c d e))</body><body package="PetitTests">testMap1	| parser |	parser := #any asParser 		map: [ :a | Array with: a ].	self assert: parser parse: #(a) to: #(a)</body><body package="PetitTests">testMap2	| parser |	parser := (#any asParser , #any asParser) 		map: [ :a :b | Array with: b with: a ].	self assert: parser parse: #(a b) to: #(b a)</body><body package="PetitTests">testMap3	| parser |	parser := (#any asParser , #any asParser , #any asParser)		map: [ :a :b :c | Array with: c with: b with: a ].	self assert: parser parse: #(a b c) to: #(c b a)</body></methods><methods><class-id>PetitTests.PPContextTest</class-id> <category>tests</category><body package="PetitTests">testFurthestFailure	| f1 f2 |		f1 := PPFailure message: #foo context: context at: 1.	self assert: context furthestFailure = f1.		f2 := PPFailure message: #foo context: context at: 1.	self assert: context furthestFailure = f1.		f2 := PPFailure message: #foo context: context at: 3.	self assert: context furthestFailure = f2.</body><body package="PetitTests">testMemoization	| stream memento memento2 collection |	stream := 'abc' asPetitStream.	context := context stream: stream.	collection := OrderedCollection new.	context propertyAt: #foo put: collection.		memento := context remember.		self assert: memento isNil not.		context next.	collection add: #element.	self assert: (context propertyAt: #foo) size = 1. 		memento2 := context remember.	context restore: memento.	self assert: (context propertyAt: #foo) size = 0. 	self assert: context position = 0.		context restore: memento2.	self assert: (context propertyAt: #foo) size = 1. 	self assert: context position = 1.</body><body package="PetitTests">testMemoization2	| stream memento |	stream := 'abc' asPetitStream.	context := context stream: stream.		memento := context remember.		context next.	self assert: context position = 1.		context restore: memento.	self assert: context position = 0.</body><body package="PetitTests">testMemoization3	| stream memento memento2 collection |	stream := 'abc' asPetitStream.	context := context stream: stream.	collection := OrderedCollection new.	memento := context remember.	context propertyAt: #foo put: collection.	memento2 := context remember.		context restore: memento.	self assert: (context hasProperty: #foo) not.		context restore: memento2.	self assert: (context hasProperty: #foo).</body><body package="PetitTests">testPutGlobals	self assert: (context hasGlobal: #foo) not.	self assert: (context hasGlobal: #bar) not.			self should: [ context globalAt: #foo ] raise: Error.	self assert: (context globalAt: #foo ifAbsent: [ #bar ]) = #bar.		self assert: (context globalAt: #foo ifAbsentPut: [ #bar ]) = #bar.		self assert: (context hasGlobal: #foo).	self assert: (context hasGlobal: #bar) not.		self assert: (context globalAt: #foo) = #bar.		self assert: (context globalAt: #foo ifAbsentPut: [ #zorg ]) = #bar.		self assert: (context hasGlobal: #foo).	self assert: (context hasGlobal: #bar) not.		self assert: (context globalAt: #foo) = #bar.		self assert: (context globalAt: #foo put: #zorg) = #zorg.		self assert: (context hasGlobal: #foo).	self assert: (context hasGlobal: #bar) not.		self assert: (context globalAt: #foo) = #zorg.		self should: [ context globalAt: #bar ] raise: Error.	self assert: (context globalAt: #bar put: #foo) = #foo.	self assert: (context globalAt: #foo) = #zorg.	self assert: (context globalAt: #bar) = #foo.</body><body package="PetitTests">testPutProperties	self assert: (context hasProperty: #foo) not.	self assert: (context hasProperty: #bar) not.			self should: [ context propertyAt: #foo ] raise: Error.	self assert: (context propertyAt: #foo ifAbsent: [ #bar ]) = #bar.		self assert: (context propertyAt: #foo ifAbsentPut: [ #bar ]) = #bar.		self assert: (context hasProperty: #foo).	self assert: (context hasProperty: #bar) not.		self assert: (context propertyAt: #foo) = #bar.		self assert: (context propertyAt: #foo ifAbsentPut: [ #zorg ]) = #bar.		self assert: (context hasProperty: #foo).	self assert: (context hasProperty: #bar) not.		self assert: (context propertyAt: #foo) = #bar.		self assert: (context propertyAt: #foo put: #zorg) = #zorg.		self assert: (context hasProperty: #foo).	self assert: (context hasProperty: #bar) not.		self assert: (context propertyAt: #foo) = #zorg.		self should: [ context propertyAt: #bar ] raise: Error.	self assert: (context propertyAt: #bar put: #foo) = #foo.	self assert: (context propertyAt: #foo) = #zorg.	self assert: (context propertyAt: #bar) = #foo.</body><body package="PetitTests">testRemoveGlobals	context globalAt: #foo put: #zorg.	context globalAt: #bar put: #qwark.		self assert: (context removeGlobal: #foo) = #zorg.	self assert: (context removeGlobal: #bar) = #qwark.		self should: [context removeGlobal: #foo] raise: Error.	self assert: (context removeGlobal: #bar ifAbsent: [ #foobar ]) = #foobar.</body><body package="PetitTests">testRemoveProperties	context propertyAt: #foo put: #zorg.	context propertyAt: #bar put: #qwark.		self assert: (context removeProperty: #foo) = #zorg.	self assert: (context removeProperty: #bar) = #qwark.		self should: [context removeProperty: #foo] raise: Error.	self assert: (context removeProperty: #bar ifAbsent: [ #foobar ]) = #foobar.</body><body package="PetitTests">testStreamProtocol	context stream: 'hi there' asPetitStream.		self assert: context position = 0.	self assert: context peek = $h.	self assert: context uncheckedPeek = $h.	self assert: context next = $h.	self assert: context peek = $i.	self assert: context uncheckedPeek = $i.	self assert: context position = 1.		context skip: 2.	self assert: context position = 3.	self assert: context peek = $t.	self assert: context atEnd not.		self assert: (context next: 5) = 'there'.	self assert: context position = 8.	self assert: context atEnd.</body></methods><methods><class-id>PetitTests.PPContextTest</class-id> <category>as yet unclassified</category><body package="PetitTests">context	^ PPContext new</body><body package="PetitTests">setUp	super setUp.	context := self context.</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>TestCase</name><environment>SUnit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnitToo</package></attributes></class><class><name>TestResource</name><environment>SUnit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>current </class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnitToo</package></attributes></class><class><name>PPCompositeParser</name><environment>PetitParser</environment><super>PetitParser.PPDelegateParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dependencies </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Tools</category><attributes><package>PetitParser</package></attributes></class></st-source>