<?xml version="1.0"?><st-source><!-- Name: GraphQLBetaBundleName: GraphQLBetaBundleStructure: a Store.BundleForParcelParcel: #('GraphQLBeta')ParcelName: GraphQLBetaDate: 6:55:41 pm January 23, 2019 --><time-stamp>From VisualWorksÂ®, 7.4 of December 5, 2005 on January 23, 2019 at 6:55:41 pm</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>GraphQLBeta</name><environment>Smalltalk</environment><private>false</private><imports>			private Smalltalk.*			private PetitParser.*			private PetitTests.*			</imports><category>GraphQLBeta</category><attributes><package>GraphQLBeta</package></attributes></name-space><class><name>GQLTestMutationType</name><environment>GraphQLBeta</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Test-Utils</category><attributes><package>GraphQLBeta-Test-Utils</package></attributes></class><comment><class-id>GraphQLBeta.GQLTestMutationType</class-id><body>I am a test mutation type, for test resources</body></comment><class><name>GQLTestQueryTypeInput</name><environment>GraphQLBeta</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Tests-TypeValidation</category><attributes><package>GraphQLBeta-Tests-TypeValidation</package></attributes></class><comment><class-id>GraphQLBeta.GQLTestQueryTypeInput</class-id><body>I am utility class for testing</body></comment><class><name>GraphQLDemoWorldMenu</name><environment>GraphQLBeta</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Demo</category><attributes><package>GraphQLBeta-Demo</package></attributes></class><comment><class-id>GraphQLBeta.GraphQLDemoWorldMenu</class-id><body>I have the world menus for this demo</body></comment><class><name>GQLTest</name><environment>GraphQLBeta</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>schema rootInstance withData compareJson </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Tests-Nodes</category><attributes><package>GraphQLBeta-Tests-Nodes</package></attributes></class><class><name>GraphQLBetaTest</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>graphQL </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Tests-Nodes</category><attributes><package>GraphQLBeta-Tests-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GraphQLBetaTest</class-id><body>I am the first basic attempt to test graphql</body></comment><class><name>GQLSingleAnonimousQueryEvaluatorTest</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Tests-Grammar</category><attributes><package>GraphQLBeta-Tests-Grammar</package></attributes></class><comment><class-id>GraphQLBeta.GQLSingleAnonimousQueryEvaluatorTest</class-id><body>A GQLSingleAnonimousQueryEvaluatorTest is a test class for testing the behavior of GQLSingleAnonimousQueryEvaluator</body></comment><class><name>GraphQLPlatform</name><environment>GraphQLBeta</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>instance </class-inst-vars><imports></imports><category>GraphQLBeta-Core</category><attributes><package>GraphQLBeta-Core</package></attributes></class><comment><class-id>GraphQLBeta.GraphQLPlatform</class-id><body>I am a class for compatibility between different types of smalltalk, like VisualWorks</body></comment><class><name>GQLFieldNodeTest</name><environment>GraphQLBeta</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>schema scalarField nonScalarField context </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Tests-Nodes</category><attributes><package>GraphQLBeta-Tests-Nodes</package></attributes></class><class><name>GQLDocumentNodeTest</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Tests-Nodes</category><attributes><package>GraphQLBeta-Tests-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLDocumentNodeTest</class-id><body>A GQLDocumentNodeTest is a test class for testing the behavior of GQLDocumentNode</body></comment><class><name>GQLQuery</name><environment>GraphQLBeta</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Demo</category><attributes><package>GraphQLBeta-Demo</package></attributes></class><comment><class-id>GraphQLBeta.GQLQuery</class-id><body>On my class side is defined the schema text and at my instance side are defined all the methods that are called by the schema. </body></comment><class><name>GQLException</name><environment>GraphQLBeta</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars>node </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Core</category><attributes><package>GraphQLBeta-Core</package></attributes></class><comment><class-id>GraphQLBeta.GQLException</class-id><body>I represent an exception of graphql, I know the node that raise some kind of exception on the parsing or the validation or the type checking of the schema.Public API and Key Messages- node      - node: - signal   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Instance Variables	node:		&amp;lt;Object&amp;gt;    Implementation Points</body></comment><class><name>GQLEvaluationException</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Core</category><attributes><package>GraphQLBeta-Core</package></attributes></class><comment><class-id>GraphQLBeta.GQLEvaluationException</class-id><body>I represent an exception of evaluation on graphql, I'm only called if the GQLTypeValidator has a problem with visiting the parts of the document.Public API and Key Messages- node      - node: - signal    Instance Variables	node:		&amp;lt;GQLNode&amp;gt;GQLEvaluationException new 			node: aGQLArgumentNode; 			signal</body></comment><class><name>GQLAbstractGrammarTest</name><environment>GraphQLBeta</environment><super>PetitTests.PPCompositeParserTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Tests-Grammar</category><attributes><package>GraphQLBeta-Tests-Grammar</package></attributes></class><comment><class-id>GraphQLBeta.GQLAbstractGrammarTest</class-id><body>A GQLAbstractGrammarTest is a test class for testing the behavior of GQLAbstractGrammar</body></comment><class><name>Person</name><environment>GraphQLBeta</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name age </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Demo</category><attributes><package>GraphQLBeta-Demo</package></attributes></class><comment><class-id>GraphQLBeta.Person</class-id><body>I am a basic object person for this demo of graphql</body></comment><class><name>GQLA</name><environment>GraphQLBeta</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Test-Trash</category><attributes><package>GraphQLBeta-Test-Trash</package></attributes></class><comment><class-id>GraphQLBeta.GQLA</class-id><body>Example class for testsPublic API and Key Messages- hey- heyID- id:   One simple example is simply gorgeous.	| anObject |	anObject := A new id: 1000.	anObject heyID.     Instance Variables	id:		Int</body></comment><class><name>GQLTestExtension</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Tests-Nodes</category><attributes><package>GraphQLBeta-Tests-Nodes</package></attributes></class><class><name>GQLDocumentWithExtensionTest</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLTestExtension</super><private>false</private><indexed-type>none</indexed-type><inst-vars>validator dictSchema </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Tests-Nodes</category><attributes><package>GraphQLBeta-Tests-Nodes</package></attributes></class><class><name>GQLSSchemaNodeExtensionTest</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLTestExtension</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictSchema dictOfInvalidSchema </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Tests-Nodes</category><attributes><package>GraphQLBeta-Tests-Nodes</package></attributes></class><class><name>GQLComplex</name><environment>GraphQLBeta</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Test-Utils</category><attributes><package>GraphQLBeta-Test-Utils</package></attributes></class><comment><class-id>GraphQLBeta.GQLComplex</class-id><body>I am a utility class for test resources, GQLComplexInput</body></comment><class><name>GQLTestValidation</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Tests-Validation</category><attributes><package>GraphQLBeta-Tests-Validation</package></attributes></class><comment><class-id>GraphQLBeta.GQLTestValidation</class-id><body>I am  common class to create a schema for the next tests</body></comment><class><name>GQLValuesValidationTest</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLTestValidation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Tests-Validation</category><attributes><package>GraphQLBeta-Tests-Validation</package></attributes></class><comment><class-id>GraphQLBeta.GQLValuesValidationTest</class-id><body>https://facebook.github.io/graphql/draft/#sec-Values</body></comment><class><name>GQLFragmentsValidationTest</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLTestValidation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Tests-Validation</category><attributes><package>GraphQLBeta-Tests-Validation</package></attributes></class><comment><class-id>GraphQLBeta.GQLFragmentsValidationTest</class-id><body>https://facebook.github.io/graphql/draft/#sec-Validation.Fragments</body></comment><class><name>GQLDirectivesValidationTest</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLTestValidation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Tests-Validation</category><attributes><package>GraphQLBeta-Tests-Validation</package></attributes></class><comment><class-id>GraphQLBeta.GQLDirectivesValidationTest</class-id><body>https://facebook.github.io/graphql/draft/#sec-Validation.Directives</body></comment><class><name>GQLMutation</name><environment>GraphQLBeta</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Test-Utils</category><attributes><package>GraphQLBeta-Test-Utils</package></attributes></class><comment><class-id>GraphQLBeta.GQLMutation</class-id><body>I am a utility class for mutation test</body></comment><class><name>GQLSchemaGrammarTest</name><environment>GraphQLBeta</environment><super>PetitTests.PPCompositeParserTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Tests-Grammar</category><attributes><package>GraphQLBeta-Tests-Grammar</package></attributes></class><comment><class-id>GraphQLBeta.GQLSchemaGrammarTest</class-id><body>A GQLSchemaGrammarTest is a test class for testing the behavior of GQLSchemaGrammar</body></comment><class><name>GQLIQueryType</name><environment>GraphQLBeta</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Test-Trash</category><attributes><package>GraphQLBeta-Test-Trash</package></attributes></class><comment><class-id>GraphQLBeta.GQLIQueryType</class-id><body>Example class query  for testsPublic API and Key Messages- a- aId:- hello- helloName:- sumNums:</body></comment><class><name>GQLSchemaGrammarEvaluatorTest</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Tests-Grammar</category><attributes><package>GraphQLBeta-Tests-Grammar</package></attributes></class><comment><class-id>GraphQLBeta.GQLSchemaGrammarEvaluatorTest</class-id><body>A GQLSchemaGrammarEvaluatorTest is a test class for testing the behavior of GQLSchemaGrammarEvaluator</body></comment><class><name>GQLSingleAnonimousQueryGrammarTest</name><environment>GraphQLBeta</environment><super>PetitTests.PPCompositeParserTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Tests-Grammar</category><attributes><package>GraphQLBeta-Tests-Grammar</package></attributes></class><comment><class-id>GraphQLBeta.GQLSingleAnonimousQueryGrammarTest</class-id><body>A GQLSingleAnonimousQueryGrammarTest is a test class for testing the behavior of GQLSingleAnonimousQueryGrammar</body></comment><class><name>GQLRequestGrammarTest</name><environment>GraphQLBeta</environment><super>PetitTests.PPCompositeParserTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parserVariable </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Tests-Grammar</category><attributes><package>GraphQLBeta-Tests-Grammar</package></attributes></class><comment><class-id>GraphQLBeta.GQLRequestGrammarTest</class-id><body>A GQLSchemaGrammarTest is a test class for testing the behavior of GQLSchemaGrammar</body></comment><class><name>GQLQueryRoot</name><environment>GraphQLBeta</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Test-Utils</category><attributes><package>GraphQLBeta-Test-Utils</package></attributes></class><comment><class-id>GraphQLBeta.GQLQueryRoot</class-id><body>I am a utility class for test validations</body></comment><class><name>GQLZGeneralTest</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLTestValidation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Tests-Validation</category><attributes><package>GraphQLBeta-Tests-Validation</package></attributes></class><comment><class-id>GraphQLBeta.GQLZGeneralTest</class-id><body>https://facebook.github.io/graphql/draft/#sec-Validation.Fields</body></comment><class><name>GQLFieldsValidationTest</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLTestValidation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Tests-Validation</category><attributes><package>GraphQLBeta-Tests-Validation</package></attributes></class><comment><class-id>GraphQLBeta.GQLFieldsValidationTest</class-id><body>https://facebook.github.io/graphql/draft/#sec-Validation.Fields</body></comment><class><name>GraphQLObject</name><environment>GraphQLBeta</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Core</category><attributes><package>GraphQLBeta-Core</package></attributes></class><comment><class-id>GraphQLBeta.GraphQLObject</class-id><body>I'm the default parent of the classes of the package GraphQLBeta.</body></comment><class><name>GQLTestFilm</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GraphQLObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id filmName rating film description gender </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Test-Utils</category><attributes><package>GraphQLBeta-Test-Utils</package></attributes></class><comment><class-id>GraphQLBeta.GQLTestFilm</class-id><body>I represent a film to test the graphql request.Public API and Key Messages- id   - initialize:name:rating:- name- rating- toDictionaryInternal Representation and Key Implementation Points.    Instance Variables	filmName:		&amp;lt;String&amp;gt;	id:		&amp;lt;String&amp;gt;	rating:		&amp;lt;Integer&amp;gt;Example	GQLTestFilm new: 1 name: 'Bella' rating: 7</body></comment><class><name>GraphQL</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GraphQLObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>rootInstance schema context shouldValidate variables operation </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Core</category><attributes><package>GraphQLBeta-Core</package></attributes></class><comment><class-id>GraphQLBeta.GraphQL</class-id><body>I handle a request given a schema and an entry point. For default the schema will be always in the class side of the class Query.Public API and Key Messages- createSchema: - handleRequest:- schema- schema:Internal Representation and Key Implementation Points.    Instance Variables	rootInstance:		&amp;lt;Query&amp;gt;	schema:		&amp;lt;GQLSchema&amp;gt;	validator:		&amp;lt;GQLTypeValidator&amp;gt;    Implementation Points</body></comment><class><name>GQLAbstractNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GraphQLObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>position </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLAbstractNode</class-id><body>I represent a abstract node of a graphql request Public API and Key Messages-  position:To see more information go to the subclasses</body></comment><class><name>GQLComment</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLAbstractNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLComment</class-id><body>I represent an comment on the request.Public API and Key Messages- value- value:    Instance Variables	value:		&amp;lt;String&amp;gt;</body></comment><class><name>GQLPosition</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GraphQLObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>line column </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Validation</category><attributes><package>GraphQLBeta-Validation</package></attributes></class><comment><class-id>GraphQLBeta.GQLPosition</class-id><body>I represent a graphql position for the json responseExample{	"line" : 4	"column" : 5}</body></comment><class><name>GQLHuman</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GraphQLObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Test-Utils</category><attributes><package>GraphQLBeta-Test-Utils</package></attributes></class><comment><class-id>GraphQLBeta.GQLHuman</class-id><body>I am a utility class for test validation</body></comment><class><name>GQLDog</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GraphQLObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name nickname barkVolume owner </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Test-Utils</category><attributes><package>GraphQLBeta-Test-Utils</package></attributes></class><comment><class-id>GraphQLBeta.GQLDog</class-id><body>I am an utility class for tests in validation and with the GQLQueryRoot schema</body></comment><class><name>GQLNodeVisitor</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GraphQLObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>schema errors text context document schemaContextStack </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Visitors</category><attributes><package>GraphQLBeta-Visitors</package></attributes></class><comment><class-id>GraphQLBeta.GQLNodeVisitor</class-id><body>I represent the validator to evaluate the document with the schema.Public API and Key Messages- initalize- schema"- visitArgumentNode:- visitDocumentNode:- visitInputValueNode:- visitObjectNode:- visitScalarNode:- visitSelectionSetNode:    Instance Variables	schema:		&amp;lt;GQLSchema&amp;gt;	schemaContextStack:		&amp;lt;Stack&amp;gt;For more information see the class GQLTypeValidator</body></comment><class><name>GQLVariablesVisitor</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLNodeVisitor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>currentOperation usedVariables currentField </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Visitors</category><attributes><package>GraphQLBeta-Visitors</package></attributes></class><comment><class-id>GraphQLBeta.GQLVariablesVisitor</class-id><body>My instances can evaluate all variables in the document request and send errors when something is wronghttps://facebook.github.io/graphql/draft/#sec-Validation.Variables</body></comment><class><name>GQLFilm</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GraphQLObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id filmName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Test-Utils</category><attributes><package>GraphQLBeta-Test-Utils</package></attributes></class><comment><class-id>GraphQLBeta.GQLFilm</class-id><body>Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:For the Class part:  State a one line summary. For example, "I represent a paragraph of text".For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.For the Collaborators Part: State my main collaborators and one line about how I interact with them. Public API and Key Messages- message one   - message two - (for bonus points) how to create instances.   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Instance Variables	name:		&amp;lt;Object&amp;gt;    Implementation Points</body></comment><class><name>GQLArgumentsVisitor</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLNodeVisitor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>currentField </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Visitors</category><attributes><package>GraphQLBeta-Visitors</package></attributes></class><comment><class-id>GraphQLBeta.GQLArgumentsVisitor</class-id><body>I follow the specificationhttps://facebook.github.io/graphql/draft/#sec-Validation.Arguments</body></comment><class><name>GQLContext</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GraphQLObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fragments variables operationName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Core</category><attributes><package>GraphQLBeta-Core</package></attributes></class><comment><class-id>GraphQLBeta.GQLContext</class-id><body>I represent a context on a request.Public API and Key Messages- fragments- operationName- variables Internal Representation and Key Implementation Points.    Instance Variables	fragments:		&amp;lt;Dictionary&amp;gt;	variables:		&amp;lt;Dictionary&amp;gt;</body></comment><class><name>GQLValuesVisitor</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLNodeVisitor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>currentField </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Visitors</category><attributes><package>GraphQLBeta-Visitors</package></attributes></class><comment><class-id>GraphQLBeta.GQLValuesVisitor</class-id><body>My instances validate all the ObjectInputs in the documenthttps://facebook.github.io/graphql/draft/#sec-Values</body></comment><class><name>GQLAlien</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GraphQLObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name homePlanet </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Test-Utils</category><attributes><package>GraphQLBeta-Test-Utils</package></attributes></class><comment><class-id>GraphQLBeta.GQLAlien</class-id><body>I am a utility class for testing</body></comment><class><name>GQLCat</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GraphQLObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name nickname meowVolume </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Test-Utils</category><attributes><package>GraphQLBeta-Test-Utils</package></attributes></class><comment><class-id>GraphQLBeta.GQLCat</class-id><body>I am a utility class for testing</body></comment><class><name>GQLError</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GraphQLObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>message locations </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Validation</category><attributes><package>GraphQLBeta-Validation</package></attributes></class><comment><class-id>GraphQLBeta.GQLError</class-id><body>I represent the error of graphql in the validation system, in order to build a json</body></comment><class><name>GraphQLBenchmark</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GraphQLObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>objects lastSize </class-inst-vars><imports></imports><category>GraphQLBeta-Test-Benchmark</category><attributes><package>GraphQLBeta-Test-Benchmark</package></attributes></class><comment><class-id>GraphQLBeta.GraphQLBenchmark</class-id><body>I am a simple class that contains benchmarks for this project</body></comment><class><name>GQLFieldsVisitor</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLNodeVisitor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>visitedFields </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Visitors</category><attributes><package>GraphQLBeta-Visitors</package></attributes></class><comment><class-id>GraphQLBeta.GQLFieldsVisitor</class-id><body>I use this specificationhttps://facebook.github.io/graphql/draft/#sec-Validation.Fields</body></comment><class><name>GQLArguments</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GraphQLObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Test-Utils</category><attributes><package>GraphQLBeta-Test-Utils</package></attributes></class><comment><class-id>GraphQLBeta.GQLArguments</class-id><body>I am a class just for test arguments</body></comment><class><name>GQLDirectivesVisitor</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLNodeVisitor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>currentLocation </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Visitors</category><attributes><package>GraphQLBeta-Visitors</package></attributes></class><comment><class-id>GraphQLBeta.GQLDirectivesVisitor</class-id><body>I can visit all the directives in the document and validate if they apply in that sectionhttps://facebook.github.io/graphql/draft/#sec-Validation.Directives</body></comment><class><name>Film</name><environment>GraphQLBeta</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name rating director gender </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Demo</category><attributes><package>GraphQLBeta-Demo</package></attributes></class><comment><class-id>GraphQLBeta.Film</class-id><body>I am a basic object film for this demo of graphql</body></comment><class><name>GQLFragmentsVisitor</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLNodeVisitor</super><private>false</private><indexed-type>none</indexed-type><inst-vars>usedFragments currentFragment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Visitors</category><attributes><package>GraphQLBeta-Visitors</package></attributes></class><comment><class-id>GraphQLBeta.GQLFragmentsVisitor</class-id><body>I follow the specificationhttps://facebook.github.io/graphql/draft/#sec-Validation.Fragments</body></comment><class><name>GQLAbstactTypeSystemTest</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictSchema </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Tests-TypeValidation</category><attributes><package>GraphQLBeta-Tests-TypeValidation</package></attributes></class><comment><class-id>GraphQLBeta.GQLAbstactTypeSystemTest</class-id><body>I have the schemas definitions for my subclasses</body></comment><class><name>GQLSTypeTest</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLAbstactTypeSystemTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Tests-TypeValidation</category><attributes><package>GraphQLBeta-Tests-TypeValidation</package></attributes></class><comment><class-id>GraphQLBeta.GQLSTypeTest</class-id><body>A GQLSTypeTest is a test class for testing the behavior of type request validator.</body></comment><class><name>GQLSchemaTest</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLAbstactTypeSystemTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Tests-TypeValidation</category><attributes><package>GraphQLBeta-Tests-TypeValidation</package></attributes></class><comment><class-id>GraphQLBeta.GQLSchemaTest</class-id><body>A GQLSchemaTest is a test class for testing the behavior of schema validator.</body></comment><class><name>GQLSRequestTest</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLAbstactTypeSystemTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Tests-TypeValidation</category><attributes><package>GraphQLBeta-Tests-TypeValidation</package></attributes></class><comment><class-id>GraphQLBeta.GQLSRequestTest</class-id><body>A GQLRequestTest is a test class for testing the behavior of request validator.According the specification of http://facebook.github.io/graphql/draft/#sec-Execution: 	- if validation errors are known, they should be reported in the list of 'errors' in the response</body></comment><class><name>GraphQLBetaDemoHTML</name><environment>GraphQLBeta</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Demo</category><attributes><package>GraphQLBeta-Demo</package></attributes></class><comment><class-id>GraphQLBeta.GraphQLBetaDemoHTML</class-id><body>I have the html page resources</body></comment><class><name>GQLSelectionSetNodeTest</name><environment>GraphQLBeta</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selectionSet objectNode1 innerEscalar objectNode2 field1 field2 context </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Tests-Nodes</category><attributes><package>GraphQLBeta-Tests-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLSelectionSetNodeTest</class-id><body>A GQLSelectionSetNodeTest is a test class for testing the behavior of GQLSelectionSetNode</body></comment><class><name>GQLNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLAbstractNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>comments </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLNode</class-id><body>I represent a node of a graphql request Public API and Key Messages- acceptVisitor:  - executeOn:with:using:To see more information go to the subclasses</body></comment><class><name>GQLDefinitionNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLDefinitionNode</class-id><body>I represent a definition on the request.For more information see my subclasses.</body></comment><class><name>GQLObjectFieldNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLObjectFieldNode</class-id><body>I represent a field of an object value.Public API and Key Messages- name- value    Instance Variables	name:		&amp;lt;String&amp;gt;	value:		&amp;lt;GQLValueNode&amp;gt;    Implementation Points</body></comment><class><name>GQLDocumentNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>operations fragments </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLDocumentNode</class-id><body>I represent a document. The principal node of the request.Public API and Key Messages- definitions- executeOn:with:using:    Instance Variables	definitions:		&amp;lt;Array&amp;gt;    Implementation Points</body></comment><class><name>GQLArgumentNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLArgumentNode</class-id><body>I represent an argument on the request.Public API and Key Messages- name- name:- value- value:- executeOn:with:using:    Instance Variables	name:		&amp;lt;String&amp;gt;	value:		&amp;lt;GQLValueNode&amp;gt;</body></comment><class><name>GQLValueNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLValueNode</class-id><body>I represent a value on a request.Public API and Key Messages- value    Instance Variables	value:		&amp;lt;String&amp;gt;    Implementation Points</body></comment><class><name>GQLFloatNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLValueNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLFloatNode</class-id><body>I represent a float value.Public API and Key Messages- executeOn:with:using:    Implementation Points</body></comment><class><name>GQLEnumNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLValueNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLEnumNode</class-id><body>I represent a enum value on the request.</body></comment><class><name>GQLIntNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLValueNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLIntNode</class-id><body>I represent a int value.Public API and Key Messages- executeOn:with:using:    Implementation Points</body></comment><class><name>GQLBooleanNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLValueNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLBooleanNode</class-id><body>I represent a boolean value.Public API and Key Messages- executeOn:with:using:    Implementation Points</body></comment><class><name>GQLVariableNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLValueNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLVariableNode</class-id><body>I represent a variable value.Public API and Key Messages- executeOn:with:using:    Implementation Points</body></comment><class><name>GQLFragmentNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLDefinitionNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name typeCondition directives selectionSet hasCycle </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLFragmentNode</class-id><body>I represent a fragment on the request.Public API and Key Messages- directives- name- selectionSet- typeCondition    Instance Variables	directives:		&amp;lt;Array&amp;gt;	name:		&amp;lt;String&amp;gt;	selectionSet:		&amp;lt;GQLSelectionSetNode&amp;gt;	typeCondition:		&amp;lt;GQLSTypeNode&amp;gt;</body></comment><class><name>GQLSelectionNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>directives </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLSelectionNode</class-id><body>I represent a selection on a request.Public API and Key Messages- directives    Instance Variables	directives:		&amp;lt;Array&amp;gt;    Implementation Points</body></comment><class><name>GQLFragmentSpreadNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLSelectionNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLFragmentSpreadNode</class-id><body>I represent a fragment spread on a request.Public API and Key Messages- name    Instance Variables	name:		&amp;lt;String&amp;gt;    Implementation Points</body></comment><class><name>GQLOperationDefinitionNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLDefinitionNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>dictIntrospectionTypes </class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLOperationDefinitionNode</class-id><body>I represent the definition of an operation on the request.To more information see my subclasses.</body></comment><class><name>GQLOperationNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLOperationDefinitionNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>type name variableDefinitions directives selectionSet rootInstance </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLOperationNode</class-id><body>I represent an operation node of a request.Public API and Key Messages- directives- name- selectionSet- type- variableDefinitions    Instance Variables	directives:		&amp;lt;Array&amp;gt;	name:		&amp;lt;String&amp;gt;	selectionSet:		&amp;lt;GQLSelectionSetNode&amp;gt;	type:		&amp;lt;GQLSTypeNode&amp;gt;	variableDefinitions:		&amp;lt;Array&amp;gt;    Implementation Points</body></comment><class><name>GQLSelectionSetNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLOperationDefinitionNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selections </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLSelectionSetNode</class-id><body>I represent a selection set on a request.Public API and Key Messages- selections- collectFields- mergeSelectionSet:with:    Instance Variables	selections:		&amp;lt;Array&amp;gt;    Implementation Points</body></comment><class><name>GQLDirectiveNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name arguments </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLDirectiveNode</class-id><body>I represent a directive on a request.Public API and Key Messages- arguments- name    Instance Variables	arguments:		&amp;lt;Array&amp;gt;	name:		&amp;lt;String&amp;gt;    Implementation Points</body></comment><class><name>GQLDefaultDirectiveNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLDirectiveNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLDefaultDirectiveNode</class-id><body>I represent an default directive defined by GraphQL specifications.Public API and Key Messages- execute</body></comment><class><name>GQLIncludeDirectiveNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLDefaultDirectiveNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLIncludeDirectiveNode</class-id><body>I represent an include directive, my argument is only one of name 'if' and type Boolean.Public API and Key Messages- condition- isInclude</body></comment><class><name>GQLSkipDirectiveNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLDefaultDirectiveNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLSkipDirectiveNode</class-id><body>I represent a skip directive, my argument is only one of name 'if' and type Boolean.Public API and Key Messages- condition- isSkip</body></comment><class><name>GQLObjectNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLValueNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>objectFields </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLObjectNode</class-id><body>I represent a object value. I'm a complex value, so I have object fields, like:{ name : "Juan", lastName : "Fernandez" }Public API and Key Messages- objectFields    Instance Variables	objectFields:		&amp;lt;Array&amp;gt;    Implementation Points</body></comment><class><name>GQLStringNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLValueNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLStringNode</class-id><body>I represent a string value.Public API and Key Messages- executeOn:with:using:    Implementation Points</body></comment><class><name>GQLFieldNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLSelectionNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>alias name arguments fullName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLFieldNode</class-id><body>I represent a field on a request.Public API and Key Messages- alias- arguments- fullName- isScalar- name    Instance Variables	alias:		&amp;lt;String&amp;gt;	arguments:		&amp;lt;Array&amp;gt;	fullName:		&amp;lt;String&amp;gt;	name:		&amp;lt;String&amp;gt;    Implementation Points</body></comment><class><name>GQLScalarFieldNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLFieldNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>dictTypeName </class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLScalarFieldNode</class-id><body>I represent a scalar field on a request.Public API and Key Messages- isScalar</body></comment><class><name>GQLNonScalarFieldNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLFieldNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selectionSet </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLNonScalarFieldNode</class-id><body>I represent a non scalar field. This means that I have a selectionSet. For examplefieldNonScalar{	fieldScalar}Public API and Key Messages- isScalar- selectionSet    Instance Variables	selectionSet:		&amp;lt;GQLSelectionSetNode&amp;gt;    Implementation Points</body></comment><class><name>GQLTypeFieldNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLNonScalarFieldNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLTypeFieldNode</class-id><body>I represent a non scalar field "__type(name: String!): __Type". This means that I have a selectionSet. For example__type(name: "FooType"){	name}</body></comment><class><name>GQLSchemaFieldNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLNonScalarFieldNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>dictNameMetaSchema </class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLSchemaFieldNode</class-id><body>I represent a non scalar field "__schema: __Schema!!". This means that I have a selectionSet. For example__schema{	queryType { name }}</body></comment><class><name>GQLVariableDefinitionNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name type defaultValue value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLVariableDefinitionNode</class-id><body>I represent a variable definition on the request.Public API and Key Messages- defaultValue- name- type    Instance Variables	defaultValue:		&amp;lt;GQLValueNode&amp;gt;	name:		&amp;lt;String&amp;gt;	type:		&amp;lt;GQLSTypeNode&amp;gt;    Implementation Points</body></comment><class><name>GQLAbstractGrammar</name><environment>GraphQLBeta</environment><super>PetitParser.PPCompositeParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sourceCharacter unicodeBOM whiteSpace lineTerminator commentChar comment comma token punctuator tokenName intValue floatValue stringValue integerPart nonZeroDigit digit fractionalPart exponentPart exponentIndicator sign stringDelimiter stringCharacter escapedUnicode escapedCharacter ignored booleanValue insignificantToken intType floatType scalarType stringType booleanType idType comments insignificantTokenNoComment ignoredNoComment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Parser</category><attributes><package>GraphQLBeta-Parser</package></attributes></class><comment><class-id>GraphQLBeta.GQLAbstractGrammar</class-id><body>I represent a abstract grammar.Public API and Key Messages- booleanValue- comma- comment- commentChar- digit- escapedCharacter - escapedUnicode - exponentIndicator - exponentPart - floatValue - fractionalPart -ignored - insignificantToken - intValue - integerPart - lineTerminator - nonZeroDigit - punctuator - sign - sourceCharacter - start- stringCharacter - stringDelimiter - stringValue - token- tokenName- unicodeBOM- whiteSpace </body></comment><class><name>GQLRequestGrammar</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLAbstractGrammar</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selection field fragmentSpread inlineFragment alias arguments argument value fragmentName typeCondition namedType variable nullValue enumValue listValue objectValue variableDefinition type listType nonNullType directive definition operationDefinition fragmentDefinition operationType variableDefinitions directives selectionSet document defaultValue objectField operation nonNullNamedType nonNullListType named scalarField nonScalarField </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Parser</category><attributes><package>GraphQLBeta-Parser</package></attributes></class><comment><class-id>GraphQLBeta.GQLRequestGrammar</class-id><body>I represent the grammar defined for a graphql request.Public API and Key Messages- alias- argument- arguments- defaultValue- definition- directive- document- enumValue- field- fragmentDefinition- fragmentName- fragmentSpread- inlineFragment- listType- listValue- namedType- nonNullType- nullValue- objectField- objectValue- operationDefinition- operationType- selection- selectionSet- start- type- typeCondition- value- variable- variableDefinition- variableDefinitions</body></comment><class><name>GQLSchemaGrammar</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLAbstractGrammar</super><private>false</private><indexed-type>none</indexed-type><inst-vars>type listType nonNull objectType objectTypeName fieldSet fieldType field fieldName schema schemaType parameterName parameters parameter inputType ignoredSpaces listInputType enumType interfaceType unionType inputObjectType enumTypeName enumValueList interfaceTypeName unionTypeName unionValuesList fieldInputObjectSet fieldInputObject inputObjectTypeName nullValue namedType nonNullType nonNullListType nonNullNamedType baseType nonNullInputType nonNullBaseType nonNullListInputType namedInputType interfaceList blockStringCharacter blockStringDelimiter description enumValue commentsInterface schemaDefinition rootOperationTypes query mutation subscription rootOperationType extension ignoreDescriptionAndComments ignoredInExtensions typeSystemToExtend typeSystemExtension objectExtension enumTypeExtension interfaceTypeExtension unionTypeExtension inputObjectTypeExtension objectTypeExtension objectTypeExtWithInterface scalarIntrospectionType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Parser</category><attributes><package>GraphQLBeta-Parser</package></attributes></class><comment><class-id>GraphQLBeta.GQLSchemaGrammar</class-id><body>I represent the grammar of the schema.Public API and Key Messages-  booleanType- field- fieldName- fieldSet- fieldType- floatType- idType- inputType- listInputType- listType- nonNull- objectType- obectTypeName- parameter- parameterName- parameters- scalarType- schema- singleInputType- singleType- start- stringType- type</body></comment><class><name>GQLSchemaGrammarEvaluator</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLSchemaGrammar</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Parser</category><attributes><package>GraphQLBeta-Parser</package></attributes></class><comment><class-id>GraphQLBeta.GQLSchemaGrammarEvaluator</class-id><body>I represent a evaluator for the schema grammar.Public API and Key Messages- field- fieldSet- inputType- listInputType- listType- objectType- parameter- parameters- schema- singleInputType- singleType- start</body></comment><class><name>GQLVariableGrammar</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLRequestGrammar</super><private>false</private><indexed-type>none</indexed-type><inst-vars>variableSet tokenValue variableValue </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Parser</category><attributes><package>GraphQLBeta-Parser</package></attributes></class><comment><class-id>GraphQLBeta.GQLVariableGrammar</class-id><body>I represent a  part of the grammar for the graphql request.Only the assignments of variables. Public API and Key Messages- variableSet- variableValue- tokenValue</body></comment><class><name>GQLVariableGrammarEvaluator</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLVariableGrammar</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Parser</category><attributes><package>GraphQLBeta-Parser</package></attributes></class><comment><class-id>GraphQLBeta.GQLVariableGrammarEvaluator</class-id><body>I represent a evaluator of variables assignmentsPublic API and Key Messages- variableSet- variableValue- tokenValue</body></comment><class><name>GQLRequestGrammarEvaluator</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLRequestGrammar</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Parser</category><attributes><package>GraphQLBeta-Parser</package></attributes></class><comment><class-id>GraphQLBeta.GQLRequestGrammarEvaluator</class-id><body>I represent a evaluator of the graphql request.</body></comment><class><name>GQLSingleAnonimousQueryGrammar</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLRequestGrammar</super><private>false</private><indexed-type>none</indexed-type><inst-vars>schemaField typeField typenameField </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Parser</category><attributes><package>GraphQLBeta-Parser</package></attributes></class><comment><class-id>GraphQLBeta.GQLSingleAnonimousQueryGrammar</class-id><body>I represent a  part of the grammar for the graphql request.Only fields with arguments. No fragments, no alias.Public API and Key Messages- document- field- selection- selectionSet- start</body></comment><class><name>GQLSingleAnonimousQueryEvaluator</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLSingleAnonimousQueryGrammar</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Parser</category><attributes><package>GraphQLBeta-Parser</package></attributes></class><comment><class-id>GraphQLBeta.GQLSingleAnonimousQueryEvaluator</class-id><body>I represent a evaluator of the graphql query single.Public API and Key Messages- argument- arguments- booleanValue- document- enumValue- field- floatValue- intValue- listValue- nullValue- objectField- objectValue- selection- selectionSet- stringValue- variable</body></comment><class><name>GraphQLBetaDemoSite</name><environment>GraphQLBeta</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>graphql </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Demo</category><attributes><package>GraphQLBeta-Demo</package></attributes></class><comment><class-id>GraphQLBeta.GraphQLBetaDemoSite</class-id><body>I am a class that creates a simple demo webapp that responds to requets and create the language of graphql</body></comment><class><name>GQLSVariableInputTest</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLAbstactTypeSystemTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Tests-TypeValidation</category><attributes><package>GraphQLBeta-Tests-TypeValidation</package></attributes></class><comment><class-id>GraphQLBeta.GQLSVariableInputTest</class-id><body>The tests in this class refer to validation in Input variables, not in the document itself</body></comment><class><name>GQLInlineFragmentNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLSelectionNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>typeCondition selectionSet </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLInlineFragmentNode</class-id><body>I represent an inline fragment on a request.Public API and Key Messages- selectionSet- typeCondition    Instance Variables	selectionSet:		&amp;lt;GQLSelectionSetNode&amp;gt;	typeCondition:		&amp;lt;GQLSTypeNode&amp;gt;    Implementation Points</body></comment><class><name>GQLTypenameFieldNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLScalarFieldNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><class><name>GQLValidator</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GraphQLObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>document text schema visitors shouldValidate rootInstance context operationName variables </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Validation</category><attributes><package>GraphQLBeta-Validation</package></attributes></class><comment><class-id>GraphQLBeta.GQLValidator</class-id><body>I am a validator, based on https://github.com/graphql/graphql-js/tree/master/src/validation</body></comment><class><name>GQLSAbstractNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GraphQLObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>position </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-NodesSchema</category><attributes><package>GraphQLBeta-NodesSchema</package></attributes></class><comment><class-id>GraphQLBeta.GQLSAbstractNode</class-id><body>I represent a abstract node generated with the descriptionPublic API and Key Messages- position- position:    Instance Variables	position:		&amp;lt;Integer&amp;gt;</body></comment><class><name>GQLSDescription</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLSAbstractNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-NodesSchema</category><attributes><package>GraphQLBeta-NodesSchema</package></attributes></class><comment><class-id>GraphQLBeta.GQLSDescription</class-id><body>I represent an description of a schema node, like:value : StringPublic API and Key Messages- value- value:     Instance Variables	value:		&amp;lt;String&amp;gt;</body></comment><class><name>GQLSNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLSAbstractNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>description comments </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-NodesSchema</category><attributes><package>GraphQLBeta-NodesSchema</package></attributes></class><comment><class-id>GraphQLBeta.GQLSNode</class-id><body>I represent a node generated by parsing the schema textPublic API and Key Messages- acceptVisitor:- initialize- position- position:- comments- comments:    Instance Variables	position:		&amp;lt;Integer&amp;gt;</body></comment><class><name>GQLSDirectiveNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLSNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name arguments directiveLocations </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-NodesSchema</category><attributes><package>GraphQLBeta-NodesSchema</package></attributes></class><comment><class-id>GraphQLBeta.GQLSDirectiveNode</class-id><body>I repreent a directive on the schemaPublic API and Key Messages - arguments- name - directiveLocations</body></comment><class><name>GQLSTypeSystemExtension</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLSNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-NodesSchema</category><attributes><package>GraphQLBeta-NodesSchema</package></attributes></class><class><name>GQLSEnumValue</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLSNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-NodesSchema</category><attributes><package>GraphQLBeta-NodesSchema</package></attributes></class><comment><class-id>GraphQLBeta.GQLSEnumValue</class-id><body>I represent an enum value of a EnumTypeNode, like:value : String! Public API and Key Messages- value- value:     Instance Variables	value:		&amp;lt;String&amp;gt;    Implementation Points</body></comment><class><name>GQLSFieldNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLSNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name type arguments fullName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-NodesSchema</category><attributes><package>GraphQLBeta-NodesSchema</package></attributes></class><comment><class-id>GraphQLBeta.GQLSFieldNode</class-id><body>I represent a field node, I'm present on object and interface types.Public API and Key Messages- addArguments: - arguments- arguments: - fullName - getArgument: - name- name: - type- type:    Instance Variables	arguments:		&amp;lt;Dictionary&amp;gt;	fullName:		&amp;lt;String&amp;gt;	name:		&amp;lt;String&amp;gt;	type:		&amp;lt;GQLSTypeNode&amp;gt;</body></comment><class><name>GQLSTypeNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLSNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-NodesSchema</category><attributes><package>GraphQLBeta-NodesSchema</package></attributes></class><comment><class-id>GraphQLBeta.GQLSTypeNode</class-id><body>I represent a type node.For more information see my subclasses</body></comment><class><name>GQLSNullTypeNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLSTypeNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>instance </class-inst-vars><imports></imports><category>GraphQLBeta-NodesSchema</category><attributes><package>GraphQLBeta-NodesSchema</package></attributes></class><comment><class-id>GraphQLBeta.GQLSNullTypeNode</class-id><body>I am null type for validation propouses</body></comment><class><name>GQLSSchemaDefinitionNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLSNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>rootOperationTypes defaultRootOpTypes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-NodesSchema</category><attributes><package>GraphQLBeta-NodesSchema</package></attributes></class><comment><class-id>GraphQLBeta.GQLSSchemaDefinitionNode</class-id><body>I represent a schema definition node, I define the root operation types.Public API and Key Messages- addRootOpTypes:with:- rootOperationTypes    Instance Variables	rootOperationTypes:		&amp;lt;Object&amp;gt;    Implementation Points</body></comment><class><name>GQLSRootOperationTypeNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLSNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name key </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-NodesSchema</category><attributes><package>GraphQLBeta-NodesSchema</package></attributes></class><comment><class-id>GraphQLBeta.GQLSRootOperationTypeNode</class-id><body>I represent a root operation of a schema definition. My root operation types only could be: query, mutation and/or subscription.</body></comment><class><name>GQLSWrapTypeNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLSTypeNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>wrappedType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-NodesSchema</category><attributes><package>GraphQLBeta-NodesSchema</package></attributes></class><comment><class-id>GraphQLBeta.GQLSWrapTypeNode</class-id><body>I represent a wrap type. Public API and Key Messages- wrappedType- wrappedType:    Instance Variables	wrappedType:		&amp;lt;GQLSTypeNode&amp;gt;</body></comment><class><name>GQLSListTypeNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLSWrapTypeNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-NodesSchema</category><attributes><package>GraphQLBeta-NodesSchema</package></attributes></class><comment><class-id>GraphQLBeta.GQLSListTypeNode</class-id><body>I represent a list type.</body></comment><class><name>GQLSSchemaNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLSNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>schemaTypes scalarTypes defaultDirectives root query schemaDefinitions schemaExtensions typeExtensions dictFieldsWithResolvers scalarTypesToDefine </inst-vars><class-inst-vars>metaSchema dictNameTypesMetaSchema </class-inst-vars><imports></imports><category>GraphQLBeta-NodesSchema</category><attributes><package>GraphQLBeta-NodesSchema</package></attributes></class><comment><class-id>GraphQLBeta.GQLSSchemaNode</class-id><body>I represent a schema node, I have different types.Public API and Key Messages- addTypes:- getType:- types- validate    Instance Variables	scalarTypes:		&amp;lt;Dictionary&amp;gt;	schemaTypes:		&amp;lt;Dictionary&amp;gt;    Implementation Points</body></comment><class><name>GQLSInputObjectFieldNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLSFieldNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-NodesSchema</category><attributes><package>GraphQLBeta-NodesSchema</package></attributes></class><comment><class-id>GraphQLBeta.GQLSInputObjectFieldNode</class-id><body>I represent a field of a input object type. My type only could be: scalar, enum or an input object.</body></comment><class><name>GQLSNonNullTypeNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLSWrapTypeNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-NodesSchema</category><attributes><package>GraphQLBeta-NodesSchema</package></attributes></class><comment><class-id>GraphQLBeta.GQLSNonNullTypeNode</class-id><body>I represent a non null type.</body></comment><class><name>GQLVariablesValidationTest</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLTestValidation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Tests-Validation</category><attributes><package>GraphQLBeta-Tests-Validation</package></attributes></class><comment><class-id>GraphQLBeta.GQLVariablesValidationTest</class-id><body>https://facebook.github.io/graphql/draft/#sec-Validation.Variables</body></comment><class><name>GQLNullNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLValueNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLNullNode</class-id><body>I represent a null value on a request.</body></comment><class><name>GQLOperationsValidationTest</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLTestValidation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Tests-Validation</category><attributes><package>GraphQLBeta-Tests-Validation</package></attributes></class><comment><class-id>GraphQLBeta.GQLOperationsValidationTest</class-id><body>https://facebook.github.io/graphql/draft/#sec-Validation.Operations</body></comment><class><name>GraphQLHeroTest</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Test-Utils</category><attributes><package>GraphQLBeta-Test-Utils</package></attributes></class><comment><class-id>GraphQLBeta.GraphQLHeroTest</class-id><body>I have a test on heroes for test resources</body></comment><class><name>GQLRequestGrammarEvaluatorTest</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Tests-Grammar</category><attributes><package>GraphQLBeta-Tests-Grammar</package></attributes></class><class><name>GQLSNamedTypeNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLSTypeNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-NodesSchema</category><attributes><package>GraphQLBeta-NodesSchema</package></attributes></class><comment><class-id>GraphQLBeta.GQLSNamedTypeNode</class-id><body>I represent a named type. Public API and Key Messages- name- name:    Instance Variables	name:		&amp;lt;String&amp;gt;</body></comment><class><name>GQLSScalarTypeNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLSNamedTypeNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-NodesSchema</category><attributes><package>GraphQLBeta-NodesSchema</package></attributes></class><comment><class-id>GraphQLBeta.GQLSScalarTypeNode</class-id><body>I represent a scalar type.Public API and Key Messages- isInputTypeFor more information see my subclasses.</body></comment><class><name>GQLSStringTypeNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLSScalarTypeNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-NodesSchema</category><attributes><package>GraphQLBeta-NodesSchema</package></attributes></class><comment><class-id>GraphQLBeta.GQLSStringTypeNode</class-id><body>I represent a string type.</body></comment><class><name>GQLSInputObjectTypeNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLSNamedTypeNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fieldSet </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-NodesSchema</category><attributes><package>GraphQLBeta-NodesSchema</package></attributes></class><comment><class-id>GraphQLBeta.GQLSInputObjectTypeNode</class-id><body>I represent a input object type. I'm a input type, used as type of an argument.Public API and Key Messages- addFields:- getField:    Instance Variables	fieldSet:		&amp;lt;Dictionary&amp;gt;    Implementation Points</body></comment><class><name>GQLSBooleanTypeNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLSScalarTypeNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-NodesSchema</category><attributes><package>GraphQLBeta-NodesSchema</package></attributes></class><comment><class-id>GraphQLBeta.GQLSBooleanTypeNode</class-id><body>I represent a boolean type.</body></comment><class><name>GQLSInterfaceTypeNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLSNamedTypeNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fields implementors </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-NodesSchema</category><attributes><package>GraphQLBeta-NodesSchema</package></attributes></class><comment><class-id>GraphQLBeta.GQLSInterfaceTypeNode</class-id><body>I represent a interface type. I have fields.Public API and Key Messages- addFields:- fields- getField:   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Instance Variables	fields:		&amp;lt;Object&amp;gt;    Implementation Points</body></comment><class><name>GQLSUnionTypeNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLSNamedTypeNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>namedTypes possibleTypes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-NodesSchema</category><attributes><package>GraphQLBeta-NodesSchema</package></attributes></class><comment><class-id>GraphQLBeta.GQLSUnionTypeNode</class-id><body>I represent a union type and i have types.Public API and Key Messages- addTypes:- namedTypes    Instance Variables	namedTypes:		&amp;lt;Dictionary&amp;gt;</body></comment><class><name>GQLSIDTypeNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLSScalarTypeNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-NodesSchema</category><attributes><package>GraphQLBeta-NodesSchema</package></attributes></class><comment><class-id>GraphQLBeta.GQLSIDTypeNode</class-id><body>I represent a id type.</body></comment><class><name>GQLSObjectTypeNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLSNamedTypeNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fieldSet interfaces </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-NodesSchema</category><attributes><package>GraphQLBeta-NodesSchema</package></attributes></class><comment><class-id>GraphQLBeta.GQLSObjectTypeNode</class-id><body>I represent a object type, i have fields and maybe some interfaces.Public API and Key Messages- addFields:- fields- getField:- implements:- interfaces    Instance Variables	fieldSet:		&amp;lt;Dictionary&amp;gt;	interfaces:		&amp;lt;Array&amp;gt;    Implementation Points</body></comment><class><name>GQLSFloatTypeNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLSScalarTypeNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-NodesSchema</category><attributes><package>GraphQLBeta-NodesSchema</package></attributes></class><comment><class-id>GraphQLBeta.GQLSFloatTypeNode</class-id><body>I represent a Float type.</body></comment><class><name>GQLSEnumTypeNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLSNamedTypeNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>enumValues </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-NodesSchema</category><attributes><package>GraphQLBeta-NodesSchema</package></attributes></class><comment><class-id>GraphQLBeta.GQLSEnumTypeNode</class-id><body>I represent a enum type. I have several values.Public API and Key Messages- addValues:- values    Instance Variables	stringValues:		&amp;lt;Array&amp;gt;    Implementation Points</body></comment><class><name>GQLOperationsVisitor</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLNodeVisitor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Visitors</category><attributes><package>GraphQLBeta-Visitors</package></attributes></class><comment><class-id>GraphQLBeta.GQLOperationsVisitor</class-id><body>I validate the operations nodes using this specificationhttps://facebook.github.io/graphql/draft/#sec-Validation.Operations</body></comment><class><name>GQLValidationException</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Core</category><attributes><package>GraphQLBeta-Core</package></attributes></class><comment><class-id>GraphQLBeta.GQLValidationException</class-id><body>I represent an exception of validation on graphql, I'm only called if the GQLSchema has a problem validating the parts of the schema vs the image of Smalltalk.Public API and Key Messages- messageClassText- messageMethodText:  aClassInstance Variables	node:		&amp;lt;Object&amp;gt;GQLValidationException new 			node: field; 			messageMethodText: Object</body></comment><class><name>GQLArgumentsTest</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLTestValidation</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Tests-Validation</category><attributes><package>GraphQLBeta-Tests-Validation</package></attributes></class><comment><class-id>GraphQLBeta.GQLArgumentsTest</class-id><body>https://facebook.github.io/graphql/draft/#sec-Validation.Arguments</body></comment><class><name>GQLTestQueryType</name><environment>GraphQLBeta</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>description gender rating boxOffice isBoxOffice </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Test-Utils</category><attributes><package>GraphQLBeta-Test-Utils</package></attributes></class><comment><class-id>GraphQLBeta.GQLTestQueryType</class-id><body>I represent a test query to test graphql requestPublic API and Key Messages- films- hello</body></comment><class><name>GQLTestSchema</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLTestQueryType</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Test-Utils</category><attributes><package>GraphQLBeta-Test-Utils</package></attributes></class><comment><class-id>GraphQLBeta.GQLTestSchema</class-id><body>I have methods for graphql schema</body></comment><class><name>GQLListNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLValueNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLListNode</class-id><body>I represent a list value. My value is an array of other valuesPublic API and Key Messages- executeOn:with:using:    Implementation Points</body></comment><class><name>GQLSIntTypeNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLSScalarTypeNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>MIN MAX </class-inst-vars><imports></imports><category>GraphQLBeta-NodesSchema</category><attributes><package>GraphQLBeta-NodesSchema</package></attributes></class><comment><class-id>GraphQLBeta.GQLSIntTypeNode</class-id><body>I represent a int type.</body></comment><class><name>GQLSSchemaNodeTest</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictSchema </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Tests-Nodes</category><attributes><package>GraphQLBeta-Tests-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLSSchemaNodeTest</class-id><body>A GQLSNodeEvaluatorTest is a test class for testing the behavior of GQLSNodeEvaluator</body></comment><methods><class-id>GraphQLBeta.GQLTestMutationType</class-id> <category>as yet unclassified</category><body package="GraphQLBeta-Test-Utils" selector="createPointX:y:">createPointX: x y: y	^ x @ y</body></methods><methods><class-id>GraphQLBeta.GraphQLDemoWorldMenu class</class-id> <category>as yet unclassified</category><body package="GraphQLBeta-Demo" selector="requestExample">requestExample	^ '{	...foo}fragment foo on Query{	allFilms{		name	}}	'</body></methods><methods><class-id>GraphQLBeta.GraphQLDemoWorldMenu class</class-id> <category>origins</category><body package="GraphQLBeta-Demo" selector="image">image	^ PNGReadWriter		formFromStream: self imageString base64Decoded asByteArray readStream</body><body package="GraphQLBeta-Demo" selector="imageString">imageString	^ 'iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAABGdBTUEAALGPC/xhBQAAACBjSFJNAAB6JgAAgIQAAPoAAACA6AAAdTAAAOpgAAA6mAAAF3CculE8AAACB1BMVEUAAADlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNavlNav////Zc6BEAAAAq3RSTlMAAAAAAAAAAAAAAAAAAAAAAAAiuroiZ///ZxFgseXlsWARAEiMZo9niFZWiWePZoxIABXM0ygyigoJijIp08sVC6P6hwmIOjmICYf6owsknRFLewICe0wRnSQWih2RJCSRHYoWiW9kZG+JI7WZEhKZtSMKoqgxNDQ0NDGoogoUy++geHl5eXeb7MsVAEeMZo5lEwwMD1l+YIxHABJinMPCj1UOaP//ZSK6uiKvO/P4AAAAAWJLR0SsV2XyiwAAAAd0SU1FB+ILFRAkMTtfxHkAAAD2SURBVBjTY2AAAUYhYRFRRgY4YGIWE5eQZGaBclnZpKRlZOXkFRTZOYBcJWUVVTV1DU0tbR1dPX0DQwYj49UmpmbmFpZW1ja2q+3sGRwcnZxdXN0YGd09PL28fXwZOP38AwKDgpm5QkLDwiMiORm4o6JjYuOAVrLFJyQmRXEzcCenpKYxAgV4eNMzMpO5GTizsnNywW5iy8svKORkKCpeXVJaVl5RUV5ZVb26ppahrn51Q2NTc0tLa1t7x+rOLobunt6+/gkTJ02eMnXa9BkzZwH18jHOnjN33vwFCxfxC0B9I8i4eMnSZYw8CO8yLl+xchUbmAkAehs/ZSlO9KwAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTgtMTEtMjFUMTY6MzY6NDktMDU6MDBSqLNsAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE4LTExLTIxVDE2OjM2OjQ5LTA1OjAwI/UL0AAAAABJRU5ErkJggg=='</body></methods><methods><class-id>GraphQLBeta.GQLTest</class-id> <category>asserting</category><body package="GraphQLBeta-Tests-Nodes" selector="assert:equals:">assert: a equals: b	compareJson = true		ifTrue: [ self assertJSONEquals: a and: b ]		ifFalse: [ super assert: a equals: b ]</body><body package="GraphQLBeta-Tests-Nodes" selector="assertComments:equals:">assertComments: aComments equals: aArray	| valueComments |	valueComments := aComments collect: [ :comment | comment value ].	self assertCollection: valueComments hasSameElements: aArray</body><body package="GraphQLBeta-Tests-Nodes" selector="assertCommentsFields:equals:">assertCommentsFields: fields equals: aArray	| aComments |	aComments := OrderedCollection new.	fields do: [ :field | aComments addAll: field comments ].	self assertComments: aComments equals: aArray</body><body package="GraphQLBeta-Tests-Nodes" selector="assertJSONEquals:and:">assertJSONEquals: aJsonString1 and: aJsonString2	self		assert:			(GraphQLPlatform current jsonFromString: aJsonString1)				= (GraphQLPlatform current jsonFromString: aJsonString2)</body></methods><methods><class-id>GraphQLBeta.GQLTest</class-id> <category>converting</category><body package="GraphQLBeta-Tests-Nodes" selector="assert:class:">assert: anObject class: aClass	self assert: anObject class equals: aClass</body><body package="GraphQLBeta-Tests-Nodes" selector="assert:fullName:">assert: anObject fullName: aName	self assert: anObject fullName equals: aName</body><body package="GraphQLBeta-Tests-Nodes" selector="assert:name:">assert: anObject name: aName	self assert: anObject name equals: aName</body><body package="GraphQLBeta-Tests-Nodes" selector="assert:position:">assert: anObject position: aInt	self assert: anObject position equals: aInt</body><body package="GraphQLBeta-Tests-Nodes" selector="assert:type:">assert: anObject type: aType	self assert: anObject type equals: aType</body><body package="GraphQLBeta-Tests-Nodes" selector="assertList:class:">assertList: aList class: aClass	aList do: [ :element | self assert: element class: aClass ]</body></methods><methods><class-id>GraphQLBeta.GQLTest</class-id> <category>parsing</category><body package="GraphQLBeta-Tests-Nodes" selector="assertArguments:ofClasses:">assertArguments: aField ofClasses: aCollection	| valuesClasses |	valuesClasses := (aField arguments collect: #value) collect: #class.	self		assert: (valuesClasses collect: [ :cls | cls name asString ])		equals: aCollection</body><body package="GraphQLBeta-Tests-Nodes" selector="assertArguments:withNames:">assertArguments: aField withNames: aCollection	self assert: (aField arguments collect: #name) equals: aCollection</body><body package="GraphQLBeta-Tests-Nodes" selector="assertArguments:withValues:">assertArguments: aField withValues: aCollection	| values |	values := (aField arguments collect: #value) collect: #value.	self assert: values equals: aCollection</body><body package="GraphQLBeta-Tests-Nodes" selector="assertList:withValues:">assertList: aList withValues: aCollection	self assert: (aList collect: #value) equals: aCollection</body><body package="GraphQLBeta-Tests-Nodes" selector="assertObjectField:withNames:">assertObjectField: anObject withNames: aCollection	self		assert: (anObject objectFields collect: #name)		equals: aCollection</body><body package="GraphQLBeta-Tests-Nodes" selector="assertObjectField:withValues:">assertObjectField: anObject withValues: aCollection	self		assert: ((anObject objectFields collect: #value) collect: #value)		equals: aCollection</body><body package="GraphQLBeta-Tests-Nodes" selector="assertSelections:withNames:">assertSelections: aField withNames: aCollection	| values |	values := aField selectionSet selections collect: #name.	self assert: values equals: aCollection</body><body package="GraphQLBeta-Tests-Nodes" selector="attendRequest:">attendRequest: text	^ self attendRequest: text using: nil with: ''</body><body package="GraphQLBeta-Tests-Nodes" selector="attendRequest:using:with:">attendRequest: text using: operationName with: textVariables	^ self		attendRequest: text		using: operationName		with: textVariables		root: rootInstance</body><body package="GraphQLBeta-Tests-Nodes" selector="attendRequest:using:with:root:">attendRequest: text using: operationName with: textVariables root: root	"The result is added a dictionary with the key 'data' according the specification found in: http://facebook.github.io/graphql/draft/#ExecuteQuery()"	| document context variables result |	document := self parseRequest: text.	textVariables isEmpty		ifFalse: [ variables := self parseVariables: textVariables ]		ifTrue: [ variables := nil ].	context := GQLContext new		addFragments: document fragments;		operationName: operationName;		variables: variables.	result := document executeOn: root with: context using: schema.	withData		ifTrue: [ ^ result ].	^ result at: 'data'</body><body package="GraphQLBeta-Tests-Nodes" selector="jsonRequest:">jsonRequest: aRequest	^ self operation: nil jsonRequest: aRequest</body><body package="GraphQLBeta-Tests-Nodes" selector="operation:jsonRequest:">operation: operation jsonRequest: aRequest	^ self operation: operation variables: '' jsonRequest: aRequest</body><body package="GraphQLBeta-Tests-Nodes" selector="operation:variables:jsonRequest:">operation: operation variables: variables jsonRequest: aRequest	| result |	result := self		attendRequest: aRequest		using: operation		with: variables.	^ GraphQLPlatform current toJson: result</body><body package="GraphQLBeta-Tests-Nodes" selector="parseRequest:">parseRequest: text	^ self requestEvaluator parse: text</body><body package="GraphQLBeta-Tests-Nodes" selector="parseSchema:">parseSchema: text	^ self schemaEvaluator parse: text</body><body package="GraphQLBeta-Tests-Nodes" selector="parseVariables:">parseVariables: text	^ self variableEvaluator parse: text</body><body package="GraphQLBeta-Tests-Nodes" selector="requestEvaluator">requestEvaluator	^ GQLRequestGrammarEvaluator</body><body package="GraphQLBeta-Tests-Nodes" selector="schemaEvaluator">schemaEvaluator	^ GQLSchemaGrammarEvaluator</body><body package="GraphQLBeta-Tests-Nodes" selector="variableEvaluator">variableEvaluator	^ GQLVariableGrammarEvaluator</body></methods><methods><class-id>GraphQLBeta.GQLTest</class-id> <category>as yet unclassified</category><body package="GraphQLBeta-Tests-Nodes" selector="validatedSchemaExtension:with:">validatedSchemaExtension: arraySchema with: resolvers	| schemaNodes |	schemaNodes := OrderedCollection new.	arraySchema		do: [ :aTextSchema | 			| schemaNode |			schemaNode := self schemaEvaluator parse: aTextSchema.			(schemaNode isKindOf: PPFailure)				ifTrue: [ ^ schemaNode ]				ifFalse: [ schemaNodes add: schemaNode ] ].	^ schemaNodes first validate: schemaNodes allButFirst with: resolvers</body><body package="GraphQLBeta-Tests-Nodes" selector="validateSchemaOf:withKey:">validateSchemaOf: dictionary withKey: keySchema	| aSchema |	dictionary		at: keySchema		ifPresent: [ :value | 			| schemas resolvers |			schemas := value first.			resolvers := value second.			aSchema := self validatedSchemaExtension: schemas with: resolvers.			(aSchema isKindOf: GQLSSchemaNode)				ifTrue: [ aSchema root: value third.					rootInstance := value third ] ]		ifAbsent: [ aSchema := nil ].	^ aSchema</body></methods><methods><class-id>GraphQLBeta.GraphQLBetaTest</class-id> <category>tests</category><body package="GraphQLBeta-Tests-Nodes" selector="testDocumentCycledFragments">testDocumentCycledFragments	| request result |	compareJson := true.	request := '{		a{		   ...data		}	}	fragment data on GQLA{		hey		...other	}	fragment other on GQLA{		hey		...data	}	'.	result := graphQL jsonRequest: request.	self		assert: result		equals:			'{	"errors" : [		{			"message" : "Cannot spread fragment \"data\" with itself via other",			"locations" : [				{					"line" : 8,					"column" : 6				}			]		},		{			"message" : "Cannot spread fragment \"other\" with itself via data",			"locations" : [				{					"line" : 12,					"column" : 6				}			]		}	]}'</body><body package="GraphQLBeta-Tests-Nodes" selector="testDocumentUniqueFragments">testDocumentUniqueFragments	| request result |	compareJson := true.	request := '{		a{		   ...data		}	}	fragment data on GQLA{		hey		...other	}	fragment data on GQLA{		hey	}	'.	result := graphQL jsonRequest: request.	self		assert: result		equals:			'{	"errors" : [		{			"message" : "There can be only one fragment named \"data\".",			"locations" : [				{					"line" : 6,					"column" : 11				},				{					"line" : 10,					"column" : 11				}			]		},		{			"message" : "Unknown fragment \"other\".",			"locations" : [				{					"line" : 8,					"column" : 6				}			]		}	]}'</body><body package="GraphQLBeta-Tests-Nodes" selector="testDocumentUnusedFragments">testDocumentUnusedFragments	| request result |	compareJson := true.	request := '{		a{		   ...data		}	}	fragment data on GQLA{		hey		heyID	}	fragment unused on GQLA{		hey	}	'.	result := graphQL jsonRequest: request.	self		assert: result		equals:			'{	"errors" : [		{			"message" : "Fragment \"unused\" is never used.",			"locations" : [				{					"line" : 10,					"column" : 11				}			]		}	]}'</body><body package="GraphQLBeta-Tests-Nodes" selector="testQuerySimple">testQuerySimple	| request response |	request := '{		hello		a { hey }	}'.	response := (graphQL handleRequest: request) at: 'data'.	self assert: response class: OrderedDictionary.	self assert: (response at: 'hello') asString equals: 'helloWorld'.	self assert: (response at: 'hello') ~= 'hello World'.	self assert: (response at: 'a') class: OrderedDictionary.	self assert: ((response at: 'a') at: 'hey') asString equals: 'heyhey'</body><body package="GraphQLBeta-Tests-Nodes" selector="testQueryWithFragments">testQueryWithFragments	| request response subResponse |	request := '{		a{		   ...data		}	}	fragment data on GQLA{		hey		heyID	}'.	response := (graphQL handleRequest: request) at: 'data'.	self assert: response class: OrderedDictionary.	subResponse := response at: 'a'.	self assert: subResponse class: OrderedDictionary.	self assert: (subResponse at: 'hey') equals: #heyhey.	self assert: (subResponse at: 'heyID') equals: 'id: nil'</body><body package="GraphQLBeta-Tests-Nodes" selector="testQueryWithFragmentsDirectives">testQueryWithFragmentsDirectives	| request response subResponse |	request := '{		a{		   ...data		}	}	fragment data on GQLA{		hey		heyID @skip(if:true)	}'.	response := (graphQL handleRequest: request) at: 'data'.	self assert: response class: OrderedDictionary.	subResponse := response at: 'a'.	self assert: subResponse class: OrderedDictionary.	self assert: (subResponse at: 'hey') equals: #heyhey.	self deny: (subResponse includes: 'heyID')</body><body package="GraphQLBeta-Tests-Nodes" selector="testQueryWithIncompletelyDefinedVariable">testQueryWithIncompletelyDefinedVariable	| request result |	compareJson := true.	request := '	query operation1($name: String){	    hello(name:$name)       sum(nums:$nums)		 an(gqla:$gqla){		     id		 }		 a(id:$id){		    id		 }   }   query operation2{     hello   }'.	result := graphQL		operation: 'operation1';		variables: '{"name":"Alex", "nums":[1, 3, 4, 5], "gqla":{id:1}, "id":2}';		jsonRequest: request.	self		assert: result		equals:			'{	"errors" : [		{			"message" : "Unknown argument \"name\" on field \"hello\" on type \"GQLIQueryType\".",			"locations" : [				{					"line" : 3,					"column" : 12				}			]		},		{			"message" : "Variable \"nums\" is not defined by operation \"operation1\".",			"locations" : [				{					"line" : 4,					"column" : 17				},				{					"line" : 2,					"column" : 8				}			]		},		{			"message" : "Variable \"gqla\" is not defined by operation \"operation1\".",			"locations" : [				{					"line" : 5,					"column" : 12				},				{					"line" : 2,					"column" : 8				}			]		},		{			"message" : "Variable \"id\" is not defined by operation \"operation1\".",			"locations" : [				{					"line" : 8,					"column" : 9				},				{					"line" : 2,					"column" : 8				}			]		}	]}'</body><body package="GraphQLBeta-Tests-Nodes" selector="testQueryWithInlineFragment">testQueryWithInlineFragment	| request response subResponse |	request := '{		a{		   ...{				hey				heyID			}		}	}'.	response := (graphQL handleRequest: request) at: 'data'.	self assert: response class: OrderedDictionary.	subResponse := response at: 'a'.	self assert: subResponse class: OrderedDictionary.	self assert: (subResponse at: 'hey') equals: #heyhey.	self assert: (subResponse at: 'heyID') equals: 'id: nil'</body><body package="GraphQLBeta-Tests-Nodes" selector="testQueryWithInlineFragmentDirectives">testQueryWithInlineFragmentDirectives	| request response subResponse |	request := '{		a{		   ... @include(if:false){				hey				heyID			}		}	}'.	response := (graphQL handleRequest: request) at: 'data'.	self assert: response class: OrderedDictionary.	subResponse := response at: 'a'.	self assert: subResponse isEmpty</body><body package="GraphQLBeta-Tests-Nodes" selector="testQueryWithInlineFragmentType">testQueryWithInlineFragmentType	| request response subResponse |	request := '{		a{		   ... on GQLA @include(if:false){				hey				heyID			}		}	}'.	response := (graphQL handleRequest: request) at: 'data'.	self assert: response class: OrderedDictionary.	subResponse := response at: 'a'.	self assert: subResponse isEmpty</body><body package="GraphQLBeta-Tests-Nodes" selector="testQueryWithParamameters">testQueryWithParamameters	| request response |	request := '{		helloFor(name:"Luke Skywalker")		hello		sum(nums:[1,2,3,4])		a { hey }	}'.	response := (graphQL handleRequest: request) at: 'data'.	self assert: response class: OrderedDictionary.	self assert: (response at: 'helloFor') equals: 'helloLuke Skywalker'.	self assert: (response at: 'hello') ~= 'hello World'.	self assert: (response at: 'a') class: OrderedDictionary.	self assert: ((response at: 'a') at: 'hey') asString equals: 'heyhey'.	self assert: (response at: 'sum') equals: 10</body><body package="GraphQLBeta-Tests-Nodes" selector="testQueryWithParamametersOnObjects">testQueryWithParamametersOnObjects	| request response |	request := '{		helloFor(name:"Luke Skywalker")		hello		sum(nums:[1,2,3,4])		a(id:"asdf1231asdf") { heyID }	}'.	response := (graphQL handleRequest: request) at: 'data'.	self assert: response class: OrderedDictionary.	self assert: (response at: 'helloFor') equals: 'helloLuke Skywalker'.	self assert: (response at: 'hello') ~= 'hello World'.	self assert: (response at: 'a') class: OrderedDictionary.	self		assert: ((response at: 'a') at: 'heyID') asString		equals: 'id: asdf1231asdf'.	self assert: (response at: 'sum') equals: 10</body><body package="GraphQLBeta-Tests-Nodes" selector="testQueryWithUndefinedVariable">testQueryWithUndefinedVariable	| request result |	compareJson := true.	request := '	query operation1{	    hello(name:$name)       sum(nums:$nums)		 an(gqla:$gqla){		     id		 }		 a(id:$id){		    id		 }   }   query operation2{     hello   }'.	result := graphQL		variables: '{"name":"Alex", "nums":[1, 3, 4, 5], "gqla":{id:1}, "id":2}';		operation: 'operation1';		jsonRequest: request.	self		assert: result		equals:			'{	"errors" : [		{			"message" : "Unknown argument \"name\" on field \"hello\" on type \"GQLIQueryType\".",			"locations" : [				{					"line" : 3,					"column" : 12				}			]		},		{			"message" : "Variable \"name\" is not defined by operation \"operation1\".",			"locations" : [				{					"line" : 3,					"column" : 17				},				{					"line" : 2,					"column" : 8				}			]		},		{			"message" : "Variable \"nums\" is not defined by operation \"operation1\".",			"locations" : [				{					"line" : 4,					"column" : 17				},				{					"line" : 2,					"column" : 8				}			]		},		{			"message" : "Variable \"gqla\" is not defined by operation \"operation1\".",			"locations" : [				{					"line" : 5,					"column" : 12				},				{					"line" : 2,					"column" : 8				}			]		},		{			"message" : "Variable \"id\" is not defined by operation \"operation1\".",			"locations" : [				{					"line" : 8,					"column" : 9				},				{					"line" : 2,					"column" : 8				}			]		}	]}'</body><body package="GraphQLBeta-Tests-Nodes" selector="testQueryWithVariables">testQueryWithVariables	| request response |	request := '	query operation1($name:String, $nums:[Int], $gqla:GQLAInput, $id:ID){	    helloFor(name:$name)       sum(nums:$nums)		 an(gqla:$gqla){		     id		 }		 a(id:$id){		    id		 }   }   query operation2{     hello   }'.	response := (graphQL		operation: 'operation1';		variables: '{"name":"Alex", "nums":[1, 3, 4, 5], "gqla":{id:1}, "id":null}';		handleRequest: request) at: 'data'.	self assert: response class: OrderedDictionary.	self assert: (response at: 'helloFor') equals: 'helloAlex'.	self assert: (response at: 'sum') equals: 13.	self assert: (response at: 'an') class: OrderedDictionary.	self assert: ((response at: 'an') at: 'id') equals: 1.	self assert: ((response at: 'a') at: 'id') equals: nil</body><body package="GraphQLBeta-Tests-Nodes" selector="testRequestUnableToParse">testRequestUnableToParse	| text request result |	compareJson := true.	text := '				schema { 					query: GQLIQueryType				}				type GQLIQueryType {					hello : String					a : GQLA				}				type GQLA {					hey : String				}'.	graphQL createSchema: text.	request := '{		hello		a {  }	}'.	result := graphQL handleRequest: request.	self assert: (result includesKey: 'errors')</body><body package="GraphQLBeta-Tests-Nodes" selector="testSchemaInvalid">testSchemaInvalid	| text |	text := 'type GQLIQueryType {					hello : String					a : GQLA				}				type A {					hey : String				}'.	graphQL createSchema: text.	self assert: graphQL schema class: GQLValidationException</body><body package="GraphQLBeta-Tests-Nodes" selector="testSchemaProbeInterfaces">testSchemaProbeInterfaces	| request response |	request := '{		helloFor(name:"Luke Skywalker")		hello		sum(nums:[1,2,3,4])		a { hey }	}'.	response := (graphQL handleRequest: request) at: 'data'.	self assert: response class: OrderedDictionary.	self assert: (response at: 'helloFor') equals: 'helloLuke Skywalker'.	self assert: (response at: 'hello') ~= 'hello World'.	self assert: (response at: 'a') class: OrderedDictionary.	self assert: ((response at: 'a') at: 'hey') asString equals: 'heyhey'.	self assert: (response at: 'sum') equals: 10</body><body package="GraphQLBeta-Tests-Nodes" selector="testSchemaProbeUnions">testSchemaProbeUnions	| request response |	request := '{		...fragmentQuery	}	fragment fragmentQuery on Queries{		... on GQLIQueryType { 			helloFor(name:"Luke Skywalker")			hello			sum(nums:[1,2,3,4])			a { hey }		}	}'.	response := (graphQL handleRequest: request) at: 'data'.	self assert: response class: OrderedDictionary.	self assert: (response at: 'helloFor') equals: 'helloLuke Skywalker'.	self assert: (response at: 'hello') ~= 'hello World'.	self assert: (response at: 'a') class: OrderedDictionary.	self assert: ((response at: 'a') at: 'hey') asString equals: 'heyhey'.	self assert: (response at: 'sum') equals: 10</body><body package="GraphQLBeta-Tests-Nodes" selector="testSchemaUnableToParse">testSchemaUnableToParse	| text |	text := 'type GQLIQueryType {					hello : String					a : 				}				type GQLA {					hey : String				}'.	self		assert: (graphQL createSchema: text)		class: GQLEvaluationException</body></methods><methods><class-id>GraphQLBeta.GraphQLBetaTest</class-id> <category>running</category><body package="GraphQLBeta-Tests-Nodes" selector="setUp">setUp	| text |	text := 'union Queries = GQLIQueryType			schema { 				query: GQLIQueryType			}			interface GQLQuery{				hello : String			}			input GQLAInput{				id: ID			}			type GQLIQueryType implements GQLQuery{					helloFor(name:String) : String					hello : String					sum(nums:[Int]) : Int					a : GQLA					an(gqla: GQLAInput): GQLA					a(id:ID) : GQLA				}				type GQLA {					hey : String					heyID : String					id: ID				}'.	graphQL := GraphQL new.	graphQL rootInstance: GQLIQueryType new.	graphQL createSchema: text.	graphQL schema root: GQLIQueryType new.	withData := false</body></methods><methods><class-id>GraphQLBeta.GQLSingleAnonimousQueryEvaluatorTest</class-id> <category>tests-accessing</category><body package="GraphQLBeta-Tests-Grammar" selector="requestEvaluator">requestEvaluator	^ GQLSingleAnonimousQueryEvaluator</body><body package="GraphQLBeta-Tests-Grammar" selector="testDocument">testDocument	| request document |	request := '{		hello	}'.	document := GQLSingleAnonimousQueryEvaluator parse: request.	self assert: document class equals: GQLDocumentNode.	self		assert: document operations first class		equals: GQLSelectionSetNode.	self		assert: document operations first selections first class		equals: GQLScalarFieldNode.	self		assert: document operations first selections first name		equals: 'hello'.	request := '{		hello		films { 			name			rating		}	}'.	document := GQLSingleAnonimousQueryEvaluator parse: request.	self assert: document class equals: GQLDocumentNode.	self		assert: document operations first class		equals: GQLSelectionSetNode.	self		assert: document operations first selections first class		equals: GQLScalarFieldNode.	self		assert: document operations first selections second class		equals: GQLNonScalarFieldNode.	self		assert: document operations first selections first name		equals: 'hello'.	self		assert: document operations first selections second name		equals: 'films'.	"object inner fields"	self		assert:			(document operations first selections second selectionSet selections				at: 1) class		equals: GQLScalarFieldNode.	self		assert:			(document operations first selections second selectionSet selections				at: 1) name		equals: 'name'.	self		assert:			(document operations first selections second selectionSet selections				at: 2) class		equals: GQLScalarFieldNode.	self		assert:			(document operations first selections second selectionSet selections				at: 2) name		equals: 'rating'</body></methods><methods><class-id>GraphQLBeta.GQLSingleAnonimousQueryEvaluatorTest</class-id> <category>tests-introspection</category><body package="GraphQLBeta-Tests-Grammar" selector="testDocumentComposedWithSchema">testDocumentComposedWithSchema	| document selection |	document := GQLSingleAnonimousQueryEvaluator parse: '{		__schema{			types{				id			}			otherField		}	}'.	self assert: document class equals: GQLDocumentNode.	self assert: document operations first class equals: GQLSelectionSetNode.	selection := document operations first selections first.	self assert: selection class equals: GQLSchemaFieldNode.	self assert: selection name equals: '__schema'.	self assert: (selection selectionSet selections collect: [:select | select name]) equals: #('types' 'otherField').</body><body package="GraphQLBeta-Tests-Grammar" selector="testDocumentComposedWithSchemaDirectives">testDocumentComposedWithSchemaDirectives	| document selection |	document := GQLSingleAnonimousQueryEvaluator parse: '{		__schema @skip(if:true){			types{				id			}			otherField		}	}'.	self assert: document class equals: GQLDocumentNode.	self assert: document operations first class equals: GQLSelectionSetNode.	selection := document operations first selections first.	self assert: selection class equals: GQLSchemaFieldNode.	self assert: selection name equals: '__schema'.	self assert: selection directives first name equals: 'skip'.	self assert: (selection selectionSet selections collect: [:select | select name]) equals: #('types' 'otherField').</body><body package="GraphQLBeta-Tests-Grammar" selector="testDocumentComposedWithType">testDocumentComposedWithType	| document selection |	document := GQLSingleAnonimousQueryEvaluator		parse:			'{		__type(name: "SomeType"){			name			otherFields{				id			}		}	}'.	self assert: document class equals: GQLDocumentNode.	self		assert: document operations first class		equals: GQLSelectionSetNode.	selection := document operations first selections first.	self assert: selection class equals: GQLTypeFieldNode.	self assert: selection name equals: '__type'.	self assert: selection arguments first class equals: GQLArgumentNode.	self assert: selection arguments first name equals: 'name'.	self		assert: (selection selectionSet selections collect: [ :select | select name ])		equals: #('name' 'otherFields')</body><body package="GraphQLBeta-Tests-Grammar" selector="testDocumentComposedWithTypeDirectives">testDocumentComposedWithTypeDirectives	| document selection |	document := GQLSingleAnonimousQueryEvaluator		parse:			'{		__type(name: "SomeType") @include(if:false){			name			otherFields{				id			}		}	}'.	self assert: document class equals: GQLDocumentNode.	self		assert: document operations first class		equals: GQLSelectionSetNode.	selection := document operations first selections first.	self assert: selection class equals: GQLTypeFieldNode.	self assert: selection name equals: '__type'.	self assert: selection directives first name equals: 'include'.	self assert: selection arguments first class equals: GQLArgumentNode.	self assert: selection arguments first name equals: 'name'.	self		assert: (selection selectionSet selections collect: [ :select | select name ])		equals: #('name' 'otherFields')</body><body package="GraphQLBeta-Tests-Grammar" selector="testDocumentSimpleWithTypename">testDocumentSimpleWithTypename	| request document selectionSet |	request := '{		__typename	}'.	document := GQLSingleAnonimousQueryEvaluator parse: request.	selectionSet := document operations first.	self assert: document class equals: GQLDocumentNode.	self assert: selectionSet class equals: GQLSelectionSetNode.	self		assert: selectionSet selections first class		equals: GQLTypenameFieldNode.	self assert: selectionSet selections first name equals: '__typename'</body><body package="GraphQLBeta-Tests-Grammar" selector="testDocumentSimpleWithTypenameDirectives">testDocumentSimpleWithTypenameDirectives	| document selectionSet |	document := GQLSingleAnonimousQueryEvaluator		parse:			'{		__typename @include(if:true)	}'.	selectionSet := document operations first.	self assert: document class equals: GQLDocumentNode.	self assert: selectionSet class equals: GQLSelectionSetNode.	self		assert: selectionSet selections first class		equals: GQLTypenameFieldNode.	self assert: selectionSet selections first name equals: '__typename'.	self		assert: selectionSet selections first directives first name		equals: 'include'.	document := GQLSingleAnonimousQueryEvaluator		parse:			'{		__typename @skip(if:true)	}'.	selectionSet := document operations first.	self assert: document class equals: GQLDocumentNode.	self assert: selectionSet class equals: GQLSelectionSetNode.	self		assert: selectionSet selections first class		equals: GQLTypenameFieldNode.	self assert: selectionSet selections first name equals: '__typename'.	self		assert: selectionSet selections first directives first name		equals: 'skip'</body></methods><methods><class-id>GraphQLBeta.GQLSingleAnonimousQueryEvaluatorTest</class-id> <category>tests-inlineFragment</category><body package="GraphQLBeta-Tests-Grammar" selector="testDocumentSimpleComposedInlineFragment">testDocumentSimpleComposedInlineFragment	| request document inline |	request := '{		...{		 name		 ...{			hello(arg : 1) 		 }		}	}'.	document := GQLSingleAnonimousQueryEvaluator parse: request.	inline := document operations first selections first.	self assert: document class equals: GQLDocumentNode.	self assert: inline class equals: GQLInlineFragmentNode.	self assert: inline typeCondition equals: nil.	self assert: inline directives equals: #().	self assert: inline selectionSet selections first name equals: 'name'.	inline := inline selectionSet selections second.	self assert: inline class equals: GQLInlineFragmentNode.	self		assert: inline selectionSet selections first name		equals: 'hello'</body><body package="GraphQLBeta-Tests-Grammar" selector="testDocumentSimpleInlineFragment">testDocumentSimpleInlineFragment	| request document inline |	request := '{		...{		name @skip(if : false)		hello(arg : 1) 		}	}'.	document := GQLSingleAnonimousQueryEvaluator parse: request.	inline := document operations first selections first.	self assert: document class equals: GQLDocumentNode.	self assert: inline class equals: GQLInlineFragmentNode.	self assert: inline typeCondition equals: nil.	self assert: inline directives equals: #().	self assert: inline selectionSet selections first name equals: 'name'.	self		assert: inline selectionSet selections second name		equals: 'hello'</body><body package="GraphQLBeta-Tests-Grammar" selector="testDocumentSimpleInlineFragmentDirectives">testDocumentSimpleInlineFragmentDirectives	| request document inline |	request := '{	   hello		... on Film @skip(if:true){		name @skip(if : false)		hello(arg : 1) 		}	}'.	document := GQLSingleAnonimousQueryEvaluator parse: request.	inline := document operations first selections second.	self assert: document class equals: GQLDocumentNode.	self assert: inline class equals: GQLInlineFragmentNode.	self assert: inline typeCondition class equals: GQLSNamedTypeNode.	self assert: inline typeCondition name equals: 'Film'.	self		assert: inline directives first class		equals: GQLSkipDirectiveNode.	self assert: inline selectionSet selections first name equals: 'name'.	self		assert: inline selectionSet selections second name		equals: 'hello'</body><body package="GraphQLBeta-Tests-Grammar" selector="testDocumentSimpleInlineFragmentType">testDocumentSimpleInlineFragmentType	| request document inline |	request := '{		... on Film{		name @skip(if : false)		hello(arg : 1) 		}	}'.	document := GQLSingleAnonimousQueryEvaluator parse: request.	inline := document operations first selections first.	self assert: document class equals: GQLDocumentNode.	self assert: inline class equals: GQLInlineFragmentNode.	self assert: inline typeCondition class equals: GQLSNamedTypeNode.	self assert: inline typeCondition name equals: 'Film'.	self assert: inline directives equals: #().	self assert: inline selectionSet selections first name equals: 'name'.	self		assert: inline selectionSet selections second name		equals: 'hello'</body></methods><methods><class-id>GraphQLBeta.GQLSingleAnonimousQueryEvaluatorTest</class-id> <category>tests-fieldsFeatures</category><body package="GraphQLBeta-Tests-Grammar" selector="testDocumentPosition">testDocumentPosition	| request document fields |	request := '{		hello		films	}'.	document := GQLSingleAnonimousQueryEvaluator parse: request.	fields := document operations first selections.	self assert: fields first position equals: 5.	self assert: fields second position equals: 13</body><body package="GraphQLBeta-Tests-Grammar" selector="testDocumentWithArgumentsPosition">testDocumentWithArgumentsPosition	| request document fields arguments |	request := '{		hello (name : "Luke")	}'.	document := GQLSingleAnonimousQueryEvaluator parse: request.	fields := document operations first selections.	arguments := fields first arguments.	self assert: fields first position equals: 5.	self assert: arguments first position equals: 12</body><body package="GraphQLBeta-Tests-Grammar" selector="testFieldsAlias">testFieldsAlias	| document userField subField |	document := self		parseRequest:			'{  				user(id: 4) {    					name    					smallPic: profilePic(size: 64)    					bigPic: profilePic(size: 1024)  			}		}'.	self assert: document class: GQLDocumentNode.	userField := document operations first selections first.	self assert: userField class: GQLNonScalarFieldNode.	self assert: userField name: 'user'.	self assert: userField arguments first name: 'id'.	self		assertSelections: userField		withNames: #('name' 'profilePic' 'profilePic').	subField := userField selectionSet selections second.	self assert: subField alias equals: 'smallPic'.	self assertArguments: subField withValues: #('64').	subField := userField selectionSet selections third.	self assert: subField alias equals: 'bigPic'.	self assertArguments: subField withValues: #('1024')</body></methods><methods><class-id>GraphQLBeta.GQLSingleAnonimousQueryEvaluatorTest</class-id> <category>tests-fieldsScalar</category><body package="GraphQLBeta-Tests-Grammar" selector="testDocumentSimpleWithArguments">testDocumentSimpleWithArguments	| request document selectionSet |	request := '{		hello (name: "Luke")	}'.	document := GQLSingleAnonimousQueryEvaluator parse: request.	selectionSet := document operations first.	self assert: document class equals: GQLDocumentNode.	self assert: selectionSet class equals: GQLSelectionSetNode.	self		assert: selectionSet selections first class		equals: GQLScalarFieldNode.	self assert: selectionSet selections first name equals: 'hello'.	self		assert: ((selectionSet selections at: 1) arguments at: 1) class		equals: GQLArgumentNode.	self		assert: ((selectionSet selections at: 1) arguments at: 1) name		equals: 'name'.	self		assert: ((selectionSet selections at: 1) arguments at: 1) value class		equals: GQLStringNode</body><body package="GraphQLBeta-Tests-Grammar" selector="testDocumentSimpleWithArgumentsAndDirective">testDocumentSimpleWithArgumentsAndDirective	| request document selectionSet |	request := '{		hello (name: "Luke") @include(if : true)	}'.	document := GQLSingleAnonimousQueryEvaluator parse: request.	selectionSet := document operations first.	self assert: document class equals: GQLDocumentNode.	self assert: selectionSet class equals: GQLSelectionSetNode.	self		assert: selectionSet selections first class		equals: GQLScalarFieldNode.	self assert: selectionSet selections first name equals: 'hello'.	self		assert: ((selectionSet selections at: 1) arguments at: 1) class		equals: GQLArgumentNode.	self		assert: ((selectionSet selections at: 1) arguments at: 1) name		equals: 'name'.	self		assert: ((selectionSet selections at: 1) arguments at: 1) value class		equals: GQLStringNode.	self		assert: (selectionSet selections at: 1) directives size		equals: 1.	self		assert: (selectionSet selections at: 1) directives first		class: GQLIncludeDirectiveNode.	self		assertArguments: (selectionSet selections at: 1) directives first		withNames: #('if').	self		assertArguments: (selectionSet selections at: 1) directives first		withValues: #('true')</body><body package="GraphQLBeta-Tests-Grammar" selector="testDocumentSimpleWithArgumentsAndDirectives">testDocumentSimpleWithArgumentsAndDirectives	| request document selectionSet |	request := '{		hello (name: "Luke") @include(if : true) @skip(if : false)	}'.	document := GQLSingleAnonimousQueryEvaluator parse: request.	selectionSet := document operations first.	self assert: document class equals: GQLDocumentNode.	self assert: selectionSet class equals: GQLSelectionSetNode.	self		assert: selectionSet selections first class		equals: GQLScalarFieldNode.	self assert: selectionSet selections first name equals: 'hello'.	self		assert: ((selectionSet selections at: 1) arguments at: 1) class		equals: GQLArgumentNode.	self		assert: ((selectionSet selections at: 1) arguments at: 1) name		equals: 'name'.	self		assert: ((selectionSet selections at: 1) arguments at: 1) value class		equals: GQLStringNode.	self		assert: (selectionSet selections at: 1) directives size		equals: 2.	self		assert: (selectionSet selections at: 1) directives first		class: GQLIncludeDirectiveNode.	self		assertArguments: (selectionSet selections at: 1) directives first		withNames: #('if').	self		assertArguments: (selectionSet selections at: 1) directives first		withValues: #('true').	self		assert: (selectionSet selections at: 1) directives second		class: GQLSkipDirectiveNode.	self		assertArguments: (selectionSet selections at: 1) directives second		withNames: #('if').	self		assertArguments: (selectionSet selections at: 1) directives second		withValues: #('false')</body></methods><methods><class-id>GraphQLBeta.GQLSingleAnonimousQueryEvaluatorTest</class-id> <category>tests-fieldsNonScalar</category><body package="GraphQLBeta-Tests-Grammar" selector="testDocumentComposedWithArguments">testDocumentComposedWithArguments	| request document selectionSet |	request := '{		hello(name: "Luke")		films { 			name (capitalize:true, prefix: "Film ")			rating		}	}'.	document := GQLSingleAnonimousQueryEvaluator parse: request.	selectionSet := document operations first.	self assert: document class equals: GQLDocumentNode.	self assert: selectionSet class equals: GQLSelectionSetNode.	self		assert: (selectionSet selections at: 1) class		equals: GQLScalarFieldNode.	self assert: (selectionSet selections at: 1) name equals: 'hello'.	self		assert: (selectionSet selections at: 2) class		equals: GQLNonScalarFieldNode.	self assert: (selectionSet selections at: 2) name equals: 'films'.	"arguments"	self		assert: ((selectionSet selections at: 1) arguments at: 1) class		equals: GQLArgumentNode.	self		assert: ((selectionSet selections at: 1) arguments at: 1) name		equals: 'name'.	self		assert: ((selectionSet selections at: 1) arguments at: 1) value class		equals: GQLStringNode.	"object inner fields"	self		assert: ((selectionSet selections at: 2) selectionSet selections at: 1) class		equals: GQLScalarFieldNode.	self		assert: ((selectionSet selections at: 2) selectionSet selections at: 1) name		equals: 'name'.	self		assert: ((selectionSet selections at: 2) selectionSet selections at: 2) class		equals: GQLScalarFieldNode.	self		assert: ((selectionSet selections at: 2) selectionSet selections at: 2) name		equals: 'rating'.	"arguments"	self		assert:			(((selectionSet selections at: 2) selectionSet selections at: 1)				arguments at: 1) class		equals: GQLArgumentNode.	self		assert:			(((selectionSet selections at: 2) selectionSet selections at: 1)				arguments at: 1) name		equals: 'capitalize'.	self		assert:			(((selectionSet selections at: 2) selectionSet selections at: 1)				arguments at: 2) name		equals: 'prefix'</body><body package="GraphQLBeta-Tests-Grammar" selector="testDocumentComposePosition">testDocumentComposePosition	| request document fields selectionSet |	request := '{		hello		films { 			name			rating		}	}'.	document := GQLSingleAnonimousQueryEvaluator parse: request.	fields := document operations first selections.	selectionSet := fields second selectionSet selections.	self assert: fields first position equals: 5.	self assert: fields second position equals: 13.	self assert: selectionSet first position equals: 25.	self assert: selectionSet second position equals: 33</body></methods><methods><class-id>GraphQLBeta.GQLSingleAnonimousQueryEvaluatorTest</class-id> <category>tests-fragmentSpread</category><body package="GraphQLBeta-Tests-Grammar" selector="testDocumentSimpleComposedFragmentSpread">testDocumentSimpleComposedFragmentSpread	| request document fragmentSpread |	request := '{		...named		hello	}	fragment named on Person{		...other @skip(if : true)		hello(arg : 1) 	}	fragment other on Droid{		name	}	'.	document := GQLSingleAnonimousQueryEvaluator parse: request.	fragmentSpread := document operations first selections first.	self assert: document class equals: GQLDocumentNode.	self assert: fragmentSpread class equals: GQLFragmentSpreadNode.	self assert: fragmentSpread name: 'named'.	fragmentSpread := document fragments first selectionSet selections		first.	self assert: fragmentSpread class equals: GQLFragmentSpreadNode.	self assert: fragmentSpread name: 'other'.	self		assert: fragmentSpread directives first		class: GQLSkipDirectiveNode</body><body package="GraphQLBeta-Tests-Grammar" selector="testDocumentSimpleFragmentSpread">testDocumentSimpleFragmentSpread	| request document fragmentSpread |	request := '{		...named		...other @skip(if : true)		hello	}	fragment named on Person{		name @skip(if : false)		hello(arg : 1) 	}	fragment other on Droid{		name	}	'.	document := GQLSingleAnonimousQueryEvaluator parse: request.	fragmentSpread := document operations first selections first.	self assert: document class equals: GQLDocumentNode.	self assert: fragmentSpread class equals: GQLFragmentSpreadNode.	self assert: fragmentSpread name: 'named'.	fragmentSpread := document operations first selections second.	self assert: fragmentSpread class equals: GQLFragmentSpreadNode.	self assert: fragmentSpread name: 'other'.	self		assert: fragmentSpread directives first		class: GQLSkipDirectiveNode</body></methods><methods><class-id>GraphQLBeta.GQLSingleAnonimousQueryEvaluatorTest</class-id> <category>tests-fragment</category><body package="GraphQLBeta-Tests-Grammar" selector="testDocumentSimpleFragmentDefinition">testDocumentSimpleFragmentDefinition	| request document fragment |	request := '{		hello (name: "Luke")	}	fragment named on Person{		name @skip(if : false)		hello(arg : 1) 	}	fragment other on Droid{		name	}	'.	document := GQLSingleAnonimousQueryEvaluator parse: request.	fragment := document fragments first.	self assert: document class equals: GQLDocumentNode.	self assert: fragment class equals: GQLFragmentNode.	self assert: fragment name: 'named'.	self assert: fragment typeCondition class: GQLSNamedTypeNode.	self assert: fragment typeCondition name: 'Person'.	self assert: fragment selectionSet selections size equals: 2.	self assert: fragment selectionSet selections first name: 'name'.	self assert: fragment selectionSet selections second name: 'hello'.	fragment := document fragments second.	self assert: fragment class equals: GQLFragmentNode.	self assert: fragment name: 'other'.	self assert: fragment typeCondition class: GQLSNamedTypeNode.	self assert: fragment typeCondition name: 'Droid'.	self assert: fragment selectionSet selections size equals: 1.	self assert: fragment selectionSet selections first name: 'name'</body></methods><methods><class-id>GraphQLBeta.GraphQLPlatform</class-id> <category>printing format</category><body package="GraphQLBeta-Core" selector="printError:">printError: ex	| s |	s := String new writeStream.	[ s		nextPutAll: ex asString;		cr;		nextPutAll:			(String				streamContents: [ :stream | 					ex signalerContext						ifNotNil: [ :context | context debugStackOn: stream ] ]) ]		ensure: [ s close ].	^ s contents</body></methods><methods><class-id>GraphQLBeta.GraphQLPlatform</class-id> <category>server</category><body package="GraphQLBeta-Core" selector="okResponse:">okResponse: string	self subclassResponsibility</body><body package="GraphQLBeta-Core" selector="registerDemoServer:">registerDemoServer: demo	self subclassResponsibility</body><body package="GraphQLBeta-Core" selector="request:at:">request: aRequest at: nameQuery	self subclassResponsibility</body><body package="GraphQLBeta-Core" selector="serverErrorResponse:">serverErrorResponse: string	self subclassResponsibility</body><body package="GraphQLBeta-Core" selector="serverStop">serverStop	self subclassResponsibility</body></methods><methods><class-id>GraphQLBeta.GraphQLPlatform</class-id> <category>accessing - classes</category><body package="GraphQLBeta-Core" selector="classAt:">classAt: symbol	self subclassResponsibility</body><body package="GraphQLBeta-Core" selector="jsonFromString:">jsonFromString: string	self subclassResponsibility</body><body package="GraphQLBeta-Core" selector="jsonWriter">jsonWriter	self subclassResponsibility</body><body package="GraphQLBeta-Core" selector="toJson:">toJson: object	self subclassResponsibility</body></methods><methods><class-id>GraphQLBeta.GraphQLPlatform class</class-id> <category>accessing</category><body package="GraphQLBeta-Core" selector="current">current	^ instance		ifNil: [ instance := (self subclasses select: [ :cls | cls isActive ]) first				new ]</body></methods><methods><class-id>GraphQLBeta.GQLFieldNodeTest</class-id> <category>test-nonScalarFields</category><body package="GraphQLBeta-Tests-Nodes" selector="testNonScalarEvaluateDirectivesTrue">testNonScalarEvaluateDirectivesTrue	"Evaluate return true if:	- directives are empty	- include is true and skip is false"	self		assert: (nonScalarField evaluateDirectives: schema using: context).	nonScalarField directives: (self includeDirective: true).	self		assert: (nonScalarField evaluateDirectives: schema using: context).	nonScalarField directives: (self skipDirective: false).	self		assert: (nonScalarField evaluateDirectives: schema using: context).	nonScalarField		directives: (self includeDirective: true skipDirective: false).	self		assert: (nonScalarField evaluateDirectives: schema using: context).	nonScalarField		directives: (self skipDirective: false includeDirective: true).	self		assert: (nonScalarField evaluateDirectives: schema using: context)</body><body package="GraphQLBeta-Tests-Nodes" selector="testNonScalarFieldsEvaluateDirectivesFalse">testNonScalarFieldsEvaluateDirectivesFalse	"Evaluate return false if:	- duplicated directives	- any directive is not defined by default directives on schema"	nonScalarField directives: (self doubleIncludeDirective: true).	self deny: (nonScalarField evaluateDirectives: schema using: context).	nonScalarField directives: (self doubleSkipDirective: false).	self deny: (nonScalarField evaluateDirectives: schema using: context).	nonScalarField directives: self negatedIncludeDirectives.	self deny: (nonScalarField evaluateDirectives: schema using: context).	scalarField directives: self negatedSkipDirectives.	self deny: (nonScalarField evaluateDirectives: schema using: context).	nonScalarField		directives: (Array with: (GQLDirectiveNode new name: 'other')).	self deny: (nonScalarField evaluateDirectives: schema using: context)</body></methods><methods><class-id>GraphQLBeta.GQLFieldNodeTest</class-id> <category>tests-scalarFields</category><body package="GraphQLBeta-Tests-Nodes" selector="testScalarEvaluateDirectivesTrue">testScalarEvaluateDirectivesTrue	"Evaluate return true if:	- directives are empty	- include is true and skip is false"	self assert: (scalarField evaluateDirectives: schema using: context).	scalarField directives: (self includeDirective: true).	self assert: (scalarField evaluateDirectives: schema using: context).	scalarField directives: (self skipDirective: false).	self assert: (scalarField evaluateDirectives: schema using: context).	scalarField		directives: (self includeDirective: true skipDirective: false).	self assert: (scalarField evaluateDirectives: schema using: context).	scalarField		directives: (self skipDirective: false includeDirective: true).	self assert: (scalarField evaluateDirectives: schema using: context)</body><body package="GraphQLBeta-Tests-Nodes" selector="testScalarFieldsEvaluateDirectivesFalse">testScalarFieldsEvaluateDirectivesFalse	"Evaluate return false if:	- duplicated directives	- any directive is not defined by default directives on schema"	scalarField directives: (self doubleIncludeDirective: true).	self deny: (scalarField evaluateDirectives: schema using: context).	scalarField directives: (self doubleSkipDirective: false).	self deny: (scalarField evaluateDirectives: schema using: context).	scalarField directives: self negatedIncludeDirectives.	self deny: (scalarField evaluateDirectives: schema using: context).	scalarField directives: self negatedSkipDirectives.	self deny: (scalarField evaluateDirectives: schema using: context).	scalarField		directives: (Array with: (GQLDirectiveNode new name: 'other')).	self deny: (scalarField evaluateDirectives: schema using: context)</body></methods><methods><class-id>GraphQLBeta.GQLFieldNodeTest</class-id> <category>utils</category><body package="GraphQLBeta-Tests-Nodes" selector="doubleIncludeDirective:">doubleIncludeDirective: aValue	| directive |	directive := (self includeDirective: aValue) first.	^ Array with: directive with: directive</body><body package="GraphQLBeta-Tests-Nodes" selector="doubleSkipDirective:">doubleSkipDirective: aValue	| directive |	directive := (self skipDirective: aValue) first.	^ Array with: directive with: directive</body><body package="GraphQLBeta-Tests-Nodes" selector="includeDirective:">includeDirective: aValue	| directive |	directive := GQLIncludeDirectiveNode new.	directive arguments first value value: aValue asString.	^ Array with: directive</body><body package="GraphQLBeta-Tests-Nodes" selector="includeDirective:skipDirective:">includeDirective: firstValue skipDirective: secondValue	| directiveI directiveS |	directiveI := (self includeDirective: firstValue) first.	directiveS := (self skipDirective: secondValue) first.	^ Array with: directiveI with: directiveS</body><body package="GraphQLBeta-Tests-Nodes" selector="negatedIncludeDirectives">negatedIncludeDirectives	^ Array		with: (self includeDirective: true) first		with: (self includeDirective: false) first</body><body package="GraphQLBeta-Tests-Nodes" selector="negatedSkipDirectives">negatedSkipDirectives	^ Array		with: (self skipDirective: false) first		with: (self skipDirective: true) first</body><body package="GraphQLBeta-Tests-Nodes" selector="skipDirective:">skipDirective: aValue	| directive |	directive := GQLSkipDirectiveNode new.	directive arguments first value value: aValue asString.	^ Array with: directive</body><body package="GraphQLBeta-Tests-Nodes" selector="skipDirective:includeDirective:">skipDirective: secondValue includeDirective: firstValue	| directiveI directiveS |	directiveI := (self includeDirective: firstValue) first.	directiveS := (self skipDirective: secondValue) first.	^ Array with: directiveS with: directiveI</body></methods><methods><class-id>GraphQLBeta.GQLFieldNodeTest</class-id> <category>running</category><body package="GraphQLBeta-Tests-Nodes" selector="setUp">setUp	schema := GQLSSchemaNode new.	scalarField := GQLScalarFieldNode new name: 'name'.	nonScalarField := GQLNonScalarFieldNode new name: 'allFilms'.	context := nil</body></methods><methods><class-id>GraphQLBeta.GQLDocumentNodeTest</class-id> <category>test-simpleRequest</category><body package="GraphQLBeta-Tests-Nodes" selector="testMutationArgumentsWithOneVariable">testMutationArgumentsWithOneVariable	| response text textVariables |	text := '	mutation pointCreation($x : Int) {		createPoint(x: $x, y: 2){			x y		}	}	'.	textVariables := '{"x":1}'.	response := self		attendRequest: text		using: 'pointCreation'		with: textVariables		root: GQLTestMutationType new.	self assert: response class: OrderedDictionary.	self assert: (response at: 'createPoint') class: OrderedDictionary.	self assert: ((response at: 'createPoint') at: 'x') equals: 1</body><body package="GraphQLBeta-Tests-Nodes" selector="testMutationArgumentsWithOneVariableAndManyAssignment">testMutationArgumentsWithOneVariableAndManyAssignment	| response text textVariables |	text := '	mutation pointCreation($x : Int) {		createPoint(x: $x, y: 2){			x y		}	}	'.	textVariables := '{"x":5, "x":4, "x":1}'.	response := self		attendRequest: text		using: 'pointCreation'		with: textVariables		root: GQLTestMutationType new.	self assert: response class: OrderedDictionary.	self assert: (response at: 'createPoint') class: OrderedDictionary.	self assert: ((response at: 'createPoint') at: 'x') equals: 1</body><body package="GraphQLBeta-Tests-Nodes" selector="testMutationArgumentsWithVariableAndDefaultValue">testMutationArgumentsWithVariableAndDefaultValue	| response text textVariables |	text := '	mutation pointCreation($x : Int = 1) {		createPoint(x: $x, y: 2){			x y		}	}	'.	textVariables := ''.	response := self		attendRequest: text		using: 'pointCreation'		with: textVariables		root: GQLTestMutationType new.	self assert: response class: OrderedDictionary.	self assert: (response at: 'createPoint') class: OrderedDictionary.	self assert: ((response at: 'createPoint') at: 'x') equals: 1</body><body package="GraphQLBeta-Tests-Nodes" selector="testMutationArgumentsWithVariableAndFragment">testMutationArgumentsWithVariableAndFragment	| response text textVariables |	text := '	mutation pointCreation($x : Int) {		createPoint(x: $x, y: 2){			...data		}	}		fragment data on Point{	   x y	}	'.	textVariables := '{"x":1}'.	response := self		attendRequest: text		using: 'pointCreation'		with: textVariables		root: GQLTestMutationType new.	self assert: response class: OrderedDictionary.	self assert: (response at: 'createPoint') class: OrderedDictionary.	self assert: ((response at: 'createPoint') at: 'x') equals: 1</body><body package="GraphQLBeta-Tests-Nodes" selector="testSimpleRequestArgumentsExcludeWithTwoDirective">testSimpleRequestArgumentsExcludeWithTwoDirective	| response |	response := self		attendRequest:			'{		helloTo(name: "Alex") @skip(if : true) @include(if : true)	}'.	self assert: response isEmpty.	response := self		attendRequest:			'{		helloTo(name: "Alex") @skip(if : true) @include(if : false)	}'.	self assert: response isEmpty.	response := self		attendRequest:			'{		helloTo(name: "Alex") @include(if : false) @skip(if : true)	}'.	self assert: response isEmpty.	response := self		attendRequest:			'{		helloTo(name: "Alex") @skip(if : false) @include(if : false)	}'.	self assert: response isEmpty</body><body package="GraphQLBeta-Tests-Nodes" selector="testSimpleRequestArgumentsIncludeWithTwoDirective">testSimpleRequestArgumentsIncludeWithTwoDirective	| response |	response := self		attendRequest:			'{		helloTo(name: "Alex") @skip(if : false) @include(if : true)	}'.	self assert: response class: OrderedDictionary.	response := self		attendRequest:			'{		helloTo(name: "Alex") @include(if : true) @skip(if : false)	}'.	self assert: response class: OrderedDictionary</body><body package="GraphQLBeta-Tests-Nodes" selector="testSimpleRequestArgumentsWithDirectiveExclude">testSimpleRequestArgumentsWithDirectiveExclude	| response |	response := self		attendRequest:			'{		helloTo(name : "Alex") @skip(if : true)	}'.	self assert: response class: OrderedDictionary.	self assert: response isEmpty.	response := self		attendRequest:			'{		helloTo(name : "Alex") @include(if : false)	}'.	self assert: response class: OrderedDictionary.	self assert: response isEmpty</body><body package="GraphQLBeta-Tests-Nodes" selector="testSimpleRequestArgumentsWithDirectiveInclude">testSimpleRequestArgumentsWithDirectiveInclude	| response |	response := self		attendRequest:			'{		helloTo(name : "Alex") @skip(if : false)	}'.	self assert: response class: OrderedDictionary.	self assert: (response at: 'helloTo') equals: 'hello Alex'.	response := self		attendRequest:			'{		helloTo(name : "Alex") @include(if : true)	}'.	self assert: response class: OrderedDictionary.	self assert: (response at: 'helloTo') equals: 'hello Alex'</body><body package="GraphQLBeta-Tests-Nodes" selector="testSimpleRequestArgumentsWithDuplicateDirective">testSimpleRequestArgumentsWithDuplicateDirective	| text |	text := '{		helloTo(name:"Alex") @skip(if : true) @skip(if : false)	}'.	self should: [ self attendRequest: text ] raise: GQLException.	text := '{		helloTo(name:"Alex") @include(if : true) @include(if : false)	}'.	self should: [ self attendRequest: text ] raise: GQLException</body><body package="GraphQLBeta-Tests-Nodes" selector="testSimpleRequestArgumentsWithEnumType">testSimpleRequestArgumentsWithEnumType	| response |	response := self		attendRequest:			'{		classification(gender: ACTION)	}'.	self assert: response class: OrderedDictionary.	self assert: (response at: 'classification') equals: 'ACTION'</body><body package="GraphQLBeta-Tests-Nodes" selector="testSimpleRequestArgumentsWithOneVariable">testSimpleRequestArgumentsWithOneVariable	| response text textVariables |	text := '	query operationHello($name: String){		helloTo(name: $name)	}	'.	textVariables := '{"name":"Alex"}'.	response := self		attendRequest: text		using: 'operationHello'		with: textVariables.	self assert: response class: OrderedDictionary.	self assert: (response at: 'helloTo') equals: 'hello Alex'</body><body package="GraphQLBeta-Tests-Nodes" selector="testSimpleRequestArgumentsWithOneVariableAndManyAssignment">testSimpleRequestArgumentsWithOneVariableAndManyAssignment	| response text textVariables |	text := '	query operationHello($name: String){		helloTo(name: $name)	}	'.	textVariables := '{"name":"Alex", "name":"Mary", "name":"Juan"}'.	response := self		attendRequest: text		using: 'operationHello'		with: textVariables.	self assert: response class: OrderedDictionary.	self assert: (response at: 'helloTo') equals: 'hello Juan'</body><body package="GraphQLBeta-Tests-Nodes" selector="testSimpleRequestArgumentsWithVariableAndDefaultValue">testSimpleRequestArgumentsWithVariableAndDefaultValue	| response text textVariables |	text := '	query operationHello($name: String="Alex"){		helloTo(name: $name)	}	'.	textVariables := ''.	response := self		attendRequest: text		using: 'operationHello'		with: textVariables.	self assert: response class: OrderedDictionary.	self assert: (response at: 'helloTo') equals: 'hello Alex'</body><body package="GraphQLBeta-Tests-Nodes" selector="testSimpleRequestArgumentsWithVariableAndDirectiveExclude">testSimpleRequestArgumentsWithVariableAndDirectiveExclude	| text textVariables response |	text := '	query operationClassification($gender: MovieType){		classification(gender: $gender) @skip(if: true)	}	'.	textVariables := '{"gender":ACTION}'.	response := self		attendRequest: text		using: 'operationClassification'		with: textVariables.	self assert: response class: OrderedDictionary.	self assert: response isEmpty.	text := '	query operationClassification($gender: MovieType){		classification(gender: $gender) @include(if: false)	}	'.	textVariables := '{"gender":ACTION}'.	response := self		attendRequest: text		using: 'operationClassification'		with: textVariables.	self assert: response class: OrderedDictionary.	self assert: response isEmpty</body><body package="GraphQLBeta-Tests-Nodes" selector="testSimpleRequestArgumentsWithVariableAndDirectiveInclude">testSimpleRequestArgumentsWithVariableAndDirectiveInclude	| response text textVariables |	text := '	query operationClassification($gender: MovieType){		classification(gender: $gender) @skip(if: false)	}	'.	textVariables := '{"gender":ACTION}'.	response := self		attendRequest: text		using: 'operationClassification'		with: textVariables.	self assert: response class: OrderedDictionary.	self assert: (response at: 'classification') equals: 'ACTION'.	text := '	query operationClassification($gender: MovieType){		classification(gender: $gender) @include(if: true)	}	'.	textVariables := '{"gender":ACTION}'.	response := self		attendRequest: text		using: 'operationClassification'		with: textVariables.	self assert: response class: OrderedDictionary.	self assert: (response at: 'classification') equals: 'ACTION'</body><body package="GraphQLBeta-Tests-Nodes" selector="testSimpleRequestArgumentsWithVariableAndFragment">testSimpleRequestArgumentsWithVariableAndFragment	| response text textVariables |	text := '	query operationHello($name: String){		...fragmentHello	}		fragment fragmentHello on GQLTestQueryType{	   helloTo(name: $name)	}	'.	textVariables := '{"name":"Alex"}'.	response := self		attendRequest: text		using: 'operationHello'		with: textVariables.	self assert: response class: OrderedDictionary.	self assert: (response at: 'helloTo') equals: 'hello Alex'</body><body package="GraphQLBeta-Tests-Nodes" selector="testSimpleRequestArgumentsWithVariableAssignedAndDefaultValue">testSimpleRequestArgumentsWithVariableAssignedAndDefaultValue	| response text textVariables |	text := '	query operationHello($name: String="Alex"){		helloTo(name: $name)	}	'.	textVariables := '{"name":"Mary"}'.	response := self		attendRequest: text		using: 'operationHello'		with: textVariables.	self assert: response class: OrderedDictionary.	self assert: (response at: 'helloTo') equals: 'hello Mary'</body><body package="GraphQLBeta-Tests-Nodes" selector="testSimpleRequestExcludeWithTwoDirective">testSimpleRequestExcludeWithTwoDirective	| response |	response := self		attendRequest:			'{		hello @skip(if : true) @include(if : true)	}'.	self assert: response isEmpty.	response := self		attendRequest:			'{		hello @skip(if : true) @include(if : false)	}'.	self assert: response isEmpty.	response := self		attendRequest:			'{		hello @include(if : false) @skip(if : true)	}'.	self assert: response isEmpty.	response := self		attendRequest:			'{		hello @skip(if : false) @include(if : false)	}'.	self assert: response isEmpty</body><body package="GraphQLBeta-Tests-Nodes" selector="testSimpleRequestIncludeWithTwoDirective">testSimpleRequestIncludeWithTwoDirective	| response |	response := self		attendRequest:			'{		hello @skip(if : false) @include(if : true)	}'.	self deny: response isEmpty.	response := self		attendRequest:			'{		hello @include(if : true) @skip(if : false)	}'.	self deny: response isEmpty</body><body package="GraphQLBeta-Tests-Nodes" selector="testSimpleRequestInterpret">testSimpleRequestInterpret	| response |	response := self		attendRequest:			'{		hello	}'.	self assert: response class: OrderedDictionary.	self assert: (response at: 'hello') equals: 'hello world'</body><body package="GraphQLBeta-Tests-Nodes" selector="testSimpleRequestInterpretInlineFragments">testSimpleRequestInterpretInlineFragments	| response |	response := self		attendRequest:			'{		...{			hello		}	}'.	self assert: response class: OrderedDictionary.	self assert: (response at: 'hello') equals: 'hello world'.	self assert: response size equals: 1</body><body package="GraphQLBeta-Tests-Nodes" selector="testSimpleRequestInterpretInlineFragmentsDirectives">testSimpleRequestInterpretInlineFragmentsDirectives	| response |	response := self		attendRequest:			'{		... on GQLTestQueryType @include(if:true){			hello		}	}'.	self assert: response class: OrderedDictionary.	self assert: (response at: 'hello') equals: 'hello world'.	self assert: response size equals: 1</body><body package="GraphQLBeta-Tests-Nodes" selector="testSimpleRequestInterpretInlineFragmentsType">testSimpleRequestInterpretInlineFragmentsType	| response |	response := self		attendRequest:			'{		... on GQLTestQueryType{			hello		}	}'.	self assert: response class: OrderedDictionary.	self assert: (response at: 'hello') equals: 'hello world'.	self assert: response size equals: 1</body><body package="GraphQLBeta-Tests-Nodes" selector="testSimpleRequestInterpretSpreadFragments">testSimpleRequestInterpretSpreadFragments	| response |	response := self		attendRequest:			'{		hello		...helloFragment	}	fragment helloFragment on GQLTestQueryType{		hello	}	'.	self assert: response class: OrderedDictionary.	self assert: (response at: 'hello') equals: 'hello world'.	self assert: response size equals: 1</body><body package="GraphQLBeta-Tests-Nodes" selector="testSimpleRequestInterpretWithAlias">testSimpleRequestInterpretWithAlias	| response |	response := self		attendRequest:			'{		myMessage : hello	}'.	self assert: response class: OrderedDictionary.	self assert: (response at: 'myMessage') equals: 'hello world'</body><body package="GraphQLBeta-Tests-Nodes" selector="testSimpleRequestInterpretWithInputObject">testSimpleRequestInterpretWithInputObject	| response |	response := self		attendRequest:			'{		information(film: {			description : "Fiction science movie",			gender : "Fiction science"		}) { 				description		 }	}'.	self assert: response class: OrderedDictionary.	self assert: (response at: 'information') class: OrderedDictionary.	self		assert: ((response at: 'information') at: 'description')		equals: 'Fiction science movie'</body><body package="GraphQLBeta-Tests-Nodes" selector="testSimpleRequestInterpretWithInputObjectModified">testSimpleRequestInterpretWithInputObjectModified	| response |	response := self		attendRequest:			'{		informationInput(film: {			filmName : "Fiction science movie"		}) { 				description		 }	}'.	self assert: response class: OrderedDictionary.	self		assert: (response at: 'informationInput')		class: OrderedDictionary.	self		assert: ((response at: 'informationInput') at: 'description')		equals: 'Fiction science movie'</body><body package="GraphQLBeta-Tests-Nodes" selector="testSimpleRequestInterpretWithInputObjectOfDifferentTypeFields">testSimpleRequestInterpretWithInputObjectOfDifferentTypeFields	| response |	response := self		attendRequest:			'{		detailedInformation(film: {			rating : 9,			boxOffice: 12345523.34,			gender : "Fiction science",			isBoxOffice : true		}) { 				gender				boxOffice				rating				isBoxOffice		 }	}'.	self assert: response class: OrderedDictionary.	response := response at: 'detailedInformation'.	self assert: response class: OrderedDictionary.	self assert: response size equals: 4.	self assert: (response at: 'gender') equals: 'Fiction science'.	self assert: (response at: 'boxOffice') equals: 12345523.34.	self assert: (response at: 'rating') equals: 9.	self assert: (response at: 'isBoxOffice') equals: true</body><body package="GraphQLBeta-Tests-Nodes" selector="testSimpleRequestInterpretWithInputObjectOfScalarType">testSimpleRequestInterpretWithInputObjectOfScalarType	| response |	response := self		attendRequest:			'{		features(film: {filmName: "Pirates of the Caribbean"})	}'.	self assert: response class: OrderedDictionary.	self		assert: (response at: 'features')		equals: 'Pirates of the Caribbean'</body><body package="GraphQLBeta-Tests-Nodes" selector="testSimpleRequestInterpretWithListInputObject">testSimpleRequestInterpretWithListInputObject	| response |	response := self		attendRequest:			'{		totalInformation(film: [ 				{description : "Fiction science movie",				gender : "Fiction science"}, 				{description : "Animated cartoon movie"}, 				{gender : "Animated cartoon"}		]){			description			gender		}	}'.	self assert: response class: OrderedDictionary.	response := response at: 'totalInformation'.	self assert: response class: OrderedCollection.	self assert: response size equals: 3.	self assert: response first class: OrderedDictionary.	self		assert: (response first at: 'description')		equals: 'Fiction science movie'.	self assert: (response first at: 'gender') equals: 'Fiction science'.	self		assert: (response second at: 'description')		equals: 'Animated cartoon movie'.	self assert: (response second at: 'gender') isNil.	self assert: (response third at: 'description') isNil.	self assert: (response third at: 'gender') equals: 'Animated cartoon'</body><body package="GraphQLBeta-Tests-Nodes" selector="testSimpleRequestSameFieldAlias">testSimpleRequestSameFieldAlias	| response |	response := self		attendRequest:			'{		hello		myMessage : hello	}'.	self assert: response class: OrderedDictionary.	self assert: (response at: 'hello') equals: 'hello world'.	self assert: (response at: 'myMessage') equals: 'hello world'</body><body package="GraphQLBeta-Tests-Nodes" selector="testSimpleRequestSpreadFragmentsWithDirectives">testSimpleRequestSpreadFragmentsWithDirectives	| response |	response := self		attendRequest:			'{		films{			name		}		...helloFragment @skip(if : true)	}	fragment helloFragment on GQLTestQueryType{		hello	}'.	self assert: response class: OrderedDictionary.	self deny: (response keys includes: 'hello').	self assert: (response keys includes: 'films')</body><body package="GraphQLBeta-Tests-Nodes" selector="testSimpleRequestUnknowSpreadFragments">testSimpleRequestUnknowSpreadFragments	| text |	text := '{		hello		...helloFragment	}	fragment fragmentHello on GQLTestQueryType{		hello	}	'.	self should: [ self attendRequest: text ] raise: GQLException</body><body package="GraphQLBeta-Tests-Nodes" selector="testSimpleRequestWithDirectiveExclude">testSimpleRequestWithDirectiveExclude	| response |	response := self		attendRequest:			'{		hello @skip(if : true)	}'.	self assert: response class: OrderedDictionary.	self assert: response isEmpty.	response := self		attendRequest:			'{		hello @include(if : false)	}'.	self assert: response class: OrderedDictionary.	self assert: response isEmpty</body><body package="GraphQLBeta-Tests-Nodes" selector="testSimpleRequestWithDirectiveInclude">testSimpleRequestWithDirectiveInclude	| response |	response := self		attendRequest:			'{		hello @skip(if : false)	}'.	self assert: response class: OrderedDictionary.	self assert: (response at: 'hello') equals: 'hello world'.	response := self		attendRequest:			'{		hello @include(if : true)	}'.	self assert: response class: OrderedDictionary.	self assert: (response at: 'hello') equals: 'hello world'</body><body package="GraphQLBeta-Tests-Nodes" selector="testSimpleRequestWithDuplicateDirective">testSimpleRequestWithDuplicateDirective	| text |	text := '{		hello @skip(if : true) @skip(if : false)	}'.	self should: [ self attendRequest: text ] raise: GQLException.	text := '{		hello @include(if : true) @include(if : false)	}'.	self should: [ self attendRequest: text ] raise: GQLException</body><body package="GraphQLBeta-Tests-Nodes" selector="testSimpleRequestWithManyOperationQuery">testSimpleRequestWithManyOperationQuery	| response text |	text := 'query operationHello {		hello	}	query operationHelloTo {		helloTo(name: "Alex")	}'.	response := self attendRequest: text using: 'operationHello' with: ''.	self assert: response class: OrderedDictionary.	self assert: (response at: 'hello') equals: 'hello world'</body><body package="GraphQLBeta-Tests-Nodes" selector="testSimpleRequestWithManyOperationQueryAndUnknownOperationName">testSimpleRequestWithManyOperationQueryAndUnknownOperationName	| text |	text := '	query operationHello {		hello	}	query operationHelloTo {		helloTo(name: "Alex")	}'.	self		should: [ self attendRequest: text using: 'operationUnknown' with: '' ]		raise: GQLException</body><body package="GraphQLBeta-Tests-Nodes" selector="testSimpleRequestWithManyOperationQueryAndWithoutOperationName">testSimpleRequestWithManyOperationQueryAndWithoutOperationName	| text |	text := '	query operationHello {		hello	}	query operationHelloTo {		helloTo(name: "Alex")	}'.	self		should: [ self attendRequest: text using: nil with: '' ]		raise: GQLException</body><body package="GraphQLBeta-Tests-Nodes" selector="testSimpleRequestWithManyOperationQueryWithDirectiveExclude">testSimpleRequestWithManyOperationQueryWithDirectiveExclude	| response text |	text := 'query operationHello {		hello @skip(if: true)	}	query operationHelloTo {		helloTo(name: "Alex") @skip(if: true)	}'.	response := self attendRequest: text using: 'operationHello' with: ''.	self assert: response class: OrderedDictionary.	self assert: response isEmpty.	text := '	query operationHello {		hello @include(if: false)	}	query operationHelloTo {		helloTo(name: "Alex") @include(if: false)	}'.	response := self attendRequest: text using: 'operationHello' with: ''.	self assert: response class: OrderedDictionary.	self assert: response isEmpty</body><body package="GraphQLBeta-Tests-Nodes" selector="testSimpleRequestWithManyOperationQueryWithDirectiveInclude">testSimpleRequestWithManyOperationQueryWithDirectiveInclude	| response text |	text := '	query operationHello {		hello @skip(if: false)	}	query operationHelloTo {		helloTo(name: "Alex") @skip(if: false)	}'.	response := self		attendRequest: text		using: 'operationHelloTo'		with: ''.	self assert: response class: OrderedDictionary.	self assert: (response at: 'helloTo') equals: 'hello Alex'.	text := '	query operationHello {		hello @include(if: true)	}	query operationHelloTo {		helloTo(name: "Alex") @include(if: true)	}'.	response := self		attendRequest: text		using: 'operationHelloTo'		with: ''.	self assert: response class: OrderedDictionary.	self assert: (response at: 'helloTo') equals: 'hello Alex'</body><body package="GraphQLBeta-Tests-Nodes" selector="testSimpleRequestWithOneOperationQuery">testSimpleRequestWithOneOperationQuery	| response text |	text := '	query operationHello {		hello	}'.	response := self attendRequest: text using: 'operationHello' with: ''.	self assert: response class: OrderedDictionary.	self assert: (response at: 'hello') equals: 'hello world'</body><body package="GraphQLBeta-Tests-Nodes" selector="testSimpleRequestWithOneOperationQueryAndWithoutOperationName">testSimpleRequestWithOneOperationQueryAndWithoutOperationName	| response text |	text := '	query operationHello {		hello	}'.	response := self attendRequest: text using: nil with: ''.	self assert: response class: OrderedDictionary.	self assert: (response at: 'hello') equals: 'hello world'</body><body package="GraphQLBeta-Tests-Nodes" selector="testSimpleRequestWithUnknownDirective">testSimpleRequestWithUnknownDirective	| text |	text := '{		hello @unknownDirective	}'.	self should: [ self attendRequest: text ] raise: GQLException.	text := '{		hello @unknownDirective(if : false)	}'.	self should: [ self attendRequest: text ] raise: GQLException</body></methods><methods><class-id>GraphQLBeta.GQLDocumentNodeTest</class-id> <category>test-fragment</category><body package="GraphQLBeta-Tests-Nodes" selector="testCyclesFragment">testCyclesFragment	| document |	document := self		parseRequest:			'{		filmsWith(rating: 5) @skip(if : false) @include(if : true){			...named		}	}	fragment named on Film{		name		...other	}	fragment other on Film{		id	   ...named	}'.	self should: [ document evaluate ] raise: GQLException</body><body package="GraphQLBeta-Tests-Nodes" selector="testNoCyclesFragment">testNoCyclesFragment	| document |	document := self		parseRequest:			'{		filmsWith(rating: 5) @skip(if : false) @include(if : true){			...named		}	}	fragment named on Film{		name		...other	}	fragment other on Film{		id	}'.	self assert: document evaluate class: GQLDocumentNode</body><body package="GraphQLBeta-Tests-Nodes" selector="testUniquenessFragment">testUniquenessFragment	| document |	document := self		parseRequest:			'{		filmsWith(rating: 5) @skip(if : false) @include(if : true){			...named		}	}	fragment named on Film{		name	}	fragment named on Film{	   name	}'.	self should: [ document evaluate ] raise: GQLException</body><body package="GraphQLBeta-Tests-Nodes" selector="testUsedFragments">testUsedFragments	| document |	document := self		parseRequest:			'{		hello	}	fragment fragmentHello on GQLTestQueryType{		hello	}'.	self should: [ document evaluate ] raise: GQLException</body><body package="GraphQLBeta-Tests-Nodes" selector="testUsedInlineFragments">testUsedInlineFragments	| document |	document := self		parseRequest:			'{		...fragmentHello	}	fragment fragmentHello on GQLTestQueryType{		hello		... { 			...fragmentOther		 }	}	fragment fragmentOther on GQLTestQueryType{		hello	}'.	self assert: document evaluate class: GQLDocumentNode</body></methods><methods><class-id>GraphQLBeta.GQLDocumentNodeTest</class-id> <category>test-composeRequest</category><body package="GraphQLBeta-Tests-Nodes" selector="testComposedRequestInlineFragment">testComposedRequestInlineFragment	| response subResponse |	response := self		attendRequest:			'{		filmsWith(rating:5){			... {				name				rating			}		}	}'.	self assert: response class: OrderedDictionary.	subResponse := response at: 'filmsWith'.	self assert: subResponse size equals: 3.	self assert: subResponse first size equals: 2</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposedRequestInlineFragmentDirectives">testComposedRequestInlineFragmentDirectives	| response subResponse |	response := self		attendRequest:			'{		filmsWith(rating:5){			... @skip(if: true){				name				rating			}		}	}'.	self assert: response class: OrderedDictionary.	subResponse := response at: 'filmsWith'.	subResponse do: [ :sub | self assert: sub isEmpty ]</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposedRequestInlineFragmentType">testComposedRequestInlineFragmentType	| response subResponse |	response := self		attendRequest:			'{		filmsWith(rating:5){			... on GQLTestFilm{				name				rating			}		}	}'.	self assert: response class: OrderedDictionary.	subResponse := response at: 'filmsWith'.	self assert: subResponse size equals: 3.	self assert: subResponse first size equals: 2</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposedRequestInterpret">testComposedRequestInterpret	| response subResponse |	response := self		attendRequest:			'{		hello		hello		films { 			rating			name		}	}'.	self assert: response class: OrderedDictionary.	subResponse := response at: 'hello'.	self assert: subResponse equals: 'hello world'.	subResponse := response at: 'films'.	self assert: subResponse class: OrderedCollection.	self assert: (subResponse first at: 'rating') equals: 9.	self		assert: (subResponse first at: 'name')		equals: 'harry potter y la piedra filosofal'</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposedRequestWhitAliasInterpret">testComposedRequestWhitAliasInterpret	| response subResponse |	response := self		attendRequest:			'{		hello		hello		myFilms : films { 			rating			name		}	}'.	self assert: response class: OrderedDictionary.	subResponse := response at: 'hello'.	self assert: subResponse equals: 'hello world'.	subResponse := response at: 'myFilms'.	self assert: subResponse class: OrderedCollection.	self assert: (subResponse first at: 'rating') equals: 9.	self		assert: (subResponse first at: 'name')		equals: 'harry potter y la piedra filosofal'</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposedRequestWithArgumentsAndAliasInterpret">testComposedRequestWithArgumentsAndAliasInterpret	| response subResponse |	response := self		attendRequest:			'{		hello		helloWorld: hello		myFilms : films { 			rating			name		}		aliasHello: helloTo(name:"terminator") 		}'.	self assert: response class: OrderedDictionary.	subResponse := response at: 'hello'.	self assert: subResponse equals: 'hello world'.	subResponse := response at: 'helloWorld'.	self assert: subResponse equals: 'hello world'.	subResponse := response at: 'myFilms'.	self assert: subResponse class: OrderedCollection.	self assert: (subResponse first at: 'rating') equals: 9.	self		assert: (subResponse first at: 'name')		equals: 'harry potter y la piedra filosofal'.	self assert: (response at: 'aliasHello') equals: 'hello terminator'</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposeRequestArgumentsExcludeWithTwoDirective">testComposeRequestArgumentsExcludeWithTwoDirective	| response |	response := self		attendRequest:			'{		filmsWith(rating: 5) @skip(if : true) @include(if : true){			name		}	}'.	self assert: response isEmpty.	response := self		attendRequest:			'{		filmsWith(rating: 5) @skip(if : true) @include(if : false){			name		}	}'.	self assert: response isEmpty.	response := self		attendRequest:			'{		filmsWith(rating: 5) @include(if : false) @skip(if : true){			name		}	}'.	self assert: response isEmpty.	response := self		attendRequest:			'{		filmsWith(rating: 5) @skip(if : false) @include(if : false){			name		}	}'.	self assert: response isEmpty</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposeRequestArgumentsIncludeWithTwoDirective">testComposeRequestArgumentsIncludeWithTwoDirective	| response |	response := self		attendRequest:			'{		filmsWith(rating: 5) @skip(if : false) @include(if : true){			name		}	}'.	self assert: response class: OrderedDictionary.	response := self		attendRequest:			'{		filmsWith(rating: 5) @include(if : true) @skip(if : false){			name		}	}'.	self assert: response class: OrderedDictionary</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposeRequestArgumentsWithDirectiveExclude">testComposeRequestArgumentsWithDirectiveExclude	| response |	response := self		attendRequest:			'{		filmsWith(rating: 5) @skip(if : true){			name		}	}'.	self assert: response isEmpty.	response := self		attendRequest:			'{		filmsWith(rating: 5) @include(if : false){			name		}	}'.	self assert: response isEmpty</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposeRequestArgumentsWithDirectiveInclude">testComposeRequestArgumentsWithDirectiveInclude	| response expectedValues |	response := self		attendRequest:			'{		filmsWith(rating: 5) @skip(if : false){			name		}	}'.	self assert: response class: OrderedDictionary.	expectedValues := (response at: 'filmsWith')		collect: [ :res | res at: 'name' ].	self		assert: expectedValues asArray		equals: #('terminator' 'rambo' 'robocop').	response := self		attendRequest:			'{		filmsWith(rating: 5) @include(if : true){			name		}	}'.	self assert: response class: OrderedDictionary.	expectedValues := (response at: 'filmsWith')		collect: [ :res | res at: 'name' ].	self		assert: expectedValues asArray		equals: #('terminator' 'rambo' 'robocop')</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposeRequestArgumentsWithDuplicateDirective">testComposeRequestArgumentsWithDuplicateDirective	| text |	text := '{		filmsWith(rating: 5) @skip(if : false) @skip(if : true){			name		}	}'.	self should: [ self attendRequest: text ] raise: GQLException.	text := '{		filmsWith(rating: 5) @include(if : true) @include(if : false){			name		}	}'.	self should: [ self attendRequest: text ] raise: GQLException</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposeRequestArgumentsWithEnumType">testComposeRequestArgumentsWithEnumType	| response |	response := self		attendRequest:			'{		filmsOf(gender: ACTION){			name			rating		}	}'.	self assert: response class: OrderedDictionary.	response := response at: 'filmsOf'.	self assert: response class: OrderedCollection.	self assert: response size equals: 1.	self assert: (response first at: 'name') equals: 'rambo'.	self assert: (response first at: 'rating') equals: 5</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposeRequestArgumentsWithEnumTypeAndAlias">testComposeRequestArgumentsWithEnumTypeAndAlias	| response |	response := self		attendRequest:			'{		filmsOfAction: filmsOf(gender: ACTION){			name			rating		}	}'.	self assert: response class: OrderedDictionary.	response := response at: 'filmsOfAction'.	self assert: response class: OrderedCollection.	self assert: response size equals: 1.	self assert: (response first at: 'name') equals: 'rambo'.	self assert: (response first at: 'rating') equals: 5</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposeRequestArgumentsWithEnumTypeAndDirectivesExclude">testComposeRequestArgumentsWithEnumTypeAndDirectivesExclude	| response |	response := self		attendRequest:			'{		filmsOf(gender: ACTION) @skip(if: true){			name			rating		}	}'.	self assert: response isEmpty.	response := self		attendRequest:			'{		filmsOf(gender: ACTION) @include(if: false){			name			rating		}	}'.	self assert: response isEmpty</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposeRequestArgumentsWithEnumTypeAndDirectivesInclude">testComposeRequestArgumentsWithEnumTypeAndDirectivesInclude	| response |	response := self		attendRequest:			'{		filmsOf(gender: ACTION) @skip(if: false){			name			rating		}	}'.	self assert: response class: OrderedDictionary.	response := response at: 'filmsOf'.	self assert: response class: OrderedCollection.	self assert: response size equals: 1.	self assert: (response first at: 'name') equals: 'rambo'.	self assert: (response first at: 'rating') equals: 5.	response := self		attendRequest:			'{		filmsOf(gender: ACTION) @include(if: true){			name			rating		}	}'.	self assert: response class: OrderedDictionary.	response := response at: 'filmsOf'.	self assert: response class: OrderedCollection.	self assert: response size equals: 1.	self assert: (response first at: 'name') equals: 'rambo'.	self assert: (response first at: 'rating') equals: 5</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposeRequestArgumentsWithListEnumType">testComposeRequestArgumentsWithListEnumType	| response |	response := self		attendRequest:			'{		filmsOn(genders: [ACTION, SCIENCE_FICTION]){			name			rating		}	}'.	self assert: response class: OrderedDictionary.	response := response at: 'filmsOn'.	self assert: response class: OrderedCollection.	self assert: response size equals: 6.	self		assert: (response first at: 'name')		equals: 'harry potter y la piedra filosofal'.	self		assert: (response second at: 'name')		equals: 'el seÃ±or de los anillos'.	self assert: (response third at: 'name') equals: 'terminator'.	self assert: (response fourth at: 'name') equals: 'rambo'.	self assert: (response fifth at: 'name') equals: 'robocop'.	self assert: (response sixth at: 'name') equals: 'alien'</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposeRequestArgumentsWithManyVariable">testComposeRequestArgumentsWithManyVariable	| response text textVariables |	text := '	query operationVariables($name: String, $gender: MovieType, $rating: Int, 							$film: GQLFilmInput, $genders: [ MovieType ]){		features(film: $film)		helloTo(name: $name)		classification(gender: $gender)		filmsWith(rating: $rating){			name		}		filmsOn(genders: $genders){			name			rating		}	}	'.	textVariables := '{"name":"Alex", "gender": ACTION, "rating": 8, 							"film": {filmName : "harry potter y la piedra filosofal"}, 							"genders": [COMEDY, ACTION]}'.	response := self		attendRequest: text		using: 'operationVariables'		with: textVariables.	self assert: response class: OrderedDictionary.	self		assert: (response at: 'features')		equals: 'harry potter y la piedra filosofal'.	self assert: (response at: 'helloTo') equals: 'hello Alex'.	self assert: (response at: 'classification') equals: 'ACTION'.	self assert: (response at: 'filmsWith') class: OrderedCollection.	self		assert: ((response at: 'filmsWith') first at: 'name')		equals: 'el seÃ±or de los anillos'.	self		assert: ((response at: 'filmsOn') first at: 'name')		equals: 'rambo'.	self assert: ((response at: 'filmsOn') first at: 'rating') equals: 5.	self		assert: ((response at: 'filmsOn') second at: 'name')		equals: 'annie'.	self assert: ((response at: 'filmsOn') second at: 'rating') equals: 6</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposeRequestArgumentsWithVariableAndDirectiveExclude">testComposeRequestArgumentsWithVariableAndDirectiveExclude	| text textVariables nameOperation response |	text := '	query operationVariables($name: String, $gender: MovieType,							$film: GQLFilm, $genders: [ MovieType ]){		features(film: $film) @skip(if: true)		helloTo(name: $name) @skip(if: true)		classification(gender: $gender) @skip(if: true)		filmsOn(genders: $genders) @skip(if: true){			name			rating		}	}	'.	nameOperation := 'operationVariables'.	textVariables := '{"name":"Alex", "gender": ACTION, 							"film": {filmName : "harry potter y la piedra filosofal"}, 							"genders": [COMEDY, ACTION]}'.	response := self		attendRequest: text		using: nameOperation		with: textVariables.	self assert: response isEmpty.	text := '	query operationVariables($name: String, $gender: MovieType,							$film: GQLFilm, $genders: [ MovieType ]){		features(film: $film) @include(if: false)		helloTo(name: $name) @include(if: false)		classification(gender: $gender) @include(if: false)		filmsOn(genders: $genders) @include(if: false){			name			rating		}	}	'.	response := self		attendRequest: text		using: nameOperation		with: textVariables.	self assert: response isEmpty</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposeRequestArgumentsWithVariableAndDirectiveInclude">testComposeRequestArgumentsWithVariableAndDirectiveInclude	| response text textVariables |	text := '	query operationVariables($name: String, $gender: MovieType, $rating: Int, 							$film: GQLFilm, $genders: [ MovieType ]){		features(film: $film) @skip(if:false)		helloTo(name: $name)  @skip(if:false)		classification(gender: $gender)  @skip(if:false)		filmsWith(rating: $rating)  @skip(if:false){			name		}		filmsOn(genders: $genders)  @skip(if:false){			name			rating		}	}	'.	textVariables := '{"name":"Alex", "gender": ACTION, "rating": 8, 							"film": {filmName : "harry potter y la piedra filosofal"}, 							"genders": [COMEDY, ACTION]}'.	response := self		attendRequest: text		using: 'operationVariables'		with: textVariables.	self assert: response class: OrderedDictionary.	self		assert: (response at: 'features')		equals: 'harry potter y la piedra filosofal'.	self assert: (response at: 'helloTo') equals: 'hello Alex'.	self assert: (response at: 'classification') equals: 'ACTION'.	self assert: (response at: 'filmsWith') class: OrderedCollection.	self		assert: ((response at: 'filmsWith') first at: 'name')		equals: 'el seÃ±or de los anillos'.	self		assert: ((response at: 'filmsOn') first at: 'name')		equals: 'rambo'.	self assert: ((response at: 'filmsOn') first at: 'rating') equals: 5.	self		assert: ((response at: 'filmsOn') second at: 'name')		equals: 'annie'.	self assert: ((response at: 'filmsOn') second at: 'rating') equals: 6.	text := '	query operationVariables($name: String, $gender: MovieType, $rating: Int, 							$film: GQLFilm, $genders: [ MovieType ]){		features(film: $film) @include(if:true)		helloTo(name: $name)  @include(if:true)		classification(gender: $gender)  @include(if:true)		filmsWith(rating: $rating)  @include(if:true){			name		}		filmsOn(genders: $genders)  @include(if:true){			name			rating		}	}	'.	response := self		attendRequest: text		using: 'operationVariables'		with: textVariables.	self assert: response class: OrderedDictionary.	self		assert: (response at: 'features')		equals: 'harry potter y la piedra filosofal'.	self assert: (response at: 'helloTo') equals: 'hello Alex'.	self assert: (response at: 'classification') equals: 'ACTION'.	self assert: (response at: 'filmsWith') class: OrderedCollection.	self		assert: ((response at: 'filmsWith') first at: 'name')		equals: 'el seÃ±or de los anillos'.	self		assert: ((response at: 'filmsOn') first at: 'name')		equals: 'rambo'.	self assert: ((response at: 'filmsOn') first at: 'rating') equals: 5.	self		assert: ((response at: 'filmsOn') second at: 'name')		equals: 'annie'.	self assert: ((response at: 'filmsOn') second at: 'rating') equals: 6</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposeRequestExcludeWithTwoDirective">testComposeRequestExcludeWithTwoDirective	| response |	response := self		attendRequest:			'{		films @skip(if : true) @include(if : true){			name		}	}'.	self assert: response isEmpty.	response := self		attendRequest:			'{		films @skip(if : true) @include(if : false){			name		}	}'.	self assert: response isEmpty.	response := self		attendRequest:			'{		films @include(if : false) @skip(if : true){			name		}	}'.	self assert: response isEmpty.	response := self		attendRequest:			'{		films @skip(if : false) @include(if : false){			name		}	}'.	self assert: response isEmpty</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposeRequestIncludeWithTwoDirective">testComposeRequestIncludeWithTwoDirective	| response |	response := self		attendRequest:			'{		films @skip(if : false) @include(if : true){			name		}	}'.	self assert: response class: OrderedDictionary.	response := self		attendRequest:			'{		films @include(if : true) @skip(if : false){			name		}	}'.	self assert: response class: OrderedDictionary</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposeRequestInterpretWithInputObject">testComposeRequestInterpretWithInputObject	| response |	response := self		attendRequest:			'{		hello		information(film: {			description : "Fiction science movie",			gender : "Fiction science"		}) { 				description		 }	}'.	self assert: response class: OrderedDictionary.	self assert: (response at: 'hello') equals: 'hello world'.	self assert: (response at: 'information') class: OrderedDictionary.	self		assert: ((response at: 'information') at: 'description')		equals: 'Fiction science movie'</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposeRequestInterpretWithInputObjectAndAlias">testComposeRequestInterpretWithInputObjectAndAlias	| response |	response := self		attendRequest:			'{		hello		aliasInformation: information(film: {			description : "Fiction science movie",			gender : "Fiction science"		}) { 				description		 }	}'.	self assert: response class: OrderedDictionary.	self assert: (response at: 'hello') equals: 'hello world'.	self		assert: (response at: 'aliasInformation')		class: OrderedDictionary.	self		assert: ((response at: 'aliasInformation') at: 'description')		equals: 'Fiction science movie'</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposeRequestInterpretWithInputObjectOfDifferentTypeFieldsAndArguments">testComposeRequestInterpretWithInputObjectOfDifferentTypeFieldsAndArguments	| response |	response := self		attendRequest:			'{		helloTo(name: "Alex")		detailedInformation(film: {			rating : 9,			boxOffice: 12345523.34,			gender : "Fiction science",			isBoxOffice : true		}) { 				gender				boxOffice				rating				isBoxOffice		 }	}'.	self assert: response class: OrderedDictionary.	self assert: (response at: 'helloTo') equals: 'hello Alex'.	response := response at: 'detailedInformation'.	self assert: response class: OrderedDictionary.	self assert: response size equals: 4.	self assert: (response at: 'gender') equals: 'Fiction science'.	self assert: (response at: 'boxOffice') equals: 12345523.34.	self assert: (response at: 'rating') equals: 9.	self assert: (response at: 'isBoxOffice') equals: true</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposeRequestInterpretWithInputObjectOfDifferentTypeFieldsAndDirectiveExclude">testComposeRequestInterpretWithInputObjectOfDifferentTypeFieldsAndDirectiveExclude	| response |	response := self		attendRequest:			'{		detailedInformation(film: {			rating : 9,			boxOffice: 12345523.34,			gender : "Fiction science",			isBoxOffice : true		}) @skip(if: true) { 				gender				boxOffice				rating				isBoxOffice		 }	}'.	self assert: response isEmpty.	response := self		attendRequest:			'{		detailedInformation(film: {			rating : 9,			boxOffice: 12345523.34,			gender : "Fiction science",			isBoxOffice : true		}) @include(if: false) { 				gender				boxOffice				rating				isBoxOffice		 }	}'.	self assert: response isEmpty</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposeRequestInterpretWithInputObjectOfDifferentTypeFieldsAndDirectiveInclude">testComposeRequestInterpretWithInputObjectOfDifferentTypeFieldsAndDirectiveInclude	| response |	response := self		attendRequest:			'{		detailedInformation(film: {			rating : 9,			boxOffice: 12345523.34,			gender : "Fiction science",			isBoxOffice : true		}) @skip(if: false) { 				gender				boxOffice				rating				isBoxOffice		 }	}'.	self assert: response class: OrderedDictionary.	response := response at: 'detailedInformation'.	self assert: response class: OrderedDictionary.	self assert: response size equals: 4.	self assert: (response at: 'gender') equals: 'Fiction science'.	self assert: (response at: 'boxOffice') equals: 12345523.34.	self assert: (response at: 'rating') equals: 9.	self assert: (response at: 'isBoxOffice') equals: true.	response := self		attendRequest:			'{		detailedInformation(film: {			rating : 9,			boxOffice: 12345523.34,			gender : "Fiction science",			isBoxOffice : true		}) @include(if: true) { 				gender				boxOffice				rating				isBoxOffice		 }	}'.	self assert: response class: OrderedDictionary.	response := response at: 'detailedInformation'.	self assert: response class: OrderedDictionary.	self assert: response size equals: 4.	self assert: (response at: 'gender') equals: 'Fiction science'.	self assert: (response at: 'boxOffice') equals: 12345523.34.	self assert: (response at: 'rating') equals: 9.	self assert: (response at: 'isBoxOffice') equals: true</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposeRequestInterpretWithListInputObject">testComposeRequestInterpretWithListInputObject	| response |	response := self		attendRequest:			'{		hello		films { 			rating			name		}		totalInformation(film: [ 				{description : "Fiction science movie",				gender : "Fiction science"}, 				{description : "Animated cartoon movie"}, 				{gender : "Animated cartoon"}				])	}'.	self assert: response class: OrderedDictionary.	self assert: (response at: 'hello') equals: 'hello world'.	self assert: (response at: 'films') class: OrderedCollection.	self assert: ((response at: 'films') first at: 'rating') equals: 9.	self		assert: ((response at: 'films') first at: 'name')		equals: 'harry potter y la piedra filosofal'.	response := response at: 'totalInformation'.	self assert: response class: Array.	self assert: response size equals: 3.	self assert: response first class: GQLTestQueryType.	self		assert: response first description		equals: 'Fiction science movie'.	self assert: response first gender equals: 'Fiction science'.	self		assert: response second description		equals: 'Animated cartoon movie'.	self assert: response third gender equals: 'Animated cartoon'</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposeRequestWithDirectiveExclude">testComposeRequestWithDirectiveExclude	| response |	response := self		attendRequest:			'{		films @skip(if : true){			name		}	}'.	self assert: response class: OrderedDictionary.	self assert: response isEmpty.	response := self		attendRequest:			'{		films @include(if : false){			name		}	}'.	self assert: response class: OrderedDictionary.	self assert: response isEmpty</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposeRequestWithDirectiveInclude">testComposeRequestWithDirectiveInclude	| response expectedValues |	response := self		attendRequest:			'{		films @skip(if : false){			name		}	}'.	self assert: response class: OrderedDictionary.	self assert: (response at: 'films') class: OrderedCollection.	expectedValues := (response at: 'films')		collect: [ :res | res at: 'name' ].	self		assert: expectedValues asArray		equals:			#('harry potter y la piedra filosofal' 'el seÃ±or de los anillos' 'terminator' 'rambo' 'robocop' 'alien' 'annie').	response := self		attendRequest:			'{		films @include(if : true){			name		}	}'.	self assert: response class: OrderedDictionary.	self assert: (response at: 'films') class: OrderedCollection.	expectedValues := (response at: 'films')		collect: [ :res | res at: 'name' ].	self		assert: expectedValues asArray		equals:			#('harry potter y la piedra filosofal' 'el seÃ±or de los anillos' 'terminator' 'rambo' 'robocop' 'alien' 'annie')</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposeRequestWithDuplicateDirective">testComposeRequestWithDuplicateDirective	| text |	text := '{		films @skip(if : false) @skip(if : true){			name		}	}'.	self should: [ self attendRequest: text ] raise: GQLException.	text := '{		films @include(if : true) @include(if : false){			name		}	}'.	self should: [ self attendRequest: text ] raise: GQLException</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposeRequestWithManyOperationMutation">testComposeRequestWithManyOperationMutation	| response text |	text := '	mutation pointCreation {		createPoint(x: 1, y: 2){		x y	}}	query operationFilmsWith {		filmsWith(rating: 5) {			name		}	}'.	response := self		attendRequest: text		using: 'pointCreation'		with: ''		root: GQLTestMutationType new.	self assert: response class: OrderedDictionary.	self assert: (response at: 'createPoint') class: OrderedDictionary.	self assert: ((response at: 'createPoint') at: 'x') equals: 1</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposeRequestWithManyOperationMutationAndWithoutOperationName">testComposeRequestWithManyOperationMutationAndWithoutOperationName	| text |	text := '	mutation pointCreation {		createPoint(x: 1, y: 2){		x y	}}	query operationFilmsWith {		filmsWith(rating: 5) {			name		}	}'.	self		should: [ self attendRequest: text using: nil with: '' ]		raise: GQLException</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposeRequestWithManyOperationQuery">testComposeRequestWithManyOperationQuery	| response text |	text := '	query operationFilms {		films {			name		}	}	query operationFilmsWith {		filmsWith(rating: 5) {			name		}	}'.	response := self attendRequest: text using: 'operationFilms' with: ''.	self assert: response class: OrderedDictionary.	self assert: (response at: 'films') class: OrderedCollection.	self		assert: ((response at: 'films') first at: 'name')		equals: 'harry potter y la piedra filosofal'</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposeRequestWithManyOperationQueryAndUnknownOperationName">testComposeRequestWithManyOperationQueryAndUnknownOperationName	| text |	text := '	query operationFilms {		films {			name		}	}	query operationFilmsWith {		filmsWith(rating: 5) {			name		}	}'.	self		should: [ self attendRequest: text using: 'operationUnknown' with: '' ]		raise: GQLException</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposeRequestWithManyOperationQueryAndWithoutOperationName">testComposeRequestWithManyOperationQueryAndWithoutOperationName	| text |	text := '	query operationFilms {		films {			name		}	}	query operationFilmsWith {		filmsWith(rating: 5) {			name		}	}'.	self		should: [ self attendRequest: text using: nil with: '' ]		raise: GQLException</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposeRequestWithManyOperationQueryWithDirectiveExclude">testComposeRequestWithManyOperationQueryWithDirectiveExclude	| text response |	text := '	query operationFilms {		films @skip(if:true) {			name		}	}	query operationFilmsWith {		filmsWith(rating: 5) @skip(if: true) {			name		}	}'.	response := self attendRequest: text using: 'operationFilms' with: ''.	self assert: response class: OrderedDictionary.	self assert: response isEmpty.	text := '	query operationFilms {		films @include(if: false) {			name		}	}	query operationFilmsWith {		filmsWith(rating: 5) @include(if: false) {			name		}	}'.	response := self attendRequest: text using: 'operationFilms' with: ''.	self assert: response class: OrderedDictionary.	self assert: response isEmpty</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposeRequestWithManyOperationQueryWithDirectiveInclude">testComposeRequestWithManyOperationQueryWithDirectiveInclude	| response text |	text := '	query operationFilms {		films @skip(if: false) {			name		}	}	query operationFilmsWith {		filmsWith(rating: 5) @skip(if: false) {			name		}	}'.	response := self attendRequest: text using: 'operationFilms' with: ''.	self assert: response class: OrderedDictionary.	self assert: (response at: 'films') class: OrderedCollection.	self assert: (response at: 'films') size equals: 7.	self		assert: ((response at: 'films') first at: 'name')		equals: 'harry potter y la piedra filosofal'.	text := '	query operationFilms {		films @include(if: true) {			name		}	}	query operationFilmsWith {		filmsWith(rating: 5) @include(if: true) {			name		}	}'.	response := self		attendRequest: text		using: 'operationFilmsWith'		with: ''.	self assert: response class: OrderedDictionary.	self assert: (response at: 'filmsWith') class: OrderedCollection.	self assert: (response at: 'filmsWith') size equals: 3.	self		assert: ((response at: 'filmsWith') first at: 'name')		equals: 'terminator'</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposeRequestWithNamedTypeOfOneLevel">testComposeRequestWithNamedTypeOfOneLevel	| response |	response := self		attendRequest:			'{		hello		films { 			id		 }	}'.	self assert: response class: OrderedDictionary.	self assert: (response at: 'hello') equals: 'hello world'.	response := response at: 'films'.	self assert: response class: OrderedCollection.	self assert: (response first at: 'id') equals: 1.	self assert: (response last at: 'id') equals: 7</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposeRequestWithNamedTypeOfTwoLevelAndFirstDirectiveExclude">testComposeRequestWithNamedTypeOfTwoLevelAndFirstDirectiveExclude	| response |	response := self		attendRequest:			'{		films @skip(if: true){ 			id			name			film { 				film(name: "harry potter y la piedra filosofal")				id			}		 }	}'.	self assert: response isEmpty.	response := self		attendRequest:			'{		films @include(if: false){ 			id			name			film { 				film(name: "harry potter y la piedra filosofal")				id			}		 }	}'.	self assert: response isEmpty</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposeRequestWithNamedTypeOfTwoLevelAndFirstDirectiveInclude">testComposeRequestWithNamedTypeOfTwoLevelAndFirstDirectiveInclude	| response |	response := self		attendRequest:			'{		films @skip(if: false){ 			id			film { 				get(filmName: "harry potter y la piedra filosofal")				id			}		 }	}'.	self assert: response class: OrderedDictionary.	response := response at: 'films'.	self assert: (response first at: 'id') equals: 1.	response := response first at: 'film'.	self assert: response class: OrderedDictionary.	self		assert: (response at: 'get')		equals: 'harry potter y la piedra filosofal'.	self assert: (response at: 'id') equals: 1</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposeRequestWithNamedTypeOfTwoLevelAndParameters">testComposeRequestWithNamedTypeOfTwoLevelAndParameters	| response |	response := self		attendRequest:			'{		helloTo(name : "Alex")		films { 			film { 				get(filmName: "harry potter y la piedra filosofal")				id			}		 }	}'.	self assert: response class: OrderedDictionary.	self assert: (response at: 'helloTo') equals: 'hello Alex'.	response := (response at: 'films') first at: 'film'.	self assert: response class: OrderedDictionary.	self		assert: (response at: 'get')		equals: 'harry potter y la piedra filosofal'.	self assert: (response at: 'id') equals: 1</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposeRequestWithNamedTypeOfTwoLevelAndSecondDirectiveExclude">testComposeRequestWithNamedTypeOfTwoLevelAndSecondDirectiveExclude	| response |	response := self		attendRequest:			'{		films { 			id			film @skip(if: true){ 				film(name: "harry potter y la piedra filosofal")				id			}		 }	}'.	self assert: response class: OrderedDictionary.	response := response at: 'films'.	self assert: response class: OrderedCollection.	self assert: (response first includesKey: 'id').	self assert: (response first at: 'id') equals: 1.	self deny: (response first includesKey: 'film').	response := self		attendRequest:			'{		films { 			id			film @include(if: false){ 				film(name: "harry potter y la piedra filosofal")				id			}		 }	}'.	self assert: response class: OrderedDictionary.	response := response at: 'films'.	self assert: response class: OrderedCollection.	self assert: (response first includesKey: 'id').	self assert: (response first at: 'id') equals: 1.	self deny: (response first includesKey: 'film')</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposeRequestWithNamedTypeOfTwoLevelAndSecondDirectiveInclude">testComposeRequestWithNamedTypeOfTwoLevelAndSecondDirectiveInclude	| response |	response := self		attendRequest:			'{		films {			film @skip(if: false){ 				id			}		 }	}'.	self assert: response class: OrderedDictionary.	response := (response at: 'films') first at: 'film'.	self assert: response class: OrderedDictionary.	self assert: (response at: 'id') equals: 1.	response := self		attendRequest:			'{		films {			film @include(if: true){ 				id			}		 }	}'.	self assert: response class: OrderedDictionary.	response := (response at: 'films') first at: 'film'.	self assert: response class: OrderedDictionary.	self assert: (response at: 'id') equals: 1</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposeRequestWithOneOperationMutation">testComposeRequestWithOneOperationMutation	| response text |	text := '	mutation pointCreation {		createPoint(x: 1, y: 2){			x y		}	}'.	response := self		attendRequest: text		using: 'pointCreation'		with: ''		root: GQLTestMutationType new.	self assert: response class: OrderedDictionary.	self assert: (response at: 'createPoint') class: OrderedDictionary.	self assert: ((response at: 'createPoint') at: 'x') equals: 1</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposeRequestWithOneOperationMutationAndWithoutOperationName">testComposeRequestWithOneOperationMutationAndWithoutOperationName	| response text |	text := '	mutation pointCreation {		createPoint(x: 1, y: 2){			x y		}	}'.	response := self		attendRequest: text		using: nil		with: ''		root: GQLTestMutationType new.	self assert: response class: OrderedDictionary.	self assert: (response at: 'createPoint') class: OrderedDictionary.	self assert: ((response at: 'createPoint') at: 'x') equals: 1</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposeRequestWithOneOperationQuery">testComposeRequestWithOneOperationQuery	| response text |	text := '	query operationFilms {		films {			name		}	}'.	response := self attendRequest: text using: 'operationFilms' with: ''.	self assert: response class: OrderedDictionary.	self assert: (response at: 'films') class: OrderedCollection.	self		assert: ((response at: 'films') first at: 'name')		equals: 'harry potter y la piedra filosofal'</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposeRequestWithOneOperationQueryAndWithoutOperationName">testComposeRequestWithOneOperationQueryAndWithoutOperationName	| response text |	text := '	query operationFilms {		films {			name		}	}'.	response := self attendRequest: text using: nil with: ''.	self assert: response class: OrderedDictionary.	self assert: (response at: 'films') class: OrderedCollection.	self assert: (response at: 'films') size equals: 7.	self		assert: ((response at: 'films') first at: 'name')		equals: 'harry potter y la piedra filosofal'</body></methods><methods><class-id>GraphQLBeta.GQLDocumentNodeTest</class-id> <category>tests-introspection</category><body package="GraphQLBeta-Tests-Nodes" selector="testIntrospectionArgsWithFragment">testIntrospectionArgsWithFragment	| request result field |	request := '{  		__type(name: "__Field") {    		name    		fields(includeDeprecated: false) {				name      			args{					...InputValue				}      			type {        			...TypeRef      			}    		}  		}	}	fragment InputValue on __InputValue { 		name		description		type { 			...TypeRef		}		defaultValue	}	fragment TypeRef on __Type{		kind		name 		ofType {        kind        name        ofType {          kind          name          ofType {            kind            name            ofType {              kind              name              ofType {                kind                name                ofType {                  kind                  name                  ofType {                    kind                    name                  }                }              }            }          }        }      }	}'.	result := self attendRequest: request using: '' with: ''.	self		assertCollection: (result at: '__type') keys		hasSameElements: #('name' 'fields').	result := (result at: '__type') at: 'fields'.	self		assertCollection: (result collect: [ :dict | dict at: 'name' ])		hasSameElements:			#('description' 'isDeprecated' 'args' 'name' 'type' 'deprecationReason').	field := result detect: [ :item | (item at: 'name') = 'description' ].	self		assertCollection: (field at: 'type') associations		hasSameElements:			(Array				with: 'kind' -&gt; 'SCALAR'				with: 'name' -&gt; 'String'				with: 'ofType' -&gt; nil).	field := result		detect: [ :item | (item at: 'name') = 'isDeprecated' ].	self		assertCollection: (field at: 'type') associations		hasSameElements:			(Array				with: 'kind' -&gt; 'NON_NULL'				with: 'name' -&gt; nil				with:					'ofType'						-&gt;							(OrderedDictionary new								at: 'kind' put: 'SCALAR';								at: 'name' put: 'Boolean';								at: 'ofType' put: nil;								yourself)).	field := result detect: [ :item | (item at: 'name') = 'args' ].	self		assertCollection: (field at: 'type') associations		hasSameElements:			(Array				with: 'kind' -&gt; 'NON_NULL'				with: 'name' -&gt; nil				with:					'ofType'						-&gt;							(OrderedDictionary new								at: 'kind' put: 'LIST';								at: 'name' put: nil;								at: 'ofType'									put:									(OrderedDictionary new										at: 'kind' put: 'NON_NULL';										at: 'name' put: nil;										at: 'ofType'											put:											(OrderedDictionary new												at: 'kind' put: 'OBJECT';												at: 'name' put: '__InputValue';												at: 'ofType' put: nil;												yourself);										yourself);								yourself)).	field := result detect: [ :item | (item at: 'name') = 'name' ].	self		assertCollection: (field at: 'type') associations		hasSameElements:			(Array				with: 'kind' -&gt; 'NON_NULL'				with: 'name' -&gt; nil				with:					'ofType'						-&gt;							(OrderedDictionary new								at: 'kind' put: 'SCALAR';								at: 'name' put: 'String';								at: 'ofType' put: nil;								yourself)).	field := result detect: [ :item | (item at: 'name') = 'type' ].	self		assertCollection: (field at: 'type') associations		hasSameElements:			(Array				with: 'kind' -&gt; 'NON_NULL'				with: 'name' -&gt; nil				with:					'ofType'						-&gt;							(OrderedDictionary new								at: 'kind' put: 'OBJECT';								at: 'name' put: '__Type';								at: 'ofType' put: nil;								yourself)).	field := result		detect: [ :item | (item at: 'name') = 'deprecationReason' ].	self		assertCollection: (field at: 'type') associations		hasSameElements:			(Array				with: 'kind' -&gt; 'SCALAR'				with: 'name' -&gt; 'String'				with: 'ofType' -&gt; nil)</body><body package="GraphQLBeta-Tests-Nodes" selector="testIntrospectionFieldsWithFragment">testIntrospectionFieldsWithFragment	| request result field |	request := '{  		__type(name: "GQLTestFilm") {    		name    		fields(includeDeprecated: false) {      			name				description				isDeprecated				deprecationReason    		}  		}	}'.	result := self attendRequest: request using: '' with: ''.	self		assertCollection: (result at: '__type') keys		hasSameElements: #('name' 'fields').	self assert: ((result at: '__type') at: 'name') equals: 'GQLTestFilm'.	result := (result at: '__type') at: 'fields'.	self		assertCollection: (result collect: [ :dict | dict at: 'name' ])		hasSameElements: #('id' 'name' 'film' 'rating' 'description').	field := result detect: [ :item | (item at: 'name') = 'id' ].	self		assertCollection: field associations		hasSameElements:			(Array				with: 'name' -&gt; 'id'				with: 'description' -&gt; nil				with: 'isDeprecated' -&gt; false				with: 'deprecationReason' -&gt; nil)</body><body package="GraphQLBeta-Tests-Nodes" selector="testIntrospectionManyTypes">testIntrospectionManyTypes	| request result expectedResult |	request := '{  		__type(name: "Point") {    		name    		fields(includeDeprecated: false) {      			name      			type {        			name      			}    		}  		}		typeMutation: __type(name: "GQLTestMutationType") {			name		},		typeQuery: __type(name: "GQLTestQueryType") { 			name		}	}'.	result := self jsonRequest: request.	expectedResult := '{  "__type": {    "name": "Point",    "fields": [      {        "name": "x",        "type": { "name": "Int" }      },      {        "name": "y",        "type": { "name": "Int" }      }    ]  },	"typeMutation": {    "name": "GQLTestMutationType"  },	"typeQuery": {    "name": "GQLTestQueryType"  }}'.	self assertJSONEquals: result and: expectedResult</body><body package="GraphQLBeta-Tests-Nodes" selector="testIntrospectionSchema">testIntrospectionSchema	| request result |	request := '{  		__schema {    		types { 				name				kind		   }			queryType { 				name			}			mutationType { 				name			}			subscriptionType { 				name			}			directives { 				name				description				locations				args { 					name				}			}  		}	}'.	result := self attendRequest: request.	self assert: (result at: '__schema') class: OrderedDictionary.	result := result at: '__schema'.	self		assertCollection: result keys		hasSameElements: #('types' 'queryType' 'mutationType' 'subscriptionType' 'directives').	self		assertCollection: ((result at: 'types') collect: [ :dict | dict associations ])		hasSameElements:			(OrderedCollection new				add: (Array with: 'name' -&gt; 'GQLTestMutationType' with: 'kind' -&gt; 'OBJECT');				add: (Array with: 'name' -&gt; 'Point' with: 'kind' -&gt; 'OBJECT');				add:					(Array						with: 'name' -&gt; 'GQLTestFilmInput'						with: 'kind' -&gt; 'INPUT_OBJECT');				add:					(Array						with: 'name' -&gt; 'GQLTestQueryTypeInput'						with: 'kind' -&gt; 'INPUT_OBJECT');				add: (Array with: 'name' -&gt; 'GQLTestQueryType' with: 'kind' -&gt; 'OBJECT');				add: (Array with: 'name' -&gt; 'GQLFilm' with: 'kind' -&gt; 'OBJECT');				add: (Array with: 'name' -&gt; 'GQLTestFilm' with: 'kind' -&gt; 'OBJECT');				add: (Array with: 'name' -&gt; 'GQLFilmInput' with: 'kind' -&gt; 'INPUT_OBJECT');				add: (Array with: 'name' -&gt; 'NamedEntity' with: 'kind' -&gt; 'INTERFACE');				add: (Array with: 'name' -&gt; 'IdentifiedEntity' with: 'kind' -&gt; 'INTERFACE');				add: (Array with: 'name' -&gt; 'MovieType' with: 'kind' -&gt; 'ENUM');				add: (Array with: 'name' -&gt; '__Schema' with: 'kind' -&gt; 'OBJECT');				add: (Array with: 'name' -&gt; '__Type' with: 'kind' -&gt; 'OBJECT');				add: (Array with: 'name' -&gt; '__Field' with: 'kind' -&gt; 'OBJECT');				add: (Array with: 'name' -&gt; '__InputValue' with: 'kind' -&gt; 'OBJECT');				add: (Array with: 'name' -&gt; '__EnumValue' with: 'kind' -&gt; 'OBJECT');				add: (Array with: 'name' -&gt; '__Directive' with: 'kind' -&gt; 'OBJECT');				add: (Array with: 'name' -&gt; '__Directive' with: 'kind' -&gt; 'OBJECT');				add: (Array with: 'name' -&gt; '__TypeKind' with: 'kind' -&gt; 'ENUM');				add: (Array with: 'name' -&gt; '__DirectiveLocation' with: 'kind' -&gt; 'ENUM');				add: (Array with: 'name' -&gt; 'String' with: 'kind' -&gt; 'SCALAR');				add: (Array with: 'name' -&gt; 'Boolean' with: 'kind' -&gt; 'SCALAR');				add: (Array with: 'name' -&gt; 'Int' with: 'kind' -&gt; 'SCALAR');				add: (Array with: 'name' -&gt; 'Float' with: 'kind' -&gt; 'SCALAR');				add: (Array with: 'name' -&gt; 'ID' with: 'kind' -&gt; 'SCALAR');				yourself).	self		assert: ((result at: 'queryType') at: 'name')		equals: 'GQLTestQueryType'.	self		assert: ((result at: 'mutationType') at: 'name')		equals: 'GQLTestMutationType'.	self assert: (result at: 'subscriptionType') isNil.	self		assertCollection: ((result at: 'directives') collect: [ :dict | dict associations ])		hasSameElements:			(OrderedCollection new				add:					(Array						with: 'name' -&gt; 'skip'						with: 'description' -&gt; nil						with: 'locations' -&gt; #('FIELD' 'FRAGMENT_SPREAD' 'INLINE_FRAGMENT')						with:							'args'								-&gt;									(OrderedCollection new										add:											(OrderedDictionary new												at: 'name' put: 'if';												yourself);										yourself));				add:					(Array						with: 'name' -&gt; 'include'						with: 'description' -&gt; nil						with: 'locations' -&gt; #('FIELD' 'FRAGMENT_SPREAD' 'INLINE_FRAGMENT')						with:							'args'								-&gt;									(OrderedCollection new										add:											(OrderedDictionary new												at: 'name' put: 'if';												yourself);										yourself));				yourself)</body><body package="GraphQLBeta-Tests-Nodes" selector="testIntrospectionType">testIntrospectionType	| request result expectedResult |	request := '{  		__type(name: "Point") {    		name    		fields(includeDeprecated: false) {      			name      			type {        			name      			}    		}  		}	}'.	result := self jsonRequest: request.	expectedResult := '{  "__type": {    "name": "Point",    "fields": [      {        "name": "x",        "type": { "name": "Int" }      },      {        "name": "y",        "type": { "name": "Int" }      }    ]  }}'.	self assertJSONEquals: result and: expectedResult</body><body package="GraphQLBeta-Tests-Nodes" selector="testIntrospectionTypeName">testIntrospectionTypeName	| request result expectedResult |	request := '{  		__typename	}'.	result := self jsonRequest: request.	expectedResult := '{  		"__typename": "GQLTestQueryType"	}'.	self assertJSONEquals: result and: expectedResult.	request := '{		__typename		filmsWith(rating: 9) {			__typename			id			name		}	}'.	result := self jsonRequest: request.	expectedResult := '{		"__typename": "GQLTestQueryType",		"filmsWith": [			{ 			"__typename": "GQLTestFilm",			"id": 1,			"name": "harry potter y la piedra filosofal"			}		]	}'.	self assertJSONEquals: result and: expectedResult</body><body package="GraphQLBeta-Tests-Nodes" selector="testIntrospectionWithFragment">testIntrospectionWithFragment	| request result expectedResult |	request := '{  		__schema { 			types { 				...FullType			}		}	}	fragment FullType on __Type { 		kind 		name	}	'.	result := self attendRequest: request.	expectedResult := OrderedCollection new		add: (Array with: 'ENUM' with: 'MovieType');		add: (Array with: 'OBJECT' with: 'GQLFilm');		add: (Array with: 'SCALAR' with: 'String');		add: (Array with: 'SCALAR' with: 'Int');		add: (Array with: 'SCALAR' with: 'Boolean');		add: (Array with: 'SCALAR' with: 'Float');		add: (Array with: 'SCALAR' with: 'ID');		add: (Array with: 'INTERFACE' with: 'IdentifiedEntity');		add: (Array with: 'OBJECT' with: '__Field');		add: (Array with: 'INPUT_OBJECT' with: 'GQLFilmInput');		add: (Array with: 'OBJECT' with: 'Point');		add: (Array with: 'ENUM' with: '__TypeKind');		add: (Array with: 'INPUT_OBJECT' with: 'GQLTestFilmInput');		add: (Array with: 'OBJECT' with: 'GQLTestMutationType');		add: (Array with: 'OBJECT' with: 'GQLTestFilm');		add: (Array with: 'OBJECT' with: '__Directive');		add: (Array with: 'INPUT_OBJECT' with: 'GQLTestQueryTypeInput');		add: (Array with: 'OBJECT' with: '__Type');		add: (Array with: 'ENUM' with: '__DirectiveLocation');		add: (Array with: 'OBJECT' with: '__Schema');		add: (Array with: 'OBJECT' with: '__EnumValue');		add: (Array with: 'INTERFACE' with: 'NamedEntity');		add: (Array with: 'OBJECT' with: '__InputValue');		add: (Array with: 'OBJECT' with: 'GQLTestQueryType');		yourself.	self		assertCollection:			(((result at: '__schema') at: 'types')				collect: [ :dict | Array with: (dict at: 'kind') with: (dict at: 'name') ])		hasSameElements: expectedResult</body></methods><methods><class-id>GraphQLBeta.GQLDocumentNodeTest</class-id> <category>test-variables</category><body package="GraphQLBeta-Tests-Nodes" selector="testDefaultValueVariable">testDefaultValueVariable	| text response |	text := '	query operation1($name: String="Alex"){		helloTo(name: $name)	}	'.	response := self attendRequest: text using: 'operation1' with: ''.	self assert: (response at: 'helloTo') equals: 'hello Alex'.	text := '	query operation1($name: String!="Alex"){		helloTo(name: $name)	}	'.	self		should: [ self attendRequest: text using: 'operation1' with: '' ]		raise: GQLException</body><body package="GraphQLBeta-Tests-Nodes" selector="testDefinedUseVariable">testDefinedUseVariable	| text textVariables |	text := '	query operation1{		...fragHello	}	fragment fragHello on GQLTestQueryType{		helloTo(name:$name)	}	'.	textVariables := '{"name":"Alex"}'.	self		should: [ self attendRequest: text using: 'operation1' with: textVariables ]		raise: GQLException</body><body package="GraphQLBeta-Tests-Nodes" selector="testDirectiveVariable">testDirectiveVariable	| text response textVariables |	text := '	query operation1($name:String, $bool:Boolean){		helloTo(name:$name) @skip(if:$bool)	}	'.	textVariables := '{"name":"Alex", "bool":false}'.	response := self		attendRequest: text		using: 'operation1'		with: textVariables.	self assert: (response at: 'helloTo') equals: 'hello Alex'.	text := 'query operation1($name : String, $gender : FilmType, $lala : Boolean, $rating:Int){      film(name:$name, rating:$rating){        name        rating @skip(if:$lala)      }      filmsOf(gender: $gender){        name        rating      }   }'.	textVariables := '{    "name":"terminator", "rating":5, "gender":ACTION, "lala":true    }'.	response := self		attendRequest: text		using: 'operation1'		with: textVariables.	self assert: ((response at: 'film') at: 'name') equals: 'terminator'.	self		assert: ((response at: 'filmsOf') first at: 'name')		equals: 'rambo'.	self assert: ((response at: 'filmsOf') first at: 'rating') equals: 5</body><body package="GraphQLBeta-Tests-Nodes" selector="testInputTypeVariable">testInputTypeVariable	| text response textVariables |	text := '	query operation1($gqlFilm: GQLFilmInput){		informationInput(film: $gqlFilm){			description			rating		}	}	'.	textVariables := '{"gqlFilm":{filmName:"rambo"}}'.	response := self		attendRequest: text		using: 'operation1'		with: textVariables.	self		assert: ((response at: 'informationInput') at: 'description')		equals: 'rambo'.	self		assert: ((response at: 'informationInput') at: 'rating')		equals: nil</body><body package="GraphQLBeta-Tests-Nodes" selector="testUniquenessVariableInvalid">testUniquenessVariableInvalid	| text textVariables |	text := '	query operation1($name: String, $name: String){		helloTo(name: $name)	}	'.	textVariables := '{"name":"Alex"}'.	self		should: [ self attendRequest: text using: 'operation1' with: textVariables ]		raise: GQLException</body><body package="GraphQLBeta-Tests-Nodes" selector="testUniquenessVariableValid">testUniquenessVariableValid	| response text textVariables |	text := '	query operation1($name: String){		...fragHello	}	query operation2($name: String){		...fragHello	}	fragment fragHello on GQLTestQueryType{		helloTo(name: $name)	}	'.	textVariables := '{"name":"Alex"}'.	response := self		attendRequest: text		using: 'operation1'		with: textVariables.	self assert: response class: OrderedDictionary.	self assert: (response at: 'helloTo') equals: 'hello Alex'</body><body package="GraphQLBeta-Tests-Nodes" selector="testUsedVariable">testUsedVariable	| text textVariables response |	text := '	query operation1($name:String){		...fragHello	}	fragment fragHello on GQLTestQueryType{		hello	}	'.	textVariables := '{"name":"Alex"}'.	self		shouldnt: [ self attendRequest: text using: 'operation1' with: textVariables ]		raise: GQLException.	text := '	query operation1($name:String){		...fragHello	}	fragment fragHello on GQLTestQueryType{		helloTo(name:$name)	}	'.	response := self		attendRequest: text		using: 'operation1'		with: textVariables.	self assert: (response at: 'helloTo') equals: 'hello Alex'</body><body package="GraphQLBeta-Tests-Nodes" selector="testValidationVariablesDocument">testValidationVariablesDocument	| text response textVariables |	text := '	query operation1($name:String, $bool:Boolean){		helloTo(name:$name) @skip(if:$bool)	}	query operation2{		hello	}	'.	textVariables := '{"name":"Alex", "bool":false}'.	response := self		attendRequest: text		using: 'operation2'		with: textVariables.	self assert: (response at: 'hello') equals: 'hello world'</body></methods><methods><class-id>GraphQLBeta.GQLDocumentNodeTest</class-id> <category>initialization</category><body package="GraphQLBeta-Tests-Nodes" selector="setUp">setUp	schema := self parseSchema: GQLTestQueryType schema.	schema := schema validate.	rootInstance := GQLTestQueryType new.	schema root: rootInstance.	withData := false</body></methods><methods><class-id>GraphQLBeta.GQLDocumentNodeTest</class-id> <category>tests</category><body package="GraphQLBeta-Tests-Nodes" selector="testComposedRequestInterpretSpreadFragments">testComposedRequestInterpretSpreadFragments	| response subResponse |	response := self		attendRequest:			'{		films { 			...filmsData		}		filmsWith(rating:5){			...filmsData		}	}	fragment filmsData on GQLTestFilm{		name		rating	}	'.	self assert: response class: OrderedDictionary.	subResponse := response at: 'films'.	self assert: (subResponse first at: 'rating') equals: 9.	self		assert: (subResponse first at: 'name')		equals: 'harry potter y la piedra filosofal'.	subResponse := response at: 'filmsWith'.	self assert: subResponse size equals: 3</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposedRequestInterpretUnknowFragments">testComposedRequestInterpretUnknowFragments	| text |	text := '{		films { 			...filmsData		}		filmsWith(rating:5){			...filmsData		}	}	fragment filmsDota on GQLTestFilm{		name		rating	}	'.	self should: [ self attendRequest: text ] raise: GQLException</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposedRequestSpreadFragmentsWithDirectives">testComposedRequestSpreadFragmentsWithDirectives	| response subResponse |	response := self		attendRequest:			'{		films { 			...filmsData @skip(if : true)		}		filmsWith(rating:5){			...filmsData		}	}	fragment filmsData on GQLTestFilm{		name		rating @include(if : false)	}	'.	self assert: response class: OrderedDictionary.	subResponse := response at: 'films'.	subResponse do: [ :res | self assert: res isEmpty ].	subResponse := response at: 'filmsWith'.	self assert: subResponse size equals: 3.	self assert: subResponse first size equals: 1</body></methods><methods><class-id>GraphQLBeta.GQLDocumentNodeTest</class-id> <category>parsing</category><body package="GraphQLBeta-Tests-Nodes" selector="requestEvaluator">requestEvaluator	^ GQLSingleAnonimousQueryEvaluator</body></methods><methods><class-id>GraphQLBeta.GQLQuery</class-id> <category>accessing</category><body package="GraphQLBeta-Demo" selector="allClasses">allClasses	^ Smalltalk allClasses</body><body package="GraphQLBeta-Demo" selector="allClassesStartingWith:">allClassesStartingWith: aName	^ self allClasses select: [ :c | c name beginsWith: aName ]</body><body package="GraphQLBeta-Demo" selector="allFilms">allFilms	^ OrderedCollection new		add:			(Film				name: 'terminator'				rating: 5				director: (Person name: 'James Cameron' age: 35)				gender: 'ACTION');		add:			(Film				name: 'Star wars: New Hope'				rating: 9				director: (Person name: 'George Lucas' age: 35)				gender: 'SCIENCE_FICTION');		add:			(Film				name: 'Star wars: The Clone Wars'				rating: 6				director: (Person name: 'George Lucas' age: 35)				gender: 'SCIENCE_FICTION');		add:			(Film				name: 'Star wars: The Empire Strikes Back'				rating: 8				director: (Person name: 'Irvin Kershner' age: 35)				gender: 'SCIENCE_FICTION');		add:			(Film				name: 'Star wars: Return of Jedi'				rating: 7				director: (Person name: 'Richard Marquand' age: 35)				gender: 'SCIENCE_FICTION');		add:			(Film				name: 'Star wars: The Phantom Menace'				rating: 6				director: (Person name: 'George Lucas' age: 35)				gender: 'SCIENCE_FICTION');		add:			(Film				name: 'Star wars: Attack of the Clones'				rating: 6				director: (Person name: 'George Lucas' age: 35)				gender: 'SCIENCE_FICTION');		yourself</body><body package="GraphQLBeta-Demo" selector="allRectangles">allRectangles	^ Rectangle allInstances</body><body package="GraphQLBeta-Demo" selector="allTypeFilms">allTypeFilms	^ Array with: 'ACTION' with: 'SCIENCE_FICTION'</body><body package="GraphQLBeta-Demo" selector="directorsAndFilms">directorsAndFilms	| collect |	collect := OrderedCollection new.	collect addAll: self allFilms.	collect		addAll: (self allFilms collect: [ :film | film director ]) asSet.	^ collect</body><body package="GraphQLBeta-Demo" selector="filmName:">filmName: aName	^ self allFilms detect: [ :f | f name = aName ] ifNone: [ nil ]</body><body package="GraphQLBeta-Demo" selector="filmNamesOfType:">filmNamesOfType: aString	(self allTypeFilms includes: aString)		ifTrue: [ ^ (self filmsOnGender: aString) collect: [ :film | film name ] ].	^ self allTypeFilms</body><body package="GraphQLBeta-Demo" selector="filmsDirectedBy:">filmsDirectedBy: aPerson	^ self allFilms select: [ :f | f director name = aPerson name ]</body><body package="GraphQLBeta-Demo" selector="filmsDirectorsIncluded:">filmsDirectorsIncluded: aCollection	| names |	names := aCollection collect: #name.	^ self allFilms select: [ :f | names includes: f director name ]</body><body package="GraphQLBeta-Demo" selector="filmsOnGender:">filmsOnGender: aGender	^ self allFilms select: [ :f | f gender = aGender ]</body><body package="GraphQLBeta-Demo" selector="firstShapesOfType:">firstShapesOfType: aType	aType = 'RECTANGLE'		ifTrue: [ ^ self allRectangles copyFrom: 1 to: 100 ]		ifFalse: [ aType = 'POINT'				ifTrue: [ ^ Point allInstances copyFrom: 1 to: 100 ]				ifFalse: [ ^ #() ] ]</body><body package="GraphQLBeta-Demo" selector="hello">hello	^ 'hello'</body><body package="GraphQLBeta-Demo" selector="helloMessageTo:">helloMessageTo: aPerson	^ 'hello ' , aPerson name</body><body package="GraphQLBeta-Demo" selector="shapeOfType:">shapeOfType: aType	aType = 'RECTANGLE'		ifTrue: [ ^ self allRectangles ]		ifFalse: [ aType = 'POINT'				ifTrue: [ ^ Point allInstances ]				ifFalse: [ ^ #() ] ]</body></methods><methods><class-id>GraphQLBeta.GQLQuery class</class-id> <category>accessing</category><body package="GraphQLBeta-Demo" selector="schema">schema	"The text of the schema"	^ 'union Queries = GQLQuery	union Shape = Rectangle | Point	enum FilmType { ACTION, COMEDY, DRAMA }	enum ShapeType { RECTANGLE, POINT, ROMBUS, TRAPEZOID }		schema{		query: GQLQuery		mutation: GQLMutation	}		type GQLMutation{		createRectangle(left: Int, right: Int, top: Int, bottom: Int) : Rectangle		createPoint(x:Int, y: Int) : Point	}		type GQLQuery{			hello: String			allClasses : [ Class ]			allClassesStarting(with: String) : [ Class ]			allRectangles : [ Rectangle ]			allFilms: [ Film ]			film(name:String):Film			filmsDirected(by:PersonInput):[Film]			filmsDirectors(included:[PersonInput]):[Film]			filmsOn(gender: FilmType) : [ Film ]			helloMessage(to:PersonInput):String			shapeOf(type: ShapeType): [ Shape ]			firstShapesOf(type: ShapeType): [ Shape ]			directorsAndFilms: [ namedItem ]	   },			interface namedItem{			name : String		}		input PersonInput{			name : String		}		type Film implements namedItem{			name : String			rating : Int			director : Person			gender : FilmType		},		type Person implements namedItem{			name : String			age : Int		}	   type Class implements namedItem{			name : String			methods : [ CompiledMethod ]		},		type CompiledMethod{			selector : String		},		type Rectangle{			origin : Point			corner : Point		},		type Point{			x : Float			y : Float		}'</body></methods><methods><class-id>GraphQLBeta.GQLException</class-id> <category>accessing</category><body package="GraphQLBeta-Core" selector="defaultAction">defaultAction	"No one has handled this error, but now give them a chance to decide how to debug it.  If none handle this either then open debugger (see UnhandedError-defaultAction)"	^ self</body></methods><methods><class-id>GraphQLBeta.GQLException</class-id> <category>as yet unclassified</category><body package="GraphQLBeta-Core" selector="node">node	"Return the element that causes a exception"	^ node</body><body package="GraphQLBeta-Core" selector="node:">node: aNode	"Recive a node element that causes a exception"	node := aNode</body></methods><methods><class-id>GraphQLBeta.GQLAbstractGrammarTest</class-id> <category>tests</category><body package="GraphQLBeta-Tests-Grammar" selector="testBooleanValue">testBooleanValue	"boolean value"	self parse: 'true' rule: #booleanValue.	self parse: 'false' rule: #booleanValue.	self fail: 'anyOtherValue' rule: #booleanValue.	self fail: '1' rule: #booleanValue.	self fail: '0' rule: #booleanValue</body><body package="GraphQLBeta-Tests-Grammar" selector="testComma">testComma	"comma"	self parse: ',' rule: #comma.	self fail: 'any other text' rule: #comma</body><body package="GraphQLBeta-Tests-Grammar" selector="testComment">testComment	self parse: '#some comment' rule: #comment.	self parse: '###' rule: #comment.	self		fail:			'#dsfd'		rule: #comment.	self fail: 'asdf' rule: #comment.	self fail: ' ' rule: #comment</body><body package="GraphQLBeta-Tests-Grammar" selector="testCommentChar">testCommentChar	"	self parse: '###' rule: #commentChar."	self parse: 's' rule: #commentChar.	'+_)(*&amp;^%$#@!~.}{:"?&gt;&lt;|\][;. 		'		do: [ :each | self parse: each asString rule: #commentChar ].	self		fail:			' 	'		rule: #commentChar</body><body package="GraphQLBeta-Tests-Grammar" selector="testFloatValue">testFloatValue	"float value"	self parse: '2312.12' rule: #floatValue.	self parse: '-123.23e12' rule: #floatValue.	self parse: '-123.23E12' rule: #floatValue.	self fail: '12' rule: #floatValue.	self fail: 'a123' rule: #floatValue.	self fail: '123.123a' rule: #floatValue</body><body package="GraphQLBeta-Tests-Grammar" selector="testIgnored">testIgnored	"UnicodeBOM"	"self parse: '""' rule: #ignored."	"self fail: '""any other text but "	"' rule: #ignored."	"Whitespace"	self parse: ' ' rule: #ignored.	self parse: '	' rule: #ignored.	"LineTerminator"	self		parse:			''		rule: #ignored.	"Comment"	self parse: '#some comment' rule: #ignored.	self parse: '###' rule: #ignored.	"comma"	self parse: ',' rule: #ignored</body><body package="GraphQLBeta-Tests-Grammar" selector="testInsignificantToken">testInsignificantToken	'	 		'		do: [ :each | self parse: each asString rule: #insignificantToken ]</body><body package="GraphQLBeta-Tests-Grammar" selector="testIntValue">testIntValue	"int value"	self parse: '2312' rule: #intValue.	self parse: '-123' rule: #intValue.	self parse: '+444' rule: #intValue.	self fail: '123.123' rule: #intValue.	self fail: '123.123e12' rule: #intValue</body><body package="GraphQLBeta-Tests-Grammar" selector="testLineTerminator">testLineTerminator	"LineTerminator"	self		parse:			''		rule: #lineTerminator.	self fail: ' ' rule: #lineTerminator</body><body package="GraphQLBeta-Tests-Grammar" selector="testNonZeroDigit">testNonZeroDigit	self parse: '1' rule: #nonZeroDigit.	self fail: '0' rule: #nonZeroDigit</body><body package="GraphQLBeta-Tests-Grammar" selector="testPunctuator">testPunctuator	"punctuator"	self parse: '{' rule: #punctuator.	self parse: '}' rule: #punctuator.	self parse: '...' rule: #punctuator.	self parse: '[' rule: #punctuator.	self parse: ']' rule: #punctuator.	self parse: '!' rule: #punctuator.	self parse: '$' rule: #punctuator.	self parse: '|' rule: #punctuator.	self parse: ':' rule: #punctuator.	self parse: '@' rule: #punctuator.	self parse: '=' rule: #punctuator.	self fail: 'any other character' rule: #punctuator</body><body package="GraphQLBeta-Tests-Grammar" selector="testStringValue">testStringValue	"string value"	self parse: '""' rule: #stringValue.	self		parse: '"any other kind of text +_)(*&amp;^%$#@ |}{:?&gt;&lt;][/;.,"'		rule: #stringValue.	self parse: '"\u00f3 \\ \/ \b \f \n \r \t"' rule: #stringValue.	self fail: '"any other text but " "' rule: #stringValue</body><body package="GraphQLBeta-Tests-Grammar" selector="testToken">testToken	"punctuator"	self parse: '{' rule: #punctuator.	self parse: '}' rule: #punctuator.	self parse: '...' rule: #punctuator.	self parse: '[' rule: #punctuator.	self parse: ']' rule: #punctuator.	self parse: '!' rule: #punctuator.	self parse: '$' rule: #punctuator.	self parse: '|' rule: #punctuator.	self parse: ':' rule: #punctuator.	self parse: '@' rule: #punctuator.	self parse: '=' rule: #punctuator.	"names"	self parse: '_Name23' rule: #token.	self parse: 'some_Name' rule: #token.	self parse: 'S' rule: #token.	self parse: '_' rule: #token.	"int value"	self parse: '2312' rule: #token.	self parse: '-123' rule: #token.	self parse: '+444' rule: #token.	"float value"	self parse: '2312.12' rule: #token.	self parse: '-123.23e12' rule: #token.	self parse: '-123.23E12' rule: #token.	"boolean value"	self parse: 'true' rule: #token.	self parse: 'false' rule: #token.	"string value"	self parse: '""' rule: #token.	self		parse: '"any other kind of text +_)(*&amp;^%$#@ |}{:?&gt;&lt;][/;.,"'		rule: #token.	self parse: '"\u00f3 \\ \/ \b \f \n \r \t"' rule: #token</body><body package="GraphQLBeta-Tests-Grammar" selector="testTokenName">testTokenName	"names"	self parse: '_Name23' rule: #tokenName.	self parse: 'some_Name' rule: #tokenName.	self parse: 'S' rule: #tokenName.	self parse: '_' rule: #tokenName.	self fail: '' rule: #tokenName.	self fail: ' someName' rule: #tokenName</body><body package="GraphQLBeta-Tests-Grammar" selector="testWhiteSpace">testWhiteSpace	"WhiteSpace"	self parse: ' ' rule: #whiteSpace.	self parse: '	' rule: #whiteSpace.	self fail: 'any other text but  ' rule: #whiteSpace</body></methods><methods><class-id>GraphQLBeta.GQLAbstractGrammarTest</class-id> <category>accessing</category><body package="GraphQLBeta-Tests-Grammar" selector="parserClass">parserClass	^ GQLAbstractGrammar</body></methods><methods><class-id>GraphQLBeta.Person</class-id> <category>accessing</category><body package="GraphQLBeta-Demo" selector="age">age	^ age</body><body package="GraphQLBeta-Demo" selector="age:">age: anObject	age := anObject</body><body package="GraphQLBeta-Demo" selector="name">name	^ name</body><body package="GraphQLBeta-Demo" selector="name:">name: anObject	name := anObject</body></methods><methods><class-id>GraphQLBeta.Person</class-id> <category>comparing</category><body package="GraphQLBeta-Demo" selector="=">= anObject	^ anObject class = self class		ifTrue: [ self name = anObject name and: [ self age = anObject age ] ]		ifFalse: [ false ]</body><body package="GraphQLBeta-Demo" selector="hash">hash	^ name hash + age hash</body></methods><methods><class-id>GraphQLBeta.Person class</class-id> <category>instance creation</category><body package="GraphQLBeta-Demo" selector="name:age:">name: aName age: aAge	| inst |	inst := self new.	inst		name: aName;		age: aAge.	^ inst</body></methods><methods><class-id>GraphQLBeta.GQLA</class-id> <category>accessing</category><body package="GraphQLBeta-Test-Trash" selector="hey">hey	"Return heyhey"	^ #heyhey</body><body package="GraphQLBeta-Test-Trash" selector="heyID">heyID	"Return id and his value"	^ 'id: ' , id asString</body><body package="GraphQLBeta-Test-Trash" selector="id">id	^ id</body><body package="GraphQLBeta-Test-Trash" selector="id:">id: aID	"Set the id"	id := aID</body></methods><methods><class-id>GraphQLBeta.GQLTestExtension</class-id> <category>initialization</category><body package="GraphQLBeta-Tests-Nodes" selector="initDictOfInvalidSchema">initDictOfInvalidSchema	^ Dictionary new		at: 'wrongDefinedObjExtensionManySchemas'			put:			(Array				with:					(Array						with:							'		schema{			query: GQLTestQueryType		}		type GQLTestQueryType {			helloTo(name: String): String		}'						with:							'		extend type GQLTestQueryType { 			cats: [ GQLCat ]		}		type GQLCat{ 			name: String		}')				with: (Array new: 0)				with: GQLTestQueryType new);		at: 'wrongDefinedObjExtensionOneSchema'			put:			(Array				with:					(Array						with:							'		schema{			query: GQLTestQueryType		}		type GQLTestQueryType {			helloTo(name: String): String		}		extend type GQLTestQueryType {			cats: [ GQLCat ]		}		type GQLCat {			name : String		}')				with: (Array new: 0)				with: GQLTestQueryType new);		at: 'wrongDefinedObjExtensWithInterface'			put:			(Array				with:					(Array						with:							'		interface NamedEntity { 			name: String		}		schema{			query: GQLTestSchema		}		type GQLTestSchema {			filmsSortedBy(name: Boolean): [ GQLTestFilm ]		}		type GQLTestFilm {			rating : Int		}'						with:							'		extend interface NamedEntity{			id: String		}		extend type GQLTestFilm implements NamedEntity {			name: String		}')				with: (Array new: 0)				with: GQLTestSchema new);		at: 'wrongDefinedObjectExtensWithResolvers'			put:			(Array				with:					(Array						with:							'		schema{			query: GQLTestQueryType		}		type GQLTestQueryType {			hello: String		}'						with:							'		extend type GQLTestQueryType {			asText(number: Int): String		}')				with: (Array with: GQLTestQueryType with: GQLFilm)				with: GQLTestQueryType new);		at: 'wrongInterfaceExtensManySchemas'			put:			(Array				with:					(Array						with:							'		schema{			query: GQLTestQueryType		}		interface DataEntity{			name: String		}		type GQLTestQueryType {			films: [ GQLTestFilm ]		}		type GQLTestFilm implements DataEntity{ 			name: String		}'						with:							'		extend interface DataEntity {			name: String		}')				with: (Array new: 0)				with: GQLTestQueryType new);		at: 'wrongInterfaceExtensOneSchema'			put:			(Array				with:					(Array						with:							'		schema{			query: GQLTestQueryType		}		interface DataEntity{			id: String		}		type GQLTestQueryType {			films: [ GQLTestFilm ]		}		type GQLTestFilm implements DataEntity{ 			name: String			id: String		}		extend interface DataEntity { 			id: String		}		')				with: (Array new: 0)				with: GQLTestQueryType new);		at: 'wrongUnionExtensionManySchemas'			put:			(Array				with:					(Array						with:							'		schema { 			query: GQLTestSchema		}	   union SearchObject = Point | Rectangle		type GQLTestSchema {			firstExtendedSearchObject: SearchObject		}		type Point{			x: Float			y: Float		}		type Rectangle{			origin: Point			corner: Point		}		'						with:							'extend union SearchObject = Point | GQLDog		type GQLDog { 			name: String		}		')				with: (Array new: 0)				with: GQLTestSchema new);		at: 'wrongUnionExtensionOneSchema'			put:			(Array				with:					(Array						with:							'		schema {			query: GQLTestSchema		}		union SearchObject = Point | Rectangle		type GQLTestSchema{			firstExtendedSearchObject: SearchObject		}		type Point{			x: Float			y: Float		}		type Rectangle{			origin: Point			corner: Point		}		type GQLDog { 			name: String		}		extend union SearchObject = Rectangle | GQLDog		')				with: (Array new: 0)				with: GQLTestSchema new);		at: 'wrongEnumExtensionManySchemas'			put:			(Array				with:					(Array						with:							'		schema{			query: GQLTestQueryType		}		enum MovieType{COMEDY, SCIENCE_FICTION}		type GQLTestQueryType{			classification(gender: MovieType): String		}'						with: 'extend enum MovieType { COMEDY }')				with: (Array new: 0)				with: GQLTestQueryType new);		at: 'wrongEnumExtensionOneSchema'			put:			(Array				with:					(Array						with:							'		schema{			query: GQLTestQueryType		}		enum MovieType{COMEDY,  DRAMA}		type GQLTestQueryType{			classification(gender: MovieType): String		}		extend enum MovieType { DRAMA }')				with: (Array new: 0)				with: GQLTestQueryType new);		at: 'wrongInputObjectExtensManySchemas'			put:			(Array				with:					(Array						with:							'		schema { 			query: GQLTestSchema		}		type GQLTestSchema { 			inform(film: GQLFilmInput, id: Int): GQLFilm		}		type GQLFilm{			id: Int			filmName: String		}		input GQLFilmInput {			id: Int!		}'						with:							'		extend input GQLFilmInput {			id: Int!		}')				with: (Array new: 0)				with: GQLTestSchema new);		at: 'wrongInputObjectExtensionOneSchema'			put:			(Array				with:					(Array						with:							'		schema { 			query: GQLTestSchema		}		type GQLTestSchema { 			inform(film: GQLFilmInput, id: Int): GQLFilm		}		type GQLFilm{			id: Int			filmName: String		}		input GQLFilmInput {			filmName: String		}		extend input GQLFilmInput {			filmName : String		}')				with: (Array new: 0)				with: GQLTestSchema new);		yourself	"Array of schemas"	"Array of resolvers"</body><body package="GraphQLBeta-Tests-Nodes" selector="initDictSchema">initDictSchema	^ Dictionary new		at: 'apartObjectExtensWithFieldDef'			put:			(Array				with:					(Array						with:							'		schema{			query: GQLTestQueryType		}		type GQLTestQueryType {			helloTo(name: String): String		}'						with:							'		extend type GQLTestQueryType {			films: [ GQLTestFilm ]		}		type GQLTestFilm {			id : Int			name : String			rating : Int		}'						with:							'		extend type GQLTestQueryType { 			features(film: GQLFilmInput): String		}		input GQLFilmInput { 			filmName: String		}')				with: (Array new: 0)				with: GQLTestQueryType new);		at: 'objectExtensWithFieldDef'			put:			(Array				with:					(Array						with:							'		schema{			query: GQLTestQueryType		}		type GQLTestQueryType {			helloTo(name: String): String		}		extend type GQLTestQueryType {			films: [ GQLTestFilm ]		}		type GQLTestFilm {			id : String			name : String			rating : Int		}')				with: (Array new: 0)				with: GQLTestQueryType new);		at: 'objectExtensWithInterface'			put:			(Array				with:					(Array						with:							'		interface NamedEntity { 			name: String		}		schema{			query: GQLTestSchema		}		type GQLTestSchema {			cats: [ GQLCat ]			filmsSortedBy(name: Boolean): [ GQLTestFilm ]		}		type GQLCat implements NamedEntity{ 			name: String			nickname: String		}		type GQLTestFilm {			id : String			name : String			rating : Int		}'						with: 'extend type GQLTestFilm implements NamedEntity')				with: (Array new: 0)				with: GQLTestSchema new);		at: 'objectExtensWithExtInterface'			put:			(Array				with:					(Array						with:							'		interface NamedEntity { 			name: String		}		schema{			query: GQLTestSchema		}		type GQLTestSchema {			filmsSortedBy(name: Boolean): [ GQLTestFilm ]		}		type GQLTestFilm {			id : String			rating : Int		}'						with:							'		extend interface NamedEntity{			id: String		}		extend type GQLTestFilm implements NamedEntity {			name: String		}')				with: (Array new: 0)				with: GQLTestSchema new);		at: 'objectExtensWithOtherResolver'			put:			(Array				with:					(Array						with:							'		schema{			query: GQLTestQueryType		}		type GQLTestQueryType {			hello: String		}'						with:							'		extend type GQLTestQueryType {			asText(number: Int): String		}')				with: (Array with: GQLTestQueryType with: GQLTestSchema)				with: GQLTestQueryType new);		at: 'apartInterfaceExtension'			put:			(Array				with:					(Array						with:							'		schema{			query: GQLTestQueryType		}		interface DataEntity{			name: String		}		type GQLTestQueryType {			hello: String			films: [ GQLTestFilm ]		}		type GQLTestFilm implements DataEntity{ 			name: String			rating: String			id: String		}'						with:							'		extend interface DataEntity {			id: String		}')				with: (Array new: 0)				with: GQLTestQueryType new);		at: 'apartInterfaceExtensionWithObExt'			put:			(Array				with:					(Array						with:							'		schema {			query: GQLTestQueryType		}		interface NamedEntity { 			name: String		}		type GQLTestQueryType {			films: [ GQLTestFilm ]		}		type GQLTestFilm implements NamedEntity { 			id: String			rating: Int		}'						with:							'		extend type GQLTestFilm implements IdentifierEntity{			name: String		}		interface IdentifierEntity{			id: String		}')				with: (Array new: 0)				with: GQLTestQueryType new);		at: 'interfaceExtension'			put:			(Array				with:					(Array						with:							'		schema{			query: GQLTestQueryType		}		interface DataEntity{			id: String		}		type GQLTestQueryType {			films: [ GQLTestFilm ]		}		type GQLTestFilm implements DataEntity{ 			name: String			rating: String			id: String		}		extend interface DataEntity { 			name: String		}		')				with: (Array new: 0)				with: GQLTestQueryType new);		at: 'apartUnionExtension'			put:			(Array				with:					(Array						with:							'		schema { 			query: GQLTestSchema		}	   union SearchObject = Point | Rectangle		type GQLTestSchema {			firstExtendedSearchObject: SearchObject		}		type Point{			x: Float			y: Float		}		type Rectangle{			origin: Point			corner: Point		}		'						with:							'extend union SearchObject = GQLCat | GQLDog		type GQLCat { 			name: String			nickname: String		}		type GQLDog { 			name: String		}		')				with: (Array new: 0)				with: GQLTestSchema new);		at: 'unionExtension'			put:			(Array				with:					(Array						with:							'		schema {			query: GQLTestSchema		}		union SearchObject = Point | Rectangle		type GQLTestSchema{			firstExtendedSearchObject: SearchObject		}		type Point{			x: Float			y: Float		}		type Rectangle{			origin: Point			corner: Point		}		type GQLCat { 			name: String			nickname: String		}		type GQLDog { 			name: String		}		extend union SearchObject = GQLCat | GQLDog		')				with: (Array new: 0)				with: GQLTestSchema new);		at: 'apartEnumExtension'			put:			(Array				with:					(Array						with:							'		schema{			query: GQLTestQueryType		}		enum MovieType{COMEDY, SCIENCE_FICTION}		type GQLTestQueryType{			classification(gender: MovieType): String		}'						with: 'extend enum MovieType { ACTION }')				with: (Array new: 0)				with: GQLTestQueryType new);		at: 'enumExtension'			put:			(Array				with:					(Array						with:							'		schema{			query: GQLTestQueryType		}		enum MovieType{COMEDY,  DRAMA}		type GQLTestQueryType{			classification(gender: MovieType): String		}		extend enum MovieType { SCIENCE_FICTION }')				with: (Array new: 0)				with: GQLTestQueryType new);		at: 'apartInputObjectExtension'			put:			(Array				with:					(Array						with:							'		schema { 			query: GQLTestSchema		}		type GQLTestSchema { 			inform(film: GQLTestFilmInput, id: Int): GQLTestFilm		}		type GQLTestFilm{			id: Int			filmName: String		}		input GQLTestFilmInput {			id: Int!		}'						with:							'		extend input GQLTestFilmInput {			filmName : String		}')				with: (Array new: 0)				with: GQLTestSchema new);		at: 'inputObjectExtension'			put:			(Array				with:					(Array						with:							'		schema { 			query: GQLTestSchema		}		type GQLTestSchema { 			inform(film: GQLTestFilmInput, id: Int): GQLTestFilm		}		type GQLTestFilm{			id: Int			filmName: String		}		input GQLTestFilmInput {			id: Int!		}		extend input GQLTestFilmInput {			filmName : String		}')				with: (Array new: 0)				with: GQLTestSchema new);		yourself	"Array of schemas"	"Array of resolvers"	"root operation type"</body></methods><methods><class-id>GraphQLBeta.GQLDocumentWithExtensionTest</class-id> <category>parsing</category><body package="GraphQLBeta-Tests-Nodes" selector="requestEvaluator">requestEvaluator	^ GQLSingleAnonimousQueryEvaluator</body></methods><methods><class-id>GraphQLBeta.GQLDocumentWithExtensionTest</class-id> <category>tests</category><body package="GraphQLBeta-Tests-Nodes" selector="testEnumTypeExtension">testEnumTypeExtension	| request result expectedResult |	schema := self		validateSchemaOf: dictSchema		withKey: 'apartEnumExtension'.	request := '{		classification(gender: ACTION)	}'.	result := self jsonRequest: request.	expectedResult := '{  "data": {	"classification": "ACTION"  }}'.	self assertJSONEquals: result and: expectedResult.	schema := self validateSchemaOf: dictSchema withKey: 'enumExtension'.	request := '{		classification(gender: SCIENCE_FICTION)	}'.	result := self jsonRequest: request.	expectedResult := '{  "data": {	"classification": "SCIENCE_FICTION"  }}'.	self assertJSONEquals: result and: expectedResult</body><body package="GraphQLBeta-Tests-Nodes" selector="testFailEnumTypeExtension">testFailEnumTypeExtension	| request result expectedResult |	schema := self		validateSchemaOf: dictSchema		withKey: 'apartEnumExtension'.	request := '{		classification(gender: ACTION)	}'.	result := self jsonRequest: request.	expectedResult := '{  "data": {	"classification": "ACTION"  }}'.	self assertJSONEquals: result and: expectedResult.	schema := self validateSchemaOf: dictSchema withKey: 'enumExtension'.	request := '{		classification(gender: SCIENCE_FICTION)	}'.	result := self jsonRequest: request.	expectedResult := '{  "data": {	"classification": "SCIENCE_FICTION"  }}'.	self assertJSONEquals: result and: expectedResult</body><body package="GraphQLBeta-Tests-Nodes" selector="testInputObjectTypeExtension">testInputObjectTypeExtension	| request result expectedResult |	schema := self		validateSchemaOf: dictSchema		withKey: 'apartInputObjectExtension'.	request := '{		inform(film: { id: 10, filmName: "Iron Man"}, id: 0){			id			filmName		}	}'.	result := self jsonRequest: request.	expectedResult := '{  "data": {	"inform": { 		"id": 10,		"filmName": "Iron Man"	 }  }}'.	self assertJSONEquals: result and: expectedResult.	schema := self		validateSchemaOf: dictSchema		withKey: 'inputObjectExtension'.	request := '{		inform(film: { id: 10, filmName: "Iron Man"}, id: 1){			id			filmName		}	}'.	result := self jsonRequest: request.	expectedResult := '{  "data": {	"inform": { 		"id": 1,		"filmName": "harry potter y la piedra filosofal"	 }  }}'.	self assertJSONEquals: result and: expectedResult</body><body package="GraphQLBeta-Tests-Nodes" selector="testInterfaceTypeExtension">testInterfaceTypeExtension	| request result expectedResult |	schema := self		validateSchemaOf: dictSchema		withKey: 'apartInterfaceExtension'.	request := '{		hello 		films{			name 			id		}	}'.	result := self jsonRequest: request.	expectedResult := '{  "data": {  	"hello": "hello world",	"films" : [			{				"name" : "harry potter y la piedra filosofal",				"id" : 1			},			{				"name" : "el seÃ±or de los anillos",				"id" : 2			},			{				"name" : "terminator",				"id" : 3			},			{				"name" : "rambo",				"id" : 4			},			{				"name" : "robocop",				"id" : 5			},			{				"name" : "alien",				"id" : 6			},			{				"name" : "annie",				"id" : 7			}		]  }}'.	self assertJSONEquals: result and: expectedResult.	schema := self		validateSchemaOf: dictSchema		withKey: 'apartInterfaceExtensionWithObExt'.	request := '{		films{			name			id		}	}'.	result := self jsonRequest: request.	expectedResult := '{	"data" : {		"films" : [			{				"name" : "harry potter y la piedra filosofal",				"id" : 1			},			{				"name" : "el seÃ±or de los anillos",				"id" : 2			},			{				"name" : "terminator",				"id" : 3			},			{				"name" : "rambo",				"id" : 4			},			{				"name" : "robocop",				"id" : 5			},			{				"name" : "alien",				"id" : 6			},			{				"name" : "annie",				"id" : 7			}		]	}}'.	self assertJSONEquals: result and: expectedResult.	schema := self		validateSchemaOf: dictSchema		withKey: 'interfaceExtension'.	request := '{		films { 			name			id		}	}'.	result := self jsonRequest: request.	expectedResult := '{	"data" : {		"films" : [			{				"name" : "harry potter y la piedra filosofal",				"id" : 1			},			{				"name" : "el seÃ±or de los anillos",				"id" : 2			},			{				"name" : "terminator",				"id" : 3			},			{				"name" : "rambo",				"id" : 4			},			{				"name" : "robocop",				"id" : 5			},			{				"name" : "alien",				"id" : 6			},			{				"name" : "annie",				"id" : 7			}		]	}}'.	self assertJSONEquals: result and: expectedResult</body><body package="GraphQLBeta-Tests-Nodes" selector="testObjectTypeExtension">testObjectTypeExtension	| request result expectedResult |	schema := self		validateSchemaOf: dictSchema		withKey: 'apartObjectExtensWithFieldDef'.	request := '{		helloTo(name: "Alex")		films {			id 			name		}		features(film: { filmName: "Rambo" } )	}'.	result := self jsonRequest: request.	expectedResult := '{	"data" : {		"helloTo" : "hello Alex",		"films" : [			{				"id" : 1,				"name" : "harry potter y la piedra filosofal"			},			{				"id" : 2,				"name" : "el seÃ±or de los anillos"			},			{				"id" : 3,				"name" : "terminator"			},			{				"id" : 4,				"name" : "rambo"			},			{				"id" : 5,				"name" : "robocop"			},			{				"id" : 6,				"name" : "alien"			},			{				"id" : 7,				"name" : "annie"			}		],		"features" : "Rambo"	}}'.	self assertJSONEquals: result and: expectedResult.	schema := self		validateSchemaOf: dictSchema		withKey: 'apartObjectExtensWithFieldDef'.	request := '{		helloTo(name: "Maria")		films{			name		}	}'.	result := self jsonRequest: request.	expectedResult := '{	"data" : {		"helloTo" : "hello Maria",		"films" : [			{				"name" : "harry potter y la piedra filosofal"			},			{				"name" : "el seÃ±or de los anillos"			},			{				"name" : "terminator"			},			{				"name" : "rambo"			},			{				"name" : "robocop"			},			{				"name" : "alien"			},			{				"name" : "annie"			}		]	}}'.	self assertJSONEquals: result and: expectedResult.	schema := self		validateSchemaOf: dictSchema		withKey: 'objectExtensWithInterface'.	request := '{		cats { 			name		}		filmsSortedBy(name: true){			name		}	}'.	result := self jsonRequest: request.	expectedResult := '{	"data" : {		"cats" : [			{				"name" : "Misi"			},			{				"name" : "Figaro"			},			{				"name" : "Minino"			}		],		"filmsSortedBy" : [			{				"name" : "alien"			},			{				"name" : "annie"			},			{				"name" : "el seÃ±or de los anillos"			},			{				"name" : "harry potter y la piedra filosofal"			},			{				"name" : "rambo"			},			{				"name" : "robocop"			},			{				"name" : "terminator"			}		]	}}'.	self assertJSONEquals: result and: expectedResult.	schema := self		validateSchemaOf: dictSchema		withKey: 'objectExtensWithExtInterface'.	request := '{		filmsSortedBy(name: false){			name			id			rating		}	}'.	result := self jsonRequest: request.	expectedResult := '{	"data" : {		"filmsSortedBy" : [			{				"name" : "harry potter y la piedra filosofal",				"id" : 1,				"rating" : 9			},			{				"name" : "el seÃ±or de los anillos",				"id" : 2,				"rating" : 8			},			{				"name" : "terminator",				"id" : 3,				"rating" : 5			},			{				"name" : "rambo",				"id" : 4,				"rating" : 5			},			{				"name" : "robocop",				"id" : 5,				"rating" : 5			},			{				"name" : "alien",				"id" : 6,				"rating" : 7			},			{				"name" : "annie",				"id" : 7,				"rating" : 6			}		]	}}'.	self assertJSONEquals: result and: expectedResult.	schema := self		validateSchemaOf: dictSchema		withKey: 'objectExtensWithOtherResolver'.	request := '{		hello		asText(number: 53)	}'.	result := self jsonRequest: request.	expectedResult := '{  "data": { 	"hello": "hello world",	"asText": "53" }}'.	self assertJSONEquals: result and: expectedResult</body><body package="GraphQLBeta-Tests-Nodes" selector="testUnionTypeExtension">testUnionTypeExtension	| request result expectedResult expectedResult2 expectedResult3 expectedResult4 |	schema := self		validateSchemaOf: dictSchema		withKey: 'apartUnionExtension'.	request := '{		firstExtendedSearchObject { 			...on Point { 				x 				y			}			...on Rectangle { 				origin { 					x					y				}			}			...on GQLCat { 				nickname			}			...on GQLDog { 				name			}		}	}'.	expectedResult := '{  "data": {		"firstExtendedSearchObject": { 	 		"x": 2.4,			"y": 4.5	 	}  }}'.	expectedResult2 := '{  "data": {		"firstExtendedSearchObject": { 			"origin": { 	 			"x": 2.4,				"y": 5			}	 	}  }}'.	expectedResult3 := '{  "data": {		"firstExtendedSearchObject": { 			"nickname": "misi"	 	}  }}'.	expectedResult4 := '{  "data": {		"firstExtendedSearchObject": { 			"name": "Firulais"	 	}  }}'.	result := GraphQLPlatform current		jsonFromString: (self jsonRequest: request).	self		assert:			(result = (GraphQLPlatform current jsonFromString: expectedResult)				or:					(result = (GraphQLPlatform current jsonFromString: expectedResult2)						or:							(result = (GraphQLPlatform current jsonFromString: expectedResult3)								or: [ result = (GraphQLPlatform current jsonFromString: expectedResult4) ]))).	schema := self validateSchemaOf: dictSchema withKey: 'unionExtension'.	request := '{		firstExtendedSearchObject { 			...on Point { 				y			}			...on Rectangle { 				corner { 					x					y				}			}			...on GQLCat { 				name				nickname			}			...on GQLDog { 				name			}		}	}'.	expectedResult := '{  "data": {		"firstExtendedSearchObject": {			"y": 4.5	 	}  }}'.	expectedResult2 := '{  "data": {		"firstExtendedSearchObject": { 			"corner": { 	 			"x": 4,				"y": 5			}	 	}  }}'.	expectedResult3 := '{  "data": {		"firstExtendedSearchObject": { 			"name": "Misi",			"nickname": "misi"	 	}  }}'.	expectedResult4 := '{  "data": {		"firstExtendedSearchObject": { 			"name": "Firulais"	 	}  }}'.	result := GraphQLPlatform current		jsonFromString: (self jsonRequest: request).	self		assert:			(result = (GraphQLPlatform current jsonFromString: expectedResult)				or:					(result = (GraphQLPlatform current jsonFromString: expectedResult2)						or:							(result = (GraphQLPlatform current jsonFromString: expectedResult3)								or: [ result = (GraphQLPlatform current jsonFromString: expectedResult4) ])))</body></methods><methods><class-id>GraphQLBeta.GQLDocumentWithExtensionTest</class-id> <category>initialization</category><body package="GraphQLBeta-Tests-Nodes" selector="setUp">setUp	validator := GQLValidator new.	dictSchema := self initDictSchema.	withData := true</body></methods><methods><class-id>GraphQLBeta.GQLSSchemaNodeExtensionTest</class-id> <category>tests</category><body package="GraphQLBeta-Tests-Nodes" selector="testFailValidateSchemaWithEnumTypeExtension">testFailValidateSchemaWithEnumTypeExtension	self		assert:			(self				validateSchemaOf: dictOfInvalidSchema				withKey: 'wrongEnumExtensionManySchemas')		class: GQLValidationException.	self		assert:			(self				validateSchemaOf: dictOfInvalidSchema				withKey: 'wrongEnumExtensionOneSchema')		class: GQLValidationException</body><body package="GraphQLBeta-Tests-Nodes" selector="testFailValidSchemaWithInputObjectypeExtension">testFailValidSchemaWithInputObjectypeExtension	self		assert:			(self				validateSchemaOf: dictOfInvalidSchema				withKey: 'wrongInputObjectExtensManySchemas')		class: GQLValidationException.	self		assert:			(self				validateSchemaOf: dictOfInvalidSchema				withKey: 'wrongInputObjectExtensionOneSchema')		class: GQLValidationException</body><body package="GraphQLBeta-Tests-Nodes" selector="testFailValidSchemaWithInterfTypeExtension">testFailValidSchemaWithInterfTypeExtension	self		assert:			(self				validateSchemaOf: dictOfInvalidSchema				withKey: 'wrongInterfaceExtensManySchemas')		class: GQLValidationException.	self		assert:			(self				validateSchemaOf: dictOfInvalidSchema				withKey: 'wrongInterfaceExtensOneSchema')		class: GQLValidationException</body><body package="GraphQLBeta-Tests-Nodes" selector="testFailValidSchemaWithObjTypeExtension">testFailValidSchemaWithObjTypeExtension	self		assert:			(self				validateSchemaOf: dictOfInvalidSchema				withKey: 'wrongDefinedObjExtensionManySchemas')		class: GQLValidationException.	self		assert:			(self				validateSchemaOf: dictOfInvalidSchema				withKey: 'wrongDefinedObjExtensionOneSchema')		class: GQLValidationException.	self		assert:			(self				validateSchemaOf: dictOfInvalidSchema				withKey: 'wrongDefinedObjExtensWithInterface')		class: GQLValidationException.	self		assert:			(self				validateSchemaOf: dictOfInvalidSchema				withKey: 'wrongDefinedObjectExtensWithResolvers')		class: GQLValidationException</body><body package="GraphQLBeta-Tests-Nodes" selector="testFailValidSchemaWithUnionTypeExtension">testFailValidSchemaWithUnionTypeExtension	self		assert:			(self				validateSchemaOf: dictOfInvalidSchema				withKey: 'wrongUnionExtensionManySchemas')		class: GQLValidationException.	self		assert:			(self				validateSchemaOf: dictOfInvalidSchema				withKey: 'wrongUnionExtensionOneSchema')		class: GQLValidationException</body><body package="GraphQLBeta-Tests-Nodes" selector="testValidateSchemaWithEnumTypeExtension">testValidateSchemaWithEnumTypeExtension	self		assert: (self validateSchemaOf: dictSchema withKey: 'apartEnumExtension')		class: GQLSSchemaNode.	self		assert: (self validateSchemaOf: dictSchema withKey: 'enumExtension')		class: GQLSSchemaNode</body><body package="GraphQLBeta-Tests-Nodes" selector="testValidateSchemaWithInputObjectypeExtension">testValidateSchemaWithInputObjectypeExtension	self		assert:			(self				validateSchemaOf: dictSchema				withKey: 'apartInputObjectExtension')		class: GQLSSchemaNode.	self		assert: (self validateSchemaOf: dictSchema withKey: 'inputObjectExtension')		class: GQLSSchemaNode</body><body package="GraphQLBeta-Tests-Nodes" selector="testValidateSchemaWithInterfaceTypeExtension">testValidateSchemaWithInterfaceTypeExtension	self		assert: (self validateSchemaOf: dictSchema withKey: 'apartInterfaceExtension')		class: GQLSSchemaNode.	self		assert:			(self				validateSchemaOf: dictSchema				withKey: 'apartInterfaceExtensionWithObExt')		class: GQLSSchemaNode.	self		assert: (self validateSchemaOf: dictSchema withKey: 'interfaceExtension')		class: GQLSSchemaNode</body><body package="GraphQLBeta-Tests-Nodes" selector="testValidateSchemaWithObjectTypeExtension">testValidateSchemaWithObjectTypeExtension	self		assert:			(self				validateSchemaOf: dictSchema				withKey: 'apartObjectExtensWithFieldDef')		class: GQLSSchemaNode.	self		assert:			(self validateSchemaOf: dictSchema withKey: 'objectExtensWithFieldDef')		class: GQLSSchemaNode.	self		assert:			(self				validateSchemaOf: dictSchema				withKey: 'objectExtensWithInterface')		class: GQLSSchemaNode.	self		assert:			(self				validateSchemaOf: dictSchema				withKey: 'objectExtensWithExtInterface')		class: GQLSSchemaNode.	self		assert:			(self				validateSchemaOf: dictSchema				withKey: 'objectExtensWithOtherResolver')		class: GQLSSchemaNode</body><body package="GraphQLBeta-Tests-Nodes" selector="testValidateSchemaWithUnionTypeExtension">testValidateSchemaWithUnionTypeExtension	self		assert: (self validateSchemaOf: dictSchema withKey: 'apartUnionExtension')		class: GQLSSchemaNode.	self		assert: (self validateSchemaOf: dictSchema withKey: 'unionExtension')		class: GQLSSchemaNode</body></methods><methods><class-id>GraphQLBeta.GQLSSchemaNodeExtensionTest</class-id> <category>initialization</category><body package="GraphQLBeta-Tests-Nodes" selector="setUp">setUp	dictSchema := self initDictSchema.	dictOfInvalidSchema := self initDictOfInvalidSchema</body></methods><methods><class-id>GraphQLBeta.GQLComplex</class-id> <category>accessing</category><body package="GraphQLBeta-Test-Utils" selector="bar">bar	^ 'bar'</body><body package="GraphQLBeta-Test-Utils" selector="foo">foo	^ 'foo'</body></methods><methods><class-id>GraphQLBeta.GQLTestValidation</class-id> <category>parsing</category><body package="GraphQLBeta-Tests-Validation" selector="attendRequest:using:with:root:">attendRequest: text using: operationName with: textVariables root: root	| document variables |	document := self parseRequest: text.	textVariables isEmpty		ifFalse: [ variables := self parseVariables: textVariables ]		ifTrue: [ variables := nil ].	^ GQLValidator new		variables: variables;		operationName: operationName;		rootInstance: root;		document: document;		text: text;		schema: schema;		execute</body><body package="GraphQLBeta-Tests-Validation" selector="requestEvaluator">requestEvaluator	^ GQLSingleAnonimousQueryEvaluator</body></methods><methods><class-id>GraphQLBeta.GQLTestValidation</class-id> <category>initialization</category><body package="GraphQLBeta-Tests-Validation" selector="setUp">setUp	schema := self parseSchema: GQLQueryRoot schema.	schema := schema validate.	rootInstance := GQLQueryRoot new.	schema root: rootInstance.	compareJson := true</body></methods><methods><class-id>GraphQLBeta.GQLValuesValidationTest</class-id> <category>tests</category><body package="GraphQLBeta-Tests-Validation" selector="testInputObjectFieldNames01">testInputObjectFieldNames01	"Every input field provided in an input object value must be defined in the set of possible fields of that input objectâs expected type."	| result |	"This document is the valid"	result := self		jsonRequest:			'{	findDog(complex: { name: "Fido" })	{ 		barkVolume	}}'.	self		assert: result		equals:			'{	"data" : {		"findDog" : {			"barkVolume" : 10		}	}}'</body><body package="GraphQLBeta-Tests-Validation" selector="testInputObjectFieldNames02">testInputObjectFieldNames02	"Every input field provided in an input object value must be defined in the set of possible fields of that input objectâs expected type."	| result |	"This document is the invalid"	result := self		jsonRequest:			'{	findDog(complex: { favoriteCookieFlavor: "Bacon" })	{ 		barkVolume	}}'.	self		assert: result		equals:			'{	"errors" : [		{			"message" : "Field \"favoriteCookieFlavor\" is not defined by type GQLDogInput",			"locations" : [				{					"line" : 3,					"column" : 21				}			]		}	]}'</body><body package="GraphQLBeta-Tests-Validation" selector="testInputObjectFieldNames03">testInputObjectFieldNames03	"Every input field provided in an input object value must be defined in the set of possible fields of that input objectâs expected type."	| result |	"This document is the valid"	result := self		jsonRequest:			'{	findDogNotNull(complex: { name: "Fido"})	{ 		name,		barkVolume	}}'.	self		assert: result		equals:			'{	"data" : {		"findDogNotNull" : {			"name": "Fido",			"barkVolume" : null		}	}}'</body><body package="GraphQLBeta-Tests-Validation" selector="testInputObjectFieldUniqueness">testInputObjectFieldUniqueness	"Input objects must not contain more than one field of the same name, otherwise an ambiguity would exist which includes an ignored portion of syntax."	| result |	"This document is the invalid"	self		flag:			'update this to work on all input objects of the document. Ej	{	args(arg: {fo: 123, fo:123}) #this has an error that we can detect	}'.	result := self		jsonRequest:			'{	findDog(complex: { name: "fido", name: "lobo" }){		barkVolume	}}'.	self		assert: result		equals:			'{	"errors" : [		{			"message" : "There can be only one input field named \"name\".",			"locations" : [				{					"line" : 3,					"column" : 21				},				{					"line" : 3,					"column" : 35				}			]		}	]}'</body><body package="GraphQLBeta-Tests-Validation" selector="testInputObjectRequiredFields">testInputObjectRequiredFields	"Input object fields may be required. Much like a field may have required arguments, an input object may have required fields. An input field is required if it has a nonânull type and does not have a default value. Otherwise, the input object field is optional."	self		flag: 'TODO, since we do not support default values in input definition'</body><body package="GraphQLBeta-Tests-Validation" selector="testValuesOfCorrectType01">testValuesOfCorrectType01	"Literal values must be compatible with the type expected in the position they are found as per the coercion rules defined in the Type System chapter.The type expected in a position include the type defined by the argument a value is provided for, the type defined by an input object field a value is provided for, and the type of a variable definition a default value is provided for."	| result |	"This document is the valid"	self		flag:			'Future work, try to execute this wihtout variables, only with the default value'.	result := self		operation: 'goodComplexDefaultValue'		variables: '{"search" : { name: "Fido" }}'		jsonRequest:			'fragment goodBooleanArg on GQLArguments {  booleanArgField(booleanArg: true)}fragment coercedIntIntoFloatArg on GQLArguments {  # Note: The input coercion rules for Float allow Int literals.  floatArgField(floatArg: 123)}query foo{	arguments{		...coercedIntIntoFloatArg		...goodBooleanArg	}}query goodComplexDefaultValue($search: GQLDogInput = { name: "Fido" }) {	findDog(complex: $search){		owner { name }	}}'.	self		assert: result		equals:			'{	"data" : {		"findDog" : {			"owner" : {				"name" : "Akevalion"			}		}	}}'</body><body package="GraphQLBeta-Tests-Validation" selector="testValuesOfCorrectType02">testValuesOfCorrectType02	"Literal values must be compatible with the type expected in the position they are found as per the coercion rules defined in the Type System chapter.The type expected in a position include the type defined by the argument a value is provided for, the type defined by an input object field a value is provided for, and the type of a variable definition a default value is provided for."	| result |	"This document is the invalid"	result := self		operation: 'badComplexValue'		variables: ''		jsonRequest:			'fragment stringIntoInt on GQLArguments {  intArgField(intArg: "123")}query foo{	arguments{		...stringIntoInt	}}query badComplexValue {	findDog(complex: { name: 123 }){barkVolume}}'.	self		assert: result		equals:			'{	"errors" : [		{			"message" : "Argument \"intArg\" has invalid value \"123\". Expected type \"Int\".",			"locations" : [				{					"line" : 3,					"column" : 23				}			]		},		{			"message" : "Expected type String, found 123.",			"locations" : [				{					"line" : 11,					"column" : 21				}			]		}	]}'</body></methods><methods><class-id>GraphQLBeta.GQLFragmentsValidationTest</class-id> <category>tests</category><body package="GraphQLBeta-Tests-Validation" selector="testAbstractSpreadsInAbstractScope01">testAbstractSpreadsInAbstractScope01	"Fragments are declared on a type and will only apply when the runtime object type matches the type condition. They also are spread within the context of a parent type. A fragment spread is only valid if its type condition could ever apply within the parent type.		Union or interfaces fragments can be used within each other. As long as there exists at least one object type that exists in the intersection of the possible types of the scope and the spread, the spread is considered valid."	| result |	"This document is valid"	result := self		jsonRequest:			'{	dog { 		...unionWithInterface		...dogOrHumanFragment	}}fragment unionWithInterface on GQLPet {  ...dogOrHumanFragment}fragment dogOrHumanFragment on DogOrHuman {  ... on GQLDog {    barkVolume  }}'.	self		assert: result		equals:			'{	"data" : {		"dog" : {			"barkVolume" : 10		}	}}'</body><body package="GraphQLBeta-Tests-Validation" selector="testAbstractSpreadsInAbstractScope02">testAbstractSpreadsInAbstractScope02	"Fragments are declared on a type and will only apply when the runtime object type matches the type condition. They also are spread within the context of a parent type. A fragment spread is only valid if its type condition could ever apply within the parent type.		Union or interfaces fragments can be used within each other. As long as there exists at least one object type that exists in the intersection of the possible types of the scope and the spread, the spread is considered valid."	| result |	"This document is invalid"	result := self		jsonRequest:			'{	dog { 		...nonIntersectingInterfaces	}}fragment nonIntersectingInterfaces on GQLPet {  ...sentientFragment}fragment sentientFragment on GQLSentient {  name}'.	self		assert: result		equals:			'{	"errors" : [		{			"message" : "Fragment \"sentientFragment\" cannot be spread here as objects of type \"GQLSentient\" can never be of type \"GQLPet\".",			"locations" : [				{					"line" : 8,					"column" : 6				}			]		}	]}'</body><body package="GraphQLBeta-Tests-Validation" selector="testAbstractSpreadsInObjectScope01">testAbstractSpreadsInObjectScope01	"Fragments are declared on a type and will only apply when the runtime object type matches the type condition. They also are spread within the context of a parent type. A fragment spread is only valid if its type condition could ever apply within the parent type.		In scope of an object type, unions or interface spreads can be used if the object type implements the interface or is a member of the union."	| result |	"This document is valid"	result := self		jsonRequest:			'{	dog { 		...interfaceWithinObjectFragment	}}fragment petNameFragment on GQLPet {	name}fragment interfaceWithinObjectFragment on GQLDog {	...petNameFragment}'.	self		assert: result		equals:			'{	"data" : {		"dog" : {			"name" : "lobo"		}	}}'</body><body package="GraphQLBeta-Tests-Validation" selector="testAbstractSpreadsInObjectScope02">testAbstractSpreadsInObjectScope02	"Fragments are declared on a type and will only apply when the runtime object type matches the type condition. They also are spread within the context of a parent type. A fragment spread is only valid if its type condition could ever apply within the parent type.		In scope of an object type, unions or interface spreads can be used if the object type implements the interface or is a member of the union."	| result |	"This document is valid"	result := self		jsonRequest:			'{	dog { 		...unionWithObjectFragment	}}fragment catOrDogNameFragment on CatOrDog {	... on GQLCat {		meowVolume	}}fragment unionWithObjectFragment on GQLDog {	...catOrDogNameFragment}'.	self		assert: result		equals:			'{	"data" : {		"dog" : { }	}}'</body><body package="GraphQLBeta-Tests-Validation" selector="testFragmentNameUniquess01">testFragmentNameUniquess01	"Fragment definitions are referenced in fragment spreads by name. To avoid ambiguity, each fragmentâs name must be unique within a document.Inline fragments are not considered fragment definitions, and are unaffected by this validation rule."	| result |	"This document is valid"	result := self		jsonRequest:			'{  dog {    ...fragmentOne    ...fragmentTwo  }}fragment fragmentOne on GQLDog {  name}fragment fragmentTwo on GQLDog {  owner {    name  }}'.	self		assert: result		equals:			'{	"data" : {		"dog" : {			"name" : "lobo",			"owner" : {				"name" : "Akevalion"			}		}	}}'</body><body package="GraphQLBeta-Tests-Validation" selector="testFragmentNameUniquess02">testFragmentNameUniquess02	"Fragment definitions are referenced in fragment spreads by name. To avoid ambiguity, each fragmentâs name must be unique within a document.Inline fragments are not considered fragment definitions, and are unaffected by this validation rule."	| result |	"This document is invalid"	result := self		jsonRequest:			'{	dog {		...fragmentOne	}}fragment fragmentOne on GQLDog {	name}fragment fragmentOne on GQLDog {	owner {		name	}}'.	self		assert: result		equals:			'{	"errors" : [		{			"message" : "There can be only one fragment named \"fragmentOne\".",			"locations" : [				{					"line" : 8,					"column" : 10				},				{					"line" : 12,					"column" : 10				}			]		}	]}'</body><body package="GraphQLBeta-Tests-Validation" selector="testFragmentsMustBeUsed">testFragmentsMustBeUsed	"efined fragments must be used within a document."	| result |	"This document is invalid"	result := self		jsonRequest:			'fragment nameFragment on GQLDog { # unused	name}{	dog {		name	}}'.	self		assert: result		equals:			'{	"errors" : [		{			"message" : "Fragment \"nameFragment\" is never used.",			"locations" : [				{					"line" : 2,					"column" : 10				}			]		}	]}'</body><body package="GraphQLBeta-Tests-Validation" selector="testFragmentsOnCompositeTypes01">testFragmentsOnCompositeTypes01	"Fragments can only be declared on unions, interfaces, and objects. They are invalid on scalars. They can only be applied on nonâleaf fields. This rule applies to both inline and named fragments."	| result |	"This document is valid"	result := self		jsonRequest:			'{	dog { 		...fragOnObject		...fragOnInterface		...fragOnUnion	}}fragment fragOnObject on GQLDog {	name}fragment fragOnInterface on GQLPet {	name}fragment fragOnUnion on CatOrDog {	... on GQLDog {		name	}}'.	self		assert: result		equals:			'{	"data" : {		"dog" : {			"name" : "lobo"		}	}}'</body><body package="GraphQLBeta-Tests-Validation" selector="testFragmentsOnCompositeTypes02">testFragmentsOnCompositeTypes02	"Fragments can only be declared on unions, interfaces, and objects. They are invalid on scalars. They can only be applied on nonâleaf fields. This rule applies to both inline and named fragments."	| result |	"This document is invalid"	result := self		jsonRequest:			'{	dog { 		...fragOnScalar		...inlineFragOnScalar	}}fragment fragOnScalar on Int {	something}fragment inlineFragOnScalar on GQLDog {	... on Boolean {		somethingElse	}}'.	self		assert: result		equals:			'{	"errors" : [		{			"message" : "Fragment \"fragOnScalar\" cannot condition on non composite type \"Int\"",			"locations" : [				{					"line" : 8,					"column" : 26				}			]		},		{			"message" : "Fragment cannot condition on non composite type \"Boolean\"",			"locations" : [				{					"line" : 13,					"column" : 9				}			]		}	]}'</body><body package="GraphQLBeta-Tests-Validation" selector="testFragmentSpreadsMustNotFormCycles01">testFragmentSpreadsMustNotFormCycles01	"The graph of fragment spreads must not form any cycles including spreading itself. Otherwise an operation could infinitely spread or infinitely execute on cycles in the underlying data."	| result |	"This document is invalid"	result := self		jsonRequest:			'{	dog {		...nameFragment	}}fragment nameFragment on GQLDog {	name	...barkVolumeFragment}fragment barkVolumeFragment on GQLDog {	barkVolume	...nameFragment}'.	self		assert: result		equals:			'{	"errors" : [		{			"message" : "Cannot spread fragment \"nameFragment\" with itself via barkVolumeFragment",			"locations" : [				{					"line" : 10,					"column" : 5				}			]		},		{			"message" : "Cannot spread fragment \"barkVolumeFragment\" with itself via nameFragment",			"locations" : [				{					"line" : 15,					"column" : 5				}			]		}	]}'</body><body package="GraphQLBeta-Tests-Validation" selector="testFragmentSpreadsMustNotFormCycles02">testFragmentSpreadsMustNotFormCycles02	"The graph of fragment spreads must not form any cycles including spreading itself. Otherwise an operation could infinitely spread or infinitely execute on cycles in the underlying data."	| result |	"This document is invalid"	result := self		jsonRequest:			'{	dog {		...dogFragment	}}fragment dogFragment on GQLDog {	name	owner {		...ownerFragment	}}fragment ownerFragment on GQLDog {	name	pets {		...dogFragment	}}'.	self		assert: result		equals:			'{	"errors" : [		{			"message" : "Cannot spread fragment \"dogFragment\" with itself via ownerFragment",			"locations" : [				{					"line" : 11,					"column" : 6				}			]		},		{			"message" : "Fragment \"ownerFragment\" cannot be spread here as objects of type \"GQLDog\" can never be of type \"GQLHuman\".",			"locations" : [				{					"line" : 11,					"column" : 6				}			]		},		{			"message" : "Cannot query field \"pets\" on type \"GQLDog\"",			"locations" : [				{					"line" : 17,					"column" : 2				}			]		},		{			"message" : "Cannot spread fragment \"ownerFragment\" with itself via dogFragment",			"locations" : [				{					"line" : 18,					"column" : 6				}			]		}	]}'</body><body package="GraphQLBeta-Tests-Validation" selector="testFragmentSpreadTargetDefined">testFragmentSpreadTargetDefined	"Named fragment spreads must refer to fragments defined within the document. It is a validation error if the target of a spread is not defined."	| result |	"This document is invalid"	result := self		jsonRequest:			'{	dog {		...undefinedFragment	}}'.	self		assert: result		equals:			'{	"errors" : [		{			"message" : "Unknown fragment \"undefinedFragment\".",			"locations" : [				{					"line" : 3,					"column" : 6				}			]		}	]}'</body><body package="GraphQLBeta-Tests-Validation" selector="testFragmentSpreadTypeExistence01">testFragmentSpreadTypeExistence01	"Fragments must be specified on types that exist in the schema. This applies for both named and inline fragments. If they are not defined in the schema, the query does not validate."	| result |	"This document is valid"	result := self		jsonRequest:			'{	dog { 		...correctType		...inlineFragment		...inlineFragment2	}}fragment correctType on GQLDog {	name}fragment inlineFragment on GQLDog {	... on GQLDog {		name	}}fragment inlineFragment2 on GQLDog {	... @include(if: true) {		name	}}'.	self		assert: result		equals:			'{	"data" : {		"dog" : {			"name" : "lobo"		}	}}'</body><body package="GraphQLBeta-Tests-Validation" selector="testFragmentSpreadTypeExistence02">testFragmentSpreadTypeExistence02	"Fragments must be specified on types that exist in the schema. This applies for both named and inline fragments. If they are not defined in the schema, the query does not validate."	| result |	"This document is invalid"	result := self		jsonRequest:			'{	dog { 		...notOnExistingType		...inlineNotExistingType	}}fragment notOnExistingType on NotInSchema {	name}fragment inlineNotExistingType on GQLDog {	... on NotInSchema {		name  }}'.	self		assert: result		equals:			'{	"errors" : [		{			"message" : "Unkwown type \"NotInSchema\".",			"locations" : [				{					"line" : 8,					"column" : 31				},				{					"line" : 13,					"column" : 9				}			]		}	]}'</body><body package="GraphQLBeta-Tests-Validation" selector="testObjectSpreadsInAbstractScope01">testObjectSpreadsInAbstractScope01	"Fragments are declared on a type and will only apply when the runtime object type matches the type condition. They also are spread within the context of a parent type. A fragment spread is only valid if its type condition could ever apply within the parent type.		Union or interface spreads can be used within the context of an object type fragment, but only if the object type is one of the possible types of that interface or union."	| result |	"This document is valid"	result := self		jsonRequest:			'{	dog { 		...petFragment		...catOrDogFragment	}}fragment petFragment on GQLPet {	name	... on GQLDog {		barkVolume	}}fragment catOrDogFragment on CatOrDog {	... on GQLCat {		meowVolume	}}'.	self		assert: result		equals:			'{	"data" : {		"dog" : {			"name" : "lobo",			"barkVolume" : 10		}	}}'</body><body package="GraphQLBeta-Tests-Validation" selector="testObjectSpreadsInAbstractScope02">testObjectSpreadsInAbstractScope02	"Fragments are declared on a type and will only apply when the runtime object type matches the type condition. They also are spread within the context of a parent type. A fragment spread is only valid if its type condition could ever apply within the parent type.		Union or interface spreads can be used within the context of an object type fragment, but only if the object type is one of the possible types of that interface or union."	| result |	"This document is invalid"	result := self		jsonRequest:			'{	dog { 		...sentientFragment		...humanOrAlienFragment	}}fragment sentientFragment on GQLSentient {	... on GQLDog {		barkVolume	}}fragment humanOrAlienFragment on HumanOrAlien {	... on GQLCat {		meowVolume	}}'.	self		assert: result		equals:			'{	"errors" : [		{			"message" : "Fragment \"sentientFragment\" cannot be spread here as objects of type \"GQLSentient\" can never be of type \"GQLDog\".",			"locations" : [				{					"line" : 4,					"column" : 6				}			]		},		{			"message" : "Fragment \"humanOrAlienFragment\" cannot be spread here as objects of type \"HumanOrAlien\" can never be of type \"GQLDog\".",			"locations" : [				{					"line" : 5,					"column" : 6				}			]		},		{			"message" : "Fragment cannot be spread here as objects of type \"GQLSentient\" can never be of type \"GQLDog\".",			"locations" : [				{					"line" : 9,					"column" : 2				}			]		},		{			"message" : "Fragment cannot be spread here as objects of type \"HumanOrAlien\" can never be of type \"GQLCat\".",			"locations" : [				{					"line" : 15,					"column" : 2				}			]		}	]}'</body><body package="GraphQLBeta-Tests-Validation" selector="testObjectSpreadsInObjectScope01">testObjectSpreadsInObjectScope01	"Fragments are declared on a type and will only apply when the runtime object type matches the type condition. They also are spread within the context of a parent type. A fragment spread is only valid if its type condition could ever apply within the parent type.		In the scope of an object type, the only valid object type fragment spread is one that applies to the same type that is in scope."	| result |	"This document is valid"	result := self		jsonRequest:			'{	dog { 		...dogFragment	}}fragment dogFragment on GQLDog { 	... on GQLDog {		barkVolume	}}'.	self		assert: result		equals:			'{	"data" : {		"dog" : {			"barkVolume" : 10		}	}}'</body><body package="GraphQLBeta-Tests-Validation" selector="testObjectSpreadsInObjectScope02">testObjectSpreadsInObjectScope02	"Fragments are declared on a type and will only apply when the runtime object type matches the type condition. They also are spread within the context of a parent type. A fragment spread is only valid if its type condition could ever apply within the parent type.		In the scope of an object type, the only valid object type fragment spread is one that applies to the same type that is in scope."	| result |	"This document is invalid"	result := self		jsonRequest:			'{	dog { 		...catInDogFragmentInvalid	}}fragment catInDogFragmentInvalid on GQLDog {  ... on GQLCat {    meowVolume  }}'.	self		assert: result		equals:			'{	"errors" : [		{			"message" : "Fragment cannot be spread here as objects of type \"GQLDog\" can never be of type \"GQLCat\".",			"locations" : [				{					"line" : 8,					"column" : 3				}			]		}	]}'</body></methods><methods><class-id>GraphQLBeta.GQLDirectivesValidationTest</class-id> <category>tests</category><body package="GraphQLBeta-Tests-Validation" selector="testDirectivesAreDefined">testDirectivesAreDefined	"GraphQL servers define what directives they support. For each usage of a directive, the directive must be available on that server."	self assert: (schema getDirective: 'skip') notNil.	self assert: (schema getDirective: 'include') notNil</body><body package="GraphQLBeta-Tests-Validation" selector="testDirectivesAreInValidLocations">testDirectivesAreInValidLocations	"GraphQL servers define what directives they support and where they support them. For each usage of a directive, the directive must be used in a location that the server has declared support for."	| result |	result := self		operation: 'foo'		jsonRequest:			'query foo @skip(if: $foo) {	dog{		nickname	}}'.	self		assert: result		equals:			'{	"errors" : [		{			"message" : "Directive \"skip\" may not be used on QUERY.",			"locations" : [				{					"line" : 2,					"column" : 12				}			]		}	]}'</body><body package="GraphQLBeta-Tests-Validation" selector="testDirectivesAreUniquePerLocation01">testDirectivesAreUniquePerLocation01	"Directives are used to describe some metadata or behavioral change on the definition they apply to. When more than one directive of the same name is used, the expected metadata or behavior becomes ambiguous, therefore only one of each directive is allowed per location."	| result |	result := self		operation: 'foo'		jsonRequest:			'query foo($foo: Boolean=true, $bar: Boolean = false) {	dog @skip(if: $foo) @skip(if: $bar) {		nickname	}}'.	self		assert: result		equals:			'{	"errors" : [		{			"message" : "The directive \"skip\" can only be used once at this location.",			"locations" : [				{					"line" : 3,					"column" : 7				},				{					"line" : 3,					"column" : 23				}			]		}	]}'</body><body package="GraphQLBeta-Tests-Validation" selector="testDirectivesAreUniquePerLocation02">testDirectivesAreUniquePerLocation02	"Directives are used to describe some metadata or behavioral change on the definition they apply to. When more than one directive of the same name is used, the expected metadata or behavior becomes ambiguous, therefore only one of each directive is allowed per location."	| result |	result := self		operation: 'foo'		jsonRequest:			'query foo($foo: Boolean = true, $bar: Boolean = false) {  dog @skip(if: $foo) {    nickname  }  dog @skip(if: $bar) {    barkVolume  }}'.	self		assertJSONEquals: result		and:			'{	"data" : {			"dog" : {				"barkVolume" : 10			}		}	}'</body><body package="GraphQLBeta-Tests-Validation" selector="testInvalidDirectives">testInvalidDirectives	| result |	result := self		jsonRequest:			'{	dog @invalid { 		name	 }}'.	self		assert: result		equals:			'{	"errors" : [		{			"message" : "Unknown directive \"invalid\".",			"locations" : [				{					"line" : 3,					"column" : 7				}			]		}	]}'</body></methods><methods><class-id>GraphQLBeta.GQLMutation</class-id> <category>as yet unclassified</category><body package="GraphQLBeta-Test-Utils" selector="createPointX:y:">createPointX: x y: y	^ x @ y</body><body package="GraphQLBeta-Test-Utils" selector="createRectangleLeft:right:top:bottom:">createRectangleLeft: left right: right top: top bottom: bottom	^ Rectangle		left: left		right: right		top: top		bottom: bottom</body></methods><methods><class-id>GraphQLBeta.GQLMutation</class-id> <category>initialization</category><body package="GraphQLBeta-Test-Utils" selector="setNumberTo:">setNumberTo: aInt	^ aInt</body></methods><methods><class-id>GraphQLBeta.GQLSchemaGrammarTest</class-id> <category>test-grammar-objectType</category><body package="GraphQLBeta-Tests-Grammar" selector="testFailObjectTypeIncomplete">testFailObjectTypeIncomplete	self fail: '{someName 	: 	ID !}' rule: #objectType.	self fail: 'type {someName 	: 	ID !}' rule: #objectType.	self fail: 'type {}' rule: #objectType.	self fail: 'type Some {}' rule: #objectType.	self fail: 'type implements' rule: #objectType.	self fail: 'type Some implements {}' rule: #objectType.	self fail: 'type Some implements {someName : ID}' rule: #objectType.	self fail: 'type Some Other { someName: ID}' rule: #objectType</body><body package="GraphQLBeta-Tests-Grammar" selector="testFailObjectTypeOther">testFailObjectTypeOther	self fail: 'enum Flower { ROSE, LAVANDA}' rule: #objectType.	self fail: 'interface Sentiet { name : String}' rule: #objectType.	self fail: 'union CatOrDog = Cat | Dog' rule: #objectType</body><body package="GraphQLBeta-Tests-Grammar" selector="testObjectType">testObjectType	self parse: 'type SomeType {someName : [Int]}' rule: #objectType.	self		parse: 'type SomeOtherTypeName {someName 	: [String ! ], someName 	:String }'		rule: #objectType.	self parse: 'type Some {someObject : Some }' rule: #objectType.	self parse: 'type Some {someObject : Some ! }' rule: #objectType.	self parse: 'type Some {someObject : [ Some ] ! }' rule: #objectType.	self parse: 'type Some {someObject : [ Some ! ] }' rule: #objectType.	self		parse: 'type Some {someObject : [ Some ! ] ! }'		rule: #objectType.	self		parse: 'type Some implements Other { some : Int }'		rule: #objectType.	self		parse:			'type SomeOtherTypeName implements Other {someName 	: [String ! ], someName 	:String }'		rule: #objectType.	self		parse: 'type Some implements Other {someObject : Some }'		rule: #objectType.	self		parse: 'type Some implements Other {someObject(a : String) : Some }'		rule: #objectType.	self		parse: 'type Some implements Other {someObject(a : String, p: Some) : Some }'		rule: #objectType.	self		parse: 'type Some implements Other {someObject : Some ! }'		rule: #objectType.	self		parse: 'type Some implements Other {someObject : [ Some ] ! }'		rule: #objectType.	self		parse: 'type Some implements Other {someObject : [ Some ! ] }'		rule: #objectType.	self		parse: 'type Some implements Other {someObject : [ Some ! ] ! }'		rule: #objectType</body></methods><methods><class-id>GraphQLBeta.GQLSchemaGrammarTest</class-id> <category>test-grammar-description</category><body package="GraphQLBeta-Tests-Grammar" selector="testDescription">testDescription	self parse: '"description of schema"' rule: #description.	self		parse: '"descriptions often occur before the definition"'		rule: #description.	self		parse:			'"""BlockString contains more than an line 					generally"""'		rule: #description</body><body package="GraphQLBeta-Tests-Grammar" selector="testDescriptionInvalid">testDescriptionInvalid	self		fail: '"description of schema" "an second description invalid"'		rule: #description.	self		fail:			'"""BlockString contains more than an line ' , Character cr asString				, 'generally""" """"an second block String invalid"""'		rule: #description.	self		fail:			'"descriptions often occur before the definition" """ block String invalid"""'		rule: #description.	self		fail:			'"""block string description""" "an second description String invalid"'		rule: #description</body></methods><methods><class-id>GraphQLBeta.GQLSchemaGrammarTest</class-id> <category>tests-grammar</category><body package="GraphQLBeta-Tests-Grammar" selector="parserClass">parserClass	^ GQLSchemaGrammar</body><body package="GraphQLBeta-Tests-Grammar" selector="testSchemaAll">testSchemaAll	| text |	text := 'enum DogCommand { SIT, DOWN, HEEL }				type Dog implements Pet {  					name: String!  					nickname: String  					barkVolume: Int  					doesKnowCommand(dogCommand: DogCommand!): Boolean!  					isHousetrained(atOtherHomes: Boolean): Boolean!  					owner: Human				}				interface Sentient {  					name: String!				}				interface Pet { 					 name: String!				}				type Alien implements Sentient {  					name: String!  					homePlanet: String				}				type Human implements Sentient {  					name: String!				}				enum CatCommand { JUMP }			type Cat implements Pet {  				name: String!  				nickname: String  				doesKnowCommand(catCommand: CatCommand!): Boolean!  				meowVolume: Int			}			union CatOrDog = Cat | Dog			union DogOrHuman = Dog | Human			union HumanOrAlien = Human | Alien			type QueryRoot {  				dog: Dog			}'.	self parse: text rule: #schema</body><body package="GraphQLBeta-Tests-Grammar" selector="testSchemaDefinition">testSchemaDefinition	self		parse:			'			schema{					query: Query				}				type Query{					hello: String				}'		rule: #schema.	self		parse:			'		schema{			query: Query			mutation: Mutation			}		type Query { 			hello: String		}		type Mutation{			setNumber(to:Int): Int		}		'		rule: #schema</body><body package="GraphQLBeta-Tests-Grammar" selector="testSchemaDefinitionIncorrect">testSchemaDefinitionIncorrect	self		fail:			'				schema{					query: Query					query2: Query2				}				type Query{					hello				}				type Query2{					helloWorld				}'		rule: #schema.	self		fail:			'schema1{						query: Query					}					type Query{						hello					}'		rule: #schema.	self		fail:			'schema{						query: Query						mutation1: Mutation					}					type Query{						hello					}					mutation Mutation{						setNumber(num:Int): Int					}					'		rule: #schema.	self		fail:			'schema{						query: __Query					}					type __Query{						hello					}					'		rule: #schema.	self		fail:			'schema{					}'		rule: #schema</body><body package="GraphQLBeta-Tests-Grammar" selector="testSchemaInputObjectType">testSchemaInputObjectType	| text |	text := 'input MessageInput {  				content: String 				author: String			}			type Message {  				id: ID!  				content: String  				author: String			}			type Query {  				getMessage(id: ID!): Message			}'.	self parse: text rule: #schema.	self		parse:			'input SomeType {						someName : [Int]					}'		rule: #schema.	self		parse:			'input SomeOtherTypeName {						someName 	: [String ! ],						someName 	:String 					}'		rule: #schema</body><body package="GraphQLBeta-Tests-Grammar" selector="testSchemaObjectType">testSchemaObjectType	| text |	text := 'type SomeType {					someName : [Int]				},				type SomeOtherTypeName {					someName 	: [String ! ]					someName 	:String 				}'.	self parse: text rule: #schema.	self		parse:			'type SomeType {						someName : [Int]					}'		rule: #schema.	self		parse:			'type SomeOtherTypeName {						someName 	: [String ! ],						someName 	:String 					}'		rule: #schema</body><body package="GraphQLBeta-Tests-Grammar" selector="testSchemaWithEnum">testSchemaWithEnum	| text |	text := 'enum DogCommand { SIT, DOWN, HEEL }				type SomeType {					someName : [Int]				},				type SomeOtherTypeName {					someName 	: [String ! ]					someName 	:String 				}'.	self parse: text rule: #schema.	self		parse:			'type SomeType {						someName : [Int]					}			enum DogCommand { SIT, DOWN, HEEL }'		rule: #schema.	self		parse:			'enum CatCommand { JUMP }			type SomeOtherTypeName {						someName 	: [String ! ],						someName 	:String 					}			enum DogCommand { SIT, DOWN, HEEL }'		rule: #schema</body><body package="GraphQLBeta-Tests-Grammar" selector="testSchemaWithInterface">testSchemaWithInterface	| text |	text := 'type SomeType {					someName : [Int]				},				interface SomeOtherTypeName {					someName 	: [String ! ]					someName 	:String 				}'.	self parse: text rule: #schema.	self		parse:			'interface SomeType {						someName : [Int]					}'		rule: #schema</body><body package="GraphQLBeta-Tests-Grammar" selector="testSchemaWithUnion">testSchemaWithUnion	| text |	text := 'union DogOrHuman = Dog | Human				union HumanOrAlien = Human | Alien				type SomeType {					someName : [Int]				},				type SomeOtherTypeName {					someName 	: [String ! ]					someName 	:String 				}'.	self parse: text rule: #schema.	self		parse:			'type SomeType {						someName : [Int]					}			union HumanOrAlien = Human | Alien'		rule: #schema.	self		parse:			'union HumanOrAlien = Human | Alien			type SomeOtherTypeName {						someName 	: [String ! ],						someName 	:String 					}			union DogOrHuman = Dog | Human'		rule: #schema</body></methods><methods><class-id>GraphQLBeta.GQLSchemaGrammarTest</class-id> <category>test-grammar-typeSystemExtension</category><body package="GraphQLBeta-Tests-Grammar" selector="testEnumTypeExtension">testEnumTypeExtension	self		parse: 'extend enum DogCommand { SIT, DOWN, HEEL }'		rule: #typeSystemExtension.	self		parse: 'extend enum CatCommand { JUMP }'		rule: #typeSystemExtension</body><body package="GraphQLBeta-Tests-Grammar" selector="testEnumTypeExtensionIncorrect">testEnumTypeExtensionIncorrect	self		fail: 'extend DogCommand { SIT, DOWN, HEEL }'		rule: #typeSystemExtension.	self fail: 'extend enum { JUMP }' rule: #typeSystemExtension.	self fail: 'extend enum DogCommand' rule: #typeSystemExtension.	self fail: 'extend enum CatCommand { }' rule: #typeSystemExtension.	self		fail: 'extend "desription of enum" enum CatCommand { MEOW }'		rule: #typeSystemExtension</body><body package="GraphQLBeta-Tests-Grammar" selector="testInputObjectTypeExtension">testInputObjectTypeExtension	self		parse: 'extend input SomeType {someName : [Int]}'		rule: #typeSystemExtension.	self		parse:			'extend input SomeOtherTypeName {someName 	: [String ! ], someName 	:String }'		rule: #typeSystemExtension.	self		parse: 'extend input Some {someObject : Some }'		rule: #typeSystemExtension.	self		parse: 'extend input Some {someObject : Some ! }'		rule: #typeSystemExtension.	self		parse: 'extend input Some {someObject : [ Some ! ] ! }'		rule: #typeSystemExtension.	self		parse: 'extend input Some { some : Int }'		rule: #typeSystemExtension.	self		parse: 'extend input Some { some(p : String) : Int }'		rule: #typeSystemExtension.	self		parse: 'extend input Some { some(p : String, a : Some) : Int }'		rule: #typeSystemExtension</body><body package="GraphQLBeta-Tests-Grammar" selector="testInputObjectTypeExtensionIncorrect">testInputObjectTypeExtensionIncorrect	self		fail: 'input SomeType {someName : [Int]}'		rule: #typeSystemExtension.	self		fail: 'extend SomeType {someName : [Int]}'		rule: #typeSystemExtension.	self		fail: 'extend input  {someName : [Int]}'		rule: #typeSystemExtension.	self fail: 'extend input SomeType' rule: #typeSystemExtension.	self fail: 'extend input SomeType {}' rule: #typeSystemExtension.	self		fail:			'extend "desription of inputObject" input SomeType { someName: String}'		rule: #typeSystemExtension</body><body package="GraphQLBeta-Tests-Grammar" selector="testInterfaceTypeExtension">testInterfaceTypeExtension	self		parse: 'extend interface SomeInterface {someObject : Some }'		rule: #typeSystemExtension.	self		parse: 'extend interface Some {some : SomeName !}'		rule: #typeSystemExtension.	self		parse:			'extend interface SomeOther {some: Some											other: Some											someOther: SomeType}'		rule: #typeSystemExtension</body><body package="GraphQLBeta-Tests-Grammar" selector="testInterfaceTypeExtensionIncorrect">testInterfaceTypeExtensionIncorrect	self		fail: 'extend SomeInterface {someObject : Some }'		rule: #typeSystemExtension.	self		fail: 'extend interface {some : SomeName !}'		rule: #typeSystemExtension.	self		fail:			'extend interface {some: Some											other: Some											someOther: SomeType}'		rule: #typeSystemExtension.	self		fail:			'extend Some {some: Some									 other: Some									 someOther: SomeType}'		rule: #typeSystemExtension.	self		fail:			'extend "desription of interfaceType" interface SomeInterface { 									someName: String}'		rule: #typeSystemExtension</body><body package="GraphQLBeta-Tests-Grammar" selector="testObjectTypeExtension">testObjectTypeExtension	self		parse: 'extend type Some {someObject : Some }'		rule: #typeSystemExtension.	self		parse: 'extend type SomeType {some : SomeName !}'		rule: #typeSystemExtension.	self		parse:			'extend type Some {some: Some											other: Some											someOther: SomeType}'		rule: #typeSystemExtension.	self		parse:			'extend type Some implements otherInterface {						some : Some						otherSome: Some}'		rule: #typeSystemExtension.	self		parse:			'extend type Some implements interfaceOne &amp; interfaceTwo {						some : Some 						someName: SomeOther}'		rule: #typeSystemExtension.	self		parse: 'extend type Some implements interfaceOne'		rule: #typeSystemExtension.	self		parse: 'extend type Some implements interfaceOne &amp; interfaceTwo'		rule: #typeSystemExtension</body><body package="GraphQLBeta-Tests-Grammar" selector="testObjectTypeExtensionIncorrect">testObjectTypeExtensionIncorrect	self fail: 'extend type Some { }' rule: #typeSystemExtension.	self		fail: 'extend type1 Some {someObject: Some }'		rule: #typeSystemExtension.	self		fail: 'extend SomeType {some : SomeName !}'		rule: #typeSystemExtension.	self		fail:			'extend {some: Some								other: Some								someOther: SomeType}'		rule: #typeSystemExtension.	self		fail:			'type Some implements otherInterface {						some : Some						otherSome: Some}'		rule: #typeSystemExtension.	self		fail:			'extend type Some implements {						some : Some 						someName: SomeOther}'		rule: #typeSystemExtension.	self fail: 'extend type Some implements ' rule: #typeSystemExtension.	self		fail: 'extend type Some implements interface1 &amp; '		rule: #typeSystemExtension.	self		fail:			'extend "desription of ObjectType" type SomeType { 						someName: String}'		rule: #typeSystemExtension</body><body package="GraphQLBeta-Tests-Grammar" selector="testSchemaExtension">testSchemaExtension	self		parse: 'extend schema {query : Query}'		rule: #typeSystemExtension.	self		parse: 'extend schema {mutation : Mutation}'		rule: #typeSystemExtension.	self		parse: 'extend schema {subscription : Subscription}'		rule: #typeSystemExtension.	self		parse: 'extend schema {query : SomeName}'		rule: #typeSystemExtension.	self		parse: 'extend schema {mutation : SomeMutation}'		rule: #typeSystemExtension.	self		parse: 'extend schema {subscription : SubscriptionTwo}'		rule: #typeSystemExtension.	self		parse:			'extend schema {query : SomeQuery									   mutation : OtherMutation}'		rule: #typeSystemExtension.	self		parse:			'extend schema {query : SomeName									   subscription : SomeOther}'		rule: #typeSystemExtension.	self		parse:			'extend schema {mutation : OtherMutation									   subscription : SomeName}'		rule: #typeSystemExtension.	self		parse:			'extend schema {query : SomeName										subscription : SomeOther									   mutation : SomeOtherToo}'		rule: #typeSystemExtension</body><body package="GraphQLBeta-Tests-Grammar" selector="testSchemaExtensionIncorrect">testSchemaExtensionIncorrect	self fail: 'extend schema {some : Query}' rule: #typeSystemExtension.	self		fail: 'extend schema {mutation2 : Mutation}'		rule: #typeSystemExtension.	self		fail: 'extend schema {other : Subscription}'		rule: #typeSystemExtension.	self		fail:			'extend schema {someName : Query									   someOther : Mutation}'		rule: #typeSystemExtension.	self		fail:			'extend schema {query1 : Query										subscription1 : Subscription									   mutation1 : Mutation}'		rule: #typeSystemExtension</body><body package="GraphQLBeta-Tests-Grammar" selector="testUnionTypeExtension">testUnionTypeExtension	self		parse: 'extend union CatOrDog = Cat | Dog'		rule: #typeSystemExtension.	self		parse: 'extend union DogOrHuman = Dog | Human'		rule: #typeSystemExtension.	self		parse: 'extend union DogOrCatOrBird = Dog | Cat | Bird'		rule: #typeSystemExtension</body><body package="GraphQLBeta-Tests-Grammar" selector="testUnionTypeExtensionIncorrect">testUnionTypeExtensionIncorrect	self fail: 'extend union = Cat | Dog' rule: #typeSystemExtension.	self		fail: 'union DogOrHuman = Dog | Human'		rule: #typeSystemExtension.	self		fail: 'extend DogOrCatOrBird = Dog | Cat | Bird'		rule: #typeSystemExtension.	self		fail: 'extend "desription of Union" union SomeUnion = Cat | Dog'		rule: #typeSystemExtension</body></methods><methods><class-id>GraphQLBeta.GQLSchemaGrammarTest</class-id> <category>test-grammar-interfaceType</category><body package="GraphQLBeta-Tests-Grammar" selector="testFailInterfaceTypeOther">testFailInterfaceTypeOther	self fail: '{someName 	: 	ID !}' rule: #interfaceType.	self fail: 'type {someName 	: 	ID !}' rule: #interfaceType.	self fail: 'type {}' rule: #interfaceType.	self fail: 'type Some {}' rule: #interfaceType.	self fail: 'type implements' rule: #interfaceType.	self fail: 'type Some implements {}' rule: #interfaceType.	self		fail: 'type Some implements {someName : ID}'		rule: #interfaceType.	self fail: 'type Some Other { someName: ID}' rule: #interfaceType.	self fail: 'union CatOrDog = Cat | Dog' rule: #interfaceType.	self fail: 'enum Some { someName: ID}' rule: #interfaceType</body><body package="GraphQLBeta-Tests-Grammar" selector="testInterfaceType">testInterfaceType	self parse: 'interface DogCommand { some : Int}' rule: #interfaceType.	self		parse:			'interface CatCommand { other : [ Int ]												  name : String !												  friends : [ Cat ]! }'		rule: #interfaceType.	self		parse:			'interface CatCommand { other : [ Int ! ] !												  name(some : String) : String !												  friends : [ Cat ]! }'		rule: #interfaceType</body><body package="GraphQLBeta-Tests-Grammar" selector="testInterfaceTypeIncorrect">testInterfaceTypeIncorrect	self fail: 'interface  { some : Int}' rule: #interfaceType.	self		fail:			'interface CatCommand { other : [ Int 												  name : String !												  friends : [ Cat ]! }'		rule: #interfaceType.	self		fail:			'interface CatCommand { other :												  name : String !												  friends : [ Cat ]! }'		rule: #interfaceType</body></methods><methods><class-id>GraphQLBeta.GQLSchemaGrammarTest</class-id> <category>test-grammar-fieldSet</category><body package="GraphQLBeta-Tests-Grammar" selector="testFieldSet">testFieldSet	self parse: '{someName : [Int]}' rule: #fieldSet.	self		parse: '{someName 	: [String ! ], someName 	:String }'		rule: #fieldSet.	self		parse: '{someName 	: [String ! ] someName 	:String }'		rule: #fieldSet.	self		parse: '{someName 	: String !, someName 	:String }'		rule: #fieldSet.	self		parse: '{someName 	: String ! someName 	:String }'		rule: #fieldSet.	self		parse: '{someName 	: [String !] ! someName 	:String }'		rule: #fieldSet.	self parse: '{ __someName: String }' rule: #fieldSet</body><body package="GraphQLBeta-Tests-Grammar" selector="testFieldSetIncorrect">testFieldSetIncorrect	self fail: 'someName 	: 	ID !' rule: #fieldSet.	self fail: '{}' rule: #fieldSet.	self fail: '{ someName }' rule: #fieldSet.	self fail: '{ someName : }' rule: #fieldSet.	self fail: '{ someName : !}' rule: #fieldSet.	self fail: '{ someName ID}' rule: #fieldSet.	self fail: '{ someName ID!}' rule: #fieldSet.	self fail: '{ someName !}' rule: #fieldSet</body></methods><methods><class-id>GraphQLBeta.GQLSchemaGrammarTest</class-id> <category>test-grammar-parameters</category><body package="GraphQLBeta-Tests-Grammar" selector="testParameters">testParameters	self parse: '(p1:[Int], p2:String)' rule: #parameters.	self parse: '(p1 : [String ! ])' rule: #parameters.	self parse: '( p1 :[Int ! ]!, p2: String!)' rule: #parameters.	self parse: '(p1: Int, __p2: String)' rule: #parameters</body><body package="GraphQLBeta-Tests-Grammar" selector="testParametersIncorrect">testParametersIncorrect	self fail: '(Int !)' rule: #parameters.	self fail: '(p1, p2)' rule: #parameters.	self fail: '(p1 : Int' rule: #parameters.	self fail: '(p1 Int)' rule: #parameters.	self fail: '(p1 Int!)' rule: #parameters.	self fail: '(p1 : !)' rule: #parameters.	self fail: '(p1 : Int, p2)' rule: #parameters.	self fail: '(p1, p2 : Int)' rule: #parameters</body></methods><methods><class-id>GraphQLBeta.GQLSchemaGrammarTest</class-id> <category>test-grammar-listInputType</category><body package="GraphQLBeta-Tests-Grammar" selector="testListInputType">testListInputType	"Inner types only input type"	self parse: '[Int]' rule: #listInputType.	self parse: '[String ! ]' rule: #listInputType.	self parse: '[Some!]' rule: #listInputType.	self parse: '[Some ! ] ' rule: #listInputType.	self parse: '[[Int]]' rule: #listInputType</body><body package="GraphQLBeta-Tests-Grammar" selector="testListInputTypeIncorrect">testListInputTypeIncorrect	self fail: 'Int !' rule: #listInputType.	self fail: '[Int ! ]!!' rule: #listInputType.	self fail: '[Int ! ]!' rule: #listInputType.	self fail: '[String ' rule: #listInputType.	self fail: '[Some ' rule: #listInputType.	self fail: '[Some! ' rule: #listInputType.	self fail: '[Some !!' rule: #listInputType.	self fail: '[ Some ] !' rule: #listInputType</body></methods><methods><class-id>GraphQLBeta.GQLSchemaGrammarTest</class-id> <category>test-grammar-enumType</category><body package="GraphQLBeta-Tests-Grammar" selector="testEnumType">testEnumType	self parse: 'enum DogCommand { SIT, DOWN, HEEL }' rule: #enumType.	self parse: 'enum CatCommand { JUMP }' rule: #enumType</body><body package="GraphQLBeta-Tests-Grammar" selector="testFailEnumTypeIncomplete">testFailEnumTypeIncomplete	self fail: 'enum { ROSE, LAVANDA}' rule: #enumType.	self fail: 'enum ROSE, LAVANDA' rule: #enumType.	self fail: 'enum { }' rule: #enumType.	self fail: 'enum FLOWER' rule: #enumType.	self fail: 'enum true { ROSE, LAVANDA}' rule: #enumType.	self fail: 'enum false { ROSE, LAVANDA}' rule: #enumType.	self fail: 'enum null { ROSE, LAVANDA}' rule: #enumType.	self fail: 'FLOWER' rule: #enumType.	self fail: 'FLOWER { ROSE, LAVANDA}' rule: #enumType</body><body package="GraphQLBeta-Tests-Grammar" selector="testFailEnumTypeOther">testFailEnumTypeOther	self fail: '{someName 	: 	ID !}' rule: #enumType.	self fail: 'type {someName 	: 	ID !}' rule: #enumType.	self fail: 'type {}' rule: #enumType.	self fail: 'type Some {}' rule: #enumType.	self fail: 'type implements' rule: #enumType.	self fail: 'type Some implements {}' rule: #enumType.	self fail: 'type Some implements {someName : ID}' rule: #enumType.	self fail: 'type Some Other { someName: ID}' rule: #enumType.	self fail: 'interface Sentiet { name : String}' rule: #enumType.	self fail: 'interface { name : String}' rule: #enumType.	self fail: 'union CatOrDog = Cat | Dog' rule: #enumType</body></methods><methods><class-id>GraphQLBeta.GQLSchemaGrammarTest</class-id> <category>test-grammar-parameter</category><body package="GraphQLBeta-Tests-Grammar" selector="testParameter">testParameter	self parse: 'p1:[Int!]!' rule: #parameter.	self parse: 'p1 : [String ! ]' rule: #parameter.	self parse: 'p2: String!' rule: #parameter.	self parse: 'p : Some' rule: #parameter.	self parse: 'p : Some!' rule: #parameter.	self parse: 'p : [ Some ] !' rule: #parameter.	self parse: 'p : [Some!] !' rule: #parameter.	self parse: '__p1: Int' rule: #parameter</body><body package="GraphQLBeta-Tests-Grammar" selector="testParameterIncorrect">testParameterIncorrect	self fail: 'Int !' rule: #parameter.	self fail: 'p1:' rule: #parameter.	self fail: 'p1: !' rule: #parameter.	self fail: 'p1 Int' rule: #parameter.	self fail: 'p1 !' rule: #parameter</body></methods><methods><class-id>GraphQLBeta.GQLSchemaGrammarTest</class-id> <category>test-grammar-inputTypes</category><body package="GraphQLBeta-Tests-Grammar" selector="testInputType">testInputType	self parse: '[Int ! ]!' rule: #inputType.	self parse: '[String ! ]' rule: #inputType.	self parse: '[ String ]!' rule: #inputType.	self parse: 'Int !' rule: #inputType.	self parse: 'String' rule: #inputType.	self parse: 'Some' rule: #inputType</body><body package="GraphQLBeta-Tests-Grammar" selector="testInputTypeIncorrect">testInputTypeIncorrect	self fail: '[Int' rule: #inputType.	self fail: '[String !' rule: #inputType.	self fail: '[ ]!' rule: #inputType.	self fail: '!' rule: #inputType.	self fail: '[Some' rule: #inputType</body></methods><methods><class-id>GraphQLBeta.GQLSchemaGrammarTest</class-id> <category>test-grammar-inputObjectType</category><body package="GraphQLBeta-Tests-Grammar" selector="testFailInputObjectTypeIncomplete">testFailInputObjectTypeIncomplete	self fail: '{someName 	: 	ID !}' rule: #inputObjectType.	self fail: 'input {someName 	: 	ID !}' rule: #inputObjectType.	self fail: 'input {}' rule: #inputObjectType.	self fail: 'input Some {}' rule: #inputObjectType.	self fail: 'input Some {}' rule: #inputObjectType.	self fail: 'input Some {some : }' rule: #inputObjectType.	self fail: 'input Some Other { someName: ID}' rule: #inputObjectType.	self fail: 'input Some { someName(a : ) : ID}' rule: #inputObjectType.	self		fail: 'input Some { someName(a : String, b ) : ID}'		rule: #inputObjectType</body><body package="GraphQLBeta-Tests-Grammar" selector="testFailInputObjectTypeOther">testFailInputObjectTypeOther	self fail: 'enum Flower { ROSE, LAVANDA}' rule: #inputObjectType.	self		fail: 'interface Sentiet { name : String}'		rule: #inputObjectType.	self fail: 'union CatOrDog = Cat | Dog' rule: #inputObjectType.	self fail: 'type SomeType {someName : [Int]}' rule: #inputObjectType.	self		fail: 'type SomeType implements Some {someName : [Int]}'		rule: #inputObjectType</body><body package="GraphQLBeta-Tests-Grammar" selector="testInputObjectType">testInputObjectType	self		parse: 'input SomeType {someName : [Int]}'		rule: #inputObjectType.	self		parse:			'input SomeOtherTypeName {someName 	: [String ! ], someName 	:String }'		rule: #inputObjectType.	self parse: 'input Some {someObject : Some }' rule: #inputObjectType.	self		parse: 'input Some {someObject : Some ! }'		rule: #inputObjectType.	self		parse: 'input Some {someObject : [ Some ] ! }'		rule: #inputObjectType.	self		parse: 'input Some {someObject : [ Some ! ] }'		rule: #inputObjectType.	self		parse: 'input Some {someObject : [ Some ! ] ! }'		rule: #inputObjectType.	self parse: 'input Some { some : Int }' rule: #inputObjectType.	self		parse: 'input Some { some(p : String) : Int }'		rule: #inputObjectType.	self		parse: 'input Some { some(p : Some) : Int }'		rule: #inputObjectType.	self		parse: 'input Some { some(p : String, a : Some) : Int }'		rule: #inputObjectType.	self parse: 'input Some { __someName: String}' rule: #inputObjectType.	self		parse: 'input Some { some: Int, __name: String }'		rule: #inputObjectType</body></methods><methods><class-id>GraphQLBeta.GQLSchemaGrammarTest</class-id> <category>test-grammar-field</category><body package="GraphQLBeta-Tests-Grammar" selector="testField">testField	self parse: 'someName1 	: Int' rule: #field.	self parse: 'someName2 	: [String ! ]!' rule: #field.	self parse: 'someName3 	: 	ID !' rule: #field.	self parse: 'someName4 	: 	SomeOtherType !' rule: #field.	self		parse: 'withParam1 ( aParam: String): 	SomeOtherType !'		rule: #field.	self		parse: 'withParam2( aParam: String, bParam:Int): 	SomeOtherType !'		rule: #field.	self		parse: 'withParam3( aParam: String, someOtherParam:Int): 	SomeOtherType !'		rule: #field.	self parse: '__some: Int' rule: #field</body><body package="GraphQLBeta-Tests-Grammar" selector="testFieldIncorrect">testFieldIncorrect	self fail: '123:Int !' rule: #field.	self fail: 'someName : [ String' rule: #field.	self fail: 'some : !' rule: #field.	self fail: 'some() : Int' rule: #field.	self fail: 'some : 123' rule: #field.	self fail: 'some : [String !' rule: #field</body></methods><methods><class-id>GraphQLBeta.GQLSchemaGrammarTest</class-id> <category>test-grammar-unionType</category><body package="GraphQLBeta-Tests-Grammar" selector="testFailUnionTypeOther">testFailUnionTypeOther	self fail: '{someName 	: 	ID !}' rule: #unionType.	self fail: 'type {someName 	: 	ID !}' rule: #unionType.	self fail: 'type {}' rule: #unionType.	self fail: 'type Some {}' rule: #unionType.	self fail: 'type implements' rule: #unionType.	self fail: 'type Some implements {}' rule: #unionType.	self fail: 'type Some implements {someName : ID}' rule: #unionType.	self fail: 'type Some Other { someName: ID}' rule: #unionType.	self fail: 'interface Sentiet { name : String}' rule: #unionType.	self fail: 'enum FLOWER { ROSE, LAVANDA }' rule: #unionType</body><body package="GraphQLBeta-Tests-Grammar" selector="testUnionType">testUnionType	self parse: 'union CatOrDog = Cat | Dog' rule: #unionType.	self parse: 'union DogOrHuman = Dog | Human' rule: #unionType.	self		parse: 'union DogOrCatOrBird = Dog | Cat | Bird'		rule: #unionType</body><body package="GraphQLBeta-Tests-Grammar" selector="testUnionTypeIncorrect">testUnionTypeIncorrect	self fail: 'union CatOrDog = Cat | ' rule: #unionType.	self fail: 'union = Cat | Dog' rule: #unionType.	self fail: 'union CatOrDog Cat | Dog' rule: #unionType.	self fail: 'union CatOrDog = Cat Dog' rule: #unionType</body></methods><methods><class-id>GraphQLBeta.GQLSchemaGrammarTest</class-id> <category>test-grammar-nonNullInputType</category><body package="GraphQLBeta-Tests-Grammar" selector="testNonNullInputType">testNonNullInputType	self parse: 'Int!' rule: #nonNullInputType.	self parse: 'SomeOtherType !' rule: #nonNullInputType.	self parse: '[ Int ]!' rule: #nonNullInputType.	self parse: '[ Int! ]!' rule: #nonNullInputType.	self parse: '[ SomeOtherType ]!' rule: #nonNullInputType.	self parse: '[ SomeOtherType! ]!' rule: #nonNullInputType</body><body package="GraphQLBeta-Tests-Grammar" selector="testNonNullInputTypeIncorrect">testNonNullInputTypeIncorrect	self fail: 'Int!!' rule: #nonNullInputType.	self fail: 'Int' rule: #nonNullInputType.	self fail: 'SomeOtherType' rule: #nonNullInputType.	self fail: '[ Int! ]' rule: #nonNullInputType.	self fail: '[ Int ]' rule: #nonNullInputType.	self fail: '[ SomeOtherType ]' rule: #nonNullInputType.	self fail: '[ SomeOtherType! ]' rule: #nonNullInputType</body></methods><methods><class-id>GraphQLBeta.GQLSchemaGrammarTest</class-id> <category>test-grammar-comment</category><body package="GraphQLBeta-Tests-Grammar" selector="testComment">testComment	self parse: '#comment of a line' rule: #comment.	self parse: '#comments dont allow lineTerminator' rule: #comment</body><body package="GraphQLBeta-Tests-Grammar" selector="testCommentIncorrect">testCommentIncorrect	self		fail:			'#comment of a 	line'		rule: #comment.	self fail: 'comments dont allow lineTerminator' rule: #comment</body></methods><methods><class-id>GraphQLBeta.GQLSchemaGrammarTest</class-id> <category>test-grammar-nonNullType</category><body package="GraphQLBeta-Tests-Grammar" selector="testNonNullType">testNonNullType	self parse: 'Int!' rule: #nonNullType.	self parse: 'SomeOtherType !' rule: #nonNullType.	self parse: '[ Int ]!' rule: #nonNullType.	self parse: '[ Int! ]!' rule: #nonNullType.	self parse: '[ SomeOtherType ]!' rule: #nonNullType.	self parse: '[ SomeOtherType! ]!' rule: #nonNullType</body><body package="GraphQLBeta-Tests-Grammar" selector="testNonNullTypeIncorrect">testNonNullTypeIncorrect	self fail: 'Int!!' rule: #nonNullType.	self fail: 'Int' rule: #nonNullType.	self fail: 'SomeOtherType' rule: #nonNullType.	self fail: '[ Int! ]' rule: #nonNullType.	self fail: '[ Int ]' rule: #nonNullType.	self fail: '[ SomeOtherType ]' rule: #nonNullType.	self fail: '[ SomeOtherType! ]' rule: #nonNullType</body></methods><methods><class-id>GraphQLBeta.GQLSchemaGrammarTest</class-id> <category>test-grammar-listType</category><body package="GraphQLBeta-Tests-Grammar" selector="testListType">testListType	self parse: '[Int]' rule: #listType.	self parse: '[SomeObject ]' rule: #listType.	self parse: '[String! ]' rule: #listType.	self parse: '[SomeObject ! ] ' rule: #listType</body><body package="GraphQLBeta-Tests-Grammar" selector="testListTypeIncorrect">testListTypeIncorrect	self fail: 'Int !' rule: #listType.	self fail: '[Int]!' rule: #listType.	self fail: '[Int ! ]!!' rule: #listType.	self fail: '[String ' rule: #listType.	self fail: '[Some !' rule: #listType</body></methods><methods><class-id>GraphQLBeta.GQLIQueryType</class-id> <category>accessing</category><body package="GraphQLBeta-Test-Trash" selector="a">a	^ GQLA new id: 1</body><body package="GraphQLBeta-Test-Trash" selector="aId:">aId: aID	^ GQLA new id: aID</body><body package="GraphQLBeta-Test-Trash" selector="anGqla:">anGqla: aGQLA	^ aGQLA</body><body package="GraphQLBeta-Test-Trash" selector="hello">hello	^ #helloWorld</body><body package="GraphQLBeta-Test-Trash" selector="helloForName:">helloForName: aString	^ #hello , aString</body><body package="GraphQLBeta-Test-Trash" selector="sumNums:">sumNums: aCollection	^ aCollection reduce: [ :a :b | a + b ]</body></methods><methods><class-id>GraphQLBeta.GQLSchemaGrammarEvaluatorTest</class-id> <category>test-schemaInterfaceType</category><body package="GraphQLBeta-Tests-Grammar" selector="testIncompleteSchemaInterfaceType">testIncompleteSchemaInterfaceType	| text |	text := 'interface NamedEntity {				  name: String			  '.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: PPFailure.	text := 'interface NamedEntity {				  name: 			  }'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: PPFailure.	text := 'interface NamedEntity {				  name: String : Int			  }'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: PPFailure</body><body package="GraphQLBeta-Tests-Grammar" selector="testSchemaInterfaceType">testSchemaInterfaceType	| text interface |	text := 'interface NamedEntity {				  field(id: Int) : [Int]				  otherVariable(param: String, param2: [Int]!) : String 				  a (param: [Int]!) : A			  }'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: GQLSSchemaNode.	interface := schema getType: 'NamedEntity'.	self assert: interface class equals: GQLSInterfaceTypeNode.	self assert: interface name equals: 'NamedEntity'.	self		assert: (interface getField: 'field') class		equals: GQLSFieldNode.	self		assert: (interface getField: 'field') type class		equals: GQLSListTypeNode.	self		assert: (interface getField: 'field') type wrappedType class		equals: GQLSIntTypeNode.	self		assert: (interface getField: 'otherVariable') type class		equals: GQLSStringTypeNode.	self		assert:			((interface getField: 'otherVariable') getArgument: 'param2') type				class		equals: GQLSNonNullTypeNode.	self		assert: (interface getField: 'a') type class		equals: GQLSNamedTypeNode</body></methods><methods><class-id>GraphQLBeta.GQLSchemaGrammarEvaluatorTest</class-id> <category>tests-schemaObjectTypes</category><body package="GraphQLBeta-Tests-Grammar" selector="testIncompleteSchemaObjectType">testIncompleteSchemaObjectType	| text |	text := 'type Query{              name :             }'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: PPFailure.	text := 'type Query{              name : String            }				{}'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: PPFailure.	text := 'type Query{              name : String            }				type Class{ 				  name :				}'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: PPFailure</body><body package="GraphQLBeta-Tests-Grammar" selector="testIncompleteSchemaObjectTypeParameters">testIncompleteSchemaObjectTypeParameters	| text |	text := 'type Query{              name (id: Int : String            }'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: PPFailure.	text := 'type Query{              name (id: Int, ) : String            }				{}'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: PPFailure.	text := 'type Query{              name (id:Int) : String            }				type Class{ 				  name :				}'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: PPFailure</body><body package="GraphQLBeta-Tests-Grammar" selector="testSchemaObjectType">testSchemaObjectType	| text someType someOtherType var |	text := 'type SomeType {					someName : [Int]					otherVariable 	:String				},				type SomeOtherTypeName {					someName 	: [String ! ]				}'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: GQLSSchemaNode.	someType := schema schemaTypes at: 'SomeType'.	someOtherType := schema schemaTypes at: 'SomeOtherTypeName'.	self assert: someType class equals: GQLSObjectTypeNode.	self assert: someType name equals: 'SomeType'.	var := someType fields at: 'someName'.	self assert: var class equals: GQLSFieldNode.	self assert: var name equals: 'someName'.	self assert: var type class equals: GQLSListTypeNode.	self		assert: someOtherType fields values first type class		equals: GQLSListTypeNode.	self assert: var type wrappedType name equals: 'Int'.	var := someType fields at: 'otherVariable'.	self assert: var name equals: 'otherVariable'.	self assert: var type name equals: 'String'</body><body package="GraphQLBeta-Tests-Grammar" selector="testSchemaObjectTypeAndEnumType">testSchemaObjectTypeAndEnumType	| text someType enumType var stringValues |	text := 'type SomeType {					someName(arg: EnumArg): String					otherVariable 	:String				},				enum EnumArg{				   ARG_1				   ARG_2					ARG_3				}'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: GQLSSchemaNode.	someType := schema schemaTypes at: 'SomeType'.	self assert: someType class equals: GQLSObjectTypeNode.	self assert: someType name equals: 'SomeType'.	var := someType fields at: 'someName'.	self assert: var class equals: GQLSFieldNode.	self assert: var name equals: 'someName'.	self assert: var arguments size equals: 1.	self		assert: (var arguments at: 'arg') type class		equals: GQLSNamedTypeNode.	enumType := schema schemaTypes at: 'EnumArg'.	self assert: enumType class equals: GQLSEnumTypeNode.	self assert: enumType values size equals: 3.	stringValues := enumType stringValues.	self assert: (stringValues at: 1) equals: 'ARG_1'.	self assert: (stringValues at: 2) equals: 'ARG_2'.	self assert: (stringValues at: 3) equals: 'ARG_3'</body><body package="GraphQLBeta-Tests-Grammar" selector="testSchemaObjectTypeParameters">testSchemaObjectTypeParameters	| text someType var |	text := 'type SomeType {					field(id: Int) : [Int]					otherVariable(param: String, param2: [Int]!):String 					a (param: [Int]!):Int				},				type SomeOtherTypeName {					someName (a:String!): [String ! ]					someName2 :String 				}'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: GQLSSchemaNode.	someType := schema schemaTypes at: 'SomeType'.	self assert: someType class equals: GQLSObjectTypeNode.	self assert: someType name equals: 'SomeType'.	self		assert: someType fields values third name		equals: 'otherVariable'.	var := someType fields at: 'a'.	self		assert: var arguments values first class		equals: GQLSInputObjectFieldNode.	self		assert: var arguments values first class		equals: GQLSInputObjectFieldNode.	self		assert: var arguments values first type class		equals: GQLSNonNullTypeNode.	self		assert: var arguments values first type wrappedType class		equals: GQLSListTypeNode</body><body package="GraphQLBeta-Tests-Grammar" selector="testSchemaObjectTypeWithInterface">testSchemaObjectTypeWithInterface	| text someType someOtherType |	text := 'type SomeType implements Type{					someName : [Int]				},				type SomeOtherTypeName implements Type &amp; Other {					someName 	: String !				}'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: GQLSSchemaNode.	someType := schema schemaTypes at: 'SomeType'.	someOtherType := schema schemaTypes at: 'SomeOtherTypeName'.	self assert: someType class equals: GQLSObjectTypeNode.	self assert: someType name equals: 'SomeType'.	self assert: someType interfaces size equals: 1.	self assert: someType interfaces first equals: 'Type'.	self assert: someOtherType class equals: GQLSObjectTypeNode.	self assert: someOtherType name equals: 'SomeOtherTypeName'.	self assert: someOtherType interfaces size equals: 2.	self assert: someOtherType interfaces first equals: 'Type'.	self assert: someOtherType interfaces second equals: 'Other'</body></methods><methods><class-id>GraphQLBeta.GQLSchemaGrammarEvaluatorTest</class-id> <category>test-schemaInputObjectType</category><body package="GraphQLBeta-Tests-Grammar" selector="testIncompleteSchemaInputObjectType">testIncompleteSchemaInputObjectType	| text |	text := 'input ExampleInputObject { 			 	a: String  				b: !				c: OtherInputObject			}'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: PPFailure.	text := 'input ExampleInputObject { 			 	a: String  				b: Int!				c: OtherInputObject			'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: PPFailure.	text := 'input ExampleInputObject { 			 	a: String  				b: Int!				c: OtherInputObject!!			}'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: PPFailure</body><body package="GraphQLBeta-Tests-Grammar" selector="testSchemaInputObjectType">testSchemaInputObjectType	| text inputObject |	text := 'input ExampleInputObject { 			 	a: String  				b: Int!				c: OtherInputObject			}'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: GQLSSchemaNode.	inputObject := schema getType: 'ExampleInputObject'.	self assert: inputObject class equals: GQLSInputObjectTypeNode.	self assert: inputObject name equals: 'ExampleInputObject'.	self		assert: (inputObject getField: 'a') class		equals: GQLSInputObjectFieldNode.	self		assert: (inputObject getField: 'a') type class		equals: GQLSStringTypeNode.	self		assert: (inputObject getField: 'b') type wrappedType class		equals: GQLSIntTypeNode.	self		assert: (inputObject getField: 'c') type class		equals: GQLSNamedTypeNode</body></methods><methods><class-id>GraphQLBeta.GQLSchemaGrammarEvaluatorTest</class-id> <category>test-schemaDefinition</category><body package="GraphQLBeta-Tests-Grammar" selector="testIncompleteSchemaDefinition">testIncompleteSchemaDefinition	| text |	"Error: Specified query type \'Query\' not found in document."	text := 'schema{				}'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: PPFailure.	text := 'schema{						query: 					}'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: PPFailure.	text := 'schema{						query: Query						mutation: 					}					type Query{						hello: String					}					'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: PPFailure</body><body package="GraphQLBeta-Tests-Grammar" selector="testSchemaDefinition">testSchemaDefinition	| text query mutation rootOperationTypes |	text := 'schema{					query: Query				}				type Query{					hello: String				}'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: GQLSSchemaNode.	self		assert: schema schemaDefinitions first class		equals: GQLSSchemaDefinitionNode.	rootOperationTypes := schema schemaDefinitions first		rootOperationTypes.	self		assert: (rootOperationTypes at: 'query') first class		equals: GQLSRootOperationTypeNode.	self		assert: (rootOperationTypes at: 'query') first name		equals: 'Query'.	query := schema getType: 'Query'.	self assert: (query fields at: 'hello') class equals: GQLSFieldNode.	text := '		schema{			query: Query			mutation: Mutation			}		type Query { 			hello: String		}		type Mutation{			setNumber(to: Int): Int		}		'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: GQLSSchemaNode.	self		assert: schema schemaDefinitions first class		equals: GQLSSchemaDefinitionNode.	rootOperationTypes := schema schemaDefinitions first		rootOperationTypes.	self		assert: (rootOperationTypes at: 'query') first class		equals: GQLSRootOperationTypeNode.	self		assert: (rootOperationTypes at: 'query') first name		equals: 'Query'.	self		assert: (rootOperationTypes at: 'mutation') first class		equals: GQLSRootOperationTypeNode.	self		assert: (rootOperationTypes at: 'mutation') first name		equals: 'Mutation'.	query := schema getType: 'Query'.	self		assert: (query fields at: 'hello') type class		equals: GQLSStringTypeNode.	mutation := schema getType: 'Mutation'.	self		assert: (mutation fields at: 'setNumber') type class		equals: GQLSIntTypeNode.	text := '		schema{			query: GQLTestQueryType			mutation: GQLTestMutationType		}		type GQLTestQueryType { 			hello: String		}		type GQLTestMutationType {			createPoint(x: Int, y: Int): Point		}		type Point { 			x: Int			y: Int		}		'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: GQLSSchemaNode.	self		assert: schema schemaDefinitions first class		equals: GQLSSchemaDefinitionNode.	rootOperationTypes := schema schemaDefinitions first		rootOperationTypes.	self		assert: (rootOperationTypes at: 'query') first class		equals: GQLSRootOperationTypeNode.	self		assert: (rootOperationTypes at: 'query') first name		equals: 'GQLTestQueryType'.	self		assert: (rootOperationTypes at: 'mutation') first class		equals: GQLSRootOperationTypeNode.	self		assert: (rootOperationTypes at: 'mutation') first name		equals: 'GQLTestMutationType'.	query := schema getType: 'GQLTestQueryType'.	self		assert: (query fields at: 'hello') type class		equals: GQLSStringTypeNode.	mutation := schema getType: 'GQLTestMutationType'.	self		assert: (mutation fields at: 'createPoint') type name		equals: 'Point'.	"es valido porque Query esta definido y eso es por defecto"	text := '		type Query { 			hello: String		}		type GQLTestQueryType {			helloTo(name: String): String		}		'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: GQLSSchemaNode.	self		assert: schema schemaDefinitions first class		equals: GQLSSchemaDefinitionNode.	rootOperationTypes := schema schemaDefinitions first		rootOperationTypes.	self assert: (rootOperationTypes at: 'query') size equals: 1.	self		assert: (rootOperationTypes at: 'query') first		class: GQLSRootOperationTypeNode.	"It is valid because Mutation is declared as query"	text := '		schema { 			query: Mutation		}		type Mutation { 			setNumber(to: Int): Int		}		'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: GQLSSchemaNode.	self		assert: schema schemaDefinitions first class		equals: GQLSSchemaDefinitionNode.	rootOperationTypes := schema schemaDefinitions first		rootOperationTypes.	self		assert: (rootOperationTypes at: 'query') first class		equals: GQLSRootOperationTypeNode.	self		assert: (rootOperationTypes at: 'query') first name		equals: 'Mutation'</body><body package="GraphQLBeta-Tests-Grammar" selector="testSchemaDefinitionWithDefaultRootOperTypes">testSchemaDefinitionWithDefaultRootOperTypes	| text rootOperationTypes |	text := '		type Query{			hello: String		}		type GQLTestQueryType{			helloTo(name:String): String		}		type Mutation{			setNumber(to:Int): Int		}'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: GQLSSchemaNode.	self		assert: schema schemaDefinitions first class		equals: GQLSSchemaDefinitionNode.	rootOperationTypes := schema schemaDefinitions first		rootOperationTypes.	self		assert: (rootOperationTypes at: 'query') first name		equals: 'GQLQuery'.	self assert: rootOperationTypes keys size equals: 1.	text := '		type GQLQuery { 			hello: String		}		type GQLMutation{			setNumber(to: Int): Int		}		'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: GQLSSchemaNode.	self		assert: schema schemaDefinitions first class		equals: GQLSSchemaDefinitionNode.	rootOperationTypes := schema schemaDefinitions first		rootOperationTypes.	self		assert: (rootOperationTypes at: 'query') first name		equals: 'GQLQuery'.	self assert: rootOperationTypes keys size equals: 1</body><body package="GraphQLBeta-Tests-Grammar" selector="testWithDoubleRootOperTypeSchemaDefinition">testWithDoubleRootOperTypeSchemaDefinition	| text |	"Error: Must provide only one query type in schema."	text := 'schema{					query: Query					query: Query2				}				type Query{					hello				}				type GQLTestQueryType {					helloTo(name:String): String				}				'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: PPFailure.	text := 'schema{						query: Query						mutation: Mutation						mutation: GQLTestMutationType					}					type Query{						hello					}					mutation Mutation{						setNumer(to:Int): Int					}					mutation GQLTestMutationType {						createPoint(x: Int, y: Int): Point					}					type Point { 						x: Int						y: Int					}					'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: PPFailure</body></methods><methods><class-id>GraphQLBeta.GQLSchemaGrammarEvaluatorTest</class-id> <category>test-schemaTypeSystemExtension</category><body package="GraphQLBeta-Tests-Grammar" selector="testSchemaEnumTypeExtension">testSchemaEnumTypeExtension	| text enumType stringValues |	text := 'extend enum DogCommand {YAP}'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: GQLSSchemaNode.	enumType := schema getTypeExtension: 'DogCommand'.	self assert: enumType class equals: GQLSEnumTypeNode.	self assert: enumType values size equals: 1.	stringValues := enumType stringValues.	self assert: stringValues first equals: 'YAP'.	text := 'extend enum CatCommand { JUMP MEOW}'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: GQLSSchemaNode.	enumType := schema getTypeExtension: 'CatCommand'.	self assert: enumType class equals: GQLSEnumTypeNode.	self assert: enumType values size equals: 2.	stringValues := enumType stringValues.	self assert: stringValues first equals: 'JUMP'.	self assert: stringValues second equals: 'MEOW'</body><body package="GraphQLBeta-Tests-Grammar" selector="testSchemaEnumTypeExtensionIncorrect">testSchemaEnumTypeExtensionIncorrect	| text |	text := 'extend enum {YAP}'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: PPFailure.	text := 'extend enum CatCommand { }'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: PPFailure</body><body package="GraphQLBeta-Tests-Grammar" selector="testSchemaExtensionIncorrect">testSchemaExtensionIncorrect	| text |	text := 'extend {					mutation: Mutation				}				type Mutation{					incrementNumber: Int				}'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: PPFailure.	text := '		extend schema{		}		'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: PPFailure</body><body package="GraphQLBeta-Tests-Grammar" selector="testSchemaInputObjectTypeExtension">testSchemaInputObjectTypeExtension	| text inputObject |	text := 'extend input ExampleInputObject { 			 	d: String				e: OtherInputObject			}'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: GQLSSchemaNode.	inputObject := schema getTypeExtension: 'ExampleInputObject'.	self assert: inputObject class equals: GQLSInputObjectTypeNode.	self assert: inputObject name equals: 'ExampleInputObject'.	self		assert: (inputObject getField: 'd') class		equals: GQLSInputObjectFieldNode.	self		assert: (inputObject getField: 'd') type class		equals: GQLSStringTypeNode.	self		assert: (inputObject getField: 'e') type class		equals: GQLSNamedTypeNode</body><body package="GraphQLBeta-Tests-Grammar" selector="testSchemaInputObjectTypeExtensionIncorrect">testSchemaInputObjectTypeExtensionIncorrect	| text |	text := 'extend input { 			 	d: String				e: OtherInputObject			}'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: PPFailure.	text := 'extend input SomeObjectInput{			}'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: PPFailure</body><body package="GraphQLBeta-Tests-Grammar" selector="testSchemaInterfaceTypeExtension">testSchemaInterfaceTypeExtension	| text interface field |	text := 'extend interface Some {					someOtherField: String				}				extend interface SomeOtherInterface { 					someNumber: Int				}'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: GQLSSchemaNode.	interface := schema getTypeExtension: 'Some'.	self assert: interface class equals: GQLSInterfaceTypeNode.	field := interface getField: 'someOtherField'.	self assert: field class equals: GQLSFieldNode.	self assert: field type class equals: GQLSStringTypeNode.	interface := schema getTypeExtension: 'SomeOtherInterface'.	self assert: interface class equals: GQLSInterfaceTypeNode.	field := interface getField: 'someNumber'.	self assert: field class equals: GQLSFieldNode.	self assert: field type class equals: GQLSIntTypeNode</body><body package="GraphQLBeta-Tests-Grammar" selector="testSchemaInterfaceTypeExtensionIncorrect">testSchemaInterfaceTypeExtensionIncorrect	| text |	text := 'extend interface {					someOtherField: String				}'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: PPFailure.	text := 'extend SomeOtherInterface { 					someNumber: Int				}'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: PPFailure</body><body package="GraphQLBeta-Tests-Grammar" selector="testSchemaObjectTypeExtension">testSchemaObjectTypeExtension	| text objectType field |	text := 'extend type SomeType {					someOtherField: String				}				extend type SomeOtherType { 					someNumber: Int				}'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: GQLSSchemaNode.	objectType := schema getTypeExtension: 'SomeType'.	self assert: objectType class equals: GQLSObjectTypeNode.	field := objectType fields at: 'someOtherField'.	self assert: field class equals: GQLSFieldNode.	self assert: field type class equals: GQLSStringTypeNode.	objectType := schema getTypeExtension: 'SomeOtherType'.	self		assert: objectType fields values first type class		equals: GQLSIntTypeNode.	field := objectType fields at: 'someNumber'.	self assert: field type name equals: 'Int'</body><body package="GraphQLBeta-Tests-Grammar" selector="testSchemaObjectTypeExtensionIncorrect">testSchemaObjectTypeExtensionIncorrect	| text |	text := 'extend type {					someOtherField: String				}'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: PPFailure.	text := 'extend SomeOtherType { 					someNumber: Int				}'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: PPFailure</body><body package="GraphQLBeta-Tests-Grammar" selector="testSchemaUnionTypeExtension">testSchemaUnionTypeExtension	| text unionType |	text := 'extend union Animals = Monkey | Elephant | Wolf				extend union Shapes = Trapezoid | Triangle'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: GQLSSchemaNode.	unionType := schema getTypeExtension: 'Animals'.	self assert: unionType class equals: GQLSUnionTypeNode.	self assert: unionType namedTypes size equals: 3.	self assert: unionType namedTypes first equals: 'Monkey'.	self assert: unionType namedTypes second equals: 'Elephant'.	self assert: unionType namedTypes third equals: 'Wolf'.	unionType := schema getTypeExtension: 'Shapes'.	self assert: unionType class equals: GQLSUnionTypeNode.	self assert: unionType namedTypes size equals: 2.	self assert: unionType namedTypes first equals: 'Trapezoid'.	self assert: unionType namedTypes second equals: 'Triangle'</body><body package="GraphQLBeta-Tests-Grammar" selector="testSchemaUnionTypeExtensionIncorrect">testSchemaUnionTypeExtensionIncorrect	| text |	text := 'extend Animals = Monkey | Elephant | Wolf '.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: PPFailure.	text := 'extend union = Trapezoid | Triangle'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: PPFailure</body></methods><methods><class-id>GraphQLBeta.GQLSchemaGrammarEvaluatorTest</class-id> <category>test-schemaWithComment</category><body package="GraphQLBeta-Tests-Grammar" selector="testSchemaEnumTypeWithComment">testSchemaEnumTypeWithComment	| text node enumValues |	text := 'enum #Dog command 				DogCommand #the values are:				{ 				#sit				SIT, 				#down				DOWN, 				#heel				HEEL }			  	enum CatCommand { 				#jump				JUMP }'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: GQLSSchemaNode.	node := schema schemaTypes at: 'DogCommand'.	enumValues := node values.	self		assertCommentsFields: enumValues		equals: #('#sit' '#down' '#heel').	enumValues := (schema schemaTypes at: 'CatCommand') values.	self assertCommentsFields: enumValues equals: #('#jump')</body><body package="GraphQLBeta-Tests-Grammar" selector="testSchemaInputObjectTypeWithComment">testSchemaInputObjectTypeWithComment	| text inputObject |	text := 'input #comment of inputObject 				ExampleInputObject {				#field a 			 	a: String				#field b  				b: Int!				#field c				c: OtherInputObject			}'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: GQLSSchemaNode.	inputObject := schema getType: 'ExampleInputObject'.	self assert: inputObject comments isEmpty.	self		assertCommentsFields: inputObject fields		equals: #('#field a' '#field b' '#field c')</body><body package="GraphQLBeta-Tests-Grammar" selector="testSchemaInterfaceWithComment">testSchemaInterfaceWithComment	| text node |	text := 'interface #namedEntity 				NamedEntity {				  #field receives an Int and returns [ Int ]				  field(id: Int) : [Int]				  #otherVariable returns an String				  otherVariable(param: String, param2: [Int]!) : String 				  #a returns an instance of A				  a (param: [Int]!) : A			  }'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: GQLSSchemaNode.	node := schema schemaTypes at: 'NamedEntity'.	self assert: node comments isEmpty.	self		assertCommentsFields: node fields		equals:			#('#field receives an Int and returns [ Int ]' '#otherVariable returns an String' '#a returns an instance of A')</body><body package="GraphQLBeta-Tests-Grammar" selector="testSchemaUnionTypeWithComment">testSchemaUnionTypeWithComment	| text node |	text := '#comment 1				union #catOrDog				CatOrDog = 				#cat				Cat | 				#dog				Dog				#comment 2				union DogOrHuman = 				#dog				Dog | 				#human				Human | 				#alien				Alien				#comment 3'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: GQLSSchemaNode.	node := schema getType: 'CatOrDog'.	self		assertComments: node comments		equals: #('#comment 1' '#comment 2').	node := schema getType: 'DogOrHuman'.	self assertComments: node comments equals: #('#comment 3')</body><body package="GraphQLBeta-Tests-Grammar" selector="testSchemaWithComment">testSchemaWithComment	| text node |	text := '#type Query by default				type Query{					hello: String				}				'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: GQLSSchemaNode.	node := schema getType: 'Query'.	self		assertComments: node comments		equals: #('#type Query by default').	text := '#type Query by default				type #allowed comment				Query #comment before the field				{					#comment in the field					hello: #field hello returns an String					String				}				'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: GQLSSchemaNode.	self assert: schema comments isEmpty.	node := schema getType: 'Query'.	self		assertComments: node comments		equals: #('#type Query by default').	node := node getField: 'hello'.	self assertComments: node comments equals: #('#comment in the field').	text := 'type SomeType #comment before the interface		 		implements Type{					someName : [Int]				}'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: GQLSSchemaNode.	node := schema getType: 'SomeType'.	self assert: node comments isEmpty</body></methods><methods><class-id>GraphQLBeta.GQLSchemaGrammarEvaluatorTest</class-id> <category>test-schemaDescription</category><body package="GraphQLBeta-Tests-Grammar" selector="testDescriptionEnum">testDescriptionEnum	| text enum enumValues |	text := '		"""description of enum""" 		enum Shapes { 		"Rectangle" RECTANGLE		"Circle" CIRCLE		 }	'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: GQLSSchemaNode.	enum := schema getType: 'Shapes'.	self assert: enum class equals: GQLSEnumTypeNode.	self assert: enum description value = '"""description of enum"""'.	enumValues := enum values.	self assert: enumValues first value = 'RECTANGLE'.	self assert: enumValues first description value = '"Rectangle"'.	self assert: enumValues second value = 'CIRCLE'.	self assert: enumValues second description value = '"Circle"'</body><body package="GraphQLBeta-Tests-Grammar" selector="testDescriptionFieldArguments">testDescriptionFieldArguments	| text node |	text := '		type Query { 			hello("especify the name of argument" to: String): String		}	'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: GQLSSchemaNode.	node := schema getType: 'Query'.	self assert: node class equals: GQLSObjectTypeNode.	node := (node getField: 'hello') getArgument: 'to'.	self		assert: node description value = '"especify the name of argument"'</body><body package="GraphQLBeta-Tests-Grammar" selector="testDescriptionInputObjects">testDescriptionInputObjects	| text inputObject |	text := '		"description of input object" input ObjectInput{			name: String			value: Int		 }	'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: GQLSSchemaNode.	inputObject := schema getType: 'ObjectInput'.	self assert: inputObject class equals: GQLSInputObjectTypeNode.	self		assert: inputObject description value = '"description of input object"'</body><body package="GraphQLBeta-Tests-Grammar" selector="testDescriptionInterface">testDescriptionInterface	| text interface |	text := '		""""description of interface""" 		interface NamedEntity { 			name: String		}	'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: GQLSSchemaNode.	interface := schema getType: 'NamedEntity'.	self assert: interface class equals: GQLSInterfaceTypeNode.	self		assert: interface description value = '""""description of interface"""'</body><body package="GraphQLBeta-Tests-Grammar" selector="testDescriptionInType">testDescriptionInType	| text query description |	text := '		"Query is the root operation type of schema by default"		type Query { 			"""			block comment			with many lines			"""			hello: String		}	'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: GQLSSchemaNode.	query := schema getType: 'Query'.	self assert: query class equals: GQLSObjectTypeNode.	description := query description.	self		assert:			description value				= '"Query is the root operation type of schema by default"'.	description := (query getField: 'hello') description.	self		assert:			description value				=					'"""			block comment			with many lines			"""'</body><body package="GraphQLBeta-Tests-Grammar" selector="testDescriptionUnion">testDescriptionUnion	| text union |	text := '		""""description of 		union""" 		union Shapes = Rectangle | Circle	'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: GQLSSchemaNode.	union := schema getType: 'Shapes'.	self assert: union class equals: GQLSUnionTypeNode.	self		assert:			union description				=					'""""description of 		union"""'</body></methods><methods><class-id>GraphQLBeta.GQLSchemaGrammarEvaluatorTest</class-id> <category>test-schemaUnionType</category><body package="GraphQLBeta-Tests-Grammar" selector="testIncompleteSchemaUnionType">testIncompleteSchemaUnionType	| text |	text := 'union CatOrDog = Cat |'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: PPFailure.	text := 'union CatOrDog  Cat | Dog'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: PPFailure.	text := 'union CatOrDog = Cat | |'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: PPFailure</body><body package="GraphQLBeta-Tests-Grammar" selector="testSchemaUnionType">testSchemaUnionType	| text dog cat |	text := 'union CatOrDog = Cat | Dog				union DogOrHuman = Dog | Human | Alien'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: GQLSSchemaNode.	cat := schema getType: 'CatOrDog'.	dog := schema getType: 'DogOrHuman'.	self assert: dog class equals: GQLSUnionTypeNode.	self assert: cat class equals: GQLSUnionTypeNode.	self assert: dog namedTypes size equals: 3.	self assert: cat namedTypes size equals: 2.	self assert: dog namedTypes first equals: 'Dog'.	self assert: dog namedTypes second equals: 'Human'.	self assert: dog namedTypes third equals: 'Alien'.	self assert: cat namedTypes first equals: 'Cat'.	self assert: cat namedTypes second equals: 'Dog'</body></methods><methods><class-id>GraphQLBeta.GQLSchemaGrammarEvaluatorTest</class-id> <category>test-schemaEnumType</category><body package="GraphQLBeta-Tests-Grammar" selector="testIncompleteSchemaEnumType">testIncompleteSchemaEnumType	| text |	text := 'enum CatCommand {}'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: PPFailure.	text := 'enum { JUMP }'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: PPFailure.	text := 'enum CatCommand { JUMP'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: PPFailure</body><body package="GraphQLBeta-Tests-Grammar" selector="testSchemaEnumType">testSchemaEnumType	| text dog cat stringValues |	text := 'enum DogCommand { SIT, DOWN, HEEL }			  enum CatCommand { JUMP }'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: GQLSSchemaNode.	dog := schema getType: 'DogCommand'.	cat := schema getType: 'CatCommand'.	self assert: dog class equals: GQLSEnumTypeNode.	self assert: cat class equals: GQLSEnumTypeNode.	self assert: dog values size equals: 3.	self assert: cat values size equals: 1.	stringValues := dog stringValues.	self assert: stringValues first equals: 'SIT'.	self assert: stringValues second equals: 'DOWN'.	self assert: stringValues third equals: 'HEEL'.	stringValues := cat stringValues.	self assert: stringValues first equals: 'JUMP'</body></methods><methods><class-id>GraphQLBeta.GQLSchemaGrammarEvaluatorTest</class-id> <category>tests</category><body package="GraphQLBeta-Tests-Grammar" selector="testSchemaExtension">testSchemaExtension	| text mutation schemaExtension rootOperationTypes |	text := 'schema { 					query: Query				}				extend schema{					mutation: Mutation				}				type Query{					hello: String				}				type Mutation{					incrementNumber: Int				}'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: GQLSSchemaNode.	schemaExtension := schema schemaExtensions first.	rootOperationTypes := schemaExtension rootOperationTypes.	self		assert: (rootOperationTypes at: 'mutation') first class		equals: GQLSRootOperationTypeNode.	self		assert: (rootOperationTypes at: 'mutation') first name		equals: 'Mutation'.	mutation := schema getType: 'Mutation'.	self		assert: (mutation fields at: 'incrementNumber') class		equals: GQLSFieldNode.	text := 'extend schema{					mutation: Mutation				}				type Mutation{					incrementNumber: Int				}'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: GQLSSchemaNode.	schemaExtension := schema schemaExtensions first.	rootOperationTypes := schemaExtension rootOperationTypes.	self		assert: (rootOperationTypes at: 'mutation') first class		equals: GQLSRootOperationTypeNode.	self		assert: (rootOperationTypes at: 'mutation') first name		equals: 'Mutation'.	mutation := schema getType: 'Mutation'.	self		assert: (mutation fields at: 'incrementNumber') class		equals: GQLSFieldNode.	text := '		extend schema{			mutation: GQLTestMutationType		}		type GQLTestMutationType {			createPoint(x: Int, y: Int): Point		}		type Point { 			x: Int			y: Int		}		'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: GQLSSchemaNode.	schemaExtension := schema schemaExtensions first.	rootOperationTypes := schemaExtension rootOperationTypes.	self		assert: (rootOperationTypes at: 'mutation') first class		equals: GQLSRootOperationTypeNode.	self		assert: (rootOperationTypes at: 'mutation') first name		equals: 'GQLTestMutationType'.	mutation := schema getType: 'GQLTestMutationType'.	self		assert: (mutation fields at: 'createPoint') type name		equals: 'Point'</body></methods><methods><class-id>GraphQLBeta.GQLSingleAnonimousQueryGrammarTest</class-id> <category>tests</category><body package="GraphQLBeta-Tests-Grammar" selector="testComposedDocument">testComposedDocument	| text |	text := '{		films { 			id 			name 			rating 		}	}'.	self parse: text rule: #document</body><body package="GraphQLBeta-Tests-Grammar" selector="testComposedDocumentWithArguments">testComposedDocumentWithArguments	| text |	text := '{		films (ids:["1", "2"]){ 			id			name 			rating (stringify: true)		}	}'.	self parse: text rule: #document</body><body package="GraphQLBeta-Tests-Grammar" selector="testComposedDocumentWithDirectives">testComposedDocumentWithDirectives	| text |	text := '{		films (ids:["1", "2"]) @skip(if : true){ 			id			name 			rating (stringify: true)		}	}'.	self parse: text rule: #document</body><body package="GraphQLBeta-Tests-Grammar" selector="testComposedDocumentWithFragments">testComposedDocumentWithFragments	| text |	text := '{		films (ids:["1", "2"]) @skip(if : true){ 			id			name 			rating (stringify: true)		}	}	fragment filmFeatures on Film { 		rating(stringify: true)		name	}	'.	self parse: text rule: #document</body><body package="GraphQLBeta-Tests-Grammar" selector="testComposedDocumentWithInlineFragments">testComposedDocumentWithInlineFragments	| text |	text := '{		films (ids:["1", "2"]) @skip(if : true){ 			id			... {				rating(stringify: true)				name			}		}	}	'.	self parse: text rule: #document</body><body package="GraphQLBeta-Tests-Grammar" selector="testComposedDocumentWithInlineFragmentsDirectives">testComposedDocumentWithInlineFragmentsDirectives	| text |	text := '{		films (ids:["1", "2"]) @skip(if : true){ 			id			... on Film @skip(if:true) @include(if:true){				rating(stringify: true)				name			}		}	}	'.	self parse: text rule: #document</body><body package="GraphQLBeta-Tests-Grammar" selector="testComposedDocumentWithInlineFragmentsType">testComposedDocumentWithInlineFragmentsType	| text |	text := '{		films (ids:["1", "2"]) @skip(if : true){ 			id			... on Film{				rating(stringify: true)				name			}		}	}	'.	self parse: text rule: #document</body><body package="GraphQLBeta-Tests-Grammar" selector="testComposedDocumentWithSchemaIntrospection">testComposedDocumentWithSchemaIntrospection	| text |	text := '{		__schema { 			types { 				name			} 		}	}'.	self parse: text rule: #document</body><body package="GraphQLBeta-Tests-Grammar" selector="testComposedDocumentWithSpreadFragments">testComposedDocumentWithSpreadFragments	| text |	text := '{		films (ids:["1", "2"]) @skip(if : true){ 			id			...filmFeatures @include(if : true)		}	}	fragment filmFeatures on Film { 		rating(stringify: true)		name	}	'.	self parse: text rule: #document</body><body package="GraphQLBeta-Tests-Grammar" selector="testComposedDocumentWithTypeIntrospection">testComposedDocumentWithTypeIntrospection	| text |	text := '{  			__type(name:"Query")		}'.	self parse: text rule: #document</body><body package="GraphQLBeta-Tests-Grammar" selector="testSimpleDocument">testSimpleDocument	| text |	text := '{  			firstName  			lastName		}'.	self parse: text rule: #document</body><body package="GraphQLBeta-Tests-Grammar" selector="testSimpleDocumentWithArguments">testSimpleDocumentWithArguments	| text |	text := '{  			firstName (upercase:true)  			lastName		}'.	self parse: text rule: #document</body><body package="GraphQLBeta-Tests-Grammar" selector="testSimpleDocumentWithDirectives">testSimpleDocumentWithDirectives	| text |	text := '{  			firstName (upercase:true) @include(if : true)  			lastName		}'.	self parse: text rule: #document</body><body package="GraphQLBeta-Tests-Grammar" selector="testSimpleDocumentWithFragments">testSimpleDocumentWithFragments	| text |	text := '{  			firstName (upercase:true) @include(if : true)  			lastName		}		fragment names on Person{			firstName (upercase:true) @include(if : true)  			lastName		}		fragment first on Person{			name		}		'.	self parse: text rule: #document</body><body package="GraphQLBeta-Tests-Grammar" selector="testSimpleDocumentWithInlineFragment">testSimpleDocumentWithInlineFragment	| text |	text := '{  			...{			firstName (upercase:true) @include(if : true)  			lastName			name			}		}'.	self parse: text rule: #document</body><body package="GraphQLBeta-Tests-Grammar" selector="testSimpleDocumentWithInlineFragmentDirectives">testSimpleDocumentWithInlineFragmentDirectives	| text |	text := '{  			... @skip(if:true){			firstName (upercase:true) @include(if : true)  			lastName			name			}		}'.	self parse: text rule: #document</body><body package="GraphQLBeta-Tests-Grammar" selector="testSimpleDocumentWithInlineFragmentType">testSimpleDocumentWithInlineFragmentType	| text |	text := '{  			... on Person{			firstName (upercase:true) @include(if : true)  			lastName			name			}		}'.	self parse: text rule: #document</body><body package="GraphQLBeta-Tests-Grammar" selector="testSimpleDocumentWithSpreadFragments">testSimpleDocumentWithSpreadFragments	| text |	text := '{  			...names		}		fragment names on Person{			firstName (upercase:true) @include(if : true)  			lastName			...name @skip(if : true)		}		fragment first on Person{			name		}		'.	self parse: text rule: #document</body><body package="GraphQLBeta-Tests-Grammar" selector="testSimpleDocumentWithTypenameIntrospection">testSimpleDocumentWithTypenameIntrospection	| text |	text := '{  			__typename		}'.	self parse: text rule: #document</body></methods><methods><class-id>GraphQLBeta.GQLSingleAnonimousQueryGrammarTest</class-id> <category>accessing</category><body package="GraphQLBeta-Tests-Grammar" selector="parserClass">parserClass	^ GQLSingleAnonimousQueryGrammar</body></methods><methods><class-id>GraphQLBeta.GQLSingleAnonimousQueryGrammarTest</class-id> <category>tests-introspection</category><body package="GraphQLBeta-Tests-Grammar" selector="testSchemaField">testSchemaField	self parse: '__schema{types{name}}' rule: #schemaField.	self parse: '__schema @skip(if: false){name}' rule: #schemaField.	self		parse:			'__schema{						fields						otherField}'		rule: #schemaField.	self		parse:			'#comment 					__schema{otherFields}'		rule: #schemaField.	self		parse:			'#comment 					__schema{						fields						otherFields{							name						}					}					#other comment'		rule: #schemaField.	self fail: '__othername' rule: #schemaField.	self fail: '__schema' rule: #schemaField.	self fail: '_schema' rule: #schemaField.	self fail: 'schema' rule: #schemaField.	self fail: '__Schema' rule: #schemaField.	self fail: '__schema(name:"Query")' rule: #schemaField.	self fail: '__schema @skip(if:true)' rule: #schemaField.	self fail: '__schema{}' rule: #schemaField</body><body package="GraphQLBeta-Tests-Grammar" selector="testTypeField">testTypeField	self parse: '__type(name:"Query"){name}' rule: #typeField.	self		parse: '__type(name:"Query")@skip(if:true){name}'		rule: #typeField.	self		parse: '__type(otherArg:"OtherType"){otherField}'		rule: #typeField.	self		parse:			'#comment 					__type(otherArg:"OtherType"){otherFields}'		rule: #typeField.	self		parse:			'#comment 					__type(otherArg:"OtherType"){						fields						otherFields{							name						}					}					#other comment'		rule: #typeField.	self fail: 'typename' rule: #typenameField.	self fail: '_typename' rule: #typenameField.	self fail: '__otherName' rule: #typenameField.	self fail: '__Typename' rule: #typenameField.	self fail: '__type(name: "OtherType")' rule: #typeField.	self fail: '__type{name}' rule: #typeField.	self fail: '__type @skip(if: true){otherField}' rule: #typeField.	self fail: '__type{types{name}}' rule: #typeField</body><body package="GraphQLBeta-Tests-Grammar" selector="testTypenameField">testTypenameField	self parse: '__typename' rule: #typenameField.	self parse: '__typename @skip(if:true)' rule: #typenameField.	self parse: '__typename @include(if:true)' rule: #typenameField.	self		parse:			'#comment 					__typename'		rule: #typenameField.	self		parse:			'#comment 					__typename					#other comment'		rule: #typenameField.	self fail: 'typename' rule: #typenameField.	self fail: '_typename' rule: #typenameField.	self fail: '__Typename' rule: #typenameField.	self fail: '__otherName' rule: #typenameField.	self fail: '__otherTypename(name: "OtherType")' rule: #typenameField.	self fail: '__typename(name: "OtherType")' rule: #typenameField.	self fail: '__typename{name}' rule: #typenameField.	self		fail: '__typename @skip(if: true){otherField}'		rule: #typenameField.	self fail: '__typename{types{name}' rule: #typenameField</body></methods><methods><class-id>GraphQLBeta.GQLRequestGrammarTest</class-id> <category>tests-grammar</category><body package="GraphQLBeta-Tests-Grammar" selector="testAlias">testAlias	| text |	text := 'smallPic:'.	self parse: text rule: #alias.	text := 'smallPic :'.	self parse: text rule: #alias</body><body package="GraphQLBeta-Tests-Grammar" selector="testArgument">testArgument	| text |	text := 'id:4'.	self parse: text rule: #argument</body><body package="GraphQLBeta-Tests-Grammar" selector="testArguments">testArguments	| text |	text := '(id: 4)'.	self parse: text rule: #arguments.	text := '(id: 4, pass: 1233, pass2: 12312)'.	self parse: text rule: #arguments</body><body package="GraphQLBeta-Tests-Grammar" selector="testComment">testComment	| text |	text := '#Comment of an line'.	self parse: text rule: #comment</body><body package="GraphQLBeta-Tests-Grammar" selector="testDirectives">testDirectives	self parse: '@skip' rule: #directives.	self parse: '@skip(if: true)' rule: #directives.	self parse: '@skip(if: false)' rule: #directives.	self fail: 'missing@(if: true)' rule: #directives</body><body package="GraphQLBeta-Tests-Grammar" selector="testDocument">testDocument	| text |	text := 'fragment friendFields on User {  		id  		name 	 	profilePic(size: 50)	}'.	self parse: text rule: #document.	text := 'fragment friendFields on User { 	 	id  		name  		...standardProfilePic	}'.	self parse: text rule: #document.	text := '{	  likeStory {			story {  	  	  		likeCount  	 		} 	 	}	}'.	self parse: text rule: #document.	text := 'mutation fetchLikeStory($var:Int){	  likeStory(storyID: Int) {			story {  	  	  		likeCount  	 		} 	 	}	}'.	self parse: text rule: #document.	text := '{	  likeStory($storyID: Int=12) {			story {  	  	  		likeCount  	 		} 	 	}	}'.	self fail: text rule: #document</body><body package="GraphQLBeta-Tests-Grammar" selector="testEnumValue">testEnumValue	self parse: 'ENUM_VALUE' rule: #enumValue.	self parse: 'any_other_name_value_noSpaces' rule: #enumValue.	self fail: 'true' rule: #enumValue.	self fail: 'false' rule: #enumValue.	self fail: 'null' rule: #enumValue</body><body package="GraphQLBeta-Tests-Grammar" selector="testField">testField	| text |	text := 'me'.	self parse: text rule: #field.	text := 'user(id: 4) {    name  }'.	self parse: text rule: #field.	text := '__name'.	self parse: text rule: #field</body><body package="GraphQLBeta-Tests-Grammar" selector="testFragmentDefinition">testFragmentDefinition	| text |	text := 'fragment friendFields on User {  id  name  profilePic(size: 50)}'.	self parse: text rule: #fragmentDefinition.	text := 'fragment friendFields on User {  id  name  ...standardProfilePic}'.	self parse: text rule: #fragmentDefinition</body><body package="GraphQLBeta-Tests-Grammar" selector="testFragmentSpread">testFragmentSpread	| text |	text := '...friendFields'.	self parse: text rule: #fragmentSpread</body><body package="GraphQLBeta-Tests-Grammar" selector="testInlineFragment">testInlineFragment	| text |	text := '... on User {      friends {        count      }    }'.	self parse: text rule: #inlineFragment.	text := '... @include(if: $expandedInfo) {      firstName      lastName      birthday    }'.	self parse: text rule: #inlineFragment</body><body package="GraphQLBeta-Tests-Grammar" selector="testInlineFragments">testInlineFragments	| text |	text := '... on User {      friends {        count      }    }'.	self parse: text rule: #inlineFragment.	text := '... @include(if: $expandedInfo) {      firstName      lastName      birthday    }'.	self parse: text rule: #inlineFragment</body><body package="GraphQLBeta-Tests-Grammar" selector="testIntrospection">testIntrospection	| text |	text := '{ 		__type(name: "User") { 			name			fields { 				name				type { 					name				}			}		}	}'.	self parse: text rule: #operationDefinition</body><body package="GraphQLBeta-Tests-Grammar" selector="testListValue">testListValue	self parse: '[1, 2, 3]' rule: #listValue.	self parse: '["a"]' rule: #listValue.	self parse: '[]' rule: #listValue.	self parse: '[[], "a", 1]' rule: #listValue.	self fail: 'null' rule: #listValue.	self fail: '123.123e12' rule: #listValue</body><body package="GraphQLBeta-Tests-Grammar" selector="testNamedType">testNamedType	self parse: 'NamedType' rule: #namedType.	self parse: '__NamedType' rule: #namedType.	self fail: 'NonNullType!' rule: #namedType</body><body package="GraphQLBeta-Tests-Grammar" selector="testNonNullType">testNonNullType	self parse: 'NonNullType!' rule: #nonNullType.	self fail: 'NonNullType' rule: #nonNullType</body><body package="GraphQLBeta-Tests-Grammar" selector="testNullValue">testNullValue	self parse: 'null' rule: #nullValue.	self fail: '123.123' rule: #nullValue.	self fail: 'asdf' rule: #nullValue</body><body package="GraphQLBeta-Tests-Grammar" selector="testObjectField">testObjectField	| text |	text := '_4__ : null'.	self parse: text rule: #objectField.	text := 'age : 12'.	self parse: text rule: #objectField</body><body package="GraphQLBeta-Tests-Grammar" selector="testObjectValue">testObjectValue	| text |	text := '{ }'.	self parse: text rule: #objectValue.	text := '{name: "12.43", age: 53 }'.	self parse: text rule: #objectValue</body><body package="GraphQLBeta-Tests-Grammar" selector="testOperationDefinition">testOperationDefinition	| text |	text := '{	  likeStory {			story {  	  	  		likeCount  	 		} 	 	}	}'.	self parse: text rule: #operationDefinition.	text := 'mutation fetchLikeStory($var:Int){	  likeStory(storyID: Int) {			story {  	  	  		likeCount  	 		} 	 	}	}'.	self parse: text rule: #operationDefinition.	text := '{	  likeStory($storyID: Int=12) {			story {  	  	  		likeCount  	 		} 	 	}	}'.	self fail: text rule: #operationDefinition</body><body package="GraphQLBeta-Tests-Grammar" selector="testSelectionSet">testSelectionSet	| text |	text := '{		films {			id #comment			name 			rating 		}	}'.	self parse: text rule: #selectionSet.	text := '{			parents { 				firstName			}  			firstName  			lastName			friends { 				nickname				lastname			}		}'.	self parse: text rule: #selectionSet.	text := '{  			friends(id:4) { 				nickname			}  			firstName  			lastName		}'.	self parse: text rule: #selectionSet</body><body package="GraphQLBeta-Tests-Grammar" selector="testType">testType	self parse: 'NonNullType' rule: #type.	self parse: 'NonNullType!' rule: #type.	self parse: '[Named]' rule: #type.	self parse: '[Named!]' rule: #type.	self parse: '[Named]!' rule: #type.	self parse: '[Named!]!' rule: #type.	self parse: 'Boolean' rule: #type.	self parse: 'Int!' rule: #type.	self parse: '[Float]' rule: #type.	self parse: '[String!]' rule: #type.	self parse: '[ID]!' rule: #type.	self parse: '[Int!]!' rule: #type</body><body package="GraphQLBeta-Tests-Grammar" selector="testTypeCondition">testTypeCondition	| text |	text := 'on User'.	self parse: text rule: #typeCondition</body><body package="GraphQLBeta-Tests-Grammar" selector="testValue">testValue	"implement tests with test contained in intValue floatValue, StringValue,	BooleanValue, NullValue, EnumValue, ListValue, ObjectValue"	"int value"	self parse: '2312' rule: #value.	self parse: '-123' rule: #value.	self parse: '+444' rule: #value.	"float value"	self parse: '2312.12' rule: #value.	self parse: '-123.23e12' rule: #value.	self parse: '-123.23E12' rule: #value.	self parse: '12' rule: #value.	"boolean value"	self parse: 'true' rule: #value.	self parse: 'false' rule: #value.	"string value"	self parse: '""' rule: #value.	self		parse: '"any other kind of text +_)(*&amp;^%$#@ |}{:?&gt;&lt;][/;.,"'		rule: #value.	self parse: '"\u00f3 \\ \/ \b \f \n \r \t"' rule: #value.	"list value"	self parse: '[1, 2, 3]' rule: #value.	self parse: '["a"]' rule: #value.	self parse: '[]' rule: #value.	self parse: '[[], "a", 1]' rule: #value.	"null value"	self parse: 'null' rule: #value.	"enum value"	self parse: 'ENUM_VALUE' rule: #value.	self parse: 'any_other_name_value_noSpaces' rule: #value.	self parse: '{ }' rule: #value.	self parse: '{name: "12.43", age: 53 }' rule: #value</body><body package="GraphQLBeta-Tests-Grammar" selector="testVariable">testVariable	self parse: '$someVariableName' rule: #variable.	self fail: 'missing$atthebegining' rule: #variable</body><body package="GraphQLBeta-Tests-Grammar" selector="testVariableDefinition">testVariableDefinition	self parse: '$devicePicSize: Int' rule: #variableDefinition.	self parse: '$devicePicSize: Int = 12' rule: #variableDefinition</body><body package="GraphQLBeta-Tests-Grammar" selector="testVariableDefinitions">testVariableDefinitions	self parse: '($devicePicSize: Int)' rule: #variableDefinitions.	self parse: '($devicePicSize: Int = 12)' rule: #variableDefinitions.	self		parse: '($devicePicSize: Int = 12, $devicePicSize: Int = 2)'		rule: #variableDefinitions.	self fail: '($devicePicSize: Int = 12,)' rule: #variableDefinitions.	self fail: '$devicePicSize: Int = 12' rule: #variableDefinitions</body></methods><methods><class-id>GraphQLBeta.GQLRequestGrammarTest</class-id> <category>initialization</category><body package="GraphQLBeta-Tests-Grammar" selector="parserClass">parserClass	^ GQLRequestGrammar</body><body package="GraphQLBeta-Tests-Grammar" selector="setUp">setUp	parserVariable := GQLVariableGrammar</body></methods><methods><class-id>GraphQLBeta.GQLRequestGrammarTest</class-id> <category>tests-grammar-comment</category><body package="GraphQLBeta-Tests-Grammar" selector="testGrammarDocumentWithComment">testGrammarDocumentWithComment	| text |	text := 'fragment #comment 1	friendFields on #comment 2	User {		#id  		id		#name  		name		#profilePic 	 	profilePic(size: 50)	}'.	self parse: text rule: #document.	text := '{	  #comment 1	  likeStory {	  #comment 2			story {			#comment 3  	  	  		likeCount  	 		} 	 	}	}'.	self parse: text rule: #document</body><body package="GraphQLBeta-Tests-Grammar" selector="testGrammarNodeWithComment">testGrammarNodeWithComment	self		parse:			'#comment 	@skip(if: false) #comment 1'		rule: #directives.	self		parse:			'user(id: 4) { 	#comment 1	name 	#comment 2	}'		rule: #field.	self		parse:			'fragment #comment 1		friendFields on User 		#comment 2		{		#id  		id		#name  		name		#name  		profilePic(size: 50)	}'		rule: #fragmentDefinition.	self		parse:			'... on #comment 1		User {		#comment 2      friends {		  #comment 3        count      }    }'		rule: #inlineFragment</body></methods><methods><class-id>GraphQLBeta.GQLQueryRoot</class-id> <category>public</category><body package="GraphQLBeta-Test-Utils" selector="arguments">arguments	^ GQLArguments new</body><body package="GraphQLBeta-Test-Utils" selector="booleanListBooleanListArg:">booleanListBooleanListArg: list	^ list</body><body package="GraphQLBeta-Test-Utils" selector="cat">cat	^ GQLCat new		name: 'Mishi';		nickname: 'Gatencio';		meowVolume: 3</body><body package="GraphQLBeta-Test-Utils" selector="catOrDog">catOrDog	^ self cat</body><body package="GraphQLBeta-Test-Utils" selector="dog">dog	^ GQLDog new		name: 'lobo';		nickname: 'lobito';		barkVolume: 10;		owner: self human</body><body package="GraphQLBeta-Test-Utils" selector="findDogComplex:">findDogComplex: input	^ self dog</body><body package="GraphQLBeta-Test-Utils" selector="findDogNotNullComplex:">findDogNotNullComplex: input	^ input</body><body package="GraphQLBeta-Test-Utils" selector="human">human	^ GQLHuman new name: 'Akevalion'</body><body package="GraphQLBeta-Test-Utils" selector="pet">pet	^ self dog</body></methods><methods><class-id>GraphQLBeta.GQLQueryRoot class</class-id> <category>accessing</category><body package="GraphQLBeta-Test-Utils" selector="schema">schema	^ 'enum DogCommand { SIT, DOWN, HEEL }schema { 	query: GQLQueryRoot}type GQLDog implements GQLPet{  name: String!  nickname: String  barkVolume: Int  doesKnowCommand(dogCommand: DogCommand!): Boolean!  isHousetrained(atOtherHomes: Boolean): Boolean!  owner: GQLHuman}interface GQLSentient {  name: String!}type GQLAlien implements GQLSentient {  name: String!  homePlanet: String}interface GQLPet {  name: String!}type GQLHuman implements GQLSentient {  name: String!}enum CatCommand { JUMP }type GQLCat implements GQLPet {  name: String!  nickname: String  doesKnowCommand(catCommand: CatCommand!): Boolean!  meowVolume: Int}union CatOrDog = GQLCat | GQLDogunion DogOrHuman = GQLDog | GQLHumanunion HumanOrAlien = GQLHuman | GQLAlientype GQLArguments {	singleID(id: ID): Boolean	singleString(string: String): String	multipleReqs(x: Int!, y: Int!): Int!	booleanArgField(booleanArg: Boolean): Boolean	floatArgField(floatArg: Float): Float	intArgField(intArg: Int): Int	nonNullBooleanArgField(nonNullBooleanArg: Boolean!): Boolean!	booleanListArgField(booleanListArg: [Boolean]!): [Boolean]	nonNullBooleanListField(nonNullBooleanListArg: [Boolean]!): [Boolean]	optionalNonNullBooleanArgField(optionalBooleanArg: Boolean!): Boolean!}input GQLDogInput{	name: String	complex: GQLComplexInput}input GQLComplexInput{	foo: Int	bar: String!}type GQLQueryRoot {	findDog(complex: GQLDogInput): GQLDog	findDogNotNull(complex: GQLDogInput!): GQLDog	dog: GQLDog	human: GQLHuman	pet: GQLPet	catOrDog: CatOrDog	arguments: GQLArguments	booleanList(booleanListArg: [Boolean!]): [Boolean]}'</body></methods><methods><class-id>GraphQLBeta.GQLZGeneralTest</class-id> <category>tests - coercion</category><body package="GraphQLBeta-Tests-Validation" selector="testBooleanInputCoercion">testBooleanInputCoercion	"https://facebook.github.io/graphql/draft/#sec-Boolean"	| type value coercedValue |	type := GQLSBooleanTypeNode new.	value := GQLBooleanNode new value: 'true'.	coercedValue := type coerceValue: value on: nil.	self assert: coercedValue value equals: 'true'.	value := GQLNullNode new.	coercedValue := type coerceValue: value on: nil.	self assert: coercedValue value equals: nil.	value := GQLIntNode new value: '0'.	self		should: [ coercedValue := type coerceValue: value on: nil ]		raise: Error</body><body package="GraphQLBeta-Tests-Validation" selector="testDemoCoercion">testDemoCoercion	| result |	compareJson := true.	result := self		jsonRequest:			'{	listOfInts(ints: 0)}'.	self		assert: result		equals:			'{	"data" : {		"listOfInts" : [			0		]	}}'</body><body package="GraphQLBeta-Tests-Validation" selector="testFloatInputCoercion">testFloatInputCoercion	"https://facebook.github.io/graphql/draft/#sec-Float"	| type value coercedValue |	type := GQLSFloatTypeNode new.	value := GQLFloatNode new value: '3.1416'.	coercedValue := type coerceValue: value on: nil.	self assert: coercedValue value equals: '3.1416'.	value := GQLNullNode new.	coercedValue := type coerceValue: value on: nil.	self assert: coercedValue value equals: nil.	value := GQLStringNode new value: '0'.	self		should: [ coercedValue := type coerceValue: value on: nil ]		raise: Error.	value := GQLIntNode new value: '2147483648'.	coercedValue := type coerceValue: value on: nil.	self assert: coercedValue value equals: '2147483648.0'</body><body package="GraphQLBeta-Tests-Validation" selector="testIDInputCoercion">testIDInputCoercion	"https://facebook.github.io/graphql/draft/#sec-Boolean"	| type value coercedValue |	type := GQLSIDTypeNode new.	value := GQLIntNode new value: '123456'.	coercedValue := type coerceValue: value on: nil.	self assert: coercedValue value equals: '123456'.	value := GQLNullNode new.	coercedValue := type coerceValue: value on: nil.	self assert: coercedValue value equals: nil.	value := GQLStringNode new value: '"123456"'.	coercedValue := type coerceValue: value on: nil.	self assert: coercedValue value equals: '"123456"'.	value := GQLBooleanNode new value: 'true'.	self		should: [ coercedValue := type coerceValue: value on: nil ]		raise: Error</body><body package="GraphQLBeta-Tests-Validation" selector="testInputObjectCoercion">testInputObjectCoercion	"https://facebook.github.io/graphql/draft/#sec-Input-Objects"	| type value coercedValue |	type := GQLSInputObjectTypeNode new		name: 'foo';		addFields:			(Array				with:					(GQLSInputObjectFieldNode new						name: 'a';						type: GQLSStringTypeNode new)				with:					(GQLSInputObjectFieldNode new						name: 'b';						type: (GQLSNonNullTypeNode new wrappedType: GQLSIntTypeNode new))).	"literal { a: 'abc', b: 123 }"	value := GQLObjectNode new		objectFields:			(Array				with:					(GQLObjectFieldNode new						name: 'a';						value: (GQLStringNode new value: '"abc"'))				with:					(GQLObjectFieldNode new						name: 'b';						value: (GQLIntNode new value: '123'))).	coercedValue := type coerceValue: value on: nil.	self assert: coercedValue asString equals: '{a: "abc", b: 123}'.	(value objectFields at: 1) value: GQLNullNode new.	coercedValue := type coerceValue: value on: nil.	self assert: coercedValue asString equals: '{a: null, b: 123}'.	value		objectFields:			(Array				with:					(GQLObjectFieldNode new						name: 'b';						value: (GQLIntNode new value: '123'))).	coercedValue := type coerceValue: value on: nil.	self assert: coercedValue asString equals: '{b: 123}'.	value		objectFields:			(Array				with:					(GQLObjectFieldNode new						name: 'a';						value: (GQLVariableNode new value: 'var'))				with:					(GQLObjectFieldNode new						name: 'b';						value: (GQLIntNode new value: '123'))).	coercedValue := type coerceValue: value on: nil.	self assert: coercedValue asString equals: '{a: $var, b: 123}'.	value := GQLVariableNode new value: 'var'.	coercedValue := type coerceValue: value on: nil.	self assert: coercedValue asString equals: '$var'.	value := GQLStringNode new value: '"abc123"'.	self should: [ type coerceValue: value on: nil ] raise: Error</body><body package="GraphQLBeta-Tests-Validation" selector="testIntInputCoercion">testIntInputCoercion	"https://facebook.github.io/graphql/draft/#sec-Int"	| type value coercedValue |	type := GQLSIntTypeNode new.	value := GQLIntNode new value: '0'.	coercedValue := type coerceValue: value on: nil.	self assert: coercedValue value equals: '0'.	value := GQLNullNode new.	coercedValue := type coerceValue: value on: nil.	self assert: coercedValue value equals: nil.	value := GQLStringNode new value: '0'.	self		should: [ coercedValue := type coerceValue: value on: nil ]		raise: Error.	value := GQLIntNode new value: '2147483648'.	self		should: [ coercedValue := type coerceValue: value on: nil ]		raise: Error</body><body package="GraphQLBeta-Tests-Validation" selector="testListInputCoercion">testListInputCoercion	"https://facebook.github.io/graphql/draft/#sec-Type-System.List"	| type value coercedValue |	type := GQLSListTypeNode new wrappedType: GQLSIntTypeNode new.	value := GQLListNode new		value:			(Array				with: (GQLIntNode new value: '1')				with: (GQLIntNode new value: '2')				with: (GQLIntNode new value: '3')).	coercedValue := type coerceValue: value on: nil.	self assert: coercedValue asString equals: '[1, 2, 3]'.	value := GQLListNode new		value:			(Array				with: (GQLIntNode new value: '1')				with: (GQLStringNode new value: '"b"')				with: (GQLIntNode new value: '3')).	self should: [ type coerceValue: value on: nil ] raise: Error.	value := GQLIntNode new value: '1'.	coercedValue := type coerceValue: value on: nil.	self assert: coercedValue asString equals: '[1]'.	value := GQLNullNode new.	coercedValue := type coerceValue: value on: nil.	self assert: coercedValue asString equals: 'null'.	type := GQLSListTypeNode new		wrappedType: (GQLSListTypeNode new wrappedType: GQLSIntTypeNode new).	value := GQLListNode new		value:			(Array				with:					(GQLListNode new value: (Array with: (GQLIntNode new value: '1')))				with:					(GQLListNode new						value:							(Array								with: (GQLIntNode new value: '2')								with: (GQLIntNode new value: '3')))).	coercedValue := type coerceValue: value on: nil.	self assert: coercedValue asString equals: '[[1], [2, 3]]'.	value := GQLListNode new		value:			(Array				with: (GQLIntNode new value: '1')				with: (GQLIntNode new value: '2')				with: (GQLIntNode new value: '3')).	coercedValue := type coerceValue: value on: nil.	self assert: coercedValue asString equals: '[[1], [2], [3]]'.	value := GQLIntNode new value: '1'.	coercedValue := type coerceValue: value on: nil.	self assert: coercedValue asString equals: '[[1]]'</body><body package="GraphQLBeta-Tests-Validation" selector="testStringInputCoercion">testStringInputCoercion	"https://facebook.github.io/graphql/draft/#sec-String"	| type value coercedValue |	type := GQLSStringTypeNode new.	value := GQLStringNode new value: '"3.1416"'.	coercedValue := type coerceValue: value on: nil.	self assert: coercedValue value equals: '"3.1416"'.	value := GQLNullNode new.	coercedValue := type coerceValue: value on: nil.	self assert: coercedValue value equals: nil.	value := GQLIntNode new value: '0'.	self		should: [ coercedValue := type coerceValue: value on: nil ]		raise: Error</body></methods><methods><class-id>GraphQLBeta.GQLZGeneralTest</class-id> <category>tests</category><body package="GraphQLBeta-Tests-Validation" selector="test01FieldInvalidQuery">test01FieldInvalidQuery	| result |	compareJson := true.	result := self		jsonRequest:			'# INVALID: bestActor does not exist on GQLTestFilm{	films {		name		bestActor	}}'.	self		assert: result		equals:			'{	"errors" : [		{			"message" : "Cannot query field \"bestActor\" on type \"GQLTestFilm\"",			"locations" : [				{					"line" : 5,					"column" : 3				}			]		}	]}'</body><body package="GraphQLBeta-Tests-Validation" selector="test02InvalidRecursiveFragment">test02InvalidRecursiveFragment	| result |	compareJson := true.	result := self		jsonRequest:			'#Invalid fragment cant have recursive{	films {		...foo	}}fragment foo on GQLTestFilm{	id	... bar}fragment bar on GQLTestFilm{	name	... foo}'.	self		assert: result		equals:			'{	"errors" : [		{			"message" : "Cannot spread fragment \"foo\" with itself via bar",			"locations" : [				{					"line" : 10,					"column" : 6				}			]		},		{			"message" : "Cannot spread fragment \"bar\" with itself via foo",			"locations" : [				{					"line" : 14,					"column" : 6				}			]		}	]}'</body><body package="GraphQLBeta-Tests-Validation" selector="test03FielsAsScalar">test03FielsAsScalar	| result |	compareJson := true.	result := self		jsonRequest:			'# INVALID: hero is not a scalar, so fields are needed{  films}'.	self		assert: result		equals:			'{	"errors" : [		{			"message" : "Field \"films\" on type \"[GQLTestFilm]\" must have selection of subfields. Did you mean \"films { ... }\"?",			"locations" : [				{					"line" : 3,					"column" : 3				}			]		}	]}'</body><body package="GraphQLBeta-Tests-Validation" selector="test04ScalarWithFields">test04ScalarWithFields	| result |	compareJson := true.	result := self		jsonRequest:			'# INVALID: name is a scalar, so fields are not permitted{  films {    name {      firstCharacterOfName    }  }}'.	self		assert: result		equals:			'{	"errors" : [		{			"message" : "Field \"name\" must not have selection since type \"String\" has no subfields.",			"locations" : [				{					"line" : 4,					"column" : 10				}			]		}	]}'</body><body package="GraphQLBeta-Tests-Validation" selector="test05InvalidField">test05InvalidField	| result |	compareJson := true.	result := self		jsonRequest:			'# INVALID: primaryFunction does not exist on Character{  films {    name    primaryFunction  }}'.	self		assert: result		equals:			'{	"errors" : [		{			"message" : "Cannot query field \"primaryFunction\" on type \"GQLTestFilm\"",			"locations" : [				{					"line" : 5,					"column" : 5				}			]		}	]}'</body><body package="GraphQLBeta-Tests-Validation" selector="test06GeneralInstrospectionQuery">test06GeneralInstrospectionQuery	| result |	compareJson := true.	result := GraphQL new		shouldValidate: true;		handleRequest:			'query IntrospectionQuery {	__schema {		queryType { name }		mutationType { name }		subscriptionType { name }		types {		...FullType		}		directives {			name			description			locations			args {			...InputValue			}		}	}}fragment FullType on Type {      kind      name      description      fields(includeDeprecated: true) {        name        description        args {          ...InputValue        }        type {          ...TypeRef        }        isDeprecated        deprecationReason      }      inputFields {        ...InputValue      }      interfaces {        ...TypeRef      }      enumValues(includeDeprecated: true) {        name        description        isDeprecated        deprecationReason      }      possibleTypes {        ...TypeRef      }    }    fragment InputValue on InputValue {      name      description      type { ...TypeRef }      defaultValue    }    fragment TypeRef on Type {      kind      name      ofType {        kind        name        ofType {          kind          name          ofType {            kind            name            ofType {              kind              name              ofType {                kind                name                ofType {                  kind                  name                  ofType {                    kind                    name                  }                }              }            }          }        }      }    }'.	self deny: (result includesKey: 'errors')</body><body package="GraphQLBeta-Tests-Validation" selector="test07GeneralRequest">test07GeneralRequest	| result |	compareJson := true.	result := GraphQL new		operation: 'm1';		variables: '{"person":{name:"Andre"},"prefix":"Abst"}';		shouldValidate: true;		handleRequest:			'		#comment of op1query op1($person: PersonInput={name:"Alex"}){  ...fr  helloMessage(to:$person)  filmsOn(gender:ACTION){    rating    ...fr2    director{      __typename      ...fr2    }  }  #comment inside	dirAndF: directorsAndFilms{    #inline fragment    ...on namedItem{      __typename      name    }  }}#comment in m1mutation m1{  createPoint(x: 2, y:5){    x    y  }}#comment in m2mutation m2{  createRectangle(left:3, right:5, top:6,bottom:1){    origin{      x @skip(if:true)      y    }    corner{      x      y    }  }}#comment in op2query op2($prefix:String){  ...fr  allClassesStarting(with: $prefix){    ...fr2  }  #comment inside}#comment of fragment frfragment fr on GQLQuery{  __typename  #fragment spread  hi: hello}fragment fr2 on namedItem{  #comment of field before  name  #comment of field after}'.	self deny: (result includesKey: 'errors')</body></methods><methods><class-id>GraphQLBeta.GQLZGeneralTest</class-id> <category>initialization</category><body package="GraphQLBeta-Tests-Validation" selector="setUp">setUp	schema := self parseSchema: GQLTestQueryType schema.	rootInstance := GQLTestQueryType new.	schema root: rootInstance.	compareJson := false</body></methods><methods><class-id>GraphQLBeta.GQLFieldsValidationTest</class-id> <category>tests</category><body package="GraphQLBeta-Tests-Validation" selector="testFieldsSelectionsMergin01">testFieldsSelectionsMergin01	"If multiple field selections with the same response names are encountered during execution, the field and arguments to execute and the resulting value should be unambiguous. Therefore any two field selections which might both be encountered for the same object are only valid if they are equivalent.For simple handâwritten GraphQL, this rule is obviously a clear developer error, however nested fragments can make this difficult to detect manually."	| result |	"This document is valid"	result := self		jsonRequest:			'{ 	dog { 		...mergeIdenticalFields		...mergeIdenticalAliasesAndFields	}}fragment mergeIdenticalFields on GQLDog {  name  name}fragment mergeIdenticalAliasesAndFields on GQLDog {  otherName: name  otherName: name}'.	self		assertJSONEquals: result		and:			'{	"data": { 		"dog" : {			"name" : "lobo",			"otherName" : "lobo"		}	}}'</body><body package="GraphQLBeta-Tests-Validation" selector="testFieldsSelectionsMergin02">testFieldsSelectionsMergin02	"If multiple field selections with the same response names are encountered during execution, the field and arguments to execute and the resulting value should be unambiguous. Therefore any two field selections which might both be encountered for the same object are only valid if they are equivalent.For simple handâwritten GraphQL, this rule is obviously a clear developer error, however nested fragments can make this difficult to detect manually."	| result |	"This document is invalid"	result := self		jsonRequest:			'{ 	dog { 		...conflictingBecauseAlias	}}fragment conflictingBecauseAlias on GQLDog {  name: nickname  name}'.	self		assert: result		equals:			'{	"errors" : [		{			"message" : "Fields \"name\" conflict because \"nickname\" and \"name\" are different fields. Use different aliases on the fields to fetch both if this was intentional.",			"locations" : [				{					"line" : 8,					"column" : 9				},				{					"line" : 9,					"column" : 3				}			]		}	]}'</body><body package="GraphQLBeta-Tests-Validation" selector="testFieldsSelectionsMergin03">testFieldsSelectionsMergin03	"If multiple field selections with the same response names are encountered during execution, the field and arguments to execute and the resulting value should be unambiguous. Therefore any two field selections which might both be encountered for the same object are only valid if they are equivalent.For simple handâwritten GraphQL, this rule is obviously a clear developer error, however nested fragments can make this difficult to detect manually."	| result |	"This document is valid"	result := self		operation: 'foo'		variables: '{"dogCommand": SIT}'		jsonRequest:			'query foo{ 	dog { 		...mergeIdenticalFieldsWithIdenticalArgs	}}query bar($dogCommand: DogCommand!){	dog { 		...mergeIdenticalFieldsWithIdenticalValues	}}fragment mergeIdenticalFieldsWithIdenticalArgs on GQLDog {  doesKnowCommand(dogCommand: SIT)  doesKnowCommand(dogCommand: SIT)}fragment mergeIdenticalFieldsWithIdenticalValues on GQLDog {  doesKnowCommand(dogCommand: $dogCommand)  doesKnowCommand(dogCommand: $dogCommand)}'.	self		assert: result		equals:			'{	"data" : {		"dog" : {			"doesKnowCommand" : true		}	}}'</body><body package="GraphQLBeta-Tests-Validation" selector="testFieldsSelectionsMergin04">testFieldsSelectionsMergin04	"If multiple field selections with the same response names are encountered during execution, the field and arguments to execute and the resulting value should be unambiguous. Therefore any two field selections which might both be encountered for the same object are only valid if they are equivalent.For simple handâwritten GraphQL, this rule is obviously a clear developer error, however nested fragments can make this difficult to detect manually."	| result |	"This document is invalid"	result := self		operation: 'foo'		variables: '{"dogCommand": HEEL, "varOne": SIT, "varTwo": SIT}'		jsonRequest:			'query foo($dogCommand: DogCommand!, $varOne: DogCommand!, $varTwo: DogCommand!) { 	dog { 		...conflictingArgsOnValues		...conflictingArgsValueAndVar		...conflictingArgsWithVars		...differingArgs	}}fragment conflictingArgsOnValues on GQLDog {  doesKnowCommand(dogCommand: SIT)  doesKnowCommand(dogCommand: HEEL)}fragment conflictingArgsValueAndVar on GQLDog {  doesKnowCommand(dogCommand: SIT)  doesKnowCommand(dogCommand: $dogCommand)}fragment conflictingArgsWithVars on GQLDog {  doesKnowCommand(dogCommand: $varOne)  doesKnowCommand(dogCommand: $varTwo)}fragment differingArgs on GQLDog {  doesKnowCommand(dogCommand: SIT)  doesKnowCommand}'.	self		assert: result		equals:			'{	"errors" : [		{			"message" : "Fields \"doesKnowCommand\" conflict because they have differing arguments. Use different aliases on the fields to fetch both if this was intentional.",			"locations" : [				{					"line" : 11,					"column" : 3				},				{					"line" : 12,					"column" : 3				},				{					"line" : 16,					"column" : 3				},				{					"line" : 17,					"column" : 3				},				{					"line" : 21,					"column" : 3				},				{					"line" : 22,					"column" : 3				},				{					"line" : 26,					"column" : 3				},				{					"line" : 27,					"column" : 3				}			]		},		{			"message" : "Field \"doesKnowCommand\" argument \"dogCommand\" of type \"DogCommand!\" is required but not provided.",			"locations" : [				{					"line" : 27,					"column" : 3				}			]		}	]}'</body><body package="GraphQLBeta-Tests-Validation" selector="testFieldsSelectionsMergin05">testFieldsSelectionsMergin05	"If multiple field selections with the same response names are encountered during execution, the field and arguments to execute and the resulting value should be unambiguous. Therefore any two field selections which might both be encountered for the same object are only valid if they are equivalent.For simple handâwritten GraphQL, this rule is obviously a clear developer error, however nested fragments can make this difficult to detect manually."	| result |	"This document is valid"	result := self		jsonRequest:			'{ 	dog { 		...safeDifferingFields		...safeDifferingArgs	}}fragment safeDifferingFields on GQLPet {  ... on GQLDog {    volume: barkVolume  }  ... on GQLCat {    volume: meowVolume  }}fragment safeDifferingArgs on GQLPet {  ... on GQLDog {    doesKnowCommand(dogCommand: SIT)  }  ... on GQLCat {    doesKnowCommand(catCommand: JUMP)  }}'.	self		assert: result		equals:			'{	"data" : {		"dog" : {			"volume" : 10,			"doesKnowCommand" : true		}	}}'</body><body package="GraphQLBeta-Tests-Validation" selector="testFieldsSelectionsMergin06">testFieldsSelectionsMergin06	"If multiple field selections with the same response names are encountered during execution, the field and arguments to execute and the resulting value should be unambiguous. Therefore any two field selections which might both be encountered for the same object are only valid if they are equivalent.For simple handâwritten GraphQL, this rule is obviously a clear developer error, however nested fragments can make this difficult to detect manually."	| result |	"This document is invalid"	result := self		jsonRequest:			'{ 	dog { 		...conflictingDifferingResponses	}}fragment conflictingDifferingResponses on GQLPet {  ... on GQLDog {    someValue: nickname  }  ... on GQLCat {    someValue: meowVolume  }}'.	self		assert: result		equals:			'{	"errors" : [		{			"message" : "Fields \"someValue\" conflict because \"nickname\" and \"meowVolume\" are different fields. Use different aliases on the fields to fetch both if this was intentional.",			"locations" : [				{					"line" : 9,					"column" : 16				},				{					"line" : 12,					"column" : 16				}			]		}	]}'</body><body package="GraphQLBeta-Tests-Validation" selector="testFieldsSelectionsMergin07">testFieldsSelectionsMergin07	"If multiple field selections with the same response names are encountered during execution, the field and arguments to execute and the resulting value should be unambiguous. Therefore any two field selections which might both be encountered for the same object are only valid if they are equivalent.For simple handâwritten GraphQL, this rule is obviously a clear developer error, however nested fragments can make this difficult to detect manually."	| result |	"This document is invalid"	result := self		jsonRequest:			'{	arguments { 		...multipleArgsReverseOrder		...multipleArgs	} }fragment multipleArgs on GQLArguments {  multipleReqs(x: 1, y: 2)}fragment multipleArgsReverseOrder on GQLArguments {  multipleReqs(y: 1, x: 2)}'.	self		assert: result		equals:			'{	"errors" : [		{			"message" : "Fields \"multipleReqs\" conflict because they have differing arguments. Use different aliases on the fields to fetch both if this was intentional.",			"locations" : [				{					"line" : 13,					"column" : 3				},				{					"line" : 9,					"column" : 3				}			]		}	]}'</body><body package="GraphQLBeta-Tests-Validation" selector="testFieldsSelectionsMergin08">testFieldsSelectionsMergin08	"If multiple field selections with the same response names are encountered during execution, the field and arguments to execute and the resulting value should be unambiguous. Therefore any two field selections which might both be encountered for the same object are only valid if they are equivalent.For simple handâwritten GraphQL, this rule is obviously a clear developer error, however nested fragments can make this difficult to detect manually."	| result |	"This document is invalid"	result := self		jsonRequest:			'{	__type(name: "GQLSentient"){		name	}	__type(name: "GQLPet"){		name	}}'.	self		assertJSONEquals: result		and:			'{  "errors": [    {      "message": "Fields \"__type\" conflict because they have differing arguments. Use different aliases on the fields to fetch both if this was intentional.",      "locations": [        {          "line": 3,          "column": 2        },        {          "line": 6,          "column": 2        }      ]    }  ]}'</body><body package="GraphQLBeta-Tests-Validation" selector="testFieldsSelectionsMergin09">testFieldsSelectionsMergin09	"If multiple field selections with the same response names are encountered during execution, the field and arguments to execute and the resulting value should be unambiguous. Therefore any two field selections which might both be encountered for the same object are only valid if they are equivalent.For simple handâwritten GraphQL, this rule is obviously a clear developer error, however nested fragments can make this difficult to detect manually."	| result |	"This document is invalid"	result := self		jsonRequest:			'{	__type(name: "GQLDog"){		name	}	...fragmentIntrospection}fragment fragmentIntrospection on GQLQueryRoot{	__type(name: "GQLCat"){		name	}}'.	self		assert: result		equals:			'{  "errors": [    {      "message": "Fields \"__type\" conflict because they have differing arguments. Use different aliases on the fields to fetch both if this was intentional.",      "locations": [        {          "line": 2,          "column": 2        },        {          "line": 8,          "column": 2        }      ]    }  ]}'</body><body package="GraphQLBeta-Tests-Validation" selector="testFieldsSelectionsMergin10">testFieldsSelectionsMergin10	"If multiple field selections with the same response names are encountered during execution, the field and arguments to execute and the resulting value should be unambiguous. Therefore any two field selections which might both be encountered for the same object are only valid if they are equivalent.For simple handâwritten GraphQL, this rule is obviously a clear developer error, however nested fragments can make this difficult to detect manually."	| result |	"This document is invalid"	result := self		jsonRequest:			'{  		__type(name: "Point") {    		name    		fields {      			name      			type {        			name      			}    		}  		}		__type(name: "GQLMutation"){    		name  		}	}'.	self		assert: result		equals:			'{  "errors": [    {      "message": "Fields \"__type\" conflict because they have differing arguments. Use different aliases on the fields to fetch both if this was intentional.",      "locations": [        {          "line": 2,          "column": 5        },        {          "line": 11,          "column": 3        }      ]    }  ]}'</body><body package="GraphQLBeta-Tests-Validation" selector="testFieldsSelectionsOIU01">testFieldsSelectionsOIU01	"OIU = Object, Interfaces and Union Types	* For each selection in the document.	* Let fieldName be the target field of selection	* fieldName must be defined on type in scope	"	| result |	"This document is invalid"	result := self		jsonRequest:			'{ 	dog { 		...fieldNotDefined		...aliasedLyingFieldTargetNotDefined	}}fragment fieldNotDefined on GQLDog {  meowVolume}fragment aliasedLyingFieldTargetNotDefined on GQLDog {  barkVolume: kawVolume}'.	self		assert: result		equals:			'{	"errors" : [		{			"message" : "Cannot query field \"meowVolume\" on type \"GQLDog\"",			"locations" : [				{					"line" : 9,					"column" : 3				}			]		},		{			"message" : "Cannot query field \"kawVolume\" on type \"GQLDog\"",			"locations" : [				{					"line" : 13,					"column" : 15				}			]		}	]}'</body><body package="GraphQLBeta-Tests-Validation" selector="testFieldsSelectionsOIU02">testFieldsSelectionsOIU02	"OIU = Object, Interfaces and Union Types	* For each selection in the document.	* Let fieldName be the target field of selection	* fieldName must be defined on type in scope	"	| result |	"This document is valid"	result := self		jsonRequest:			'{	dog{		name		...interfaceFieldSelection	} }fragment interfaceFieldSelection on GQLPet {  name}'.	self		assert: result		equals:			'{	"data" : {		"dog" : {			"name" : "lobo"		}	}}'</body><body package="GraphQLBeta-Tests-Validation" selector="testFieldsSelectionsOIU03">testFieldsSelectionsOIU03	"OIU = Object, Interfaces and Union Types	* For each selection in the document.	* Let fieldName be the target field of selection	* fieldName must be defined on type in scope	"	| result |	"This document is invalid"	result := self		jsonRequest:			'{	dog{		name		...definedOnImplementorsButNotInterface	} }fragment definedOnImplementorsButNotInterface on GQLPet {  nickname}'.	self		assert: result		equals:			'{	"errors" : [		{			"message" : "Cannot query field \"nickname\" on type \"GQLPet\"",			"locations" : [				{					"line" : 9,					"column" : 3				}			]		}	]}'</body><body package="GraphQLBeta-Tests-Validation" selector="testFieldsSelectionsOIU04">testFieldsSelectionsOIU04	"OIU = Object, Interfaces and Union Types	* For each selection in the document.	* Let fieldName be the target field of selection	* fieldName must be defined on type in scope	"	| result |	"This document is valid"	result := self		jsonRequest:			'{	dog{		...inDirectFieldSelectionOnUnion	} }fragment inDirectFieldSelectionOnUnion on CatOrDog {	__typename  ... on GQLPet {    name  }  ... on GQLDog {    barkVolume  }}'.	self		assert: result		equals:			'{	"data" : {		"dog" : {			"__typename" : "GQLDog",			"name": "lobo",			"barkVolume" : 10		}	}}'</body><body package="GraphQLBeta-Tests-Validation" selector="testFieldsSelectionsOIU05">testFieldsSelectionsOIU05	"OIU = Object, Interfaces and Union Types	* For each selection in the document.	* Let fieldName be the target field of selection	* fieldName must be defined on type in scope	"	| result |	"This document is invalid"	result := self		jsonRequest:			'{	dog{		...directFieldSelectionOnUnion	} }fragment directFieldSelectionOnUnion on CatOrDog {  name  barkVolume}'.	self		assert: result		equals:			'{	"errors" : [		{			"message" : "Cannot query field \"name\" on type \"CatOrDog\"",			"locations" : [				{					"line" : 8,					"column" : 3				}			]		},		{			"message" : "Cannot query field \"barkVolume\" on type \"CatOrDog\"",			"locations" : [				{					"line" : 9,					"column" : 3				}			]		}	]}'</body><body package="GraphQLBeta-Tests-Validation" selector="testLeafFieldSelections01">testLeafFieldSelections01	"	Field selections on scalars are never allowed: scalars are the leaf nodes of any GraphQL query"	| result |	"This document is valid"	result := self		jsonRequest:			'{ 	dog { 		...scalarSelection	}}fragment scalarSelection on GQLDog {  barkVolume}'.	self		assertJSONEquals: result		and:			'{	"data" : { 		"dog" : {			"barkVolume" : 10		}	}}'</body><body package="GraphQLBeta-Tests-Validation" selector="testLeafFieldSelections02">testLeafFieldSelections02	"	Field selections on scalars are never allowed: scalars are the leaf nodes of any GraphQL query"	| result |	"This document is invalid"	result := self		jsonRequest:			'{ 	dog { 		...scalarSelectionsNotAllowedOnBoolean	}}fragment scalarSelectionsNotAllowedOnBoolean on GQLDog {  barkVolume {    sinceWhen  }}'.	self		assert: result		equals:			'{	"errors" : [		{			"message" : "Field \"barkVolume\" must not have selection since type \"Int\" has no subfields.",			"locations" : [				{					"line" : 8,					"column" : 14				}			]		}	]}'</body><body package="GraphQLBeta-Tests-Validation" selector="testLeafFieldSelections03">testLeafFieldSelections03	| result |	"This is document is valid"	result := self		operation: 'directQueryOnUnionWithoutSubFields'		jsonRequest:			'query directQueryOnUnionWithoutSubFields {  	catOrDog{		__typename		... on GQLCat {			nickname		}	}}'.	self		assert: result		equals:			'{	"data" : {		"catOrDog" : {			"__typename" : "GQLCat",			"nickname" : "Gatencio"		}	}}'</body><body package="GraphQLBeta-Tests-Validation" selector="testLeafFieldSelections04">testLeafFieldSelections04	"Conversely the leaf field selections of GraphQL queries must be scalars. Leaf selections on objects, interfaces, and unions without subfields are disallowed."	| result |	"This is document is invalid"	result := self		operation: 'directQueryOnUnionWithoutSubFields'		jsonRequest:			'query directQueryOnObjectWithoutSubFields {  human}query directQueryOnInterfaceWithoutSubFields {  pet}query directQueryOnUnionWithoutSubFields {  catOrDog}'.	self		assert: result		equals:			'{	"errors" : [		{			"message" : "Field \"human\" on type \"GQLHuman\" must have selection of subfields. Did you mean \"human { ... }\"?",			"locations" : [				{					"line" : 3,					"column" : 3				}			]		},		{			"message" : "Field \"pet\" on type \"GQLPet\" must have selection of subfields. Did you mean \"pet { ... }\"?",			"locations" : [				{					"line" : 7,					"column" : 3				}			]		},		{			"message" : "Field \"catOrDog\" on type \"CatOrDog\" must have selection of subfields. Did you mean \"catOrDog { ... }\"?",			"locations" : [				{					"line" : 11,					"column" : 3				}			]		}	]}'</body></methods><methods><class-id>GraphQLBeta.GQLTestFilm</class-id> <category>accessing</category><body package="GraphQLBeta-Test-Utils" selector="description">description	^ description</body><body package="GraphQLBeta-Test-Utils" selector="description:">description: anObject	description := anObject</body><body package="GraphQLBeta-Test-Utils" selector="film">film	^ film</body><body package="GraphQLBeta-Test-Utils" selector="filmName">filmName	^ filmName</body><body package="GraphQLBeta-Test-Utils" selector="filmName:">filmName: anObject	filmName := anObject</body><body package="GraphQLBeta-Test-Utils" selector="gender">gender	^ gender</body><body package="GraphQLBeta-Test-Utils" selector="gender:">gender: anObject	gender := anObject</body><body package="GraphQLBeta-Test-Utils" selector="id">id	^ id</body><body package="GraphQLBeta-Test-Utils" selector="id:">id: anObject	id := anObject</body><body package="GraphQLBeta-Test-Utils" selector="name">name	^ filmName</body><body package="GraphQLBeta-Test-Utils" selector="name:">name: aName	self filmName: aName</body><body package="GraphQLBeta-Test-Utils" selector="rating">rating	^ rating</body><body package="GraphQLBeta-Test-Utils" selector="rating:">rating: aRating	rating := aRating</body><body package="GraphQLBeta-Test-Utils" selector="toDictionary">toDictionary	^ Dictionary new		at: #id put: id;		at: #name put: filmName;		at: #rating put: rating</body></methods><methods><class-id>GraphQLBeta.GQLTestFilm</class-id> <category>initialization</category><body package="GraphQLBeta-Test-Utils" selector="initialize:name:rating:gender:">initialize: anId name: aString rating: aNumber gender: aGender	id := anId.	filmName := aString.	rating := aNumber.	description := aString.	gender := aGender.	film := GQLFilm new initialize: aString id: anId</body></methods><methods><class-id>GraphQLBeta.GQLTestFilm class</class-id> <category>instance creation</category><body package="GraphQLBeta-Test-Utils" selector="new:name:rating:gender:">new: id name: filmName rating: rating gender: gender	| inst |	inst := self new.	inst		initialize: id		name: filmName		rating: rating		gender: gender.	^ inst</body></methods><methods><class-id>GraphQLBeta.GraphQL</class-id> <category>initialization</category><body package="GraphQLBeta-Core" selector="createSchema:">createSchema: aTextSchema	"Given a text schema, parses this text if everything is ok then evaluate this nodes and the schema is validated"	schema := GQLSchemaGrammarEvaluator parse: aTextSchema.	(schema isKindOf: PPFailure)		ifTrue: [ ^ GQLEvaluationException new				messageText: 'Fail parsing on schema';				raise ]		ifFalse: [ schema := schema validate.			(schema isKindOf: GQLValidationException)				ifTrue: [ ^ schema ] ]</body><body package="GraphQLBeta-Core" selector="initialize">initialize	"Initialize the validator and the entry point with the default schema"	rootInstance := Dictionary new.	rootInstance		at: 'query' put: GQLQuery new;		at: 'mutation' put: GQLMutation new.	self createSchema: GQLQuery schema.	shouldValidate := true</body><body package="GraphQLBeta-Core" selector="rootInstance:">rootInstance: aRoot	"Set the root instance of graphql server"	rootInstance := aRoot</body></methods><methods><class-id>GraphQLBeta.GraphQL</class-id> <category>accessing</category><body package="GraphQLBeta-Core" selector="evaluateVariables:">evaluateVariables: aObject	| variables |	variables := nil.	(aObject isString and: [ aObject isNotEmpty ])		ifTrue: [ ^ GQLVariableGrammarEvaluator parse: aObject ].	(aObject isKindOf: Dictionary)		ifTrue: [ ^ self				evaluateVariables: (GraphQL blockJsonBuilder value: aObject) string ].	^ variables</body><body package="GraphQLBeta-Core" selector="handleRequest:">handleRequest: aTextRequest	| document vars |	schema		root:			(rootInstance class = Dictionary				ifTrue: [ rootInstance at: 'query' ]				ifFalse: [ rootInstance ]).	"This hack for tests, need to review this"	document := GQLSingleAnonimousQueryEvaluator parse: aTextRequest.	(document isKindOf: PPFailure)		ifTrue: [ ^ document asJsonDictionary ].	vars := self evaluateVariables: variables.	^ GQLValidator new		variables: vars;		operationName: operation;		rootInstance: rootInstance;		document: document;		text: aTextRequest;		schema: schema;		shouldValidate: shouldValidate;		execute</body><body package="GraphQLBeta-Core" selector="jsonRequest:">jsonRequest: aTextRequest	^ GraphQLPlatform current toJson: (self handleRequest: aTextRequest)</body><body package="GraphQLBeta-Core" selector="operation:">operation: string	operation := string</body><body package="GraphQLBeta-Core" selector="schema">schema	"Return the schema"	^ schema</body><body package="GraphQLBeta-Core" selector="schema:">schema: aGQLSchema	"Set the schema"	schema := aGQLSchema</body><body package="GraphQLBeta-Core" selector="shouldValidate:">shouldValidate: bool	shouldValidate := bool</body><body package="GraphQLBeta-Core" selector="variables:">variables: string	variables := string</body></methods><methods><class-id>GraphQLBeta.GraphQL class</class-id> <category>accessing</category><body package="GraphQLBeta-Core" selector="blockJsonBuilder">blockJsonBuilder	^ [ :object | 	ZnEntity		with:			((String				streamContents: [ :stream | 					(NeoJSONWriter on: stream)						mapInstVarsFor: GQLPosition;						mapInstVarsFor: GQLError;						nextPut: object.					stream cr ]) replaceAll: Character cr with: Character lf)		type: ZnMimeType applicationJson ]</body><body package="GraphQLBeta-Core" selector="mapper">mapper	^ (Array new: 4)		at: 1			put:			[ :request | request uri isSlash and: [ request method = #GET ] ]				-&gt; [ :request :demo | demo answerTo: request ];		at: 2			put:			[ :request | 			(request uri isSlash and: [ request method = #POST ])				and: [ request contentType sub = ZnMimeType applicationJson sub ] ]				-&gt; [ :request :demo | 					| response |					response := demo answerForTools: request.					ZnResponse ok: (GraphQL blockJsonBuilder value: response) ];		at: 3			put:			[ :request | 			(request uri pathSegments size = 1 and: [ request method = #PUT ])				and: [ request contentType = ZnMimeType applicationJson ] ]				-&gt;					[ :request | ZnResponse ok: (GraphQL blockJsonBuilder value: Dictionary new) ];		at: 4			put:			[ :request | request uri pathSegments size = 1 and: [ request method = #DELETE ] ]				-&gt;					[ :request | ZnResponse ok: (GraphQL blockJsonBuilder value: Dictionary new) ];		yourself	"----------------------------------------------------------------"	"----------------------------------------------------------------"	"----------------------------------------------------------------"</body></methods><methods><class-id>GraphQLBeta.GQLAbstractNode</class-id> <category>initialization</category><body package="GraphQLBeta-Nodes" selector="initialize">initialize	position := 0</body></methods><methods><class-id>GraphQLBeta.GQLAbstractNode</class-id> <category>accessing</category><body package="GraphQLBeta-Nodes" selector="position">position	^ position</body><body package="GraphQLBeta-Nodes" selector="position:">position: anObject	position := anObject</body></methods><methods><class-id>GraphQLBeta.GQLComment</class-id> <category>accessing</category><body package="GraphQLBeta-Nodes" selector="value">value	^ value</body><body package="GraphQLBeta-Nodes" selector="value:">value: anObject	value := anObject</body></methods><methods><class-id>GraphQLBeta.GQLPosition</class-id> <category>accessing</category><body package="GraphQLBeta-Validation" selector="column">column	^ column</body><body package="GraphQLBeta-Validation" selector="column:">column: anInteger	column := anInteger</body><body package="GraphQLBeta-Validation" selector="line">line	^ line</body><body package="GraphQLBeta-Validation" selector="line:">line: anInteger	line := anInteger</body></methods><methods><class-id>GraphQLBeta.GQLPosition</class-id> <category>comparing</category><body package="GraphQLBeta-Validation" selector="=">= other	^ self class = other class		and: [ line = other line and: [ column = other column ] ]</body><body package="GraphQLBeta-Validation" selector="hash">hash	^ line * 10 + column</body></methods><methods><class-id>GraphQLBeta.GQLHuman</class-id> <category>accessing</category><body package="GraphQLBeta-Test-Utils" selector="name">name	^ name</body><body package="GraphQLBeta-Test-Utils" selector="name:">name: string	name := string</body></methods><methods><class-id>GraphQLBeta.GQLDog</class-id> <category>accessing</category><body package="GraphQLBeta-Test-Utils" selector="barkVolume">barkVolume	^ barkVolume</body><body package="GraphQLBeta-Test-Utils" selector="barkVolume:">barkVolume: integer	barkVolume := integer</body><body package="GraphQLBeta-Test-Utils" selector="complex">complex	^ nil</body><body package="GraphQLBeta-Test-Utils" selector="name">name	^ name</body><body package="GraphQLBeta-Test-Utils" selector="name:">name: string	name := string</body><body package="GraphQLBeta-Test-Utils" selector="nickname">nickname	^ nickname</body><body package="GraphQLBeta-Test-Utils" selector="nickname:">nickname: string	nickname := string</body><body package="GraphQLBeta-Test-Utils" selector="owner">owner	^ owner</body><body package="GraphQLBeta-Test-Utils" selector="owner:">owner: human	owner := human</body></methods><methods><class-id>GraphQLBeta.GQLDog</class-id> <category>accessing-computed</category><body package="GraphQLBeta-Test-Utils" selector="doesKnowCommandDogCommand:">doesKnowCommandDogCommand: command	^ #('SIT') includes: command</body><body package="GraphQLBeta-Test-Utils" selector="isHousetrainedAtOtherHomes:">isHousetrainedAtOtherHomes: bool	^ false</body></methods><methods><class-id>GraphQLBeta.GQLNodeVisitor</class-id> <category>visiting</category><body package="GraphQLBeta-Visitors" selector="visitArgumentNode:">visitArgumentNode: node	</body><body package="GraphQLBeta-Visitors" selector="visitDirectiveNode:">visitDirectiveNode: node	</body><body package="GraphQLBeta-Visitors" selector="visitDocumentNode:">visitDocumentNode: node	</body><body package="GraphQLBeta-Visitors" selector="visitFragmentNode:">visitFragmentNode: node	</body><body package="GraphQLBeta-Visitors" selector="visitFragmentSpreadNode:">visitFragmentSpreadNode: node	</body><body package="GraphQLBeta-Visitors" selector="visitInlineFragmentNode:">visitInlineFragmentNode: node	</body><body package="GraphQLBeta-Visitors" selector="visitNonScalarFieldNode:">visitNonScalarFieldNode: node	</body><body package="GraphQLBeta-Visitors" selector="visitOperationNode:">visitOperationNode: node	</body><body package="GraphQLBeta-Visitors" selector="visitScalarFieldNode:">visitScalarFieldNode: node	</body><body package="GraphQLBeta-Visitors" selector="visitSchemaFieldNode:">visitSchemaFieldNode: node	</body><body package="GraphQLBeta-Visitors" selector="visitSelectionSetNode:">visitSelectionSetNode: node	</body><body package="GraphQLBeta-Visitors" selector="visitTypeFieldNode:">visitTypeFieldNode: node	</body><body package="GraphQLBeta-Visitors" selector="visitTypenameFieldNode:">visitTypenameFieldNode: node	</body></methods><methods><class-id>GraphQLBeta.GQLNodeVisitor</class-id> <category>error</category><body package="GraphQLBeta-Visitors" selector="addError:">addError: newError	errors add: newError</body><body package="GraphQLBeta-Visitors" selector="addErrorMessage:node:">addErrorMessage: string node: node	self		addError:			(GQLError new				message: string;				locationFor: node on: text)</body><body package="GraphQLBeta-Visitors" selector="addErrorMessage:nodes:">addErrorMessage: string nodes: nodes	self		addError:			(GQLError new				message: string;				locationFor: nodes on: text)</body></methods><methods><class-id>GraphQLBeta.GQLNodeVisitor</class-id> <category>accessing</category><body package="GraphQLBeta-Visitors" selector="context:">context: anObject	context := anObject</body><body package="GraphQLBeta-Visitors" selector="document">document	^ document</body><body package="GraphQLBeta-Visitors" selector="errors">errors	^ errors ifNil: [ #() ]</body><body package="GraphQLBeta-Visitors" selector="errors:">errors: aCollection	errors := aCollection</body><body package="GraphQLBeta-Visitors" selector="schema">schema	^ schema</body><body package="GraphQLBeta-Visitors" selector="schema:">schema: aSchema	schema := aSchema</body><body package="GraphQLBeta-Visitors" selector="text">text	^ text</body><body package="GraphQLBeta-Visitors" selector="text:">text: string	"the original string"	text := string</body></methods><methods><class-id>GraphQLBeta.GQLNodeVisitor</class-id> <category>accessing - computed</category><body package="GraphQLBeta-Visitors" selector="getFragmentTypeOf:">getFragmentTypeOf: ref	| type |	ref isNullType		ifTrue: [ ^ ref ].	type := schema getType: ref name.	type		ifNil: [ type := GQLSNullTypeNode instance ]		ifNotNil: [ type isObjectType | type isUnionType | type isInterfaceType				ifFalse: [ type := GQLSNullTypeNode instance ] ].	^ type</body></methods><methods><class-id>GraphQLBeta.GQLNodeVisitor</class-id> <category>utilities</category><body package="GraphQLBeta-Visitors" selector="stackedOn:do:">stackedOn: node do: block	document := node.	schemaContextStack := Stack new.	schemaContextStack push: schema query.	block value.	schemaContextStack pop</body><body package="GraphQLBeta-Visitors" selector="stackedType:do:">stackedType: node do: block	| type isNil |	type := schema perform: (node type , #Type) asSymbol.	isNil := false.	type		ifNil: [ type := GQLSNullTypeNode instance.			isNil := true ].	schemaContextStack push: type.	block value.	schemaContextStack pop.	^ isNil</body></methods><methods><class-id>GraphQLBeta.GQLVariablesVisitor</class-id> <category>validation</category><body package="GraphQLBeta-Visitors" selector="currentOperationVariable:">currentOperationVariable: arg	currentOperation class = GQLOperationNode		ifFalse: [ ^ nil ].	currentOperation variableDefinitions ifNil: [ ^ nil ].	^ currentOperation variableDefinitions		detect: [ :var | var name = arg value value ]		ifFound: [ :var | var ]		ifNone: [ nil ]</body><body package="GraphQLBeta-Visitors" selector="validateFieldNode:">validateFieldNode: node	| var |	node arguments		do: [ :arg | 			arg value isVariableNode				ifTrue: [ usedVariables add: arg value value.					var := self currentOperationVariable: arg.					var isNil						ifTrue: [ | s |							s := String new writeStream.							s								nextPutAll: 'Variable "';								nextPutAll: arg name.							currentOperation class = GQLOperationNode								ifTrue: [ s										nextPutAll: '" is not defined by operation "';										nextPutAll: currentOperation name;										nextPutAll: '".' ]								ifFalse: [ s nextPutAll: '" is not defined.' ].							self								addErrorMessage: s contents								nodes: (Array with: arg value with: currentOperation) ]						ifFalse: [ currentField ifNil: [ ^ self ].							currentField arguments								detect: [ :sarg | sarg name = arg name ]								ifFound: [ :sarg | 									sarg type printString = var type printString										ifFalse: [ | s |											s := String new writeStream.											s												nextPutAll: 'Variable "';												nextPutAll: var name;												nextPutAll: '" of type "'.											var type printOn: s.											s nextPutAll: '" used in position expecting type "'.											sarg type printOn: s.											s nextPutAll: '".'.											self												addErrorMessage: s contents												node: (Array with: var with: arg value) ] ] ] ] ]</body><body package="GraphQLBeta-Visitors" selector="validateVariableDefaultValue:">validateVariableDefaultValue: var	| s |	var defaultValue ifNil: [ ^ self ].	(var type canCoerce: var defaultValue on: schema)		ifTrue: [ ^ self ].	(var type isObjectInputType: schema)		ifTrue: [ ^ self ].	s := String new writeStream.	s nextPutAll: 'Expected type '.	var type printOn: s.	s nextPutAll: ', found '.	var defaultValue printOn: s.	s nextPutAll: '.'.	self addErrorMessage: s contents node: var defaultValue</body><body package="GraphQLBeta-Visitors" selector="validateVariableType:">validateVariableType: var	| type s |	type := var type rawType: schema.	type		ifNil: [ ^ self				addErrorMessage: 'Unknown type "' , var type name , '".'				node: var ].	type isInputType		ifTrue: [ ^ self ].	s := String new writeStream.	s		nextPutAll: 'Variable "$';		nextPutAll: var name;		nextPutAll: '" cannot be non-input type "'.	var type printOn: s.	s nextPutAll: '".'.	self addErrorMessage: s contents node: var</body></methods><methods><class-id>GraphQLBeta.GQLVariablesVisitor</class-id> <category>visiting</category><body package="GraphQLBeta-Visitors" selector="validateVariableContextValue:">validateVariableContextValue: var	context variables		detect: [ :variable | variable name = var name ]		ifFound: [ :variable | 			| s |			(var type canCoerce: variable value on: schema)				ifTrue: [ ^ self ].			s := String new writeStream.			s				nextPutAll: 'Variable "$';				nextPutAll: var name;				nextPutAll: '" got invalid value '.			variable value printOn: s.			s nextPutAll: '. Expected type "'.			var type printOn: s.			s nextPutAll: '".'.			self addErrorMessage: s contents node: var ]		ifNone: [ var type class = GQLSNonNullTypeNode				ifTrue: [ | s |					s := String new writeStream.					s						nextPutAll: 'Variable "$';						nextPutAll: var name;						nextPutAll: '" of required type "'.					var type printOn: s.					s nextPutAll: '" was not provided.'.					self addErrorMessage: s contents node: var ] ]</body><body package="GraphQLBeta-Visitors" selector="visitDirectiveNode:">visitDirectiveNode: node	self validateFieldNode: node</body><body package="GraphQLBeta-Visitors" selector="visitDocumentNode:">visitDocumentNode: node	self		stackedOn: node		do: [ node operations				do: [ :op | 					currentOperation := op.					usedVariables := OrderedCollection new.					op accept: self ] ]</body><body package="GraphQLBeta-Visitors" selector="visitFragmentSpreadNode:">visitFragmentSpreadNode: node	| fragment |	node directives do: [ :dir | dir accept: self ].	fragment := document getFragment: node name.	fragment ifNil: [ ^ self ].	(fragment hasCycle: document)		ifTrue: [ ^ self ].	fragment selectionSet accept: self</body><body package="GraphQLBeta-Visitors" selector="visitInlineFragmentNode:">visitInlineFragmentNode: node	node directives do: [ :dir | dir accept: self ]</body><body package="GraphQLBeta-Visitors" selector="visitNonScalarFieldNode:">visitNonScalarFieldNode: node	| current type field |	current := schemaContextStack top.	field := current getField: node name.	type := field isNil		ifTrue: [ GQLSNullTypeNode instance ]		ifFalse: [ field type rawType: schema ].	schemaContextStack push: type.	node selectionSet accept: self.	schemaContextStack pop.	node directives do: [ :dir | dir accept: self ].	currentField := field.	self validateFieldNode: node</body><body package="GraphQLBeta-Visitors" selector="visitOperationNode:">visitOperationNode: node	| ocurrences |	self		stackedType: node		do: [ node selectionSet accept: self.			ocurrences := node variableDefinitions groupedBy: #name.			ocurrences				keysAndValuesDo: [ :k :list | 					list size &gt; 1						ifTrue: [ self								addErrorMessage: 'There can be only one variable named "' , k , '".'								nodes: list ] ].			node variableDefinitions				do: [ :var | 					self validateVariableType: var.					self validateVariableDefaultValue: var.					self validateVariableContextValue: var.					(usedVariables anySatisfy: [ :usedVar | usedVar = var name ])						ifFalse: [ self								addErrorMessage:									'Variable "$' , var name , '" is never used in operation "'										, node name , '".'								node: var ] ] ]</body><body package="GraphQLBeta-Visitors" selector="visitScalarFieldNode:">visitScalarFieldNode: node	| current |	current := schemaContextStack top.	node directives do: [ :dir | dir accept: self ].	currentField := current getField: node name.	self validateFieldNode: node</body><body package="GraphQLBeta-Visitors" selector="visitSelectionSetNode:">visitSelectionSetNode: node	node selections do: [ :fieldNode | fieldNode accept: self ]</body></methods><methods><class-id>GraphQLBeta.GQLFilm</class-id> <category>as yet unclassified</category><body package="GraphQLBeta-Test-Utils" selector="getFilmName:">getFilmName: aFilmName	^ aFilmName</body><body package="GraphQLBeta-Test-Utils" selector="id">id	^ id</body></methods><methods><class-id>GraphQLBeta.GQLFilm</class-id> <category>accessing</category><body package="GraphQLBeta-Test-Utils" selector="filmName">filmName	^ filmName</body><body package="GraphQLBeta-Test-Utils" selector="filmName:">filmName: aFilmName	filmName := aFilmName</body><body package="GraphQLBeta-Test-Utils" selector="id:">id: anObject	id := anObject</body><body package="GraphQLBeta-Test-Utils" selector="initialize:">initialize: aName	filmName := aName</body><body package="GraphQLBeta-Test-Utils" selector="initialize:id:">initialize: aName id: aId	filmName := aName.	id := aId</body></methods><methods><class-id>GraphQLBeta.GQLArgumentsVisitor</class-id> <category>validation</category><body package="GraphQLBeta-Visitors" selector="validateArguments:">validateArguments: node	self validateOcurrences: node.	self validateNotNullFor: node</body><body package="GraphQLBeta-Visitors" selector="validateNotNullFor:">validateNotNullFor: node	| field |	currentField ifNil: [ ^ self ].	currentField isNullType		ifTrue: [ ^ self ].	field := currentField.	field arguments		do: [ :argS | 			node arguments				detect: [ :arg | argS name = arg name ]				ifFound: [ :arg | "is ok" ]				ifNone: [ | type |					type := argS type.					type class = GQLSNonNullTypeNode						ifTrue: [ | s |							s := String new writeStream.							field class = GQLSFieldNode								ifTrue: [ s nextPutAll: 'Field "' ]								ifFalse: [ s nextPutAll: 'Directive "@' ].							s								nextPutAll: field name;								nextPutAll: '" argument "';								nextPutAll: argS name;								nextPutAll: '" of type "'.							argS type printOn: s.							s nextPutAll: '" is required but not provided.'.							self addErrorMessage: s contents node: node ] ] ]</body><body package="GraphQLBeta-Visitors" selector="validateOcurrences:">validateOcurrences: node	| ocurrences |	ocurrences := node arguments groupedBy: [ :arg | arg name ].	ocurrences		keysAndValuesDo: [ :k :nodes | 			nodes size &gt; 1				ifTrue: [ | s |					s := String new writeStream.					s						nextPutAll: 'There can be only one argument named "';						nextPutAll: k;						nextPutAll: '".'.					self addErrorMessage: s contents nodes: nodes ] ]</body></methods><methods><class-id>GraphQLBeta.GQLArgumentsVisitor</class-id> <category>visiting</category><body package="GraphQLBeta-Visitors" selector="validateCoerceArgument:in:">validateCoerceArgument: argument in: argSchema	| type s realValue |	argument value isVariableNode		ifTrue: [ ^ self ].	type := argSchema type.	realValue := self realValueFor: argument value.	(type canCoerce: realValue on: schema)		ifTrue: [ ^ self ].	s := String new writeStream.	s		nextPutAll: 'Argument "';		nextPutAll: argument name;		nextPutAll: '" has invalid value '.	argument printValueOn: s.	s nextPutAll: '. Expected type "'.	type printOn: s.	s nextPutAll: '".'.	self addErrorMessage: s contents node: realValue</body><body package="GraphQLBeta-Visitors" selector="visitArgumentNode:">visitArgumentNode: node	currentField ifNil: [ ^ self ].	currentField isNullType		ifTrue: [ ^ self ].	currentField arguments		detect: [ :argS | argS name = node name ]		ifFound: [ :argS | self validateCoerceArgument: node in: argS ]		ifNone: [ self addErrorUnknownArgFor: node ]</body><body package="GraphQLBeta-Visitors" selector="visitDirectiveNode:">visitDirectiveNode: node	currentField := schema getDirective: node name.	self validateArguments: node.	node arguments do: [ :arg | arg accept: self ]</body><body package="GraphQLBeta-Visitors" selector="visitDocumentNode:">visitDocumentNode: node	self		stackedOn: node		do: [ node operations do: [ :op | op accept: self ].			node fragments do: [ :f | f accept: self ] ]</body><body package="GraphQLBeta-Visitors" selector="visitFragmentNode:">visitFragmentNode: node	| type |	type := self getFragmentTypeOf: node typeCondition.	schemaContextStack push: type.	node selectionSet accept: self.	schemaContextStack pop</body><body package="GraphQLBeta-Visitors" selector="visitInlineFragmentNode:">visitInlineFragmentNode: node	node directives do: [ :d | d accept: self ]</body><body package="GraphQLBeta-Visitors" selector="visitNonScalarFieldNode:">visitNonScalarFieldNode: node	| current field type |	current := schemaContextStack top.	field := current getField: node name.	type := field isNil		ifTrue: [ GQLSNullTypeNode instance ]		ifFalse: [ field type rawType: schema ].	schemaContextStack push: type.	currentField := field.	self validateArguments: node.	node arguments do: [ :arg | arg accept: self ].	node directives do: [ :d | d accept: self ].	node selectionSet accept: self.	schemaContextStack pop</body><body package="GraphQLBeta-Visitors" selector="visitOperationNode:">visitOperationNode: node	self		stackedType: node		do: [ node selectionSet accept: self.			node directives do: [ :d | d accept: self ] ]</body><body package="GraphQLBeta-Visitors" selector="visitScalarFieldNode:">visitScalarFieldNode: node	| current |	current := schemaContextStack top.	currentField := current getField: node name.	self validateArguments: node.	node arguments do: [ :arg | arg accept: self ].	node directives do: [ :d | d accept: self ]</body><body package="GraphQLBeta-Visitors" selector="visitSelectionSetNode:">visitSelectionSetNode: node	node selections do: [ :f | f accept: self ]</body></methods><methods><class-id>GraphQLBeta.GQLArgumentsVisitor</class-id> <category>errors</category><body package="GraphQLBeta-Visitors" selector="addErrorUnknownArgFor:">addErrorUnknownArgFor: arg	| s current field |	current := current := schemaContextStack top.	field := currentField.	s := String new writeStream.	s		nextPutAll: 'Unknown argument "';		nextPutAll: arg name.	field class = GQLSFieldNode		ifTrue: [ s				nextPutAll: '" on field "';				nextPutAll: field name;				nextPutAll: '" on type "';				nextPutAll: current name ]		ifFalse: [ s				nextPutAll: '" on directive "@';				nextPutAll: field name ].	s nextPutAll: '".'.	self addErrorMessage: s contents node: arg</body></methods><methods><class-id>GraphQLBeta.GQLArgumentsVisitor</class-id> <category>accesing</category><body package="GraphQLBeta-Visitors" selector="realValueFor:">realValueFor: value	value isVariableNode		ifFalse: [ ^ value ].	^ context variables		at: value value		ifPresent: [ :var | var value ]		ifAbsent: [ value ]</body></methods><methods><class-id>GraphQLBeta.GQLContext</class-id> <category>initialization</category><body package="GraphQLBeta-Core" selector="initialize">initialize	fragments := Dictionary new.	variables := Dictionary new</body></methods><methods><class-id>GraphQLBeta.GQLContext</class-id> <category>accessing</category><body package="GraphQLBeta-Core" selector="addFragments:">addFragments: aCollection	"Given a collection, recollect on a dictionary each fragment name and the fragment"	fragments := Dictionary new.	aCollection do: [ :fr | fragments at: fr name put: fr ]</body><body package="GraphQLBeta-Core" selector="fragments">fragments	^ fragments</body><body package="GraphQLBeta-Core" selector="fragments:">fragments: anObject	fragments := anObject</body><body package="GraphQLBeta-Core" selector="operationName">operationName	^ operationName</body><body package="GraphQLBeta-Core" selector="operationName:">operationName: string	operationName := string</body><body package="GraphQLBeta-Core" selector="variables">variables	^ variables</body><body package="GraphQLBeta-Core" selector="variables:">variables: aCollection	aCollection isNotNil		ifTrue: [ | nameVar |			aCollection				do: [ :var | 					nameVar := var name value.					variables						at: nameVar						ifPresent: [ :v | 							var type isNotNil								ifTrue: [ (variables at: nameVar) type: var type ].							var defaultValue isNotNil								ifTrue: [ (variables at: nameVar) defaultValue: var defaultValue ].							var value isNotNil								ifTrue: [ (variables at: nameVar) value: var value ] ]						ifAbsent: [ variables at: nameVar put: var ] ] ]</body></methods><methods><class-id>GraphQLBeta.GQLContext</class-id> <category>testing</category><body package="GraphQLBeta-Core" selector="isValid">isValid	"Verify if all the variables are defined in operation"	variables values		detect: [ :var | var type isNil ]		ifFound: [ :var | 			^ GQLException new				node: self;				messageText: 'All variables must be defined on operation';				raise ]</body></methods><methods><class-id>GraphQLBeta.GQLContext</class-id> <category>action</category><body package="GraphQLBeta-Core" selector="reset">reset	fragments removeAll.	variables removeAll.	operationName := nil</body></methods><methods><class-id>GraphQLBeta.GQLValuesVisitor</class-id> <category>validation</category><body package="GraphQLBeta-Visitors" selector="getType:">getType: arg	currentField ifNil: [ ^ nil ].	currentField isNullType		ifTrue: [ ^ nil ].	^ currentField arguments		detect: [ :sarg | sarg name = arg name ]		ifFound: [ :sarg | sarg ]		ifNone: [ nil ]</body><body package="GraphQLBeta-Visitors" selector="validateArgument:">validateArgument: arg	| type value |	value := arg value.	type := self getType: arg.	type ifNil: [ ^ self ].	type := schema getType: (self getTypeNameOf: type).	self validateValue: value type: type</body><body package="GraphQLBeta-Visitors" selector="validateFieldNode:">validateFieldNode: node	node arguments do: [ :arg | self validateArgument: arg ]</body><body package="GraphQLBeta-Visitors" selector="validateObjectInputField:on:type:">validateObjectInputField: field on: sfield type: type	| s |	sfield		ifNil: [ s := String new writeStream.			s				nextPutAll: 'Field "';				nextPutAll: field name;				nextPutAll: '" is not defined by type ';				nextPutAll: type name.			self addErrorMessage: s contents node: field.			^ self ].	(sfield type canCoerce: field value on: schema)		ifTrue: [ ^ self ].	s := String new writeStream.	s nextPutAll: 'Expected type '.	sfield type printOn: s.	s nextPutAll: ', found '.	field value printOn: s.	s nextPutAll: '.'.	self addErrorMessage: s contents node: field</body><body package="GraphQLBeta-Visitors" selector="validateValue:type:">validateValue: value type: type	| ocurrences |	value class = GQLObjectNode		ifFalse: [ ^ self ].	ocurrences := OrderedDictionary new.	value objectFields		do: [ :field | 			| sfield |			(ocurrences at: field name ifAbsentPut: [ OrderedCollection new ])				add: field.			sfield := type getField: field name.			self validateObjectInputField: field on: sfield type: type ].	ocurrences		keysAndValuesDo: [ :k :nodes | 			nodes size &gt; 1				ifTrue: [ self						addErrorMessage: 'There can be only one input field named "' , k , '".'						nodes: nodes ] ]</body><body package="GraphQLBeta-Visitors" selector="validateVariableDefaultValue:">validateVariableDefaultValue: var	| type |	var defaultValue ifNil: [ ^ self ].	type := schema getType: var type name.	self validateValue: var defaultValue type: type</body></methods><methods><class-id>GraphQLBeta.GQLValuesVisitor</class-id> <category>visiting</category><body package="GraphQLBeta-Visitors" selector="visitDocumentNode:">visitDocumentNode: node	self		stackedOn: node		do: [ node operations do: [ :op | op accept: self ].			node fragments do: [ :frag | frag accept: self ] ]</body><body package="GraphQLBeta-Visitors" selector="visitFragmentNode:">visitFragmentNode: node	| type |	type := self getFragmentTypeOf: node typeCondition.	schemaContextStack push: type.	node selectionSet accept: self.	schemaContextStack pop</body><body package="GraphQLBeta-Visitors" selector="visitInlineFragmentNode:">visitInlineFragmentNode: node	node directives do: [ :dir | dir accept: self ]</body><body package="GraphQLBeta-Visitors" selector="visitNonScalarFieldNode:">visitNonScalarFieldNode: node	| current type field |	current := schemaContextStack top.	field := current getField: node name.	type := field isNil		ifTrue: [ GQLSNullTypeNode instance ]		ifFalse: [ field type rawType: schema ].	schemaContextStack push: type.	node selectionSet accept: self.	schemaContextStack pop.	node directives do: [ :dir | dir accept: self ].	currentField := field.	self validateFieldNode: node</body><body package="GraphQLBeta-Visitors" selector="visitOperationNode:">visitOperationNode: node	self		stackedType: node		do: [ node selectionSet accept: self.			node variableDefinitions				do: [ :var | self validateVariableDefaultValue: var ] ]</body><body package="GraphQLBeta-Visitors" selector="visitScalarFieldNode:">visitScalarFieldNode: node	| current |	current := schemaContextStack top.	node directives do: [ :dir | dir accept: self ].	currentField := (current isUnionType or: [ current isScalarType ])		ifTrue: [ nil ]		ifFalse: [ current getField: node name ].	self validateFieldNode: node</body><body package="GraphQLBeta-Visitors" selector="visitSelectionSetNode:">visitSelectionSetNode: node	node selections do: [ :fieldNode | fieldNode accept: self ]</body></methods><methods><class-id>GraphQLBeta.GQLValuesVisitor</class-id> <category>as yet unclassified</category><body package="GraphQLBeta-Visitors" selector="getTypeNameOf:">getTypeNameOf: aType	^ [ aType type isWrappedType		ifTrue: [ self getTypeNameOf: aType type wrappedType ]		ifFalse: [ aType type name ] ]		on: MessageNotUnderstood		do: [ :ex | aType name ]</body></methods><methods><class-id>GraphQLBeta.GQLAlien</class-id> <category>accessing</category><body package="GraphQLBeta-Test-Utils" selector="homePlanet">homePlanet	^ homePlanet</body><body package="GraphQLBeta-Test-Utils" selector="name">name	^ name</body></methods><methods><class-id>GraphQLBeta.GQLCat</class-id> <category>accessing</category><body package="GraphQLBeta-Test-Utils" selector="doesKnowCommandCatCommand:">doesKnowCommandCatCommand: command	^ false</body><body package="GraphQLBeta-Test-Utils" selector="meowVolume">meowVolume	^ meowVolume</body><body package="GraphQLBeta-Test-Utils" selector="meowVolume:">meowVolume: integer	meowVolume := integer</body><body package="GraphQLBeta-Test-Utils" selector="name">name	^ name</body><body package="GraphQLBeta-Test-Utils" selector="name:">name: string	name := string</body><body package="GraphQLBeta-Test-Utils" selector="nickname">nickname	^ nickname</body><body package="GraphQLBeta-Test-Utils" selector="nickname:">nickname: string	nickname := string</body></methods><methods><class-id>GraphQLBeta.GQLError</class-id> <category>accessing</category><body package="GraphQLBeta-Validation" selector="addLocations:">addLocations: list	locations addAll: list</body><body package="GraphQLBeta-Validation" selector="locationFor:on:">locationFor: arr on: string	| line column list positions |	list := arr isCollection		ifTrue: [ arr ]		ifFalse: [ Array with: arr ].	positions := OrderedCollection new: list size.	list		do: [ :node | 			line := 1.			column := 1.			1 to: node position - 1 do: [ :index | 				| char |				char := string at: index.				(char = Character cr or: [ char = Character lf ])					ifTrue: [ line := line + 1.						column := 0 ].				column := column + 1 ].			positions				add:					(GQLPosition new						line: line;						column: column) ].	self locations: positions</body><body package="GraphQLBeta-Validation" selector="locations">locations	^ locations</body><body package="GraphQLBeta-Validation" selector="locations:">locations: list	locations := list</body><body package="GraphQLBeta-Validation" selector="message">message	^ message</body><body package="GraphQLBeta-Validation" selector="message:">message: string	message := string</body></methods><methods><class-id>GraphQLBeta.GraphQLBenchmark</class-id> <category>accessing</category><body package="GraphQLBeta-Test-Benchmark" selector="queryPoints">queryPoints	^ self class objects</body><body package="GraphQLBeta-Test-Benchmark" selector="queryRectangles">queryRectangles	^ self class objects</body></methods><methods><class-id>GraphQLBeta.GraphQLBenchmark class</class-id> <category>accessing</category><body package="GraphQLBeta-Test-Benchmark" selector="lastSize">lastSize	^ lastSize ifNil: [ 0 ]</body><body package="GraphQLBeta-Test-Benchmark" selector="objects">objects	^ objects</body><body package="GraphQLBeta-Test-Benchmark" selector="schema">schema	"The text of the schema"	^ '	type GraphQLBenchmark{		queryPoints: [ Point ]		queryRectangles: [ Rectangle ]	},	type Rectangle{		origin: Point		corner: Point	},	type Point{		x : Float		y : Float	}'</body></methods><methods><class-id>GraphQLBeta.GraphQLBenchmark class</class-id> <category>benchmarking</category><body package="GraphQLBeta-Test-Benchmark" selector="benchmarkPoints:query:">benchmarkPoints: numberOfPoints query: query	| g res result |	g := GraphQL new.	g rootInstance: self new.	g createSchema: self schema.	result := g handleRequest: query.	res := result at: 'queryPoints'.	self assert: res size = numberOfPoints.	result := GraphQLPlatform current toJson: result.	self assert: result isString</body><body package="GraphQLBeta-Test-Benchmark" selector="benchmarkRectangles:query:">benchmarkRectangles: numberOfRectangles query: query	| g res result |	g := GraphQL new.	g rootInstance: self new.	g createSchema: self schema.	result := g handleRequest: query.	res := result at: 'queryRectangles'.	self assert: res size = numberOfRectangles.	result := GraphQLPlatform current toJson: result.	self assert: result isString</body><body package="GraphQLBeta-Test-Benchmark" selector="benchmarkTimePoints:query:">benchmarkTimePoints: numberOfPoints query: query	"for an array with numberOfPoints instances of points"	"self benchmarkTimePoints: 1000000 query: '{queryPoints}' "	self lastSize = numberOfPoints		ifFalse: [ self initializePoints: numberOfPoints ].	self cleanMemory.	Transcript		cr;		"show: 'Bench01 for: ';		show: numberOfPoints;		show: ' points';		cr;		show: 'Time: ';"			show:			[ self benchmarkPoints: numberOfPoints query: query ] timeToRun				asSeconds</body><body package="GraphQLBeta-Test-Benchmark" selector="benchmarkTimeRectangles:query:">benchmarkTimeRectangles: numberOfRectangles query: query	"for an array with numberOfRectangles instances of points"	"self benchmarkTimePoints: 1000000 query: '{queryPoints}' "	self lastSize = numberOfRectangles		ifFalse: [ self initializeRectangles: numberOfRectangles ].	self cleanMemory.	Transcript		cr;		"show: 'Bench02 for: ';		show: numberOfRectangles;		show: ' rectangles';		cr;		show: 'Time: ';"			show:			[ self benchmarkRectangles: numberOfRectangles query: query ]				timeToRun asSeconds</body></methods><methods><class-id>GraphQLBeta.GQLFieldsVisitor</class-id> <category>visiting</category><body package="GraphQLBeta-Visitors" selector="visitDocumentNode:">visitDocumentNode: node	self		stackedOn: node		do: [ visitedFields := Dictionary new.			node operations do: [ :op | op accept: self ].			node fragments do: [ :f | f accept: self ] ]</body><body package="GraphQLBeta-Visitors" selector="visitFragmentNode:">visitFragmentNode: node	| type |	type := self getFragmentTypeOf: node typeCondition.	schemaContextStack push: type.	node selectionSet accept: self.	schemaContextStack pop</body><body package="GraphQLBeta-Visitors" selector="visitInlineFragmentNode:">visitInlineFragmentNode: node	| current type |	current := schemaContextStack top.	type := node typeCondition.	type ifNil: [ type := current ].	type := type rawType: schema.	(type isNil or: [ type isScalarType ])		ifTrue: [ type := GQLSNullTypeNode instance ].	schemaContextStack push: type.	node selectionSet accept: self.	schemaContextStack pop</body><body package="GraphQLBeta-Visitors" selector="visitNonScalarFieldNode:">visitNonScalarFieldNode: node	| current field type |	current := schemaContextStack top.	field := current getField: node name.	field		ifNil: [ self				addErrorMessage:					'Cannot query field "' , node name , '" on type "' , current name						, '"'				node: node.			^ self ].	type := field type rawType: schema.	type isScalarType		ifTrue: [ self				addErrorMessage:					'Field "' , node name , '" must not have selection since type "'						, type name , '" has no subfields.'				node: node selectionSet ]		ifFalse: [ schemaContextStack push: type.			node selectionSet accept: self.			schemaContextStack pop ]</body><body package="GraphQLBeta-Visitors" selector="visitOperationNode:">visitOperationNode: node	| isNil |	isNil := self		stackedType: node		do: [ node selectionSet accept: self ].	isNil		ifTrue: [ self				addErrorMessage: node type , ' not supported, review schema definition.'				node: node ]</body><body package="GraphQLBeta-Visitors" selector="visitScalarFieldNode:">visitScalarFieldNode: node	| current hasField field |	current := schemaContextStack top.	field := nil.	hasField := (field := current getField: node name) isNotNil.	hasField		ifTrue:			[ field ifNotNil: [ self validateScalarFieldNode: node on: field ] ]		ifFalse: [ self				addErrorMessage:					'Cannot query field "' , node name , '" on type "' , current name						, '"'				node: node ]</body><body package="GraphQLBeta-Visitors" selector="visitSelectionSetNode:">visitSelectionSetNode: node	self validateFieldsMerging: node.	node selections do: [ :f | f accept: self ]</body></methods><methods><class-id>GraphQLBeta.GQLFieldsVisitor</class-id> <category>validation</category><body package="GraphQLBeta-Visitors" selector="validateField:onField:">validateField: assoc1 onField: assoc2	| nodes f1 f2 parentType1 parentType2 type1 type2 |	f1 := assoc1 value.	f2 := assoc2 value.	f1 == f2		ifTrue: [ ^ self ].	parentType1 := assoc1 key.	parentType2 := assoc2 key.	parentType1 ifNil: [ ^ self ].	parentType2 ifNil: [ ^ self ].	parentType1 isObjectType		ifFalse: [ ^ self ].	parentType2 isObjectType		ifFalse: [ ^ self ].	type1 := parentType1 getFieldType: f1 name.	type2 := parentType2 getFieldType: f2 name.	f1 key = f2 key		ifFalse: [ ^ self ].	nodes := Array with: f1 with: f2.	f1 name = f2 name		ifTrue: [ parentType1 = parentType2				ifTrue: [ (f1 hasSameArguments: f2 arguments)						ifFalse: [ self								addErrorMessage:									'Fields "' , f1 key										,											'" conflict because they have differing arguments. Use different aliases on the fields to fetch both if this was intentional.'								nodes: nodes ] ]				ifFalse: [ "self halt." ] ]		ifFalse: [ type1 class = type2 class				ifTrue: [ ^ self ].			self				addErrorMessage:					'Fields "' , f1 key , '" conflict because "' , f1 name , '" and "'						, f2 name						,							'" are different fields. Use different aliases on the fields to fetch both if this was intentional.'				nodes: nodes ]</body><body package="GraphQLBeta-Visitors" selector="validateFieldsMerging:">validateFieldsMerging: node	| fieldsForName |	fieldsForName := self getFieldsForNameFrom: node.	1 to: fieldsForName size - 1 do: [ :i | 		i + 1 to: fieldsForName size do: [ :k | 			| assoc1 assoc2 |			assoc1 := fieldsForName at: i.			assoc2 := fieldsForName at: k.			self validateField: assoc1 onField: assoc2 ] ]</body><body package="GraphQLBeta-Visitors" selector="validateScalarFieldNode:on:">validateScalarFieldNode: node on: field	| type s |	type := field type rawType: schema.	type isNullType		ifTrue: [ ^ self ].	type isScalarType		ifTrue: [ ^ self ].	s := String new writeStream.	s		nextPutAll: 'Field "';		nextPutAll: node name;		nextPutAll: '" on type "'.	field type printOn: s.	s		nextPutAll: '" must have selection of subfields. Did you mean "';		nextPutAll: node name;		nextPutAll: ' { ... }"?'.	self addErrorMessage: s contents node: node</body></methods><methods><class-id>GraphQLBeta.GQLFieldsVisitor</class-id> <category>accessing</category><body package="GraphQLBeta-Visitors" selector="getFieldsForNameFrom:">getFieldsForNameFrom: node	| fieldsForName fill |	fieldsForName := OrderedCollection new.	fill := nil.	fill := [ :n :p | 	n selections		do: [ :selection | 			selection				ifField: [ fieldsForName add: p -&gt; selection ]				ifFragment: [ | fragment |					fragment := document getFragment: selection name.					(fragment isNil or: [ fragment hasCycle: document ])						ifFalse: [ fill								value: fragment selectionSet								value: (self getTypeParent: fragment) ] ]				ifInline: [ fill						value: selection selectionSet						value: (self getTypeParent: selection) ] ] ].	fill value: node value: (self getTypeParent: node).	"avoid repeating fields"	fieldsForName copy		do: [ :assoc | 			visitedFields				at: assoc value				ifPresent: [ :v | fieldsForName remove: assoc ]				ifAbsent: [ visitedFields at: assoc value put: assoc ] ].	^ fieldsForName</body><body package="GraphQLBeta-Visitors" selector="getTypeParent:">getTypeParent: node	^ node class = GQLSelectionSetNode		ifTrue: [ schemaContextStack top ]		ifFalse: [ node typeCondition				ifNil: [ schemaContextStack top ]				ifNotNil: [ schema getType: node typeCondition name ] ]</body></methods><methods><class-id>GraphQLBeta.GQLArguments</class-id> <category>public</category><body package="GraphQLBeta-Test-Utils" selector="booleanArgField">booleanArgField	^ true</body><body package="GraphQLBeta-Test-Utils" selector="booleanArgFieldBooleanArg:">booleanArgFieldBooleanArg: bool	bool ifNil: [ ^ true ].	^ bool not</body><body package="GraphQLBeta-Test-Utils" selector="booleanListArgFieldBooleanListArg:">booleanListArgFieldBooleanListArg: list	^ list</body><body package="GraphQLBeta-Test-Utils" selector="floatArgFieldFloatArg:">floatArgFieldFloatArg: float	^ float</body><body package="GraphQLBeta-Test-Utils" selector="intArgFieldIntArg:">intArgFieldIntArg: int	^ int * int</body><body package="GraphQLBeta-Test-Utils" selector="multipleReqsX:y:">multipleReqsX: x y: y	^ x * x + y</body><body package="GraphQLBeta-Test-Utils" selector="nonNullBooleanArgFieldNonNullBooleanArg:">nonNullBooleanArgFieldNonNullBooleanArg: bool	^ bool not</body><body package="GraphQLBeta-Test-Utils" selector="nonNullBooleanListFieldNonNullBooleanListArg:">nonNullBooleanListFieldNonNullBooleanListArg: bools	^ bools</body><body package="GraphQLBeta-Test-Utils" selector="optionalNonNullBooleanArgFieldOptionalBooleanArg:">optionalNonNullBooleanArgFieldOptionalBooleanArg: bool	^ bool</body><body package="GraphQLBeta-Test-Utils" selector="singleIDId:">singleIDId: id	^ id</body><body package="GraphQLBeta-Test-Utils" selector="singleStringString:">singleStringString: string	^ string</body></methods><methods><class-id>GraphQLBeta.GQLDirectivesVisitor</class-id> <category>visiting</category><body package="GraphQLBeta-Visitors" selector="validateDirectiveLocation:">validateDirectiveLocation: node	| ocurrences |	currentLocation := node.	ocurrences := OrderedDictionary new.	node directives		do: [ :d | 			(ocurrences at: d name ifAbsentPut: [ OrderedCollection new ]) add: d.			d accept: self ].	ocurrences		keysAndValuesDo: [ :k :nodes | 			nodes size &gt; 1				ifTrue: [ self						addErrorMessage: 'The directive "' , k , '" can only be used once at this location.'						nodes: nodes ] ]</body><body package="GraphQLBeta-Visitors" selector="visitDirectiveNode:">visitDirectiveNode: node	| directive |	directive := schema getDirective: node name.	directive		ifNil: [ ^ self				addErrorMessage: 'Unknown directive "' , node name , '".'				node: node ].	(directive directiveLocations includes: currentLocation class)		ifFalse: [ self				addErrorMessage:					'Directive "' , node name , '" may not be used on '						, currentLocation class nodeName , '.'				node: node ]</body><body package="GraphQLBeta-Visitors" selector="visitDocumentNode:">visitDocumentNode: node	node operations do: [ :op | op accept: self ].	node fragments do: [ :f | f accept: self ]</body><body package="GraphQLBeta-Visitors" selector="visitFragmentNode:">visitFragmentNode: node	currentLocation := node.	node directives do: [ :d | d accept: self ].	node selectionSet accept: self</body><body package="GraphQLBeta-Visitors" selector="visitInlineFragmentNode:">visitInlineFragmentNode: node	self validateDirectiveLocation: node</body><body package="GraphQLBeta-Visitors" selector="visitIntrospectionFieldNode:">visitIntrospectionFieldNode: node	self validateDirectiveLocation: node</body><body package="GraphQLBeta-Visitors" selector="visitNonScalarFieldNode:">visitNonScalarFieldNode: node	self validateDirectiveLocation: node</body><body package="GraphQLBeta-Visitors" selector="visitOperationNode:">visitOperationNode: node	self validateDirectiveLocation: node.	node selectionSet accept: self</body><body package="GraphQLBeta-Visitors" selector="visitScalarFieldNode:">visitScalarFieldNode: node	self validateDirectiveLocation: node</body><body package="GraphQLBeta-Visitors" selector="visitSchemaFieldNode:">visitSchemaFieldNode: node	self validateDirectiveLocation: node</body><body package="GraphQLBeta-Visitors" selector="visitSelectionSetNode:">visitSelectionSetNode: node	node selections do: [ :s | s accept: self ]</body><body package="GraphQLBeta-Visitors" selector="visitTypeFieldNode:">visitTypeFieldNode: node	self validateDirectiveLocation: node</body><body package="GraphQLBeta-Visitors" selector="visitTypenameFieldNode:">visitTypenameFieldNode: node	self validateDirectiveLocation: node</body></methods><methods><class-id>GraphQLBeta.Film</class-id> <category>accessing</category><body package="GraphQLBeta-Demo" selector="director">director	^ director</body><body package="GraphQLBeta-Demo" selector="director:">director: aPerson	director := aPerson</body><body package="GraphQLBeta-Demo" selector="gender">gender	^ gender</body><body package="GraphQLBeta-Demo" selector="gender:">gender: aGender	gender := aGender</body><body package="GraphQLBeta-Demo" selector="name">name	^ name</body><body package="GraphQLBeta-Demo" selector="name:">name: aString	name := aString</body><body package="GraphQLBeta-Demo" selector="rating">rating	^ rating</body><body package="GraphQLBeta-Demo" selector="rating:">rating: aInt	rating := aInt</body></methods><methods><class-id>GraphQLBeta.Film class</class-id> <category>instance creation</category><body package="GraphQLBeta-Demo" selector="name:rating:director:gender:">name: aName rating: aRating director: aDirector gender: aGender	| inst |	inst := self new.	inst		name: aName;		rating: aRating;		director: aDirector;		gender: aGender.	^ inst</body></methods><methods><class-id>GraphQLBeta.GQLFragmentsVisitor</class-id> <category>validation</category><body package="GraphQLBeta-Visitors" selector="getPossibleTypes:">getPossibleTypes: ref	| result type |	type := self getFragmentTypeOf: ref.	result := Set new.	type isObjectType		ifTrue: [ result add: type ].	type isInterfaceType		ifTrue: [ type implementors do: [ :i | result add: i ] ].	type isUnionType		ifTrue:			[ type namedTypes do: [ :s | result add: (schema getType: s) ] ].	^ result</body><body package="GraphQLBeta-Visitors" selector="validateFragments:">validateFragments: fragments	| ocurrences |	ocurrences := fragments groupedBy: [ :f | f name ].	ocurrences		keysAndValuesDo: [ :k :list | 			list size &gt; 1				ifTrue: [ self						addErrorMessage: 'There can be only one fragment named "' , k , '".'						nodes: list ] ].	fragments		do: [ :f | 			| visited s |			self validateFragmentType: f.			(usedFragments includes: f name)				ifFalse: [ s := String new writeStream.					s						nextPutAll: 'Fragment "';						nextPutAll: f name;						nextPutAll: '" is never used.'.					self addErrorMessage: s contents node: f ].			visited := Set new.			(document hasCycle: f with: visited)				ifTrue: [ | node |					f setHasCycle: true.					node := (visited intersection: f targetSpreads) asArray						at: visited size.					s := String new writeStream.					s						nextPutAll: 'Cannot spread fragment "';						nextPutAll: f name;						nextPutAll: '" with itself via ';						nextPutAll: node name.					self addErrorMessage: s contents node: node ] ]</body><body package="GraphQLBeta-Visitors" selector="validateFragmentSpreadPossibility:fragmentType:parentType:">validateFragmentSpreadPossibility: node fragmentType: fragmentType parentType: parentType	| applicableTypes s types1 types2 |	types1 := self getPossibleTypes: fragmentType.	types1 ifEmpty: [ ^ self ].	types2 := self getPossibleTypes: parentType.	types2 ifEmpty: [ ^ self ].	applicableTypes := types1 intersection: types2.	applicableTypes		ifEmpty: [ s := String new writeStream.			s nextPutAll: 'Fragment '.			node class = GQLInlineFragmentNode				ifFalse: [ s						nextPutAll: '"';						nextPutAll: node name;						nextPutAll: '" ' ].			s nextPutAll: 'cannot be spread here as objects of type "'.			fragmentType printOn: s.			s nextPutAll: '" can never be of type "'.			parentType printOn: s.			s nextPutAll: '".'.			self addErrorMessage: s contents node: node ]</body><body package="GraphQLBeta-Visitors" selector="validateFragmentType:">validateFragmentType: f	| stype type |	type := f typeCondition.	type ifNil: [ ^ self ].	stype := schema getType: type name.	stype		ifNil: [ self addErrorMessage: 'Unkwown type "' , type name , '".' node: type ]		ifNotNil: [ stype isObjectType | stype isInterfaceType | stype isUnionType				ifFalse: [ | s |					s := String new writeStream.					s nextPutAll: 'Fragment '.					f class = GQLFragmentNode						ifTrue: [ s								nextPutAll: '"';								nextPutAll: f name;								nextPutAll: '" ' ].					s nextPutAll: 'cannot condition on non composite type "'.					type printOn: s.					s nextPutAll: '"'.					self addErrorMessage: s contents node: type ] ]</body></methods><methods><class-id>GraphQLBeta.GQLFragmentsVisitor</class-id> <category>visiting</category><body package="GraphQLBeta-Visitors" selector="visitDocumentNode:">visitDocumentNode: node	self		stackedOn: node		do: [ usedFragments := Set new.			node operations do: [ :op | op accept: self ].			node fragments do: [ :f | f accept: self ].			self validateFragments: node fragments ]</body><body package="GraphQLBeta-Visitors" selector="visitFragmentNode:">visitFragmentNode: node	| type |	type := self getFragmentTypeOf: node typeCondition.	schemaContextStack push: type.	currentFragment := node.	node selectionSet accept: self.	schemaContextStack pop</body><body package="GraphQLBeta-Visitors" selector="visitFragmentSpreadNode:">visitFragmentSpreadNode: node	usedFragments add: node name.	document fragments		detect: [ :f | f name = node name ]		ifFound: [ :f | 			| current |			current := schemaContextStack top.			self				validateFragmentSpreadPossibility: node				fragmentType: f typeCondition				parentType: current ]		ifNone: [ self				addErrorMessage: 'Unknown fragment "' , node name , '".'				node: node ]</body><body package="GraphQLBeta-Visitors" selector="visitInlineFragmentNode:">visitInlineFragmentNode: node	| current type ftype |	current := schemaContextStack top.	type := node typeCondition.	type ifNil: [ type := current ].	ftype := currentFragment		ifNil: [ current ]		ifNotNil: [ currentFragment typeCondition ].	self		validateFragmentSpreadPossibility: node		fragmentType: ftype		parentType: type.	self validateFragmentType: node.	type := type rawType: schema.	schemaContextStack push: type.	node selectionSet accept: self.	schemaContextStack pop</body><body package="GraphQLBeta-Visitors" selector="visitNonScalarFieldNode:">visitNonScalarFieldNode: node	| current type field |	current := schemaContextStack top.	field := current getField: node name.	type := field isNil		ifTrue: [ GQLSNullTypeNode instance ]		ifFalse: [ field type rawType: schema ].	schemaContextStack push: type.	node selectionSet accept: self.	schemaContextStack pop</body><body package="GraphQLBeta-Visitors" selector="visitOperationNode:">visitOperationNode: node	self stackedType: node do: [ node selectionSet accept: self ]</body><body package="GraphQLBeta-Visitors" selector="visitSchemaFieldNode:">visitSchemaFieldNode: node	schemaContextStack		push: (GQLSSchemaNode metaSchema getType: 'GQLSSchemaNode').	node selectionSet accept: self.	schemaContextStack pop</body><body package="GraphQLBeta-Visitors" selector="visitSelectionSetNode:">visitSelectionSetNode: node	node selections do: [ :f | f accept: self ]</body></methods><methods><class-id>GraphQLBeta.GQLAbstactTypeSystemTest</class-id> <category>initialization</category><body package="GraphQLBeta-Tests-TypeValidation" selector="getSchema:withRoot:">getSchema: keySchema withRoot: aRoot	| aSchema |	dictSchema		at: keySchema		ifPresent: [ :value | 			aSchema := self parseSchema: value.			rootInstance := aRoot.			aSchema := aSchema validate.			aSchema root: rootInstance ]		ifAbsent: [ aSchema := nil ].	^ aSchema</body><body package="GraphQLBeta-Tests-TypeValidation" selector="initDictSchema">initDictSchema	^ Dictionary new		at: 'schemaWithMultipleInterface'			put:			'		schema{			query: GQLTestQueryType		}		interface NamedEntity{			name : String		}		interface ClassName{			className: String		}		type GQLTestQueryType{			filmsWith(rating: Int): [GQLTestFilm]		}		type GQLTestFilm implements NamedEntity &amp; ClassName{         id : String        name : String		  className: String      }	';		at: 'schemaWithUndefinedFieldInterface'			put:			'		schema{			query: GQLTestFilm		}		interface NamedEntity{			name : String		}		interface MethodName{			nameMethod: String		}		type GQLTestFilm implements NamedEntity &amp; MethodName{         id : String        name : String		  className: String      }	';		at: 'schemaUndefinedAndWithManyTypes'			put:			'		type GQLTestQueryType {			hello: String		}		type GQLQueryRoot { 			dog: GQLDog		}		type GQLDog { 			name: String			owner: GQLHuman		}		type GQLHuman { 			name: String		}	';		at: 'schemaNoRootOperationType'			put:			'		schema { 		}		type Query { 			hello: String		 }	';		at: 'schemaNoRootOperationTypeQuery'			put:			'		schema { 			mutation: GQLMutation		}		type GQLMutation { 			setNumber(to:Int): Int		 }	';		at: 'schemaUndefined'			put:			(self				parseSchema:					'		type GQLTestQueryType {			hello: String		}	');		at: 'schemaDefinedQueryTwice'			put:			'		type Query{			hello: String		}		type Query{			film(name: String): String		}	';		at: 'schemaDefinedTypeTwice'			put:			'		type GQLTestQueryType{			hello: String		}		type GQLTestQueryType{			helloTo(name:String): String		}	';		at: 'schemaWithUnknownFieldName'			put:			'		type Query { 			helloName: String		}	';		at: 'schemaWithUnknownFieldNameMutation'			put:			'		type GQLMutation { 			setNumber2(to: Int): Int		}	';		at: 'invalidDescriptionInType'			put:			'		type "Query is the root operation query by default"		Query { 			hello: String		}	';		at: 'invalidDescriptionInField'			put:			'		type Query { 			hello "field hello": String		}	';		at: 'invalidBlockStringDescription'			put:			'		type Query {			"""				first description with BlockString 			""" 			"""				second description			""""			hello: String		}	';		at: 'invalidStringDescription'			put:			'		" description 1"		" description 2"		type Query { 			hello: String		}	';		at: 'inputIntType'			put:			'	schema { 		query: GQLTestSchema	}	type GQLTestSchema{		filmsWith(rating: Int): [ GQLTestFilm ]		isEven(number: Int): Boolean	}	type GQLTestFilm{		name: String	}	';		at: 'outputIntType'			put:			'	schema { 		query: GQLTestSchema	}	type GQLTestSchema{		asText(number: Int): Int #return a number in String		isEven(number: Int): Int #return a Boolean		squareRoot(of: Float): Int #return a Float	}	';		at: 'inputFloatType'			put:			'	schema { 		query: GQLTestSchema	}	type GQLTestSchema{		point(x:Float, y:Float): Point	}	type Point{		x: Float		y: Float	}';		at: 'outputFloatType'			put:			'	schema { 		query: GQLTestSchema	}	type GQLTestSchema{		asText(number: Float): Float # return the number as String		totalFilms: Float #return a Int		isEven(number: Float): Float #return a Boolean		hello: Float #return a String		point(x: Float, y: Float): Float #return a Point	}	type Point{		x: Float		y: Float	}	';		at: 'inputStringType'			put:			'		schema { 		   query: GQLTestSchema	   }		enum MovieType{COMEDY, SCIENCE_FICTION, DRAMA}		type GQLTestSchema{			helloTo(name:String) : String		}	';		at: 'outputStringType'			put:			'		schema { 			query: GQLTestSchema		}		type GQLTestSchema{			hello: String			totalFilms: String #return a Int			isEven(number: Int): String #return a Boolean			pi: String #return a Float #return a Float			point(x: Float, y: Float): String #return a Point		}	';		at: 'inputBooleanType'			put:			'		schema { 			query: GQLTestSchema		}		type GQLTestSchema{			films(sortedByName: Boolean): [ GQLTestFilm ]			hello: String		}		type GQLTestFilm{			name: String		}	';		at: 'outputBooleanType'			put:			'		schema { 			query: GQLTestSchema		}		type GQLTestSchema{			hello : Boolean			pi: Boolean			totalFilms: Boolean			point(x: Float, y: Float): Boolean		}	';		at: 'inputIDType'			put:			'		schema { 			query: GQLTestSchema		}		type GQLTestSchema{			filteredFilm(id: ID): GQLTestFilm		}		type GQLTestFilm{			id: ID			name: String		}	';		at: 'outputIDType'			put:			'		schema { 			query: GQLTestSchema		}		type GQLTestSchema{			hello : ID			totalFilms: ID			pi: ID			isEven(number: Int): ID			point(x: Float, y: Float): ID		}	';		at: 'inputObjectTypeInvalid'			put:			'		schema { 			query: GQLTestQueryType		}		type GQLTestQueryType{			information(film: GQLTestFilm) : GQLTestFilm		}		type GQLTestFilm{			id: ID			name: String		}	';		at: 'inputObjectType'			put:			'		schema { 			query: GQLTestQueryType		}		type GQLTestQueryType{			features(film: GQLFilmInput) : String		}		input GQLFilmInput{			id: ID			filmName: String		}	';		at: 'outputObjectType'			put:			'		schema { 			query: GQLTestSchema		}		type GQLTestSchema{			point(x: Float, y: Float): Point			hello: Point #return a String			cats: [ GQLCat ]		}		type Point{			x: Float			y: Float		}		type GQLCat{			name: String		}	';		at: 'inputInterfaceType'			put:			'		schema { 			query: GQLTestSchema		}	   interface NamedEntity{	      name: String 	   }		type GQLTestSchema implements NamedEntity{			name: String			nameOf(item: NamedEntity): String		}		type GQLCat implements NamedEntity{			name: String			nickname: String		}	';		at: 'outputInterfaceType'			put:			'		schema { 			query: GQLTestSchema		}	   interface NamedEntity{	      name: String 	   }		type GQLTestSchema {			entity: NamedEntity			entities: [ NamedEntity ]		}		type GQLTestFilm implements NamedEntity { 			name: String			rating: Int		}		type GQLCat implements NamedEntity{			name: String			nickname: String		}	';		at: 'inputUnionType'			put:			'		schema { 			query: GQLTestSchema		}	   union NamedObject = GQLCat | GQLTestFilm 		type GQLTestSchema {			nameOf(item: NamedObject): String		}		type GQLCat{			name: String			nickname: String		}		type GQLTestFilm{			name: String			rating: Int		}	';		at: 'outputUnionType'			put:			'		schema { 			query: GQLTestSchema		}	   union SearchObject = Point | Rectangle		type GQLTestSchema {			firstSearchObject: SearchObject		}		type Point{			x: Float			y: Float		}		type Rectangle{			origin: Point			corner: Point		}	';		at: 'inputEnumType'			put:			'		schema { 			query: GQLTestSchema		}		enum MovieType{COMEDY, SCIENCE_FICTION, DRAMA}		type GQLTestSchema{			classification(gender: MovieType): String		}	';		at: 'outputEnumType'			put:			'		schema { 			query: GQLTestSchema		}		enum MovieType{COMEDY, SCIENCE_FICTION, DRAMA}		type GQLTestSchema{			totalFilms: MovieType			hello: MovieType			classification(gender: MovieType): MovieType		}	';		at: 'inputInputObject'			put:			'		schema { 			query: GQLTestSchema		}		type GQLTestSchema { 			informationInput(film: GQLTestFilmInput): GQLTestQueryType			inform(film: GQLFilmInput, id: Int): GQLFilm		}		input GQLTestFilmInput{			id: Int			filmName: String		}		type GQLFilm{			id: Int			filmName: String		}		input GQLFilmInput {			id: Int!			filmName : String		}		type GQLTestQueryType{			description: String			gender: String		}	';		at: 'outputInputObject'			put:			'		schema { 			query: GQLTestSchema		}		type GQLTestSchema { 			information(film: GQLTestFilmInput) : GQLTestFilmInput		}		input GQLTestFilmInput{			id: Int			filmName: String		}	';		at: 'inputList'			put:			'		schema { 			query: GQLTestSchema		}		type GQLTestSchema{			filmsOn(genders: [MovieType]): [ GQLTestFilm ]			nameGenders(listGender: [ MovieType ]): [ MovieType ]			listOf(arrays: [ [ Int ] ]): [ [ Int ] ]		}		type GQLTestFilm { 			id : ID			name : String			rating : Int		}		enum MovieType{COMEDY, SCIENCE_FICTION, ACTION}	';		at: 'outputList'			put:			'		schema { 			query: GQLTestSchema		}		type GQLTestSchema{			filmsWith(rating : Int) : [ GQLTestFilm ]			filmsWithNull(rating: Int): [ GQLTestFilm ]			listOf(arrays: [ [ Int ] ]): [ [ Int ] ]			hello: [ String ] #return a String			totalFilms: [ Boolean ] #returns a Int		}		type GQLTestFilm{			id : ID			name : String			rating : Int		}		enum MovieType{COMEDY, SCIENCE_FICTION, ACTION}	';		at: 'invalidOutputListString'			put:			'		schema { 			query: GQLTestSchema		}		type GQLTestSchema{			listOf(arrays: [ [ Int ] ]): [ [ String ] ] #return a [ [ Int ] ]		}	';		at: 'invalidOutputListBoolean'			put:			'		schema { 			query: GQLTestSchema		}		type GQLTestSchema{			listOf(arrays: [ [ Int ] ]): [ [ Boolean ] ] #return a [ [ Int ] ]		}	';		at: 'invalidOutputListEnum'			put:			'		schema { 			query: GQLTestSchema		}		type GQLTestSchema{			listOf(arrays: [ [ Int ] ]): [ [ MovieType ] ] #return a [ [ Int ] ]		}		enum MovieType{COMEDY, SCIENCE_FICTION, ACTION}	';		at: 'inputNotNullValue'			put:			'		schema { 			query: GQLTestSchema		}		type GQLTestSchema{			helloTo(name:String!) : String			isEven(number: Int!): Boolean			point(x:Float!, y:Float): Point			listOf(arrays: [ [ Int! ]! ]!): [ [ Int ] ]			nameGenders(listGender: [MovieType]!): [ MovieType ]		}		type Point{			x: Float			y: Float		}		enum MovieType{COMEDY, SCIENCE_FICTION, ACTION}	';		at: 'outputNotNullValue'			put:			'		schema { 			query: GQLTestSchema		}		type GQLTestSchema{			filmsWith(rating : Int) : [ GQLTestFilm ]!			point(x:Float, y:Float): Point!			helloTo(name:String) : String!		}		type GQLTestFilm{			id: Int			filmName: String		}	';		at: 'inputListNotNullValue'			put:			'		schema { 			query: GQLTestSchema		}		type GQLTestSchema{			nameGenders(listGender: [ MovieType! ]): [ MovieType ]			listOf(arrays: [ [ Int !]! ]!): [ [ Int ] ]			totalInformation(film: [GQLTestQueryTypeInput]!): [ GQLTestQueryType]		}		input GQLTestQueryTypeInput{			description: String			gender: String		}		type GQLTestQueryType{			description: String			gender: String		}		enum MovieType{COMEDY, SCIENCE_FICTION, ACTION}	';		at: 'outputListNotNullValue'			put:			'		schema { 			query: GQLTestSchema		}		type GQLTestSchema{			listOf(arrays: [ [ Int ] ]): [ [ Int! ]! ]!		}	';		at: 'inputVariable'			put:			'		schema { 			query: GQLTestSchema		}		type GQLTestSchema { 			helloTo(name: String!): String			isEven(number: Int): Boolean			informationInput(film: GQLTestFilmInput!): GQLTestQueryType			point(x: Float!, y: Float): Point		}		input GQLTestFilmInput{			id: Int!			filmName: String		}		type GQLTestQueryType{			description: String			gender: String		}		type Point{			x: Float!			y: Float		}	';		yourself</body><body package="GraphQLBeta-Tests-TypeValidation" selector="setUp">setUp	dictSchema := self initDictSchema.	compareJson := true</body></methods><methods><class-id>GraphQLBeta.GQLAbstactTypeSystemTest</class-id> <category>parsing</category><body package="GraphQLBeta-Tests-TypeValidation" selector="attendRequest:using:with:root:">attendRequest: text using: operationName with: textVariables root: root	"The result is added a dictionary with the key 'data' according the specification found in: http://facebook.github.io/graphql/draft/#ExecuteQuery()"	| document variables |	document := self parseRequest: text.	(document isKindOf: PPFailure)		ifTrue: [ ^ document asJsonDictionary ].	variables := textVariables isEmpty		ifFalse: [ self parseVariables: textVariables ]		ifTrue: [ nil ].	^ GQLValidator new		variables: variables;		operationName: operationName;		rootInstance: root;		document: document;		text: text;		schema: schema;		execute</body></methods><methods><class-id>GraphQLBeta.GQLAbstactTypeSystemTest</class-id> <category>evaluation</category><body package="GraphQLBeta-Tests-TypeValidation" selector="evalSchemaWithKey:withRoot:">evalSchemaWithKey: keySchema withRoot: aRoot	"Evaluate the schema accord the specification"	| aSchema result |	dictSchema		at: keySchema		ifPresent: [ aSchema := self parseSchema: (dictSchema at: keySchema).			aSchema				validate;				root: aRoot.			result := self jsonSchema: aSchema ]		ifAbsent: [ result := nil ].	^ result</body></methods><methods><class-id>GraphQLBeta.GQLSTypeTest</class-id> <category>tests-scalar</category><body package="GraphQLBeta-Tests-TypeValidation" selector="testBooleanInputValue">testBooleanInputValue	"The only valid type is Boolean"	| request result expectedResult |	schema := self		getSchema: 'inputBooleanType'		withRoot: GQLTestSchema new.	request := '{		films(sortedByName: true){			name		}	}'.	result := self jsonRequest: request.	expectedResult := '{	"data" : {		"films" : [			{				"name" : "alien"			},			{				"name" : "annie"			},			{				"name" : "el seÃ±or de los anillos"			},			{				"name" : "harry potter y la piedra filosofal"			},			{				"name" : "rambo"			},			{				"name" : "robocop"			},			{				"name" : "terminator"			}		]	}}'.	self assert: result equals: expectedResult.	request := '{		films(sortedByName: "true"){			name		}	}'.	result := self jsonRequest: request.	expectedResult := '{	"errors" : [		{			"message" : "Argument \"sortedByName\" has invalid value \"true\". Expected type \"Boolean\".",			"locations" : [				{					"line" : 2,					"column" : 23				}			]		}	]}'.	self assert: result equals: expectedResult.	request := '{		hello @skip(if:"false")	}'.	result := self jsonRequest: request.	expectedResult := '{	"errors" : [		{			"message" : "Argument \"if\" has invalid value \"false\". Expected type \"Boolean!\".",			"locations" : [				{					"line" : 2,					"column" : 18				}			]		}	]}'.	self assert: result equals: expectedResult.	request := '{		films(sortedByName: 1){			name		}	}'.	result := self jsonRequest: request.	expectedResult := '{	"errors" : [		{			"message" : "Argument \"sortedByName\" has invalid value 1. Expected type \"Boolean\".",			"locations" : [				{					"line" : 2,					"column" : 23				}			]		}	]}'.	self assert: result equals: expectedResult</body><body package="GraphQLBeta-Tests-TypeValidation" selector="testFloatInputValue">testFloatInputValue	"The only valid input type is Float, Int"	| request result expectedResult |	schema := self		getSchema: 'inputFloatType'		withRoot: GQLTestSchema new.	request := '{		point(x:2, y:3){			x			y		}	}'.	result := self jsonRequest: request.	expectedResult := '{	"data" : {		"point" : {			"x" : 2.0,			"y" : 3.0		}	}}'.	self assert: result equals: expectedResult.	request := '{		point(x:"2.3", y:3.4){			x			y		}	}'.	result := self jsonRequest: request.	expectedResult := '{	"errors" : [		{			"message" : "Argument \"x\" has invalid value \"2.3\". Expected type \"Float\".",			"locations" : [				{					"line" : 2,					"column" : 11				}			]		}	]}'.	self assert: result equals: expectedResult.	request := '{		point(x:"2.1", y:"3.4"){			x			y		}	}'.	result := self jsonRequest: request.	expectedResult := '{	"errors" : [		{			"message" : "Argument \"x\" has invalid value \"2.1\". Expected type \"Float\".",			"locations" : [				{					"line" : 2,					"column" : 11				}			]		},		{			"message" : "Argument \"y\" has invalid value \"3.4\". Expected type \"Float\".",			"locations" : [				{					"line" : 2,					"column" : 20				}			]		}	]}'.	self assert: result equals: expectedResult</body><body package="GraphQLBeta-Tests-TypeValidation" selector="testIDInputValue">testIDInputValue	"The defined input values as ID accept: Int, String. The rest values give error"	| request result expectedResult |	schema := self getSchema: 'inputIDType' withRoot: GQLTestSchema new.	request := '{		filteredFilm(id:1){			name		}	}'.	result := self jsonRequest: request.	expectedResult := '{	"data" : {		"filteredFilm" : {			"name" : "harry potter y la piedra filosofal"		}	}}'.	self assert: result equals: expectedResult.	request := '{		filteredFilm(id:"1"){			name		}	}'.	result := self jsonRequest: request.	expectedResult := '{	"data" : {		"filteredFilm" : {			"name" : "harry potter y la piedra filosofal"		}	}}'.	self assert: result equals: expectedResult.	request := '{		filteredFilm(id:2.0){			name		}	}'.	result := self jsonRequest: request.	expectedResult := '{	"errors" : [		{			"message" : "Argument \"id\" has invalid value 2.0. Expected type \"ID\".",			"locations" : [				{					"line" : 2,					"column" : 19				}			]		}	]}'.	self assert: result equals: expectedResult.	request := '{		filteredFilm(id:true){			name		}	}'.	result := self jsonRequest: request.	expectedResult := '{	"errors" : [		{			"message" : "Argument \"id\" has invalid value true. Expected type \"ID\".",			"locations" : [				{					"line" : 2,					"column" : 19				}			]		}	]}'.	self assert: result equals: expectedResult</body><body package="GraphQLBeta-Tests-TypeValidation" selector="testIntInputValue">testIntInputValue	"The only valid input type is Int"	| request response expectedResult |	schema := self getSchema: 'inputIntType' withRoot: GQLTestSchema new.	request := '{		filmsWith(rating:"1"){			name		}	}'.	response := self jsonRequest: request.	expectedResult := '{	"errors" : [		{			"message" : "Argument \"rating\" has invalid value \"1\". Expected type \"Int\".",			"locations" : [				{					"line" : 2,					"column" : 20				}			]		}	]}'.	self assert: response equals: expectedResult.	request := '{		isEven(number: 1.34)	}'.	response := self jsonRequest: request.	expectedResult := '{	"errors" : [		{			"message" : "Argument \"number\" has invalid value 1.34. Expected type \"Int\".",			"locations" : [				{					"line" : 2,					"column" : 18				}			]		}	]}'.	self assert: response equals: expectedResult.	request := '{		isEven(number: true)	}'.	response := self jsonRequest: request.	expectedResult := '{	"errors" : [		{			"message" : "Argument \"number\" has invalid value true. Expected type \"Int\".",			"locations" : [				{					"line" : 2,					"column" : 18				}			]		}	]}'.	self assert: response equals: expectedResult.	request := '{		isEven(number: 2147483648)	}'.	response := self jsonRequest: request.	expectedResult := '{	"errors" : [		{			"message" : "Argument \"number\" has invalid value 2147483648. Expected type \"Int\".",			"locations" : [				{					"line" : 2,					"column" : 18				}			]		}	]}'.	self assert: response equals: expectedResult.	request := '{		isEven(number: -2147483649)	}'.	response := self jsonRequest: request.	expectedResult := '{	"errors" : [		{			"message" : "Argument \"number\" has invalid value -2147483649. Expected type \"Int\".",			"locations" : [				{					"line" : 2,					"column" : 18				}			]		}	]}'.	self assert: response equals: expectedResult</body><body package="GraphQLBeta-Tests-TypeValidation" selector="testStringInputValue">testStringInputValue	"The only valid input type is String"	| request resValidator expectedResult |	schema := self		getSchema: 'inputStringType'		withRoot: GQLTestSchema new.	request := '{		helloTo(name: COMEDY)	}'.	resValidator := self jsonRequest: request.	expectedResult := '{	"errors" : [		{			"message" : "Argument \"name\" has invalid value COMEDY. Expected type \"String\".",			"locations" : [				{					"line" : 2,					"column" : 17				}			]		}	]}'.	self assert: resValidator equals: expectedResult.	request := '{		helloTo(name: Alex)	}'.	resValidator := self jsonRequest: request.	expectedResult := '{	"errors" : [		{			"message" : "Argument \"name\" has invalid value Alex. Expected type \"String\".",			"locations" : [				{					"line" : 2,					"column" : 17				}			]		}	]}'.	self assert: resValidator equals: expectedResult.	request := '{		helloTo(name: 1)	}'.	resValidator := self jsonRequest: request.	expectedResult := '{	"errors" : [		{			"message" : "Argument \"name\" has invalid value 1. Expected type \"String\".",			"locations" : [				{					"line" : 2,					"column" : 17				}			]		}	]}'.	self assert: resValidator equals: expectedResult.	request := '{		helloTo(name: true)	}'.	resValidator := self jsonRequest: request.	expectedResult := '{	"errors" : [		{			"message" : "Argument \"name\" has invalid value true. Expected type \"String\".",			"locations" : [				{					"line" : 2,					"column" : 17				}			]		}	]}'.	self assert: resValidator equals: expectedResult</body></methods><methods><class-id>GraphQLBeta.GQLSTypeTest</class-id> <category>tests-variables</category><body package="GraphQLBeta-Tests-TypeValidation" selector="testVariableInputObjectInputValue">testVariableInputObjectInputValue	| request result expectedResult variables |	schema := self getSchema: 'inputVariable' withRoot: GQLTestSchema new.	request := 'query operation1($testFilm: GQLTestFilmInput!){		informationInput(film: $testFilm){			description		}	}'.	variables := '{"testFilm": {id: 1, filmName: "Rambo"}}'.	result := self		operation: 'operation1'		variables: variables		jsonRequest: request.	expectedResult := '{	"data" : {		"informationInput" : {			"description" : "Rambo"		}	}}'.	self assert: result equals: expectedResult.	request := 'query operation1($testFilm: GQLTestFilmInput!){		informationInput(film: $testFilm){			description		}	}'.	variables := '{"testFilm": {id: 1, filmName: "Rambo"}}'.	result := self		operation: 'operation1'		variables: variables		jsonRequest: request.	expectedResult := '{	"data" : {		"informationInput" : {			"description" : "Rambo"		}	}}'</body><body package="GraphQLBeta-Tests-TypeValidation" selector="testVariableInputValue">testVariableInputValue	| request result expectedResult variables |	schema := self		getSchema: 'inputNotNullValue'		withRoot: GQLTestSchema new.	request := 'query operation1($name: String!){		helloTo(name: $name)	}'.	variables := '{"name": "Alex"}'.	result := self		operation: 'operation1'		variables: variables		jsonRequest: request.	expectedResult := '{	"data" : {		"helloTo" : "hello Alex"		}	}'.	self assert: result equals: expectedResult.	request := 'query operation1($num: String){		isEven(number: $num)	}'.	variables := '{"num": 13}'.	result := self		operation: 'operation1'		variables: variables		jsonRequest: request.	expectedResult := '{	"errors" : [		{			"message" : "Variable \"$num\" got invalid value 13. Expected type \"String\".",			"locations" : [				{					"line" : 1,					"column" : 18				}			]		},		{			"message" : "Variable \"num\" of type \"String\" used in position expecting type \"Int!\".",			"locations" : [				{					"line" : 1,					"column" : 18				},				{					"line" : 2,					"column" : 18				}			]		}	]}'.	self assert: result equals: expectedResult.	request := 'query operation1($num: Int){		isEven(number: 3)	}'.	variables := '{"num": 3}'.	result := self		operation: 'operation1'		variables: variables		jsonRequest: request.	expectedResult := '{  "errors": [    {      "message": "Variable \"$num\" is never used in operation \"operation1\".",      "locations": [        {          "line": 3,          "column": 11        }      ]    }  ]}'.	request := 'query operation1($num: Int=2.3){		isEven(number: $num)	}'.	variables := ''.	result := self		operation: 'operation1'		variables: variables		jsonRequest: request.	expectedResult := '{	"errors" : [		{			"message" : "Variable \"num\" of type \"Int\" used in position expecting type \"Int!\".",			"locations" : [				{					"line" : 1,					"column" : 18				},				{					"line" : 2,					"column" : 18				}			]		},		{			"message" : "Expected type Int, found 2.3.",			"locations" : [				{					"line" : 1,					"column" : 28				}			]		}	]}'.	self assert: result equals: expectedResult</body></methods><methods><class-id>GraphQLBeta.GQLSTypeTest</class-id> <category>tests-input object</category><body package="GraphQLBeta-Tests-TypeValidation" selector="testInputObjectInputValue">testInputObjectInputValue	| request result expectedResult |	schema := self		getSchema: 'inputInputObject'		withRoot: GQLTestSchema new.	request := '{		informationInput(film: { id: 1, filmName: "Rambo" }){			description		}	}'.	result := self jsonRequest: request.	expectedResult := '{	"data" : {		"informationInput" : {			"description" : "Rambo"		}	}}'.	self assert: result equals: expectedResult.	request := '{		inform(film: null, id: 1){			filmName		}	}'.	result := self jsonRequest: request.	expectedResult := '{	"data" : {		"inform" : {			"filmName" : "harry potter y la piedra filosofal"		}	}}'.	self assert: result equals: expectedResult.	request := '{		informationInput(film: { id: 1 }){			description		}	}'.	result := self jsonRequest: request.	expectedResult := '{	"data" : {		"informationInput" : {			"description" : "harry potter y la piedra filosofal"		}	}}'.	self assert: result equals: expectedResult.	request := '{		inform(id: 1){			filmName		}	}'.	result := self jsonRequest: request.	expectedResult := '{	"data" : {		"inform" : {			"filmName" : "harry potter y la piedra filosofal"		}	}}'.	self assert: result equals: expectedResult.	request := '{		informationInput(film: 1){			description		}	}'.	result := self jsonRequest: request.	expectedResult := '{	"errors" : [		{			"message" : "Argument \"film\" has invalid value 1. Expected type \"GQLTestFilmInput\".",			"locations" : [				{					"line" : 2,					"column" : 26				}			]		}	]}'.	self assert: result equals: expectedResult.	request := '{		informationInput(film: {id: 1, filmName: 1}){			description		}	}'.	result := self jsonRequest: request.	expectedResult := '{	"errors" : [		{			"message" : "Expected type String, found 1.",			"locations" : [				{					"line" : 2,					"column" : 34				}			]		}	]}'.	self assert: result equals: expectedResult.	request := '{		informationInput(film: {id: 1, type: "Action"}){			description		}	}'.	result := self jsonRequest: request.	expectedResult := '{	"errors" : [		{			"message" : "Field \"type\" is not defined by type GQLTestFilmInput",			"locations" : [				{					"line" : 2,					"column" : 34				}			]		}	]}'.	self assert: result equals: expectedResult.	request := '{		informationInput(film: { filmName: "Rambo" }){			description		}	}'.	result := self jsonRequest: request.	expectedResult := '{	"data" : {		"informationInput" : {			"description" : "Rambo"		}	}}'.	self assert: result equals: expectedResult</body></methods><methods><class-id>GraphQLBeta.GQLSTypeTest</class-id> <category>tests-interface</category><body package="GraphQLBeta-Tests-TypeValidation" selector="testInterfaceOutputValue">testInterfaceOutputValue	| request result expectedResult |	schema := self		getSchema: 'outputInterfaceType'		withRoot: GQLTestSchema new.	request := '{		entities{		   name			... on GQLCat{			   nickname		   }		   ... on GQLTestFilm{		      rating		   }		}	}'.	result := self jsonRequest: request.	expectedResult := '{  "data": {    "entities": [      {        "name": "Rambo",		  "rating": 5      },      {        "name": "Harry Potter",		  "rating": 7      },      {        "name": "Misi",		  "nickname": "Misifus"      },      {        "name": "Figaro",		  "nickname": "Figaro"      },      {        "name": "Minino",	  	  "nickname": "Mini"      }    ]  }}'.	self assertJSONEquals: result and: expectedResult.	request := '{		entity{		   name		}	}'.	result := self jsonRequest: request.	expectedResult := '{	"data" : {		"entity" : {			"name" : "Rambo"		}	}}'.	self assertJSONEquals: result and: expectedResult.	request := '{		entities{		   name			rating		}	}'.	result := self jsonRequest: request.	expectedResult := '{  "errors": [    {      "message": "Cannot query field \"rating\" on type \"NamedEntity\". Did you mean to use an inline fragment on \"GQLTestFilm\"?",      "stack": [        "Cannot query field \"rating\" on type \"NamedEntity\". Did you mean to use an inline fragment on \"GQLTestFilm\"?",        "",        "GraphQL request (4:4)",        "3:     name",        "4:     rating",        "       ^",        "5:   }"      ]    }  ]}'</body></methods><methods><class-id>GraphQLBeta.GQLSTypeTest</class-id> <category>tests-wrapping types</category><body package="GraphQLBeta-Tests-TypeValidation" selector="testListNotNullInputValue">testListNotNullInputValue	"The only valid type is a not null list"	| request result expectedResult |	schema := self		getSchema: 'inputListNotNullValue'		withRoot: GQLTestSchema new.	request := '{		totalInformation(film: [  ]){			description		}	}'.	result := self jsonRequest: request.	expectedResult := '{  "data": {    "totalInformation": []  }}'.	self assertJSONEquals: result and: expectedResult.	request := '{		totalInformation(film: null){			description		}	}'.	result := self jsonRequest: request.	expectedResult := '{	"errors" : [		{			"message" : "Argument \"film\" has invalid value null. Expected type \"[GQLTestQueryTypeInput]!\".",			"locations" : [				{					"line" : 2,					"column" : 26				}			]		}	]}'.	self assert: result equals: expectedResult.	request := '{		totalInformation(film: [{description: "Rambo"}, {description: "Terminator"}, null]){			description		}	}'.	result := self jsonRequest: request.	expectedResult := '{	"data" : {		"totalInformation" : [			{				"description" : "Rambo"			},			{				"description" : "Terminator"			},			null		]	}}'.	self assert: result equals: expectedResult.	request := '{		nameGenders(listGender: [COMEDY, SCIENCE_FICTION])	}'.	result := self jsonRequest: request.	expectedResult := '{  "data": {    "nameGenders": [      "COMEDY",      "SCIENCE_FICTION"    ]  }}'.	self assertJSONEquals: result and: expectedResult.	request := '{		nameGenders(listGender: [ COMEDY, null ])	}'.	result := self jsonRequest: request.	expectedResult := '{	"errors" : [		{			"message" : "Argument \"listGender\" has invalid value [COMEDY, null]. Expected type \"[MovieType!]\".",			"locations" : [				{					"line" : 2,					"column" : 27				}			]		}	]}'.	self assert: result equals: expectedResult.	request := '{		listOf(arrays: [[1, 2, 3], [3, 4, 5]])	}'.	result := self jsonRequest: request.	expectedResult := '{  "data": {    "listOf": [      [        1,        2,        3      ],      [        3,        4,        5      ]    ]  }}'.	self assertJSONEquals: result and: expectedResult.	request := '{		listOf(arrays: null)	}'.	result := self jsonRequest: request.	expectedResult := '{	"errors" : [		{			"message" : "Argument \"arrays\" has invalid value null. Expected type \"[[Int!]!]!\".",			"locations" : [				{					"line" : 2,					"column" : 18				}			]		}	]}'.	self assert: result equals: expectedResult.	request := '{		listOf(arrays: [ null ])	}'.	result := self jsonRequest: request.	expectedResult := '{	"errors" : [		{			"message" : "Argument \"arrays\" has invalid value [null]. Expected type \"[[Int!]!]!\".",			"locations" : [				{					"line" : 2,					"column" : 18				}			]		}	]}'.	self assert: result equals: expectedResult.	request := '{		listOf(arrays: [[1, null]])	}'.	result := self jsonRequest: request.	expectedResult := '{	"errors" : [		{			"message" : "Argument \"arrays\" has invalid value [[1, null]]. Expected type \"[[Int!]!]!\".",			"locations" : [				{					"line" : 2,					"column" : 18				}			]		}	]}'.	self assert: result equals: expectedResult</body><body package="GraphQLBeta-Tests-TypeValidation" selector="testNotNullInputValue">testNotNullInputValue	| request result expectedResult |	schema := self		getSchema: 'inputNotNullValue'		withRoot: GQLTestSchema new.	request := '{		helloTo(name: null)	}'.	result := self jsonRequest: request.	expectedResult := '{	"errors" : [		{			"message" : "Argument \"name\" has invalid value null. Expected type \"String!\".",			"locations" : [				{					"line" : 2,					"column" : 17				}			]		}	]}'.	self assert: result equals: expectedResult.	request := '{		isEven(number: null)	}'.	result := self jsonRequest: request.	expectedResult := '{	"errors" : [		{			"message" : "Argument \"number\" has invalid value null. Expected type \"Int!\".",			"locations" : [				{					"line" : 2,					"column" : 18				}			]		}	]}'.	self assert: result equals: expectedResult.	request := '{		point(x: null){			x			y		}	}'.	result := self jsonRequest: request.	expectedResult := '{	"errors" : [		{			"message" : "Argument \"x\" has invalid value null. Expected type \"Float!\".",			"locations" : [				{					"line" : 2,					"column" : 12				}			]		}	]}'.	self assert: result equals: expectedResult.	request := '{		point(x: 2.6){			x			y		}	}'.	result := self jsonRequest: request.	expectedResult := '{	"data" : {		"point" : {			"x" : 2.6,			"y" : null		}	}}'.	self assert: result equals: expectedResult.	request := '{		nameGenders(listGender: [null])	}'.	result := self jsonRequest: request.	expectedResult := '{	"data" : {		"nameGenders" : null	}}'.	self assert: result equals: expectedResult.	request := '{		listOf(arrays: [ [ 1, 2 ], [ 2, 3 ], [ 3, 4 ] ])	}'.	result := self jsonRequest: request.	expectedResult := '{	"data" : {		"listOf" : [			[				1,				2			],			[				2,				3			],			[				3,				4			]		]	}}'.	self assert: result equals: expectedResult.	request := '{		listOf(arrays: [ 1, 2 ])	}'.	result := self jsonRequest: request.	expectedResult := '{	"data" : {		"listOf" : [			[				1			],			[				2			]		]	}}'.	self assert: result equals: expectedResult.	request := '{		listOf(arrays: 1)	}'.	result := self jsonRequest: request.	expectedResult := '{	"data" : {		"listOf" : [			[				1			]		]	}}'.	self assert: result equals: expectedResult.	request := '{		listOf(arrays: null)	}'.	result := self jsonRequest: request.	expectedResult := '{	"errors" : [		{			"message" : "Argument \"arrays\" has invalid value null. Expected type \"[[Int!]!]!\".",			"locations" : [				{					"line" : 2,					"column" : 18				}			]		}	]}'.	self assert: result equals: expectedResult</body></methods><methods><class-id>GraphQLBeta.GQLSTypeTest</class-id> <category>tests-union</category><body package="GraphQLBeta-Tests-TypeValidation" selector="testUnionOutputValue">testUnionOutputValue	| request result expectedResult expectedResult2 |	schema := self		getSchema: 'outputUnionType'		withRoot: GQLTestSchema new.	request := '{		firstSearchObject{			name		}	}'.	result := self jsonRequest: request.	expectedResult := '{  "errors": [    {      "message": "Cannot query field \"name\" on type \"SearchObject\"",      "locations": [        {          "line": 3,          "column": 4        }      ]    }  ]}'.	self assertJSONEquals: result and: expectedResult.	request := '{		firstSearchObject{			... on Point{				x			}		}	}'.	result := self jsonRequest: request.	expectedResult := '{  "data": {    "firstSearchObject": {        "x": 2.4    }  }}'.	expectedResult2 := '{  "data": {    "firstSearchObject": {  }  	 }	}'.	result := GraphQLPlatform current jsonFromString: result.	self		assert:			(result = (GraphQLPlatform current jsonFromString: expectedResult)				or: [ result = (GraphQLPlatform current jsonFromString: expectedResult2) ]).	request := '{		firstSearchObject{			... on Point{				x			}			... on Rectangle{				origin { 					y				}			}		}	}'.	result := self jsonRequest: request.	expectedResult := '{  "data": {    "firstSearchObject": {        "x": 2.4    }  }}'.	expectedResult2 := '{	"data": { 		"firstSearchObject": { 			"origin": { 				"y": 5			 }		 }	 }	}'.	result := GraphQLPlatform current jsonFromString: result.	self		assert:			(result = (GraphQLPlatform current jsonFromString: expectedResult)				or: [ result = (GraphQLPlatform current jsonFromString: expectedResult2) ])</body></methods><methods><class-id>GraphQLBeta.GQLSTypeTest</class-id> <category>tests-enum</category><body package="GraphQLBeta-Tests-TypeValidation" selector="testEnumInputValue">testEnumInputValue	| request result expectedResult |	schema := self getSchema: 'inputEnumType' withRoot: GQLTestSchema new.	request := '{		classification(gender: ACTION)	}'.	result := self jsonRequest: request.	expectedResult := '{	"errors" : [		{			"message" : "Argument \"gender\" has invalid value ACTION. Expected type \"MovieType\".",			"locations" : [				{					"line" : 2,					"column" : 26				}			]		}	]}'.	self assert: result equals: expectedResult.	request := '{		classification(gender: SCIENCE_FICTION)	}'.	result := self jsonRequest: request.	expectedResult := '{	"data" : {		"classification" : "SCIENCE_FICTION"	}}'.	self assert: result equals: expectedResult.	request := '{		classification(gender: "COMEDY")	}'.	result := self jsonRequest: request.	expectedResult := '{	"errors" : [		{			"message" : "Argument \"gender\" has invalid value \"COMEDY\". Expected type \"MovieType\".",			"locations" : [				{					"line" : 2,					"column" : 26				}			]		}	]}'.	self assert: result equals: expectedResult.	request := '{		classification(gender: 1)	}'.	result := self jsonRequest: request.	expectedResult := '{	"errors" : [		{			"message" : "Argument \"gender\" has invalid value 1. Expected type \"MovieType\".",			"locations" : [				{					"line" : 2,					"column" : 26				}			]		}	]}'.	self assert: result equals: expectedResult</body></methods><methods><class-id>GraphQLBeta.GQLSRequestTest</class-id> <category>tests</category><body package="GraphQLBeta-Tests-TypeValidation" selector="testRequest">testRequest	| request result expectedResult |	schema := self		getSchema: 'inputStringType'		withRoot: GQLTestSchema new.	compareJson := true.	request := '{		helloTo(name: "Alex")	'.	result := self jsonRequest: request.	expectedResult := '{	"errors" : [		{			"message" : "Syntax Error: blank expected",			"locations" : [				{					"line" : 3,					"column" : 1				}			]		}	]}'.	self assert: result equals: expectedResult.	request := '{		helloTo(nameOf: "Alex")	}'.	result := self jsonRequest: request.	expectedResult := '{	"errors" : [		{			"message" : "Unknown argument \"nameOf\" on field \"helloTo\" on type \"GQLTestSchema\".",			"locations" : [				{					"line" : 2,					"column" : 11				}			]		}	]}'.	self assert: result equals: expectedResult.	request := '{	}'.	result := self attendRequest: request using: '' with: ''.	expectedResult := '{	"errors" : [		{			"message" : "Syntax Error: $# expected",			"locations" : [				{					"line" : 2,					"column" : 1				}			]		}	]}'.	self assert: (result includesKey: 'errors').	request := '{		hel	}'.	result := self jsonRequest: request.	expectedResult := '{	"errors" : [		{			"message" : "Cannot query field \"hel\" on type \"GQLTestSchema\"",			"locations" : [				{					"line" : 2,					"column" : 3				}			]		}	]}'.	self assert: result equals: expectedResult</body></methods><methods><class-id>GraphQLBeta.GQLSRequestTest</class-id> <category>tests-fragments</category><body package="GraphQLBeta-Tests-TypeValidation" selector="testFragment">testFragment	| request result expectedResult |	schema := self		getSchema: 'inputBooleanType'		withRoot: GQLTestSchema new.	request := '{		hello	}	fragment fragment1 on GQLTestFilm{		name	}	'.	result := self jsonRequest: request.	expectedResult := '{	"errors" : [		{			"message" : "Fragment \"fragment1\" is never used.",			"locations" : [				{					"line" : 4,					"column" : 11				}			]		}	]}'.	self assert: result equals: expectedResult.	request := '{		hello	}	fragment fragment1 on GQLTestFilm{		name	}	fragment fragment1 on GQLTestFilm{		name	}	'.	result := self jsonRequest: request.	expectedResult := '{	"errors" : [		{			"message" : "Fragment \"fragment1\" is never used.",			"locations" : [				{					"line" : 4,					"column" : 11				},				{					"line" : 7,					"column" : 11				}			]		},		{			"message" : "There can be only one fragment named \"fragment1\".",			"locations" : [				{					"line" : 4,					"column" : 11				},				{					"line" : 7,					"column" : 11				}			]		}	]}'.	self assert: result equals: expectedResult.	request := '{		hello	}	fragment fragment1 on GQLTes{		name	}'.	result := self jsonRequest: request.	expectedResult := '{	"errors" : [		{			"message" : "Fragment \"fragment1\" is never used.",			"locations" : [				{					"line" : 4,					"column" : 11				}			]		},		{			"message" : "Unkwown type \"GQLTes\".",			"locations" : [				{					"line" : 4,					"column" : 24				}			]		}	]}'.	self assert: result equals: expectedResult.	request := '{	films(sortedByName: true) {			...gqlTest		}	}	fragment gqlTest on GQLTestFilm{		name		...otherGQLTest	}	fragment otherGQLTest on GQLTestFilm{	   ...gqlTest	}'.	result := self jsonRequest: request.	expectedResult := '{	"errors" : [		{			"message" : "Cannot spread fragment \"gqlTest\" with itself via otherGQLTest",			"locations" : [				{					"line" : 8,					"column" : 6				}			]		},		{			"message" : "Cannot spread fragment \"otherGQLTest\" with itself via gqlTest",			"locations" : [				{					"line" : 11,					"column" : 8				}			]		}	]}'.	self assert: result equals: expectedResult</body></methods><methods><class-id>GraphQLBeta.GraphQLBetaDemoHTML class</class-id> <category>dependencies</category><body package="GraphQLBeta-Demo" selector="htmlPage">htmlPage	"DO NOT EDIT"	^ '&lt;!DOCTYPE html&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;GraphQL editor&lt;/title&gt;&lt;meta name="description" content="GraphQL Editor - write and run your GraphQL code inside this page."&gt;&lt;script&gt;  var protocol = ("https:" == document.location.protocol)? "https" : "http";  document.write(unescape("%3Cscript src=\""+ protocol + "://code.jquery.com/jquery-1.11.0.min.js\" type=\"text/javascript\"%3E%3C/script%3E"));  document.write(unescape("%3Cscript src=\""+ protocol + "://code.jquery.com/jquery-migrate-1.2.1.min.js\" type=\"text/javascript\"%3E%3C/script%3E"));&lt;/script&gt;&lt;link href="https://js.do/js/codemirror-5.32.1/lib/codemirror.css" rel="stylesheet"&gt;&lt;script src="https://js.do/js/codemirror-5.32.1/lib/codemirror.js"&gt;&lt;/script&gt;&lt;style&gt;body{  margin: 0;  font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;  font-size: 14px;  line-height: 20px;  color: #333333;  background-color: #ffffff;}header {  background-color: black;  padding: 5px;}h1{  color: white;}#gql_operation, #gql_variables{  position: absolute;}#results_area, #gql_code{  position: absolute;  top: 120px;  bottom: 60px;}#results_area{  padding-left: 5px;  right: 1em;  left: 50%;}#gql_code, #gql_operation, #gql_variables{  padding-right: 5px;  right: 50%;  left: 1em;}.beauty-input {  -webkit-border-radius: 3px;     -moz-border-radius: 3px;          border-radius: 3px;  background-color: #ffffff;  border: 1px solid #cccccc;  -webkit-box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075);     -moz-box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075);          box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075);  -webkit-transition: border linear 0.2s, box-shadow linear 0.2s;     -moz-transition: border linear 0.2s, box-shadow linear 0.2s;       -o-transition: border linear 0.2s, box-shadow linear 0.2s;          transition: border linear 0.2s, box-shadow linear 0.2s;}.label {  display: inline-block;  padding: 2px 4px;  font-size: 11.844px;  font-weight: bold;  line-height: 14px;  color: #ffffff;  text-shadow: 0 -1px 0 rgba(0, 0, 0, 0.25);  white-space: nowrap;  vertical-align: baseline;  background-color: #999999;  border-radius: 3px;}.top_label {  z-index: 10;  position: absolute;  top: 0px;  right: 10px;  opacity: 0.5;}#col_resize{  position: absolute;  left: 50%;  right: 50%;  top: 140px;  bottom: 60px;  width: 10px;  margin-left: -5px;  cursor: col-resize;  z-index: 3;  text-align: center;  vertical-align: middle;  line-height: 50;  color: #bbb;  text-shadow: 1px 0px #ddd;}footer{  position: absolute;  text-align: center;  bottom: 10px;  left: 1em;  right: 1em;}.buttons{  margin-top: 20px;  position: absolute;  top: 69px;  right: 1em;  left: 1em;}.btn{  display: inline-block;  padding: 4px 12px;  margin-bottom: 0;  font-size: 14px;  line-height: 20px;  color: #333333;  text-align: center;  text-shadow: 0 1px 1px rgba(255, 255, 255, 0.75);  vertical-align: middle;  cursor: pointer;  background-color: #f5f5f5;  background-image: -moz-linear-gradient(top, #ffffff, #e6e6e6);  background-image: -webkit-gradient(linear, 0 0, 0 100%, from(#ffffff), to(#e6e6e6));  background-image: -webkit-linear-gradient(top, #ffffff, #e6e6e6);  background-image: -o-linear-gradient(top, #ffffff, #e6e6e6);  background-image: linear-gradient(to bottom, #ffffff, #e6e6e6);  background-repeat: repeat-x;  border: 1px solid #bbbbbb;  border-color: #e6e6e6 #e6e6e6 #bfbfbf;  border-color: rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.25);  border-bottom-color: #a2a2a2;  -webkit-border-radius: 4px;  -moz-border-radius: 4px;  border-radius: 4px;  filter: progid:DXImageTransform.Microsoft.gradient(startColorstr="#ffffffff", endColorstr="#ffe6e6e6", GradientType=0);  filter: progid:DXImageTransform.Microsoft.gradient(enabled=false);  -webkit-box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2), 0 1px 2px rgba(0, 0, 0, 0.05);  -moz-box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2), 0 1px 2px rgba(0, 0, 0, 0.05);  box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2), 0 1px 2px rgba(0, 0, 0, 0.05);}.btn:hover {  color: #333333;  text-decoration: none;  background-color: #e6e6e6;  *background-color: #d9d9d9;  /* Buttons in IE7 don"t get borders, so darken on hover */  background-position: 0 -15px;  -webkit-transition: background-position 0.1s linear;     -moz-transition: background-position 0.1s linear;       -o-transition: background-position 0.1s linear;          transition: background-position 0.1s linear;}.btn:focus {  outline: thin dotted #333;  outline: 5px auto -webkit-focus-ring-color;  outline-offset: -2px;}.btn.active,.btn:active {  background-color: #e6e6e6;  background-color: #d9d9d9 \9;  background-image: none;  outline: 0;  -webkit-box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.15), 0 1px 2px rgba(0, 0, 0, 0.05);     -moz-box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.15), 0 1px 2px rgba(0, 0, 0, 0.05);          box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.15), 0 1px 2px rgba(0, 0, 0, 0.05);}a{  text-decoration: none;}.btn-small [class^="icon-"], .btn-small [class*=" icon-"] {    margin-top: 0;}.btn-small{  margin-top: 0;  font-size: 11.9px;  padding: 2px 10px;  font-size: 11.9px;  border-radius: 3px;}[class^="icon-"], [class*=" icon-"] {  display: inline-block;  width: 14px;  height: 14px;  margin-top: 1px;  line-height: 14px;  vertical-align: text-top;  background-image: url(https://js.do/bootstrap/img/glyphicons-halflings.png);  background-position: 14px 14px;  background-repeat: no-repeat;}.icon-play {  background-position: -264px -72px;}.icon-file {  background-position: -24px -24px;}.icon-options{  background-position: -264px 0;}.overlayer{  position: absolute;  z-index: 30;  width: 100%;  height: 100%;  display: none;}.exampleOptions{  padding: 5px;  width: 100px;  border: solid 1px gray;  position: absolute;  z-index: 40;  background: white;}.exampleOptions a{  display: block;}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;  &lt;div class="overlayer"&gt;    &lt;div class="exampleOptions"&gt;      &lt;a href="javascript:;" onclick="example(this);return false;"&gt;Films&lt;/a&gt;      &lt;a href="javascript:;" onclick="example(this);return false;"&gt;Heros&lt;/a&gt;      &lt;a href="javascript:;" onclick="example(this);return false;"&gt;Operation&lt;/a&gt;    &lt;/div&gt;  &lt;/div&gt;  &lt;header&gt;    &lt;h1&gt;ProtoGraphQL in Smalltalk&lt;/h1&gt;  &lt;/header&gt;  &lt;form method="get" id="gql_form"&gt;    &lt;input id="query" name="query" type= "hidden"&gt;    &lt;input id="operation" name="operation" type= "hidden"&gt;    &lt;input id="variables" name="variables" type= "hidden"&gt;    &lt;div class="buttons"&gt;      &lt;a href="javascript:;" class="btn xbtn-info btn-small" onclick="run_code(); return false;"&gt;        &lt;i class="icon-play"&gt;&lt;/i&gt;        &amp;nbsp; Run&lt;/a&gt;      &lt;a href="javascript:;" class="btn xbtn-info btn-small" onclick="moreOptions(); return false;"&gt;          &lt;i class="icon-options"&gt;&lt;/i&gt;          &amp;nbsp; Options&lt;/a&gt;      &lt;a href="javascript:;" class="btn xbtn-info btn-small" onclick="showExamples(this); return false;"&gt;        &lt;i class="icon-file"&gt;&lt;/i&gt;        &amp;nbsp; Examples      &lt;/a&gt;      &lt;label&gt;&lt;input type="checkbox" id="shouldValidate" checked&gt;Use validation&lt;/label&gt;    &lt;/div&gt;    &lt;div id="gql_code"&gt;      &lt;span class="label top_label"&gt;GraphQL&lt;/span&gt;    &lt;/div&gt;    &lt;div id="moreOptions"&gt;      &lt;div id="gql_operation"&gt;        &lt;span class="label top_label"&gt;Operation&lt;/span&gt;      &lt;/div&gt;      &lt;div id="gql_variables"&gt;        &lt;span class="label top_label"&gt;Variables&lt;/span&gt;      &lt;/div&gt;    &lt;/div&gt;  &lt;/form&gt;  &lt;div id="col_resize"&gt;||&lt;/div&gt;  &lt;div id="results_area" class="code_area_result"&gt;    &lt;span class="label top_label"&gt;Result&lt;/span&gt;  &lt;/div&gt;  &lt;footer&gt;SemanTICs S.R.L.&amp; Object Profile&lt;/footer&gt;  &lt;script&gt;  var codeMirror, resultsMirror, operationMirror, variablesMirror;  var examples = [];  examples["Heros"]="{\n# You need to have the class Hero, https://github.com/OBJECTSEMANTICS/GraphQL\n  heros{\n    name\n    planet\n  }\n}\n";  examples["Films"] = "{\n	allFilms{\n		name	\n	}\n}";  examples["Operation"] = [`query operation1($name : String, $person : PersonInput, $gender : FilmType){\tfilm(name:$name){\t\tname\t\trating\t}\tfilmsOn(gender: $gender){\t\tname\t\trating\t}\tfilmsDirected(by:$person){\t\tname\t}}query operation2 {\thello}`, "operation1", "{ \"name\":\"terminator\", \"person\":{name:\"George Lucas\"}, \"gender\":ACTION }"];  $(function(){    codeMirror = CodeMirror(document.getElementById("gql_code"),{      "lineNumbers": true,      "indentUnit": 0,      "theme": "default",      "smartIndent": false,      "enterMode": "flat",      "styleActiveLine": true,      "autofocus": true    });    resultsMirror = createMirror("results_area");    operationMirror = createMirror("gql_operation");    variablesMirror = createMirror("gql_variables");    $(".CodeMirror").addClass("beauty-input");    window.onresize = function() {      recalculate_windows_size();    }    window.onload = function() {      recalculate_windows_size();      resultsMirror.refresh();    }  });  function createMirror(id){    return CodeMirror(document.getElementById(id),{      "lineNumbers": true,      "indentUnit": 0,      "theme": "default",      "smartIndent": false,      "enterMode": "flat",      "styleActiveLine": true,      "autofocus": false    });  }  $(".overlayer").click(function(){ $(".overlayer").hide()});  $("#col_resize").on("mousedown mouseup mouseover", function(event) {    event.preventDefault();    if (event.type == "mousedown") {      var w = $(window).width();      $(document).on("mousemove", function(event2) {        var percent = (event2.pageX/w * 100);        if (percent&gt;95) {          if (percent&gt;97) { // if mouse out of browser, disable drag.            disable_drag();          }          percent=95;        } else if (percent &lt; 5) {          if (percent&lt;3) { // if mouse out of browser, disable drag.            disable_drag();          }          percent = 5;        }        $("#gql_code, #gql_operation, #gql_variables").css("right", (100-percent)+"%");        $("#col_resize").css("right", (100-percent)+"%").css("left", (percent)+"%");        $("#results_area").css("left", (percent)+"%");      });    } else if (event.type == "mouseup") {      disable_drag();    }    function disable_drag() {      $(document).off("mousemove");    }  });  function recalculate_windows_size() {    var h = document.getElementById("gql_code").clientHeight;    $(".CodeMirror").height(h);    var el = $("#moreOptions");    if(el.css("display") == "none") return;    $("#gql_code .CodeMirror").height(h * 0.59);    $("#gql_operation").css({top: 120 + h * 0.61 });    $("#gql_variables").css({top: 120 + h * 0.82 });    $("#gql_operation .CodeMirror, #gql_variables .CodeMirror").height(h*0.18);  }  function example(id){    var arr = examples[$(id).html()], x, y, z;    if(typeof arr === "string"){      x = arr;      y = z = "";    }else{      if($("#moreOptions").css("display") == "none")        moreOptions();      x = arr[0];      y = arr[1];      z = arr[2];    }    codeMirror.setValue(x);    operationMirror.setValue(y);    variablesMirror.setValue(z);    codeMirror.markClean();    operationMirror.markClean();    variablesMirror.markClean();  }  function showExamples(obj){    $(".overlayer").show();    var bb = $(obj).get(0).getBoundingClientRect();    $(".exampleOptions").css({top: bb.y + bb.height, left: bb.x});  }  function moreOptions(){    var el = $("#moreOptions");    if(el.css("display") !== "none")      el.hide();    else el.show();    recalculate_windows_size();  }  function run_code(){    $("#query").val(codeMirror.getValue());    $("#operation").val(operationMirror.getValue());    $("#variables").val(variablesMirror.getValue());    $.ajax({      url:"",      type:"POST",      data:{        query: codeMirror.getValue(),        operationName: operationMirror.getValue(),        variables: variablesMirror.getValue(),        shouldValidate: $("#shouldValidate").prop("checked")      },      contentType:"application/json; charset=utf-8",      success: function(data){        resultsMirror.setValue(JSON.stringify(data,null,"\t"));      },      error: function(request, status, error){        resultsMirror.setValue(request.responseText);      }    });  }  &lt;/script&gt;&lt;/html&gt;'</body></methods><methods><class-id>GraphQLBeta.GQLSelectionSetNodeTest</class-id> <category>tests-accessing</category><body package="GraphQLBeta-Tests-Nodes" selector="testCollectFieldsDistintComposed">testCollectFieldsDistintComposed	| res |	objectNode1 name: 'film'.	innerEscalar := Array with: (GQLFieldNode new name: 'name').	objectNode1		selectionSet: (GQLSelectionSetNode new selections: innerEscalar).	objectNode2 name: 'allFilms'.	innerEscalar := Array with: (GQLFieldNode new name: 'rating').	objectNode2		selectionSet: (GQLSelectionSetNode new selections: innerEscalar).	selectionSet selections: (Array with: objectNode1 with: objectNode2).	res := selectionSet collectFields: context.	self assert: res keys size equals: 2</body><body package="GraphQLBeta-Tests-Nodes" selector="testCollectFieldsDistintSimple">testCollectFieldsDistintSimple	| res |	field1 name: 'hello'.	field2 name: 'text'.	selectionSet selections: (Array with: field1 with: field2).	res := selectionSet collectFields: context.	self assert: res keys size equals: 2</body><body package="GraphQLBeta-Tests-Nodes" selector="testCollectFieldsSameComposed">testCollectFieldsSameComposed	| res |	objectNode1 name: 'film'.	innerEscalar := Array with: (GQLFieldNode new name: 'name').	objectNode1		selectionSet: (GQLSelectionSetNode new selections: innerEscalar).	objectNode2 name: 'film'.	innerEscalar := Array with: (GQLFieldNode new name: 'rating').	objectNode2		selectionSet: (GQLSelectionSetNode new selections: innerEscalar).	selectionSet selections: (Array with: objectNode1 with: objectNode2).	res := selectionSet collectFields: context.	self assert: res keys size equals: 1</body><body package="GraphQLBeta-Tests-Nodes" selector="testCollectFieldsSameSimple">testCollectFieldsSameSimple	| res |	field1 name: 'hello'.	field2 name: 'hello'.	selectionSet selections: (Array with: field1 with: field2).	res := selectionSet collectFields: context.	self assert: res keys size equals: 1</body><body package="GraphQLBeta-Tests-Nodes" selector="testFailCollectFieldsComposed">testFailCollectFieldsComposed	| res argument |	argument := GQLArgumentNode new		name: 'id';		value: '1'.	objectNode1		name: 'film';		arguments: (Array with: argument).	innerEscalar := Array with: (GQLFieldNode new name: 'name').	objectNode1		selectionSet: (GQLSelectionSetNode new selections: innerEscalar).	objectNode2 name: 'film'.	innerEscalar := Array with: (GQLFieldNode new name: 'rating').	objectNode2		selectionSet: (GQLSelectionSetNode new selections: innerEscalar).	selectionSet selections: (Array with: objectNode1 with: objectNode2).	self		should: [ selectionSet collectFields: context ]		raise: GQLException</body><body package="GraphQLBeta-Tests-Nodes" selector="testFailCollectFieldsSimple">testFailCollectFieldsSimple	| argument |	argument := GQLArgumentNode new		name: 'id';		value: '4'.	field1		name: 'hello';		arguments: (Array with: argument).	field2 name: 'hello'.	selectionSet selections: (Array with: field1 with: field2).	self		should: [ selectionSet collectFields: context ]		raise: GQLException</body><body package="GraphQLBeta-Tests-Nodes" selector="testFailSameShapeWithNonScalarFieldArguments">testFailSameShapeWithNonScalarFieldArguments	| argument |	argument := GQLArgumentNode new		name: 'id';		value: '1'.	objectNode1		name: 'film';		arguments: (Array with: argument).	innerEscalar := Array with: (GQLFieldNode new name: 'name').	objectNode1		selectionSet: (GQLSelectionSetNode new selections: innerEscalar).	argument := GQLArgumentNode new		name: 'id';		value: '2'.	objectNode2		name: 'film';		arguments: (Array with: argument).	innerEscalar := Array with: (GQLFieldNode new name: 'rating').	objectNode2		selectionSet: (GQLSelectionSetNode new selections: innerEscalar).	self deny: (selectionSet sameShape: objectNode1 with: objectNode2)</body><body package="GraphQLBeta-Tests-Nodes" selector="testFailSameShapeWithScalarFieldArguments">testFailSameShapeWithScalarFieldArguments	| argument |	argument := GQLArgumentNode new		name: 'id';		value: '4'.	field1		name: 'hello';		arguments: (Array with: argument).	argument := GQLArgumentNode new		name: 'id';		value: '2'.	field2		name: 'hello';		arguments: (Array with: argument).	selectionSet selections: (Array with: field1 with: field2).	self deny: (selectionSet sameShape: field1 with: field2)</body><body package="GraphQLBeta-Tests-Nodes" selector="testMergeSelectionSetWith">testMergeSelectionSetWith	objectNode1 name: 'film'.	innerEscalar := Array with: (GQLFieldNode new name: 'name').	objectNode1		selectionSet: (GQLSelectionSetNode new selections: innerEscalar).	objectNode2 name: 'film'.	innerEscalar := Array with: (GQLFieldNode new name: 'rating').	objectNode2		selectionSet: (GQLSelectionSetNode new selections: innerEscalar).	selectionSet mergeSelectionSet: objectNode1 with: objectNode2.	self assert: objectNode1 selectionSet selections size equals: 2</body><body package="GraphQLBeta-Tests-Nodes" selector="testSameShapeWithNonScalarField">testSameShapeWithNonScalarField	objectNode1 name: 'film'.	innerEscalar := Array with: (GQLFieldNode new name: 'name').	objectNode1		selectionSet: (GQLSelectionSetNode new selections: innerEscalar).	objectNode2 name: 'film'.	innerEscalar := Array with: (GQLFieldNode new name: 'rating').	objectNode2		selectionSet: (GQLSelectionSetNode new selections: innerEscalar).	self assert: (selectionSet sameShape: objectNode1 with: objectNode2)</body><body package="GraphQLBeta-Tests-Nodes" selector="testSameShapeWithNonScalarFieldArguments">testSameShapeWithNonScalarFieldArguments	| argument |	argument := GQLArgumentNode new		name: 'id';		value: '1'.	objectNode1		name: 'film';		arguments: (Array with: argument).	innerEscalar := Array with: (GQLFieldNode new name: 'name').	objectNode1		selectionSet: (GQLSelectionSetNode new selections: innerEscalar).	objectNode2		name: 'film';		arguments: (Array with: argument).	innerEscalar := Array with: (GQLFieldNode new name: 'rating').	objectNode2		selectionSet: (GQLSelectionSetNode new selections: innerEscalar).	self assert: (selectionSet sameShape: objectNode1 with: objectNode2)</body><body package="GraphQLBeta-Tests-Nodes" selector="testSameShapeWithScalarField">testSameShapeWithScalarField	field1 name: 'hello'.	field2 name: 'hello'.	selectionSet selections: (Array with: field1 with: field2).	self assert: (selectionSet sameShape: field1 with: field2)</body><body package="GraphQLBeta-Tests-Nodes" selector="testSameShapeWithScalarFieldArguments">testSameShapeWithScalarFieldArguments	| argument |	argument := GQLArgumentNode new		name: 'id';		value: '4'.	field1		name: 'hello';		arguments: (Array with: argument).	field2		name: 'hello';		arguments: (Array with: argument).	selectionSet selections: (Array with: field1 with: field2).	self assert: (selectionSet sameShape: field1 with: field2)</body></methods><methods><class-id>GraphQLBeta.GQLSelectionSetNodeTest</class-id> <category>running</category><body package="GraphQLBeta-Tests-Nodes" selector="setUp">setUp	selectionSet := GQLSelectionSetNode new.	objectNode1 := GQLNonScalarFieldNode new.	objectNode2 := GQLNonScalarFieldNode new.	field1 := GQLScalarFieldNode new.	field2 := GQLScalarFieldNode new.	context := GQLContext new</body></methods><methods><class-id>GraphQLBeta.GQLNode</class-id> <category>initialization</category><body package="GraphQLBeta-Nodes" selector="initialize">initialize	comments := OrderedCollection new</body></methods><methods><class-id>GraphQLBeta.GQLNode</class-id> <category>adding</category><body package="GraphQLBeta-Nodes" selector="addComments:">addComments: aArray	aArray		do: [ :aArr | 			aArr isNotNil				ifTrue: [ comments addAll: aArr ] ]</body></methods><methods><class-id>GraphQLBeta.GQLNode</class-id> <category>accessing</category><body package="GraphQLBeta-Nodes" selector="comments">comments	^ comments</body><body package="GraphQLBeta-Nodes" selector="comments:">comments: anObject	comments := anObject</body></methods><methods><class-id>GraphQLBeta.GQLNode</class-id> <category>action</category><body package="GraphQLBeta-Nodes" selector="executeOn:with:using:">executeOn: resolver with: context using: schema	"This is responsability of the subclass"	self shouldBeImplemented</body></methods><methods><class-id>GraphQLBeta.GQLNode</class-id> <category>visiting</category><body package="GraphQLBeta-Nodes" selector="accept:">accept: visitor	visitor visitSelectionSetNode: self</body></methods><methods><class-id>GraphQLBeta.GQLNode class</class-id> <category>accessing</category><body package="GraphQLBeta-Nodes" selector="nodeName">nodeName	^ self class name</body></methods><methods><class-id>GraphQLBeta.GQLDefinitionNode</class-id> <category>testing</category><body package="GraphQLBeta-Nodes" selector="isOperation">isOperation	^ self subclassResponsibility</body></methods><methods><class-id>GraphQLBeta.GQLObjectFieldNode</class-id> <category>accessing</category><body package="GraphQLBeta-Nodes" selector="name">name	"Return the name"	^ name</body><body package="GraphQLBeta-Nodes" selector="name:">name: anObject	"Set the name"	name := anObject</body><body package="GraphQLBeta-Nodes" selector="value">value	"Return the value"	^ value</body><body package="GraphQLBeta-Nodes" selector="value:">value: anObject	"Set the value"	value := anObject</body></methods><methods><class-id>GraphQLBeta.GQLObjectFieldNode</class-id> <category>printing</category><body package="GraphQLBeta-Nodes" selector="printOn:">printOn: stream	stream		nextPutAll: name;		nextPutAll: ': '.	value printOn: stream</body></methods><methods><class-id>GraphQLBeta.GQLObjectFieldNode</class-id> <category>action</category><body package="GraphQLBeta-Nodes" selector="executeOn:with:using:">executeOn: resolver with: context using: schema	^ value executeOn: resolver with: context using: schema</body></methods><methods><class-id>GraphQLBeta.GQLDocumentNode</class-id> <category>initialization</category><body package="GraphQLBeta-Nodes" selector="initialize">initialize	super initialize.	fragments := OrderedCollection new.	operations := OrderedCollection new</body></methods><methods><class-id>GraphQLBeta.GQLDocumentNode</class-id> <category>accessing</category><body package="GraphQLBeta-Nodes" selector="definitions:">definitions: aList	"Set operations or fragments"	operations := aList select: [ :def | def isOperation ].	fragments := aList reject: [ :def | def isOperation ]</body><body package="GraphQLBeta-Nodes" selector="fragments">fragments	"Return the fragments"	^ fragments</body><body package="GraphQLBeta-Nodes" selector="fragments:">fragments: aArray	"Set the fragments"	fragments := aArray</body><body package="GraphQLBeta-Nodes" selector="operations">operations	"Return the operations"	^ operations</body><body package="GraphQLBeta-Nodes" selector="operations:">operations: aArray	"Set the operations"	operations := aArray</body><body package="GraphQLBeta-Nodes" selector="spreads">spreads	"Return all the fragment spreads on the operations and the fragments"	| spreads |	spreads := Set new.	operations		do: [ :operation | spreads addAll: operation targetSpreads ].	fragments do: [ :fragment | spreads addAll: fragment targetSpreads ].	^ spreads</body></methods><methods><class-id>GraphQLBeta.GQLDocumentNode</class-id> <category>public access</category><body package="GraphQLBeta-Nodes" selector="evaluate">evaluate	"Validate the fragments"	| fragmentsNames spreads |	fragmentsNames := fragments collect: #name.	spreads := self spreads.	fragmentsNames size = fragmentsNames asSet size		ifFalse: [ ^ GQLException new				messageText: 'Duplicated name fragment';				raise ].	fragments		detect: [ :fragment | self hasCycle: fragment with: Set new ]		ifFound: [ :fragment | 			^ GQLException new				node: fragment;				messageText: 'Cycles on fragment';				raise ].	fragments size = spreads size		ifFalse: [ ^ GQLException new				messageText: 'Unused fragments';				raise ].	spreads		detect: [ :spread | (fragmentsNames includes: spread name) not ]		ifFound: [ :spread | 			^ GQLException new				node: spread;				messageText: 'Undefined fragment';				raise ]</body><body package="GraphQLBeta-Nodes" selector="getFragment:">getFragment: aName	"Return the fragment with aName"	^ fragments		detect: [ :fragment | fragment name = aName ]		ifFound: [ :fragment | fragment ]		ifNone: [ nil ]</body><body package="GraphQLBeta-Nodes" selector="hasCycle:with:">hasCycle: aFragment with: visited	^ aFragment targetSpreads asArray		anySatisfy: [ :spread | 			| frag nextVisited res |			(visited includes: spread)				ifTrue: [ ^ true ].			frag := self getFragment: spread name.			frag ifNil: [ ^ false ].			nextVisited := Set new.			nextVisited add: spread.			nextVisited addAll: visited.			res := self hasCycle: frag with: nextVisited.			res				ifTrue: [ visited add: spread ].			res ]</body></methods><methods><class-id>GraphQLBeta.GQLDocumentNode</class-id> <category>action</category><body package="GraphQLBeta-Nodes" selector="executeOn:with:using:">executeOn: root with: context using: schema	"Given a root, a context and the schema, execute this document"	| result |	(context operationName isNil or: [ context operationName size = 0 ])		ifTrue:			[ result := self executeShorthandOn: root with: context using: schema ]		ifFalse: [ | validVariables |			validVariables := self validVariablesDocument: context.			(validVariables isMemberOf: GQLException)				ifTrue: [ result := validVariables ]				ifFalse:					[ result := self executeOperationOn: root with: context using: schema ] ].	"The result is added a dictionary according the specification of GraphQL 	found in: http://facebook.github.io/graphql/draft/#ExecuteQuery()	"	result class = GQLException		ifTrue: [ ^ result ]		ifFalse: [ ^ Dictionary new				at: 'data' put: result;				yourself ]</body><body package="GraphQLBeta-Nodes" selector="executeOperationOn:with:using:">executeOperationOn: root with: context using: schema	"Execute the operation of name defined on the context, if there isnt an operation with the name raise an exception"	operations		detect: [ :op | op name = context operationName ]		ifFound: [ :op | ^ op executeOn: root with: context using: schema ]		ifNone: [ ^ GQLException new				messageText: 'Operation with name ' , context operationName , ' not defined';				raise ]</body><body package="GraphQLBeta-Nodes" selector="executeShorthandOn:with:using:">executeShorthandOn: root with: context using: schema	"Execute the shorthand operation only if is the only one, if not raise an exception that must be require operationName"	operations size = 1		ifTrue: [ ^ operations first executeOn: root with: context using: schema ]		ifFalse: [ ^ GQLException new				messageText: 'Query error, require operationName';				raise ]</body><body package="GraphQLBeta-Nodes" selector="validVariablesDocument:">validVariablesDocument: context	| variables |	variables := self variablesOn: context.	(variables isMemberOf: GQLException)		ifTrue: [ ^ variables ]		ifFalse: [ context variables: variables.			context variables values				detect: [ :var | 					var type isNil						or: [ var type class = GQLSNonNullTypeNode								and: [ var defaultValue isNotNil ] ] ]				ifFound: [ ^ GQLException new						node: self;						messageText: 'All variables must be defined on operations';						raise ] ]</body><body package="GraphQLBeta-Nodes" selector="variablesOn:">variablesOn: context	| collectedVariables |	collectedVariables := OrderedCollection new.	operations		do: [ :op | 			| varDefinitions colVar |			colVar := op collectVariables: context.			(colVar isMemberOf: GQLException)				ifTrue: [ ^ colVar ]				ifFalse: [ varDefinitions := op validVariables.					collectedVariables addAll: varDefinitions					"colVar asSet = (varDefinitions  collect: [ :var | var name value ]) asSet			ifTrue: [ collectedVariables addAll: varDefinitions ]			ifFalse: [ self halt.^ GQLException new node: self; 					messageText: 'Error with variables'; raise ]" ] ].	^ collectedVariables</body></methods><methods><class-id>GraphQLBeta.GQLDocumentNode</class-id> <category>visiting</category><body package="GraphQLBeta-Nodes" selector="accept:">accept: aVisitor	aVisitor visitDocumentNode: self</body></methods><methods><class-id>GraphQLBeta.GQLArgumentNode</class-id> <category>accessing</category><body package="GraphQLBeta-Nodes" selector="name">name	"Return the name"	^ name</body><body package="GraphQLBeta-Nodes" selector="name:">name: anObject	"Set the name"	name := anObject</body><body package="GraphQLBeta-Nodes" selector="resolver:using:">resolver: aType using: schema	| symbol cls |	symbol := self value name: aType name using: schema.	symbol ifNil: [ ^ nil ].	symbol := symbol asSymbol.	cls := Smalltalk classNamed: symbol.	cls ifNil: [ self error: 'Missing class' ].	^ cls new</body><body package="GraphQLBeta-Nodes" selector="resolverArg:with:ofType:">resolverArg: resolver with: field ofType: aType	| resolverArg |	aType isScalarType		ifTrue: [ ^ resolver ]		ifFalse: [ aType isWrappedType				ifTrue: [ resolverArg := self						resolverArg: resolver						with: field						ofType: aType wrappedType ]				ifFalse: [ | nameResolver allClasses class |					nameResolver := (aType nameUsing: self value) asSymbol.					allClasses := Smalltalk allClasses.					class := allClasses						detect: [ :c | c name = nameResolver ]						ifNone: [ self error: 'not valid' ].					resolverArg := class new ] ].	^ resolverArg</body><body package="GraphQLBeta-Nodes" selector="resolverArg:with:ofType:using:">resolverArg: resolver with: field ofType: aType using: schema	aType isScalarType		ifTrue: [ ^ resolver ]		ifFalse: [ aType isWrappedType				ifTrue: [ ^ self						resolverArg: resolver						with: field						ofType: aType wrappedType						using: schema ]				ifFalse: [ ^ self resolver: aType using: schema ] ]</body><body package="GraphQLBeta-Nodes" selector="value">value	"Return the value"	^ value</body><body package="GraphQLBeta-Nodes" selector="value:">value: anObject	"Set the value"	value := anObject</body></methods><methods><class-id>GraphQLBeta.GQLArgumentNode</class-id> <category>comparing</category><body package="GraphQLBeta-Nodes" selector="=">= another	^ name = another name and: [ value = another value ]</body><body package="GraphQLBeta-Nodes" selector="partialEquals:using:">partialEquals: other using: context	"Given other argument, verify if have the same name and return the same type of value"	^ self name = other name		and: [ | type |			type := other type wrappedType name.			self value class = GQLVariableNode				ifTrue: [ other type asString						beginsWith: (context variables at: self value value) type asString ]				ifFalse: [ self value nodeName = type ] ]</body></methods><methods><class-id>GraphQLBeta.GQLArgumentNode</class-id> <category>action</category><body package="GraphQLBeta-Nodes" selector="executeOn:with:using:">executeOn: resolver with: context using: schema	"Pass to execute the argument value"	^ value executeOn: resolver with: context using: schema</body></methods><methods><class-id>GraphQLBeta.GQLArgumentNode</class-id> <category>visiting</category><body package="GraphQLBeta-Nodes" selector="accept:">accept: visitor	visitor visitArgumentNode: self</body></methods><methods><class-id>GraphQLBeta.GQLArgumentNode</class-id> <category>printing</category><body package="GraphQLBeta-Nodes" selector="printValueOn:">printValueOn: stream	self value printOn: stream</body></methods><methods><class-id>GraphQLBeta.GQLValueNode</class-id> <category>testing</category><body package="GraphQLBeta-Nodes" selector="isObjectNode">isObjectNode	^ false</body><body package="GraphQLBeta-Nodes" selector="isVariableNode">isVariableNode	^ false</body></methods><methods><class-id>GraphQLBeta.GQLValueNode</class-id> <category>accessing</category><body package="GraphQLBeta-Nodes" selector="name:using:">name: aName using: schema	^ nil</body><body package="GraphQLBeta-Nodes" selector="nodeName">nodeName	self subclassResponsibility</body><body package="GraphQLBeta-Nodes" selector="value">value	"Return the value"	^ value</body><body package="GraphQLBeta-Nodes" selector="value:">value: anObject	"Set the value"	value := anObject</body><body package="GraphQLBeta-Nodes" selector="valueWith:">valueWith: context	"Set the value"	^ value</body></methods><methods><class-id>GraphQLBeta.GQLValueNode</class-id> <category>printing</category><body package="GraphQLBeta-Nodes" selector="printOn:">printOn: stream	value printOn: stream</body></methods><methods><class-id>GraphQLBeta.GQLValueNode</class-id> <category>comparing</category><body package="GraphQLBeta-Nodes" selector="=">= other	^ self value = other value</body></methods><methods><class-id>GraphQLBeta.GQLValueNode</class-id> <category>action</category><body package="GraphQLBeta-Nodes" selector="executeOn:with:using:">executeOn: resolver with: context using: schema	self subclassResponsibility</body></methods><methods><class-id>GraphQLBeta.GQLValueNode</class-id> <category>as yet unclassified</category><body package="GraphQLBeta-Nodes" selector="valueVariables">valueVariables	^ Dictionary new</body></methods><methods><class-id>GraphQLBeta.GQLFloatNode</class-id> <category>printing</category><body package="GraphQLBeta-Nodes" selector="printOn:">printOn: stream	value asNumber printOn: stream</body></methods><methods><class-id>GraphQLBeta.GQLFloatNode</class-id> <category>action</category><body package="GraphQLBeta-Nodes" selector="executeOn:with:using:">executeOn: resolver with: context using: schema	"Execute the input value according to the resolver, the enviroment and the schema"	^ value asNumber</body></methods><methods><class-id>GraphQLBeta.GQLEnumNode</class-id> <category>accessing</category><body package="GraphQLBeta-Nodes" selector="name:using:">name: aName using: schema	^ self class name</body></methods><methods><class-id>GraphQLBeta.GQLEnumNode</class-id> <category>printing</category><body package="GraphQLBeta-Nodes" selector="printOn:">printOn: stream	stream nextPutAll: value</body></methods><methods><class-id>GraphQLBeta.GQLEnumNode</class-id> <category>action</category><body package="GraphQLBeta-Nodes" selector="executeOn:with:using:">executeOn: aGQLEnumNode with: aGQLContext using: aGQLSSchemaNode	^ value</body></methods><methods><class-id>GraphQLBeta.GQLIntNode</class-id> <category>accessing</category><body package="GraphQLBeta-Nodes" selector="nodeName">nodeName	^ 'Int'</body></methods><methods><class-id>GraphQLBeta.GQLIntNode</class-id> <category>printing</category><body package="GraphQLBeta-Nodes" selector="printOn:">printOn: stream	value asInteger printOn: stream</body></methods><methods><class-id>GraphQLBeta.GQLIntNode</class-id> <category>action</category><body package="GraphQLBeta-Nodes" selector="executeOn:with:using:">executeOn: resolver with: context using: schema	"Execute the input value according to the resolver, the enviroment and the schema"	^ value asInteger</body></methods><methods><class-id>GraphQLBeta.GQLBooleanNode</class-id> <category>accessing</category><body package="GraphQLBeta-Nodes" selector="nodeName">nodeName	^ 'Boolean'</body></methods><methods><class-id>GraphQLBeta.GQLBooleanNode</class-id> <category>printing</category><body package="GraphQLBeta-Nodes" selector="printOn:">printOn: stream	stream nextPutAll: value</body></methods><methods><class-id>GraphQLBeta.GQLBooleanNode</class-id> <category>action</category><body package="GraphQLBeta-Nodes" selector="executeOn:with:using:">executeOn: resolver with: context using: schema	"Execute the input value according to the resolver, the enviroment and the schema"	^ value = 'true'</body></methods><methods><class-id>GraphQLBeta.GQLVariableNode</class-id> <category>testing</category><body package="GraphQLBeta-Nodes" selector="isVariableNode">isVariableNode	^ true</body></methods><methods><class-id>GraphQLBeta.GQLVariableNode</class-id> <category>accessing</category><body package="GraphQLBeta-Nodes" selector="name:using:">name: aName using: schema	(schema schemaTypes includesKey: aName)		ifTrue: [ ^ (schema schemaTypes at: aName) nameOfClass: aName ]		ifFalse: [ ^ aName ]</body><body package="GraphQLBeta-Nodes" selector="value:executeOn:with:using:">value: aVarDefinition executeOn: resolver with: context using: schema	| varValue |	varValue := aVarDefinition currentValue.	varValue isObjectNode		ifTrue: [ varValue objectFields				do: [ :objField | 					resolver						perform: (objField name , ':') asSymbol						with: (objField value executeOn: resolver with: context using: schema) ] ].	^ varValue executeOn: resolver with: context using: schema</body><body package="GraphQLBeta-Nodes" selector="valueVariables">valueVariables	^ Dictionary new		at: value put: self;		yourself</body><body package="GraphQLBeta-Nodes" selector="valueWith:">valueWith: context	^ context variables		at: value		ifPresent: [ :var | var currentValue value ]		ifAbsent: [ value ]</body></methods><methods><class-id>GraphQLBeta.GQLVariableNode</class-id> <category>printing</category><body package="GraphQLBeta-Nodes" selector="printOn:">printOn: stream	stream		nextPutAll: '$';		nextPutAll: value</body></methods><methods><class-id>GraphQLBeta.GQLVariableNode</class-id> <category>action</category><body package="GraphQLBeta-Nodes" selector="executeOn:with:using:">executeOn: resolver with: context using: schema	context variables isNil		ifTrue: [ ^ GQLException new				node: self;				messageText: 'Error on variables';				raise ]		ifFalse: [ context variables				detect: [ :var | var name value = self value ]				ifFound: [ :var | 					^ self						value: var						executeOn: resolver						with: context						using: schema ]				ifNone: [ ^ GQLException new						node: self;						messageText: 'Error on variables';						raise ] ]</body></methods><methods><class-id>GraphQLBeta.GQLFragmentNode</class-id> <category>accessing</category><body package="GraphQLBeta-Nodes" selector="directives">directives	"Return the directives"	^ directives ifNil: [ #() ]</body><body package="GraphQLBeta-Nodes" selector="directives:">directives: anObject	"Set the directives"	directives := anObject</body><body package="GraphQLBeta-Nodes" selector="name">name	"Return the name"	^ name</body><body package="GraphQLBeta-Nodes" selector="name:">name: anObject	"Set the name"	name := anObject</body><body package="GraphQLBeta-Nodes" selector="selectionSet">selectionSet	"Return the selection set"	^ selectionSet</body><body package="GraphQLBeta-Nodes" selector="selectionSet:">selectionSet: anObject	"Set the selection set"	selectionSet := anObject</body><body package="GraphQLBeta-Nodes" selector="setHasCycle:">setHasCycle: bool	hasCycle := bool</body><body package="GraphQLBeta-Nodes" selector="targetSpreads">targetSpreads	"Return the fragment spreads of this node"	^ selectionSet targetSpreads</body><body package="GraphQLBeta-Nodes" selector="typeCondition">typeCondition	"Return the type condition"	^ typeCondition</body><body package="GraphQLBeta-Nodes" selector="typeCondition:">typeCondition: anObject	"Set the type condition"	typeCondition := anObject</body></methods><methods><class-id>GraphQLBeta.GQLFragmentNode</class-id> <category>testing</category><body package="GraphQLBeta-Nodes" selector="hasCycle:">hasCycle: aDocument	^ hasCycle		ifNil: [ hasCycle := aDocument hasCycle: self with: Set new ]</body><body package="GraphQLBeta-Nodes" selector="isOperation">isOperation	^ false</body></methods><methods><class-id>GraphQLBeta.GQLFragmentNode</class-id> <category>visiting</category><body package="GraphQLBeta-Nodes" selector="accept:">accept: visitor	visitor visitFragmentNode: self</body></methods><methods><class-id>GraphQLBeta.GQLSelectionNode</class-id> <category>testing</category><body package="GraphQLBeta-Nodes" selector="isSpread">isSpread	^ false</body></methods><methods><class-id>GraphQLBeta.GQLSelectionNode</class-id> <category>as yet unclassified</category><body package="GraphQLBeta-Nodes" selector="collectVariablesOn:with:">collectVariablesOn: context with: visitedFragments	^ self subclassResponsibility</body><body package="GraphQLBeta-Nodes" selector="collectVarSelectionSet:using:with:">collectVarSelectionSet: aSelectionSet using: context with: visitedFragments	| groupedVariables |	groupedVariables := Set new.	aSelectionSet selections		do: [ :selection | 			groupedVariables				addAll: (selection collectVariablesOn: context with: visitedFragments) ].	^ groupedVariables</body></methods><methods><class-id>GraphQLBeta.GQLSelectionNode</class-id> <category>action</category><body package="GraphQLBeta-Nodes" selector="executeDirectives:">executeDirectives: context	"Execute the directives based on the variables declared on context or their arguments"	| executedDirectives |	directives ifNil: [ ^ true ].	^ directives allSatisfy: [ :dir | dir execute: context ]</body></methods><methods><class-id>GraphQLBeta.GQLSelectionNode</class-id> <category>utils</category><body package="GraphQLBeta-Nodes" selector="ifField:ifFragment:ifInline:">ifField: aFieldBlock ifFragment: aFragmentBlock ifInline: aInlineBlock	^ self subclassResponsibility</body></methods><methods><class-id>GraphQLBeta.GQLSelectionNode</class-id> <category>accessing</category><body package="GraphQLBeta-Nodes" selector="directives">directives	"Return the directives"	^ directives ifNil: [ #() ]</body><body package="GraphQLBeta-Nodes" selector="directives:">directives: anObject	"Set the directives"	directives := anObject</body><body package="GraphQLBeta-Nodes" selector="evaluateDirectives:using:">evaluateDirectives: schema using: context	"Verify that directives follow the specification of the schema directives"	directives ifNil: [ ^ true ].	(directives select: #isSkip) size &lt;= 1		&amp; ((directives select: #isInclude) size &lt;= 1)		ifTrue: [ ^ directives				allSatisfy: [ :directive | directive evaluateOn: schema using: context ] ]		ifFalse: [ ^ false ]</body></methods><methods><class-id>GraphQLBeta.GQLFragmentSpreadNode</class-id> <category>as yet unclassified</category><body package="GraphQLBeta-Nodes" selector="collectVariablesOn:with:">collectVariablesOn: context with: visitedFragments	| groupedVariables |	groupedVariables := Set new.	(visitedFragments includes: name)		ifFalse: [ visitedFragments add: name.			groupedVariables				addAll:					(self						collectVarSelectionSet: (context fragments at: name) selectionSet						using: context						with: visitedFragments) ].	^ groupedVariables</body></methods><methods><class-id>GraphQLBeta.GQLFragmentSpreadNode</class-id> <category>accessing</category><body package="GraphQLBeta-Nodes" selector="name">name	"Return the name"	^ name</body><body package="GraphQLBeta-Nodes" selector="name:">name: anObject	"Set the name"	name := anObject</body><body package="GraphQLBeta-Nodes" selector="targetSpreads">targetSpreads	"Return an array with self"	^ Array with: self</body></methods><methods><class-id>GraphQLBeta.GQLFragmentSpreadNode</class-id> <category>utils</category><body package="GraphQLBeta-Nodes" selector="ifField:ifFragment:ifInline:">ifField: aFieldBlock ifFragment: aFragmentBlock ifInline: aInlineBlock	^ aFragmentBlock value</body></methods><methods><class-id>GraphQLBeta.GQLFragmentSpreadNode</class-id> <category>comparing</category><body package="GraphQLBeta-Nodes" selector="=">= other	^ self name = other name</body><body package="GraphQLBeta-Nodes" selector="hash">hash	^ self name hash</body></methods><methods><class-id>GraphQLBeta.GQLFragmentSpreadNode</class-id> <category>visiting</category><body package="GraphQLBeta-Nodes" selector="accept:">accept: visitor	visitor visitFragmentSpreadNode: self</body></methods><methods><class-id>GraphQLBeta.GQLFragmentSpreadNode</class-id> <category>testing</category><body package="GraphQLBeta-Nodes" selector="isSpread">isSpread	^ true</body></methods><methods><class-id>GraphQLBeta.GQLOperationDefinitionNode</class-id> <category>testing</category><body package="GraphQLBeta-Nodes" selector="isOperation">isOperation	^ true</body></methods><methods><class-id>GraphQLBeta.GQLOperationDefinitionNode</class-id> <category>accessing</category><body package="GraphQLBeta-Nodes" selector="rootOperation:">rootOperation: root	^ root isDictionary		ifTrue: [ root at: self type ]		ifFalse: [ root ]</body><body package="GraphQLBeta-Nodes" selector="targetSpreads">targetSpreads	^ self subclassResponsibility</body><body package="GraphQLBeta-Nodes" selector="type">type	^ self subclassResponsibility</body></methods><methods><class-id>GraphQLBeta.GQLOperationNode</class-id> <category>accessing</category><body package="GraphQLBeta-Nodes" selector="directives">directives	"Return the directives"	^ directives ifNil: [ #() ]</body><body package="GraphQLBeta-Nodes" selector="directives:">directives: anObject	"Set the directives"	directives := anObject</body><body package="GraphQLBeta-Nodes" selector="name">name	"Return the name"	^ name</body><body package="GraphQLBeta-Nodes" selector="name:">name: aName	"Set the name"	aName ifNotNil: [ name := aName inputValue ]</body><body package="GraphQLBeta-Nodes" selector="selectionSet">selectionSet	"Return the selection set"	^ selectionSet</body><body package="GraphQLBeta-Nodes" selector="selectionSet:">selectionSet: anObject	"Set the selection set"	selectionSet := anObject</body><body package="GraphQLBeta-Nodes" selector="targetSpreads">targetSpreads	"Return the names of fragment spreads used"	^ selectionSet targetSpreads</body><body package="GraphQLBeta-Nodes" selector="type">type	"Return the type"	^ type</body><body package="GraphQLBeta-Nodes" selector="type:">type: anObject	"Set the type"	type := anObject</body><body package="GraphQLBeta-Nodes" selector="variableDefinitions">variableDefinitions	"Return the variable definitions"	^ variableDefinitions ifNil: [ #() ]</body><body package="GraphQLBeta-Nodes" selector="variableDefinitions:">variableDefinitions: anObject	"Set the variable definitions"	variableDefinitions := anObject</body></methods><methods><class-id>GraphQLBeta.GQLOperationNode</class-id> <category>action</category><body package="GraphQLBeta-Nodes" selector="collectVariables:">collectVariables: context	"Collect all variables"	| groupedVariables visitedFragments selections |	groupedVariables := Set new.	visitedFragments := Set new.	selections := self selectionSet selections.	selections		do: [ :selection | 			groupedVariables				addAll: (selection collectVariablesOn: context with: visitedFragments) ].	^ groupedVariables</body><body package="GraphQLBeta-Nodes" selector="executeOn:with:using:">executeOn: root with: context using: schema	"Execute the operation with the root, an enviroment and the schema"	| response |	response := OrderedDictionary new.	response		addAll:			(self selectionSet				executeOn: (self rootOperation: root)				with: context				using: schema).	^ response</body><body package="GraphQLBeta-Nodes" selector="unrepeatedVariables:">unrepeatedVariables: aCollection	^ (aCollection collect: [ :var | var name value ]) asSet size		= aCollection size</body></methods><methods><class-id>GraphQLBeta.GQLOperationNode</class-id> <category>as yet unclassified</category><body package="GraphQLBeta-Nodes" selector="validVariables">validVariables	| variables |	variables := OrderedCollection new.	variableDefinitions isNotNil		ifTrue: [ variables := variableDefinitions.			(self unrepeatedVariables: variables)				ifFalse: [ variables := OrderedCollection new ] ].	^ variables</body></methods><methods><class-id>GraphQLBeta.GQLOperationNode</class-id> <category>visiting</category><body package="GraphQLBeta-Nodes" selector="accept:">accept: visitor	visitor visitOperationNode: self</body></methods><methods><class-id>GraphQLBeta.GQLOperationNode class</class-id> <category>accessing</category><body package="GraphQLBeta-Nodes" selector="nodeName">nodeName	^ 'QUERY'</body></methods><methods><class-id>GraphQLBeta.GQLSelectionSetNode</class-id> <category>as yet unclassified</category><body package="GraphQLBeta-Nodes" selector="collectFragmentNameFields:with:root:using:and:on:">collectFragmentNameFields: selection with: schemaTypes root: aString using: visitedFragments and: dictNameFields on: context	| responseKey fragment |	responseKey := selection name.	(visitedFragments includesKey: responseKey)		ifFalse: [ visitedFragments at: responseKey put: selection.			fragment := context fragments at: responseKey.			fragment selectionSet				collectNameFieldsToAvoid: schemaTypes				root: aString				with: context				and: dictNameFields ].	^ dictNameFields</body><body package="GraphQLBeta-Nodes" selector="collectInlineNameFields:with:root:and:">collectInlineNameFields: selection with: schemaTypes root: aString and: dictNameFields	selection typeCondition		ifNotNil: [ (self				fieldToExecute: selection typeCondition name				with: aString				using: schemaTypes)				ifTrue: [ (dictNameFields at: 'nameFieldsToExecute')						addAll: (selection selectionSet selections collect: [ :sel | sel name ]) ]				ifFalse: [ (dictNameFields at: 'nameFieldsToAvoid')						addAll: (selection selectionSet selections collect: [ :sel | sel name ]) ] ].	^ dictNameFields</body><body package="GraphQLBeta-Nodes" selector="collectNameFieldsToAvoid:root:with:and:">collectNameFieldsToAvoid: schemaTypes root: aString with: context and: dictNameFields	| visitedFragments nameFieldsToExecute copyDictNameFields |	copyDictNameFields := dictNameFields deepCopy.	visitedFragments := OrderedDictionary new.	selections		select: [ :field | field executeDirectives: context ]		thenDo: [ :selection | 			copyDictNameFields := selection				ifField: [ dictNameFields ]				ifFragment: [ self						collectFragmentNameFields: selection						with: schemaTypes						root: aString						using: visitedFragments						and: dictNameFields						on: context ]				ifInline: [ self						collectInlineNameFields: selection						with: schemaTypes						root: aString						and: dictNameFields ] ].	nameFieldsToExecute := copyDictNameFields at: 'nameFieldsToExecute'.	^ (copyDictNameFields at: 'nameFieldsToAvoid')		reject: [ :aName | nameFieldsToExecute includes: aName ]</body><body package="GraphQLBeta-Nodes" selector="collectNameFieldsToAvoid:with:and:">collectNameFieldsToAvoid: schemaTypes with: aString and: context	| dictNameFields |	dictNameFields := Dictionary new		at: 'nameFieldsToAvoid' put: OrderedCollection new;		at: 'nameFieldsToExecute' put: OrderedCollection new;		yourself.	^ self		collectNameFieldsToAvoid: schemaTypes		root: aString		with: context		and: dictNameFields</body><body package="GraphQLBeta-Nodes" selector="fieldToExecute:with:using:">fieldToExecute: aNameType with: aNameRoot using: schemaTypes	^ aNameType = aNameRoot		ifFalse: [ | aType |			aType := schemaTypes at: aNameType.			aType isInterfaceType				and: [ (aType implementors collect: [ :impl | impl name ])						includes: aNameRoot ] ]		ifTrue: [ true ]</body></methods><methods><class-id>GraphQLBeta.GQLSelectionSetNode</class-id> <category>action</category><body package="GraphQLBeta-Nodes" selector="collectField:with:">collectField: selection with: groupedFields	"View on groupedFields if selection exist or if can merge"	| responseKey |	responseKey := selection key.	(groupedFields includesKey: responseKey)		ifTrue: [ (self sameShape: (groupedFields at: responseKey) with: selection)				ifTrue: [ selection isScalar						ifFalse: [ self								mergeSelectionSet: (groupedFields at: responseKey)								with: selection ] ]				ifFalse: [ ^ GQLException new						node: selection;						messageText: 'Duplicated fields with different arguments, use alias';						raise ] ]		ifFalse: [ groupedFields at: responseKey put: selection ].	^ groupedFields</body><body package="GraphQLBeta-Nodes" selector="collectFields:">collectFields: context	"Collect all the selections"	| groupedFields visitedFragments |	groupedFields := OrderedDictionary new.	visitedFragments := OrderedDictionary new.	selections		select: [ :field | field executeDirectives: context ]		thenDo: [ :selection | 			groupedFields := selection				ifField: [ self collectField: selection with: groupedFields ]				ifFragment: [ self						collectFragment: selection						with: visitedFragments						using: groupedFields						on: context ]				ifInline: [ self						collectInlineFragment: selection						with: groupedFields						on: context ] ].	^ groupedFields</body><body package="GraphQLBeta-Nodes" selector="collectFragment:with:using:on:">collectFragment: selection with: visitedFragments using: groupedFields on: context	"View on visitedFragments if fragment exist, then add selectionSet based on groupedFieldsHERE IS IMPORTANT VERIFY THE TYPE"	| responseKey fragment fragmentFieldSet |	responseKey := selection name.	(visitedFragments includesKey: responseKey)		ifFalse: [ visitedFragments at: responseKey put: selection.			context fragments				at: responseKey				ifPresent: [ :v | fragment := v ]				ifAbsent: [ ^ GQLException new						node: selection;						messageText: 'Undefined fragment';						raise ].			fragmentFieldSet := fragment selectionSet collectFields: context.			fragmentFieldSet				valuesDo: [ :value | self collectField: value with: groupedFields ] ].	^ groupedFields</body><body package="GraphQLBeta-Nodes" selector="collectInlineFragment:with:on:">collectInlineFragment: selection with: groupedFields on: context	"Collect inline fragments based on their selection setHERE TYPE CHECK THE TYPE OF INLINE FRAGMENT"	| fragmentFieldSet |	fragmentFieldSet := selection selectionSet collectFields: context.	fragmentFieldSet		valuesDo: [ :value | self collectField: value with: groupedFields ].	^ groupedFields</body><body package="GraphQLBeta-Nodes" selector="executeOn:with:using:">executeOn: root with: context using: schema	"Execute the field nodes with the root, an enviroment and the schema"	| collectedFields response myRoot |	selections		detect:			[ :selection | (selection evaluateDirectives: schema using: context) not ]		ifFound: [ :selection | 			^ GQLException new				node: selection;				messageText: 'Error on directives';				raise ].	collectedFields := self collectFields: context.	collectedFields class = GQLException		ifTrue: [ ^ collectedFields ].	myRoot := self rootOperation: root.	(myRoot isKindOf: GQLSNamedTypeNode)		ifTrue: [ myRoot := schema getType: myRoot name ].	myRoot isNotNil		ifTrue: [ | nameFieldsToAvoid |			response := OrderedDictionary new.			nameFieldsToAvoid := self				collectNameFieldsToAvoid: schema schemaTypes				with: myRoot className asString				and: context.			collectedFields				do: [ :f | 					(nameFieldsToAvoid includes: f key)						ifFalse: [ response								at: f key								put: (f executeOn: myRoot with: context using: schema) ] ] ].	^ response</body><body package="GraphQLBeta-Nodes" selector="mergeSelectionSet:with:">mergeSelectionSet: field1 with: field2	"Merge two selection sets"	| newFieldNodes |	newFieldNodes := OrderedCollection new.	newFieldNodes addAll: field2 selectionSet selections.	newFieldNodes addAll: field1 selectionSet selections.	field1 selectionSet selections: newFieldNodes asArray</body><body package="GraphQLBeta-Nodes" selector="sameShape:with:">sameShape: field1 with: field2	"Verify if two fields have the same name and value argumentsHERE IS IMPORTANT VERIFY THE TYPE"	^ field1 name = field2 name		and: [ field1 arguments = field2 arguments ]</body><body package="GraphQLBeta-Nodes" selector="type">type	^ 'query'</body></methods><methods><class-id>GraphQLBeta.GQLSelectionSetNode</class-id> <category>accessing</category><body package="GraphQLBeta-Nodes" selector="selections">selections	"Return the selections"	^ selections</body><body package="GraphQLBeta-Nodes" selector="selections:">selections: fields	"Set the selections"	selections := fields</body><body package="GraphQLBeta-Nodes" selector="targetSpreads">targetSpreads	"Return all the fragments spreads used on this node"	| spreads |	spreads := Set new.	selections		do: [ :selection | spreads addAll: selection targetSpreads ].	^ spreads</body></methods><methods><class-id>GraphQLBeta.GQLDirectiveNode</class-id> <category>execute</category><body package="GraphQLBeta-Nodes" selector="evaluateOn:using:">evaluateOn: schema using: context	"Evaluate if the directive exist on schema, as it's defined"	| directive |	directive := schema getDirective: self name.	^ directive isNotNil		and: [ self partialEquals: directive using: context ]</body></methods><methods><class-id>GraphQLBeta.GQLDirectiveNode</class-id> <category>accessing</category><body package="GraphQLBeta-Nodes" selector="arguments">arguments	"Return the arguments"	^ arguments ifNil: [ #() ]</body><body package="GraphQLBeta-Nodes" selector="arguments:">arguments: anObject	"Set the arguments"	arguments := anObject</body><body package="GraphQLBeta-Nodes" selector="isInclude">isInclude	^ false</body><body package="GraphQLBeta-Nodes" selector="isSkip">isSkip	^ false</body><body package="GraphQLBeta-Nodes" selector="name">name	"Return the name"	^ name</body><body package="GraphQLBeta-Nodes" selector="name:">name: anObject	"Set the name"	name := anObject</body></methods><methods><class-id>GraphQLBeta.GQLDirectiveNode</class-id> <category>comparing</category><body package="GraphQLBeta-Nodes" selector="partialEquals:using:">partialEquals: other using: context	"Given other directive, verify if has the same name and arguments"	^ (self arguments size = other arguments size		and: [ self name = other name ])		and: [ self arguments				allSatisfy: [ :arg | 					other arguments						anySatisfy: [ :o | arg partialEquals: o using: context ] ] ]</body></methods><methods><class-id>GraphQLBeta.GQLDirectiveNode</class-id> <category>running</category><body package="GraphQLBeta-Nodes" selector="execute:">execute: context	^ self subclassResponsibility</body></methods><methods><class-id>GraphQLBeta.GQLDirectiveNode</class-id> <category>visiting</category><body package="GraphQLBeta-Nodes" selector="accept:">accept: visitor	visitor visitDirectiveNode: self</body></methods><methods><class-id>GraphQLBeta.GQLDirectiveNode class</class-id> <category>instance creation</category><body package="GraphQLBeta-Nodes" selector="new:">new: aName	| inst |	self allSubclasses		detect: [ :subclass | subclass directiveName = aName ]		ifFound: [ :subclass | inst := subclass new ]		ifNone: [ inst := self new ].	^ inst</body></methods><methods><class-id>GraphQLBeta.GQLDefaultDirectiveNode</class-id> <category>initialization</category><body package="GraphQLBeta-Nodes" selector="initialize">initialize	super initialize.	arguments := Array		with:			(GQLArgumentNode new				name: 'if';				value: GQLBooleanNode new)</body></methods><methods><class-id>GraphQLBeta.GQLDefaultDirectiveNode</class-id> <category>execute</category><body package="GraphQLBeta-Nodes" selector="execute:">execute: context	| node |	node := self arguments first value.	^ node value = self condition		or: [ (node valueWith: context) = self condition ]</body></methods><methods><class-id>GraphQLBeta.GQLDefaultDirectiveNode</class-id> <category>accessing</category><body package="GraphQLBeta-Nodes" selector="condition">condition	^ self subclassResponsibility</body></methods><methods><class-id>GraphQLBeta.GQLDefaultDirectiveNode class</class-id> <category>as yet unclassified</category><body package="GraphQLBeta-Nodes" selector="directiveName">directiveName	^ ''</body></methods><methods><class-id>GraphQLBeta.GQLIncludeDirectiveNode</class-id> <category>initialization</category><body package="GraphQLBeta-Nodes" selector="initialize">initialize	super initialize.	name := 'include'</body></methods><methods><class-id>GraphQLBeta.GQLIncludeDirectiveNode</class-id> <category>accessing</category><body package="GraphQLBeta-Nodes" selector="condition">condition	"Return the condition that must have to able the field"	^ 'true'</body><body package="GraphQLBeta-Nodes" selector="isInclude">isInclude	^ true</body></methods><methods><class-id>GraphQLBeta.GQLIncludeDirectiveNode class</class-id> <category>as yet unclassified</category><body package="GraphQLBeta-Nodes" selector="directiveName">directiveName	^ 'include'</body></methods><methods><class-id>GraphQLBeta.GQLSkipDirectiveNode</class-id> <category>initialization</category><body package="GraphQLBeta-Nodes" selector="initialize">initialize	super initialize.	name := 'skip'</body></methods><methods><class-id>GraphQLBeta.GQLSkipDirectiveNode</class-id> <category>accessing</category><body package="GraphQLBeta-Nodes" selector="condition">condition	"Return the condition that must have to able the field"	^ 'false'</body><body package="GraphQLBeta-Nodes" selector="isSkip">isSkip	^ true</body></methods><methods><class-id>GraphQLBeta.GQLSkipDirectiveNode class</class-id> <category>as yet unclassified</category><body package="GraphQLBeta-Nodes" selector="directiveName">directiveName	^ 'skip'</body></methods><methods><class-id>GraphQLBeta.GQLObjectNode</class-id> <category>accessing</category><body package="GraphQLBeta-Nodes" selector="name:using:">name: aName using: schema	(aName endsWith: 'Input')		ifTrue: [ ^ aName copyFrom: 1 to: aName size - 5 ]		ifFalse: [ ^ aName ]</body><body package="GraphQLBeta-Nodes" selector="objectFields">objectFields	"Return the object fields"	^ objectFields</body><body package="GraphQLBeta-Nodes" selector="objectFields:">objectFields: anObject	"Set the object fields"	objectFields := anObject.	objectFields isEmpty		ifTrue: [ ^ GQLException new				messageText: 'objectFields empty';				raise ]		ifFalse: [ self position: objectFields first position ]</body><body package="GraphQLBeta-Nodes" selector="valueVariables">valueVariables	| valueVariables |	valueVariables := Dictionary new.	self objectFields		select: [ :objField | objField value isVariableNode ]		thenDo:			[ :objField | valueVariables at: objField value value put: objField value ].	^ valueVariables</body></methods><methods><class-id>GraphQLBeta.GQLObjectNode</class-id> <category>testing</category><body package="GraphQLBeta-Nodes" selector="isObjectNode">isObjectNode	^ true</body></methods><methods><class-id>GraphQLBeta.GQLObjectNode</class-id> <category>printing</category><body package="GraphQLBeta-Nodes" selector="printOn:">printOn: stream	stream nextPutAll: '{'.	self objectFields		do: [ :field | field printOn: stream ]		separatedBy: [ stream nextPutAll: ', ' ].	stream nextPutAll: '}'</body></methods><methods><class-id>GraphQLBeta.GQLObjectNode</class-id> <category>action</category><body package="GraphQLBeta-Nodes" selector="executeOn:with:using:">executeOn: resolver with: context using: schema	"Return the object with its respective fields"	| objectResult |	objectResult := resolver class new.	objectFields		do: [ :objField | 			objectResult := objectResult				perform: (objField name , ':') asSymbol				with: (objField executeOn: resolver with: context using: schema) ].	^ objectResult</body></methods><methods><class-id>GraphQLBeta.GQLStringNode</class-id> <category>printing</category><body package="GraphQLBeta-Nodes" selector="printOn:">printOn: stream	stream nextPutAll: value</body></methods><methods><class-id>GraphQLBeta.GQLStringNode</class-id> <category>action</category><body package="GraphQLBeta-Nodes" selector="executeOn:with:using:">executeOn: resolver with: context using: schema	"Execute the input value according to the resolver, the enviroment and the schema"	^ value copyFrom: 2 to: value size - 1</body></methods><methods><class-id>GraphQLBeta.GQLFieldNode</class-id> <category>as yet unclassified</category><body package="GraphQLBeta-Nodes" selector="collectAllArguments">collectAllArguments	| args |	args := OrderedCollection new.	self directives do: [ :d | args addAll: d arguments ].	args addAll: arguments.	^ args</body><body package="GraphQLBeta-Nodes" selector="collectVariables:using:">collectVariables: args using: context	| groupedVariables |	groupedVariables := Set new.	args		collect: [ :arg | arg value valueVariables ]		thenDo: [ :dictVariables | 			dictVariables keys				do: [ :keyVariable | 					context variables						at: keyVariable						ifAbsent: [ context variables								at: keyVariable								put: (GQLVariableDefinitionNode new name: (dictVariables at: keyVariable)) ].					groupedVariables add: keyVariable ] ].	^ groupedVariables</body><body package="GraphQLBeta-Nodes" selector="collectVariablesOn:with:">collectVariablesOn: context with: visitedFragments	| args groupedVariables |	groupedVariables := Set new.	args := self collectAllArguments.	groupedVariables := self collectVariables: args using: context.	^ groupedVariables</body><body package="GraphQLBeta-Nodes" selector="fieldOfType:using:">fieldOfType: aString using: aSchema	| type field |	type := aSchema getType: aString.	field := type getField: self name.	field ifNil: [ field := type fieldOfName: self name using: aSchema ].	^ field</body><body package="GraphQLBeta-Nodes" selector="valueOf:toPerform:with:using:">valueOf: resolver toPerform: field with: aArray using: aSchema	| block response |	block := [ :aResolver :aField :array | 	aResolver		perform: aField fullName asSymbol		withArguments: array asArray ].	[ response := block		valueWithArguments:			((Array new: 3)				at: 1 put: resolver;				at: 2 put: field;				at: 3 put: aArray;				yourself) ]		on: Error		do: [ :ex | response := block				valueWithArguments:					((Array new: 3)						at: 1 put: (aSchema getType: resolver className);						at: 2 put: field;						at: 3 put: aArray;						yourself) ].	^ response</body></methods><methods><class-id>GraphQLBeta.GQLFieldNode</class-id> <category>testing</category><body package="GraphQLBeta-Nodes" selector="hasSameArguments:">hasSameArguments: args	^ arguments size = args size		and: [ arguments				allSatisfy: [ :arg | 					args						anySatisfy: [ :a | arg name = a name and: [ arg value = a value ] ] ] ]</body><body package="GraphQLBeta-Nodes" selector="isScalar">isScalar	"To verify if a field is scalar"	self shouldBeImplemented</body></methods><methods><class-id>GraphQLBeta.GQLFieldNode</class-id> <category>accessing</category><body package="GraphQLBeta-Nodes" selector="alias">alias	"Return the alias"	^ alias</body><body package="GraphQLBeta-Nodes" selector="alias:">alias: anObject	"Set the alias"	alias := anObject</body><body package="GraphQLBeta-Nodes" selector="arguments">arguments	"Return the arguments"	^ arguments</body><body package="GraphQLBeta-Nodes" selector="arguments:">arguments: anObject	"If anObject is nil set the arguments to a new array, otherwise set the arguments"	anObject		ifNil: [ arguments := Array new ]		ifNotNil: [ arguments := anObject ]</body><body package="GraphQLBeta-Nodes" selector="fullName">fullName	"Return the full name"	fullName		ifNil: [ | write |			write := WriteStream on: String new.			write nextPutAll: self name.			self arguments				ifNotEmpty: [ :ags | 					ags						doWithIndex: [ :ag :i | 							i = 1								ifTrue: [ write										nextPutAll: ag name capitalized;										nextPut: $: ]								ifFalse: [ write										nextPutAll: ag name;										nextPut: $: ] ] ].			fullName := write contents ].	^ fullName</body><body package="GraphQLBeta-Nodes" selector="key">key	"The key on the dictionary of the response"	^ alias ifNil: [ name ] ifNotNil: [ alias ]</body><body package="GraphQLBeta-Nodes" selector="name">name	"Return the name"	^ name</body><body package="GraphQLBeta-Nodes" selector="name:">name: anObject	"Set the name"	name := anObject</body><body package="GraphQLBeta-Nodes" selector="paramsOn:with:using:ofClass:">paramsOn: resolver with: context using: schema ofClass: className	| params field |	field := self fieldOfType: className using: schema.	params := field arguments		collect: [ :argS | 			| arg |			arg := self arguments				detect: [ :a | a name = argS name ]				ifFound: [ :a | a ]				ifNone: [ nil ].			arg				ifNotNil: [ | resolverArg |					resolverArg := arg						resolverArg: resolver						with: field						ofType: argS type						using: schema.					arg value: (argS type coerceValue: arg value on: schema).					arg executeOn: resolverArg with: context using: schema ] ].	^ params</body><body package="GraphQLBeta-Nodes" selector="targetSpreads">targetSpreads	^ self subclassResponsibility</body></methods><methods><class-id>GraphQLBeta.GQLFieldNode</class-id> <category>utils</category><body package="GraphQLBeta-Nodes" selector="ifField:ifFragment:ifInline:">ifField: aFieldBlock ifFragment: aFragmentBlock ifInline: aInlineBlock	^ aFieldBlock value</body></methods><methods><class-id>GraphQLBeta.GQLFieldNode</class-id> <category>action</category><body package="GraphQLBeta-Nodes" selector="executeOn:with:using:">executeOn: resolver with: context using: schema	self subclassResponsibility</body></methods><methods><class-id>GraphQLBeta.GQLScalarFieldNode</class-id> <category>action</category><body package="GraphQLBeta-Nodes" selector="executeOn:with:using:">executeOn: resolver with: context using: schema	"Given a resolver, an enviroment and the schema, execute the scalar node"	| result params className selector resolverSelector field dict |	selector := self fullName asSymbol.	resolverSelector := resolver.	className := resolverSelector isClass		ifTrue: [ #Class ]		ifFalse: [ resolverSelector className ].	params := self		paramsOn: resolverSelector		with: context		using: schema		ofClass: className.	field := (schema getType: className) getField: self name.	field ifNotNil: [ selector := field fullName asSymbol ].	resolverSelector class allMethods		detect: [ :method | method selector = selector ]		ifNone: [ resolverSelector := (schema dictFieldsResolvers at: selector) new ].	result := resolverSelector		perform: selector		withArguments: params asArray.	dict := self class dictTypeName.	(dict keys includes: result)		ifTrue: [ result := dict at: result ].	^ result</body></methods><methods><class-id>GraphQLBeta.GQLScalarFieldNode</class-id> <category>accessing</category><body package="GraphQLBeta-Nodes" selector="targetSpreads">targetSpreads	"Return empty beacuse cant have fragment spreads"	^ #()</body></methods><methods><class-id>GraphQLBeta.GQLScalarFieldNode</class-id> <category>visiting</category><body package="GraphQLBeta-Nodes" selector="accept:">accept: visitor	visitor visitScalarFieldNode: self</body></methods><methods><class-id>GraphQLBeta.GQLScalarFieldNode</class-id> <category>testing</category><body package="GraphQLBeta-Nodes" selector="isScalar">isScalar	"Answer true for be a scalar field"	^ true</body></methods><methods><class-id>GraphQLBeta.GQLScalarFieldNode class</class-id> <category>accessing</category><body package="GraphQLBeta-Nodes" selector="dictTypeName">dictTypeName	dictTypeName		ifNil: [ dictTypeName := Dictionary new				at: 'GQLSTypeNode' put: '__Type';				at: 'GQLSInputObjectFieldNode' put: '__InputValue';				at: 'GQLSFieldNode' put: '__Field';				at: 'GQLSEnumValue' put: '__EnumValue';				at: 'GQLSDirectiveNode' put: '__Directive';				yourself ].	^ dictTypeName</body></methods><methods><class-id>GraphQLBeta.GQLNonScalarFieldNode</class-id> <category>utils</category><body package="GraphQLBeta-Nodes" selector="collectVariablesOn:with:">collectVariablesOn: context with: visitedFragments	| groupVariables args |	groupVariables := Set new.	args := self collectAllArguments.	groupVariables addAll: (self collectVariables: args using: context).	selectionSet		ifNotNil: [ groupVariables				addAll:					(self						collectVarSelectionSet: selectionSet						using: context						with: visitedFragments) ].	^ groupVariables</body></methods><methods><class-id>GraphQLBeta.GQLNonScalarFieldNode</class-id> <category>accessing</category><body package="GraphQLBeta-Nodes" selector="selectionSet">selectionSet	"Return the selection set"	^ selectionSet</body><body package="GraphQLBeta-Nodes" selector="selectionSet:">selectionSet: anObject	"Set the selection set"	selectionSet := anObject</body><body package="GraphQLBeta-Nodes" selector="targetSpreads">targetSpreads	"Return the fragments spreads used on the selectionSet"	^ selectionSet targetSpreads</body></methods><methods><class-id>GraphQLBeta.GQLNonScalarFieldNode</class-id> <category>action</category><body package="GraphQLBeta-Nodes" selector="executeOn:with:using:">executeOn: resolver with: context using: schema	"Given a resolver, an contextiroment and the schema, execute the request"	| objectValue type result params className field resolverSel |	className := resolver isClass		ifTrue: [ #Class ]		ifFalse: [ resolver className ].	params := self		paramsOn: resolver		with: context		using: schema		ofClass: className.	field := self fieldOfType: className using: schema.	type := field type.	type class = GQLSNonNullTypeNode		ifTrue: [ type := type wrappedType ].	resolverSel := resolver.	resolver class = schema class		ifTrue: [ resolverSel := schema ].	objectValue := self		valueOf: resolverSel		toPerform: field		with: params		using: schema.	type class = GQLSListTypeNode		ifTrue: [ result := OrderedCollection new.			objectValue				ifNotNil: [ objectValue						do: [ :el | 							result								add: (self selectionSet executeOn: el with: context using: schema) ] ]				ifNil: [ result := nil ] ]		ifFalse: [ result := self selectionSet				executeOn: objectValue				with: context				using: schema ].	^ result</body></methods><methods><class-id>GraphQLBeta.GQLNonScalarFieldNode</class-id> <category>visiting</category><body package="GraphQLBeta-Nodes" selector="accept:">accept: visitor	visitor visitNonScalarFieldNode: self</body></methods><methods><class-id>GraphQLBeta.GQLNonScalarFieldNode</class-id> <category>testing</category><body package="GraphQLBeta-Nodes" selector="isScalar">isScalar	"Answer false because is not scalar"	^ false</body></methods><methods><class-id>GraphQLBeta.GQLTypeFieldNode</class-id> <category>accessing</category><body package="GraphQLBeta-Nodes" selector="paramsOn:with:using:ofClass:">paramsOn: resolver with: context using: schema ofClass: className	| params |	params := OrderedCollection new.	(arguments size = 1 and: [ arguments first name = 'name' ])		ifTrue: [ | argument |			argument := arguments first.			params				add: (argument executeOn: resolver with: context using: schema) ].	^ params</body><body package="GraphQLBeta-Nodes" selector="targetSpreads">targetSpreads	"Return the fragments spreads used on the selectionSet"	^ selectionSet targetSpreads</body></methods><methods><class-id>GraphQLBeta.GQLTypeFieldNode</class-id> <category>action</category><body package="GraphQLBeta-Nodes" selector="executeOn:with:using:">executeOn: resolver with: context using: schema	| param className newResolver |	className := resolver className.	param := (self		paramsOn: resolver		with: context		using: schema		ofClass: className) first.	newResolver := schema schemaTypes		at: param		ifAbsent: [ GQLSSchemaNode dictNameTypesMetaSchema				at: param				ifPresent: [ :value | newResolver := schema schemaTypes at: value ]				ifAbsent: [ ^ nil ] ].	^ self selectionSet		executeOn: newResolver		with: context		using: schema</body></methods><methods><class-id>GraphQLBeta.GQLTypeFieldNode</class-id> <category>visiting</category><body package="GraphQLBeta-Nodes" selector="accept:">accept: visitor	visitor visitTypeFieldNode: self</body></methods><methods><class-id>GraphQLBeta.GQLSchemaFieldNode</class-id> <category>action</category><body package="GraphQLBeta-Nodes" selector="executeOn:with:using:">executeOn: resolver with: context using: schema	| objectValue result |	objectValue := GQLSSchemaNode new.	result := self selectionSet		executeOn: objectValue		with: context		using: schema.	result		at: 'types'		ifPresent: [ :list | 			list				do: [ :dict | 					dict						at: 'name'						ifPresent: [ :aName | 							self class dictNameMetaSchema								at: aName								ifPresent: [ :val | dict at: 'name' put: val ] ] ] ].	^ result</body></methods><methods><class-id>GraphQLBeta.GQLSchemaFieldNode</class-id> <category>accessing</category><body package="GraphQLBeta-Nodes" selector="targetSpreads">targetSpreads	"Return the fragments spreads used on the selectionSet"	^ #()</body></methods><methods><class-id>GraphQLBeta.GQLSchemaFieldNode</class-id> <category>visiting</category><body package="GraphQLBeta-Nodes" selector="accept:">accept: visitor	visitor visitSchemaFieldNode: self</body></methods><methods><class-id>GraphQLBeta.GQLSchemaFieldNode class</class-id> <category>accessing</category><body package="GraphQLBeta-Nodes" selector="dictNameMetaSchema">dictNameMetaSchema	dictNameMetaSchema		ifNil: [ dictNameMetaSchema := Dictionary new				at: 'GQLSSchemaNode' put: '__Schema';				at: 'GQLSTypeNode' put: '__Type';				at: 'GQLSFieldNode' put: '__Field';				at: 'GQLSEnumValue' put: '__EnumValue';				at: 'GQLSInputObjectFieldNode' put: '__InputValue';				at: 'GQLSDirectiveNode' put: '__Directive';				at: 'GQLSStringTypeNode' put: 'String';				at: 'GQLSBooleanTypeNode' put: 'Boolean';				yourself ].	^ dictNameMetaSchema</body></methods><methods><class-id>GraphQLBeta.GQLVariableDefinitionNode</class-id> <category>accessing</category><body package="GraphQLBeta-Nodes" selector="currentValue">currentValue	value isNil		ifTrue: [ ^ defaultValue ]		ifFalse: [ ^ value ]</body><body package="GraphQLBeta-Nodes" selector="defaultValue">defaultValue	"Return the defaultValue"	^ defaultValue</body><body package="GraphQLBeta-Nodes" selector="defaultValue:">defaultValue: anObject	"Set the default value"	defaultValue := anObject</body><body package="GraphQLBeta-Nodes" selector="name">name	"Return the name"	^ name</body><body package="GraphQLBeta-Nodes" selector="name:">name: anObject	"Set the name"	name := anObject</body><body package="GraphQLBeta-Nodes" selector="type">type	"Return the type"	^ type</body><body package="GraphQLBeta-Nodes" selector="type:">type: anObject	"Set the type"	type := anObject</body><body package="GraphQLBeta-Nodes" selector="value">value	^ value</body><body package="GraphQLBeta-Nodes" selector="value:">value: anObject	value := anObject</body></methods><methods><class-id>GraphQLBeta.GQLAbstractGrammar</class-id> <category>grammar</category><body package="GraphQLBeta-Parser" selector="booleanValue">booleanValue	"Return a token accepting true or false"	^ ('true' asParser / 'false' asParser) flatten token</body><body package="GraphQLBeta-Parser" selector="comma">comma	"Return a parser accepting the comma"	^ $, asParser</body><body package="GraphQLBeta-Parser" selector="comment">comment	"Return a parser accepting the char # followed by a parser accepting the list of comment chars"	^ ($# asParser , commentChar star) flatten token</body><body package="GraphQLBeta-Parser" selector="commentChar">commentChar	"Return a parser that succes when fails accepting the newline and followed by a parser accepting the sourceCharacter"	^ #newline asParser not , sourceCharacter</body><body package="GraphQLBeta-Parser" selector="comments">comments	"Return a parser accepting the list of comment"	^ (comment trim: ignoredNoComment) star</body><body package="GraphQLBeta-Parser" selector="digit">digit	"Return a parser accepting a digit"	^ #digit asParser</body><body package="GraphQLBeta-Parser" selector="escapedCharacter">escapedCharacter	"Return a parser accepting all the characters associated with a escape, like: \t \r"	^ $" asParser / $\ asParser / $/ asParser / $b asParser / $f asParser		/ $n asParser / $r asParser / $t asParser</body><body package="GraphQLBeta-Parser" selector="escapedUnicode">escapedUnicode	"Return a parser accepting word four times"	^ #word asParser times: 4</body><body package="GraphQLBeta-Parser" selector="exponentIndicator">exponentIndicator	"Return a parser accepting the char e or the char E"	^ $e asParser / $E asParser</body><body package="GraphQLBeta-Parser" selector="exponentPart">exponentPart	"Return a parser accepting a exponentIndicator follow by a parser accepting a optional sign follow by a parser accepting a list of digits"	^ exponentIndicator , sign optional , digit plus</body><body package="GraphQLBeta-Parser" selector="floatValue">floatValue	"Return a parser accepting:	- integerPart fractionalPart exponentPart	- integerPart fractionalPart	- integerPart exponentPart"	^ (integerPart , fractionalPart , exponentPart) flatten token		/ (integerPart , fractionalPart) flatten token		/ (integerPart , exponentPart) flatten token	"^ integerPart , ((fractionalPart , exponentPart) / fractionalPart / exponentPart )"</body><body package="GraphQLBeta-Parser" selector="fractionalPart">fractionalPart	"Return a parser accepting . followed by a parser accepting one or more digits"	^ $. asParser , digit plus</body><body package="GraphQLBeta-Parser" selector="ignored">ignored	"Return the parsers accepting the list of things we want to ignore"	^ comment / lineTerminator / unicodeBOM / whiteSpace / comma</body><body package="GraphQLBeta-Parser" selector="ignoredNoComment">ignoredNoComment	"Return the parsers accepting the list of things we want to ignore but no comment"	^ lineTerminator / unicodeBOM / whiteSpace / comma</body><body package="GraphQLBeta-Parser" selector="insignificantToken">insignificantToken	"Return a parser accepting the list of insignificant token"	^ whiteSpace / comment / lineTerminator</body><body package="GraphQLBeta-Parser" selector="insignificantTokenNoComment">insignificantTokenNoComment	"Return a parser accepting the list of insignificant token no comment"	^ whiteSpace / lineTerminator</body><body package="GraphQLBeta-Parser" selector="integerPart">integerPart	"Return a parser accepting:	- sign optional 0	- sign optional nonZero digitList"	^ sign optional , ($0 asParser / (nonZeroDigit , digit star))</body><body package="GraphQLBeta-Parser" selector="intValue">intValue	"Return a token representing the integerPart"	^ integerPart flatten token</body><body package="GraphQLBeta-Parser" selector="lineTerminator">lineTerminator	"New Line (U+000A)	Carriage Return (U+000D)New Line (U+000A)	Carriage Return (U+000D)New Line (U+000A)"	^ #newline asParser</body><body package="GraphQLBeta-Parser" selector="nonZeroDigit">nonZeroDigit	"Return a parser that succes when fails accepting the $0 and followed by a parser accepting the digit"	^ $0 asParser not , digit</body><body package="GraphQLBeta-Parser" selector="punctuator">punctuator	"Return a parser accepting one of! $ ( ) ... : = @ [ ] { | }"	^ $! asParser / $$ asParser / $( asParser / $) asParser		/ '...' asParser / $: asParser / $= asParser / $@ asParser		/ $[ asParser / $] asParser / ${ asParser / $| asParser		/ $} asParser</body><body package="GraphQLBeta-Parser" selector="sign">sign	"Return a parser accepting the char + or -"	^ $+ asParser / $- asParser</body><body package="GraphQLBeta-Parser" selector="sourceCharacter">sourceCharacter	"/[\u0009\u000A\u000D\u0020-\uFFFF]/ "	^ #any asParser</body><body package="GraphQLBeta-Parser" selector="start">start	"Return a parser accepting the sourceCharacter and success at the end of the input"	^ sourceCharacter end</body><body package="GraphQLBeta-Parser" selector="stringCharacter">stringCharacter	"Return a parser accepting:	- SourceCharacter but not stringDelimiter or  \	- \u escapedUnicode	- \ escapedCharacter"	^ (stringDelimiter not , $\ asParser not , sourceCharacter)		/ ('\u' asParser , escapedUnicode)		/ ('\' asParser , escapedCharacter)</body><body package="GraphQLBeta-Parser" selector="stringDelimiter">stringDelimiter	"Return a parser accepting the quotation symbol"	^ $" asParser</body><body package="GraphQLBeta-Parser" selector="stringValue">stringValue	"Return a parser accepting a string delimited by quotation symbol"	^ (stringDelimiter , stringCharacter star , stringDelimiter) flatten		token</body><body package="GraphQLBeta-Parser" selector="token">token	"Return the parser that accepts the lexical tokens: a punctuator or tokename or float value or int value or string value"	^ punctuator / tokenName / floatValue / intValue / stringValue</body><body package="GraphQLBeta-Parser" selector="tokenName">tokenName	"Return a parser accepting: _ letter _ wordList"	^ ($_ asParser / #letter asParser		, ($_ asParser / #word asParser) star) flatten token</body><body package="GraphQLBeta-Parser" selector="unicodeBOM">unicodeBOM	"Byte Order Mark (U+FEFF)"	^ 'U+FEFF' asParser</body><body package="GraphQLBeta-Parser" selector="whiteSpace">whiteSpace	"Horizontal Tab (U+0009)	 Space (U+0020)"	^ #blank asParser</body></methods><methods><class-id>GraphQLBeta.GQLAbstractGrammar</class-id> <category>accessing</category><body package="GraphQLBeta-Parser" selector="booleanType">booleanType	"Return a token of a parser accepting Boolean"	^ ('Boolean' asParser , #word asParser not , $_ asParser not) token</body><body package="GraphQLBeta-Parser" selector="floatType">floatType	"Return a token of parser Float"	^ ('Float' asParser , #word asParser not , $_ asParser not) token</body><body package="GraphQLBeta-Parser" selector="idType">idType	"Return a token of parser ID"	^ ('ID' asParser , #word asParser not , $_ asParser not) token</body><body package="GraphQLBeta-Parser" selector="intType">intType	"Return a token of parse Int"	^ ('Int' asParser , #word asParser not , $_ asParser not) token</body><body package="GraphQLBeta-Parser" selector="nullValue">nullValue	"Return a token of parsing: null"	^ 'null' asParser token</body><body package="GraphQLBeta-Parser" selector="scalarType">scalarType	"Return a parser accepting:intTypefloatTypestringTypebooleanTypeidType"	^ intType / floatType / stringType / booleanType / idType</body><body package="GraphQLBeta-Parser" selector="stringType">stringType	"Return a token of parse String"	^ ('String' asParser , #word asParser not , $_ asParser not) token</body></methods><methods><class-id>GraphQLBeta.GQLRequestGrammar</class-id> <category>accessing</category><body package="GraphQLBeta-Parser" selector="argument">argument	"Return a parser accepting:tokenName : Value"	^ tokenName , ($: asParser trim: insignificantToken) , value</body><body package="GraphQLBeta-Parser" selector="arguments">arguments	"Return a parser accepting:( Argument+ )"	^ ($( asParser trimRight: ignored)		, (argument trimRight: ignored) plus , $) asParser</body><body package="GraphQLBeta-Parser" selector="defaultValue">defaultValue	"Return a parser accepting:= value"	^ ($= asParser trimRight: insignificantToken) , value</body><body package="GraphQLBeta-Parser" selector="definition">definition	"Return a parser accepting operationDefinition or fragmentDefinition"	^ operationDefinition / fragmentDefinition</body><body package="GraphQLBeta-Parser" selector="enumValue">enumValue	"Return a parser accepting a tokenName but not a booleanValue or null"	^ (booleanValue not , nullValue not , tokenName) flatten token</body><body package="GraphQLBeta-Parser" selector="fragmentName">fragmentName	"Return a parser accepting a token name but not on"	^ 'on' asParser not , tokenName</body><body package="GraphQLBeta-Parser" selector="inlineFragment">inlineFragment	"Return a parser accepting:... typeConditionOptional directivesOptional selectionSet"	^ comments , ('...' asParser token trimRight: insignificantToken)		, (typeCondition optional trimRight: insignificantToken)		, (directives optional trimRight: insignificantToken) , selectionSet		, comments</body><body package="GraphQLBeta-Parser" selector="listValue">listValue	"Return a parser accepting:	[]	[ Value* ]"	^ ($[ asParser trimRight: ignored) token		, (value trimRight: ignored) star , $] asParser token</body><body package="GraphQLBeta-Parser" selector="objectValue">objectValue	"Return a parser accepting: - { } - { ObjectField* }"	^ (${ asParser trimRight: ignored)		, (objectField trimRight: ignored) star , $} asParser token</body><body package="GraphQLBeta-Parser" selector="operationType">operationType	"Return a parser accepting:- query- mutation"	^ 'query' asParser / 'mutation' asParser</body><body package="GraphQLBeta-Parser" selector="selection">selection	"Return a token for a field or fragmentSpread or inlineFragment"	^ field / fragmentSpread / inlineFragment</body><body package="GraphQLBeta-Parser" selector="start">start	"Return a parser accepting a document, transform this to a token and then end the input"	^ document end</body><body package="GraphQLBeta-Parser" selector="type">type	"Return a parser accepting:- nonNullType- namedType- listType"	^ nonNullType / namedType / listType</body><body package="GraphQLBeta-Parser" selector="value">value	"[~Const]Variable IntValue FloatValue StringValue BooleanValue 	 NullValue EnumValue ListValue[~Const] ObjectValue[~Const]"	^ variable / floatValue / intValue / stringValue / booleanValue		/ nullValue / enumValue / listValue / objectValue</body><body package="GraphQLBeta-Parser" selector="variable">variable	"Return a token input from parse:$ tokenName"	^ ($$ asParser , tokenName) flatten token</body><body package="GraphQLBeta-Parser" selector="variableDefinition">variableDefinition	"Return a parser accepting:variable : type defaultValueOptional"	^ variable , ($: asParser trim: insignificantToken)		, (type trimRight: insignificantToken) , defaultValue optional</body></methods><methods><class-id>GraphQLBeta.GQLRequestGrammar</class-id> <category>grammar</category><body package="GraphQLBeta-Parser" selector="alias">alias	"Return a parser accepting: tokenName :"	^ (tokenName trimRight: insignificantToken)		, ($: asParser trim: insignificantToken)</body><body package="GraphQLBeta-Parser" selector="directive">directive	"Return a parser accepting:@ tokenName ArgumentsOptional"	^ $@ asParser , (tokenName trimRight: insignificantTokenNoComment)		, arguments optional , comments</body><body package="GraphQLBeta-Parser" selector="directives">directives	"Return a parser accepting:	Directive+"	^ (directive trim: ignored) plus</body><body package="GraphQLBeta-Parser" selector="document">document	"Return a parser accepting one or more definitions"	^ (definition trim: insignificantTokenNoComment) plus</body><body package="GraphQLBeta-Parser" selector="field">field	"Return a parser accepting:	nonScalarField	scalarField"	^ nonScalarField / scalarField</body><body package="GraphQLBeta-Parser" selector="fragmentDefinition">fragmentDefinition	"Return a parser accepting:fragment fragmentName typeCondition directiveOptional selectionSet"	^ comments , 'fragment' asParser , whiteSpace plus		, (fragmentName trim: insignificantToken)		, (typeCondition trimRight: insignificantToken)		, (directives optional trimRight: insignificantToken)		, (selectionSet trimRight: insignificantTokenNoComment) , comments</body><body package="GraphQLBeta-Parser" selector="fragmentSpread">fragmentSpread	"Return a parser accepting: ... FragmentName DirectivesOptional"	^ comments , '...' asParser , (fragmentName trim: ignored)		, directives optional , comments</body><body package="GraphQLBeta-Parser" selector="listType">listType	"Return a parser accepting:[ type ]"	^ ($[ asParser trimRight: ignored) , (type trimRight: ignored)		, ($] asParser trimRight: insignificantToken)</body><body package="GraphQLBeta-Parser" selector="named">named	"Return a name"	^ tokenName</body><body package="GraphQLBeta-Parser" selector="namedType">namedType	"Return a parser accepting:	-scalarType	-named"	^ scalarType / named</body><body package="GraphQLBeta-Parser" selector="nonNullListType">nonNullListType	"Return a parser accepting:- listType !"	^ listType , $! asParser</body><body package="GraphQLBeta-Parser" selector="nonNullNamedType">nonNullNamedType	"Return a parser accepting:- namedType !"	^ (namedType trim: ignored) , $! asParser</body><body package="GraphQLBeta-Parser" selector="nonNullType">nonNullType	"Return a parser accepting:- nonNullNamedType- nonNullListType"	^ nonNullNamedType / nonNullListType trim: insignificantToken</body><body package="GraphQLBeta-Parser" selector="nonScalarField">nonScalarField	"Return a parser accepting:- aliasOptional tokenName argumentsOptional directivesOptional selectionSet"	^ comments , alias optional		, (tokenName trimRight: insignificantToken)		, (arguments optional trimRight: insignificantToken)		, (directives optional trimRight: insignificantToken)		, (selectionSet trimRight: insignificantTokenNoComment) , comments</body><body package="GraphQLBeta-Parser" selector="objectField">objectField	"Return a parser accepting: tokenName : value"	^ tokenName , ($: asParser trim: insignificantToken) , value</body><body package="GraphQLBeta-Parser" selector="operation">operation	"Return a parser accepting:- operationType tokenName variableDefinitionsOptional directivesOptional selectionSet"	^ comments , operationType , whiteSpace plus		, (tokenName optional trim: insignificantToken)		, (variableDefinitions optional trim: insignificantToken)		, (directives optional trimRight: insignificantToken)		, (selectionSet trimRight: insignificantTokenNoComment) , comments</body><body package="GraphQLBeta-Parser" selector="operationDefinition">operationDefinition	"Return a parser accepting:- selection set- operation"	^ selectionSet / operation</body><body package="GraphQLBeta-Parser" selector="scalarField">scalarField	"Return a parser accepting:aliasOptional tokenName argumentsOptional directivesOptional"	^ comments , alias optional		, (tokenName trimRight: insignificantTokenNoComment)		, (arguments optional trimRight: insignificantTokenNoComment)		, (directives optional trimRight: insignificantTokenNoComment)		, comments</body><body package="GraphQLBeta-Parser" selector="selectionSet">selectionSet	"Return a parser accepting:  { Selection+ }"	^ comments , ${ asParser , (selection trim: ignoredNoComment) plus		, $} asParser , comments</body><body package="GraphQLBeta-Parser" selector="typeCondition">typeCondition	"Return a parser accepting:on namedType"	^ 'on' asParser , whiteSpace plus		, (namedType trim: insignificantToken)</body><body package="GraphQLBeta-Parser" selector="variableDefinitions">variableDefinitions	"Return a parser accepting:( variableDefinition+ )"	^ $( asParser		, ((variableDefinition trim: insignificantToken) separatedBy: comma)		, $) asParser</body></methods><methods><class-id>GraphQLBeta.GQLSchemaGrammar</class-id> <category>accessing</category><body package="GraphQLBeta-Parser" selector="blockStringDelimiter">blockStringDelimiter	"Return a parser accepting the triple quotation symbol"	^ ($" asParser times: 3) flatten token</body><body package="GraphQLBeta-Parser" selector="mutation">mutation	"Return a parser accepting: mutation: tokenName"	^ comments , ('mutation' asParser trim: ignored) flatten token		, (':' asParser trim: ignored) , (tokenName trim: ignoredNoComment)		, comments</body><body package="GraphQLBeta-Parser" selector="objectType">objectType	"Return a parser accepting:description type objectTypeName implementsOptional fieldSet, with the comments"	^ comments , description optional , comments , 'type' asParser		, (objectTypeName trim: ignored) , interfaceList optional , fieldSet		, comments</body><body package="GraphQLBeta-Parser" selector="query">query	"Return a parser accepting: query: nameOfQuery"	^ comments , ('query' asParser trimRight: ignored) flatten token		, (':' asParser trim: ignored) , (tokenName trim: ignoredNoComment)		, comments</body><body package="GraphQLBeta-Parser" selector="scalarIntrospectionType">scalarIntrospectionType	"Return a parser accepting:description type objectTypeName implementsOptional fieldSet, with the comments"	^ comments , description optional , comments , 'scalar' asParser		, (objectTypeName trim: ignored) , interfaceList optional , fieldSet		, comments</body><body package="GraphQLBeta-Parser" selector="stringValue">stringValue	^ (blockStringDelimiter , blockStringCharacter star		, blockStringDelimiter) flatten token		/			(stringDelimiter , stringCharacter star , stringDelimiter) flatten				token</body><body package="GraphQLBeta-Parser" selector="subscription">subscription	"Return a parser accepting: subscription: nameOfSubscription"	^ comments , ('subscription' asParser trim: ignored) flatten token		, (':' asParser trim: ignored) , (tokenName trim: ignoredNoComment)		, comments</body></methods><methods><class-id>GraphQLBeta.GQLSchemaGrammar</class-id> <category>grammar</category><body package="GraphQLBeta-Parser" selector="baseType">baseType	"Return a parser accepting object filed base types"	^ scalarType / namedType	"enumTypeName / objectTypeName / interfaceTypeName / unionTypeName "</body><body package="GraphQLBeta-Parser" selector="blockStringCharacter">blockStringCharacter	"Return a parser accepting:	- SourceCharacter but not blockStringDelimiter or  (\,blockStringDelimiter)	- (\,blockStringDelimiter)"	^ (blockStringDelimiter not		, ($\ asParser , blockStringDelimiter) not , sourceCharacter)		/ ($\ asParser , blockStringDelimiter) flatten token</body><body package="GraphQLBeta-Parser" selector="commentsInterface">commentsInterface	"Return a parser accepting the comment ignoring the ignoredSpaces"	^ (comment trim: ignoredSpaces) star</body><body package="GraphQLBeta-Parser" selector="description">description	"Return the description of a GraphQL service"	^ stringValue trim: ignoredNoComment</body><body package="GraphQLBeta-Parser" selector="enumType">enumType	"Return a parser accepting:description enum enumTypeName enumValueList, join with the comments"	^ comments , description optional , comments		, ('enum' asParser trim: ignored) , (enumTypeName trim: ignored)		, (enumValueList trim: ignoredNoComment) , comments</body><body package="GraphQLBeta-Parser" selector="enumTypeExtension">enumTypeExtension	"Return a parser accepting:	enum enumTypeName enumValueList, join with the comments"	^ ('enum' asParser trim: ignored) , (enumTypeName trim: ignored)		, (enumValueList trim: ignoredNoComment) , comments</body><body package="GraphQLBeta-Parser" selector="enumTypeName">enumTypeName	"Return a token name that is not a true, false or null"	^ (booleanValue not , nullValue not , tokenName) flatten token</body><body package="GraphQLBeta-Parser" selector="enumValue">enumValue	"Return a parser accepting: description tokenName, with the comments "	^ comments , description optional , comments		, (tokenName trim: ignoredNoComment) , comments</body><body package="GraphQLBeta-Parser" selector="enumValueList">enumValueList	"Return a parser accepting:{ enumValue+ }"	^ ${ asParser , enumValue plus , $} asParser</body><body package="GraphQLBeta-Parser" selector="extension">extension	"Return a parser accepting:extend"	^ 'extend' asParser trim: ignored</body><body package="GraphQLBeta-Parser" selector="field">field	"Return a parser accepting:description fieldName parametersOptional : fieldType, with the comments"	^ comments , description optional , comments , fieldName		, (parameters trim: ignored) optional , ($: asParser trim: ignored)		, fieldType , comments</body><body package="GraphQLBeta-Parser" selector="fieldInputObject">fieldInputObject	"Return a parser accepting:description fieldName parametersOptional : fieldInputObjectType, with the comments"	^ comments , description optional , comments		, (fieldName trim: ignored) , (parameters trim: ignored) optional		, ($: asParser trim: ignored) , inputType , comments</body><body package="GraphQLBeta-Parser" selector="fieldInputObjectSet">fieldInputObjectSet	"Return a parser accepting:{ fieldInputObject+ }"	^ ${ asParser , (fieldInputObject trim: ignoredNoComment) plus		, $} asParser</body><body package="GraphQLBeta-Parser" selector="fieldName">fieldName	^ tokenName</body><body package="GraphQLBeta-Parser" selector="fieldSet">fieldSet	"Return a parser accepting:{ field+ }"	^ ${ asParser , (field trim: ignoredNoComment) plus , $} asParser</body><body package="GraphQLBeta-Parser" selector="fieldType">fieldType	"Return a parser accepting baseType or wrappedType"	^ nonNullType / baseType / listType</body><body package="GraphQLBeta-Parser" selector="ignoreDescriptionAndComments">ignoreDescriptionAndComments	"Return the description of a GraphQL service"	^ ignoredInExtensions plus</body><body package="GraphQLBeta-Parser" selector="ignoredInExtensions">ignoredInExtensions	"Return the description of a GraphQL service"	^ description / ignored</body><body package="GraphQLBeta-Parser" selector="ignoredSpaces">ignoredSpaces	"Return the parsers accepting the list of things we want to ignore"	^ comment / lineTerminator / unicodeBOM / whiteSpace</body><body package="GraphQLBeta-Parser" selector="inputObjectType">inputObjectType	"Return a parser accepting:description input inputObjectTypeName fieldSet, with the comments"	^ comments , description optional , comments , 'input' asParser		, (inputObjectTypeName trim: ignored) , fieldInputObjectSet		, comments</body><body package="GraphQLBeta-Parser" selector="inputObjectTypeExtension">inputObjectTypeExtension	"Return a parser accepting:	input inputObjectTypeName fieldSet, with the comments"	^ 'input' asParser , (inputObjectTypeName trim: ignored)		, fieldInputObjectSet , comments</body><body package="GraphQLBeta-Parser" selector="inputObjectTypeName">inputObjectTypeName	"Return a token name"	^ tokenName</body><body package="GraphQLBeta-Parser" selector="inputType">inputType	^ nonNullInputType / namedInputType / listInputType</body><body package="GraphQLBeta-Parser" selector="interfaceList">interfaceList	^ ('implements' asParser trim: ignored)		, ((interfaceTypeName trim: ignoredSpaces) separatedBy: $&amp; asParser)</body><body package="GraphQLBeta-Parser" selector="interfaceType">interfaceType	"Return a parser accepting:description interface interfaceTypeName fieldSet, with the comments"	^ comments , description optional , comments , 'interface' asParser		, (interfaceTypeName trim: ignored) , fieldSet , comments</body><body package="GraphQLBeta-Parser" selector="interfaceTypeExtension">interfaceTypeExtension	"Return a parser accepting:	interface interfaceTypeName fieldSet, with the comments"	^ 'interface' asParser , (interfaceTypeName trim: ignored) , fieldSet		, comments</body><body package="GraphQLBeta-Parser" selector="interfaceTypeName">interfaceTypeName	"Return a token name"	^ tokenName</body><body package="GraphQLBeta-Parser" selector="listInputType">listInputType	"Return a parser accepting:[ inputType ] "	^ $[ asParser , (inputType trim: ignored)		, ($] asParser trimRight: ignored)</body><body package="GraphQLBeta-Parser" selector="listType">listType	"Return a parser accepting: [ fieldType ]"	^ $[ asParser , (fieldType trim: ignored)		, ($] asParser trimRight: ignoredNoComment)</body><body package="GraphQLBeta-Parser" selector="namedInputType">namedInputType	"Return a token name"	^ scalarType / namedType</body><body package="GraphQLBeta-Parser" selector="namedType">namedType	"Return a token name"	^ tokenName</body><body package="GraphQLBeta-Parser" selector="nonNull">nonNull	"Return a parser accepting !"	^ $! asParser</body><body package="GraphQLBeta-Parser" selector="nonNullBaseType">nonNullBaseType	"Return a parser accepting: type nonNull"	^ (baseType trim: ignored) , nonNull</body><body package="GraphQLBeta-Parser" selector="nonNullInputType">nonNullInputType	"Return a parser accepting: namedType nonNull"	^ nonNullBaseType / nonNullNamedType / nonNullListInputType</body><body package="GraphQLBeta-Parser" selector="nonNullListInputType">nonNullListInputType	"Return a parser accepting: listInputType!"	^ listInputType , nonNull</body><body package="GraphQLBeta-Parser" selector="nonNullListType">nonNullListType	"Return a parser accepting: listType!"	^ listType , nonNull</body><body package="GraphQLBeta-Parser" selector="nonNullNamedType">nonNullNamedType	"Return a parser accepting: nametype nonNull"	^ (namedType trim: ignored) , nonNull</body><body package="GraphQLBeta-Parser" selector="nonNullType">nonNullType	"Return a parser accepting: type nonNull"	^ nonNullBaseType / nonNullListType</body><body package="GraphQLBeta-Parser" selector="objectExtension">objectExtension	"Return a parser accepting:objectType / interfaceList"	^ objectTypeExtension / objectTypeExtWithInterface</body><body package="GraphQLBeta-Parser" selector="objectTypeExtension">objectTypeExtension	"Return a parser accepting:	type objectTypeName implementsOptional fieldSet, with the comments"	^ 'type' asParser , (objectTypeName trim: ignored)		, interfaceList optional , fieldSet , comments</body><body package="GraphQLBeta-Parser" selector="objectTypeExtWithInterface">objectTypeExtWithInterface	^ 'type' asParser , (objectTypeName trim: ignored) , interfaceList		, comments</body><body package="GraphQLBeta-Parser" selector="objectTypeName">objectTypeName	"Return a token name"	^ tokenName</body><body package="GraphQLBeta-Parser" selector="parameter">parameter	"Return a parser accepting: description parameterName : inputType, with the comments"	^ (description trim: ignored) optional , parameterName		, ($: asParser trim: ignored) , inputType</body><body package="GraphQLBeta-Parser" selector="parameterName">parameterName	"Return a token name"	^ tokenName</body><body package="GraphQLBeta-Parser" selector="parameters">parameters	"Return a parser accepting:  ( parameter+ )"	^ ($( asParser trimRight: ignored)		, (parameter trimRight: ignored) plus , $) asParser</body><body package="GraphQLBeta-Parser" selector="rootOperationType">rootOperationType	"Return a parser accepting: query, mutation, subscription "	^ query / mutation / subscription</body><body package="GraphQLBeta-Parser" selector="rootOperationTypes">rootOperationTypes	"Return a parser accepting:{ query, mutation, subscription }"	^ (${ asParser trim: ignoredNoComment) , rootOperationType plus		, ($} asParser trim: ignoredNoComment)</body><body package="GraphQLBeta-Parser" selector="schema">schema	"Return a parser accepting one or more type"	^ (schemaType trim: ignoredNoComment) plus</body><body package="GraphQLBeta-Parser" selector="schemaDefinition">schemaDefinition	"Return a parser accepting:schema rootOperationTypes fieldSet, with the comments"	^ comments , ('schema' asParser trim: ignored) flatten token		, rootOperationTypes , comments</body><body package="GraphQLBeta-Parser" selector="schemaType">schemaType	"Return a parser accepting:- objectType- enumType- interfaceType- unionType- inputObjectType"	^ objectType / scalarIntrospectionType / enumType / interfaceType		/ unionType / inputObjectType / schemaDefinition		/ typeSystemExtension</body><body package="GraphQLBeta-Parser" selector="start">start	"Return a parser accepting a schema and then the end of the input"	^ schema end</body><body package="GraphQLBeta-Parser" selector="type">type	"Return a parser accepting:- scalarType- objectTypeName- enumTypeName- interfaceTypeName- unionTypeName"	^ scalarType / objectTypeName / enumTypeName / interfaceTypeName		/ unionTypeName</body><body package="GraphQLBeta-Parser" selector="typeSystemExtension">typeSystemExtension	^ comments , extension , typeSystemToExtend</body><body package="GraphQLBeta-Parser" selector="typeSystemToExtend">typeSystemToExtend	"Return a parser accepting:- objectType- enumType- interfaceType- unionType- inputObjectType"	^ objectExtension / enumTypeExtension / interfaceTypeExtension		/ unionTypeExtension / inputObjectTypeExtension / schemaDefinition</body><body package="GraphQLBeta-Parser" selector="unionType">unionType	"Return a parser accepting:description union unionTypeName = unionValuesList, with the comments"	^ comments , description optional , comments , 'union' asParser		, (unionTypeName trim: ignored) , ($= asParser trim: ignored)		, unionValuesList , comments</body><body package="GraphQLBeta-Parser" selector="unionTypeExtension">unionTypeExtension	"Return a parser accepting:	union unionTypeName = unionValuesList, with the comments"	^ 'union' asParser , (unionTypeName trim: ignored)		, ($= asParser trim: ignored) , unionValuesList , comments</body><body package="GraphQLBeta-Parser" selector="unionTypeName">unionTypeName	"Return a token name"	^ tokenName</body><body package="GraphQLBeta-Parser" selector="unionValuesList">unionValuesList	"Return a parser accepting:  objectTypeName | unionValue "	^ (unionTypeName trimRight: ignoredNoComment)		separatedBy: ($| asParser trim: ignored)</body></methods><methods><class-id>GraphQLBeta.GQLSchemaGrammarEvaluator</class-id> <category>grammar</category><body package="GraphQLBeta-Parser" selector="comment">comment	"Return a GQLComment instance"	^ super comment		performs: [ :tokens | 			| node |			node := GQLComment new.			node value: tokens inputValue trim.			node position: tokens start.			node ]</body><body package="GraphQLBeta-Parser" selector="comments">comments	"Return a [GQLComment]"	^ super comments performs: [ :tokens | tokens ]</body><body package="GraphQLBeta-Parser" selector="description">description	^ super description		performs: [ :tokens | 			| node |			node := GQLSDescription new.			node position: tokens start.			node value: tokens inputValue.			node ]</body><body package="GraphQLBeta-Parser" selector="enumType">enumType	"Return a GQLSEnumTypeNode instance with the enumTypeName, the values and the position on the text schema"	^ super enumType		performs: [ :tokens | 			| node |			node := GQLSEnumTypeNode new.			node description: (tokens at: 2).			node name: (tokens at: 5) inputValue.			node addValues: (tokens at: 6) second.			node position: (tokens at: 5) start.			node addComments: (tokens atAll: #(1 3 7)) ]</body><body package="GraphQLBeta-Parser" selector="enumTypeExtension">enumTypeExtension	"Return a GQLSEnumTypeNode instance with the enumTypeName, the values and the position on the text schema"	^ super enumTypeExtension		performs: [ :tokens | 			| node |			node := GQLSEnumTypeNode new.			node name: (tokens at: 2) inputValue.			node addValues: (tokens at: 3) second.			node position: (tokens at: 2) start.			node addComments: (tokens atAll: #(4)) ]</body><body package="GraphQLBeta-Parser" selector="enumValue">enumValue	"Return a GQLSEnumTypeNode instance with the enumTypeName, the values and the position on the text schema"	^ super enumValue		performs: [ :tokens | 			| node |			node := GQLSEnumValue new.			node description: (tokens at: 2).			node value: (tokens at: 4) inputValue.			node position: (tokens at: 4) start.			node addComments: (tokens atAll: #(1 3 5)) ]</body><body package="GraphQLBeta-Parser" selector="field">field	"Return a GQLSFieldNode instance with the name, arguments, type and position on the text schema"	^ super field		performs: [ :tokens | 			| node |			node := GQLSFieldNode new.			node description: (tokens at: 2).			node name: (tokens at: 4) inputValue.			node addArguments: (tokens at: 5).			node type: (tokens at: 7).			node position: (tokens at: 4) start.			node addComments: (tokens atAll: #(1 3 8)).			node fullName.			node ]</body><body package="GraphQLBeta-Parser" selector="fieldInputObject">fieldInputObject	"Return a GQLSFieldInputObjectFieldNode instance with the name, arguments, type and position on the text schema"	^ super field		performs: [ :tokens | 			| node |			node := GQLSInputObjectFieldNode new.			node description: (tokens at: 2).			node name: (tokens at: 4) inputValue.			node addArguments: (tokens at: 5).			node type: (tokens at: 7).			node position: (tokens at: 4) start.			node addComments: (tokens atAll: #(1 3 8)).			node fullName.			node ]</body><body package="GraphQLBeta-Parser" selector="inputObjectType">inputObjectType	"Return a GQLSInputObjectTypeNode instance with the input object name, the fields and the position on the text schema"	^ super inputObjectType		performs: [ :tokens | 			| node |			node := GQLSInputObjectTypeNode new.			node description: (tokens at: 2).			node name: (tokens at: 5) inputValue.			node addFields: (tokens at: 6).			node position: (tokens at: 5) start.			node addComments: (tokens atAll: #(1 3 7)) ]</body><body package="GraphQLBeta-Parser" selector="inputObjectTypeExtension">inputObjectTypeExtension	"Return a GQLSInputObjectTypeNode instance with the input object name, the fields and the position on the text schema"	^ super inputObjectTypeExtension		performs: [ :tokens | 			| node |			node := GQLSInputObjectTypeNode new.			node name: (tokens at: 2) inputValue.			node addFields: (tokens at: 3).			node position: (tokens at: 2) start.			node addComments: (tokens atAll: #(4)) ]</body><body package="GraphQLBeta-Parser" selector="interfaceList">interfaceList	"Return an array"	^ super interfaceList		performs:			[ :tokens | (tokens at: 2) reject: #isCharacter thenCollect: #inputValue ]</body><body package="GraphQLBeta-Parser" selector="interfaceType">interfaceType	"Return a GQLSInterfaceTypeNode instance with the enumTypeName, the values and the position on the text schema"	^ super interfaceType		performs: [ :tokens | 			| node |			node := GQLSInterfaceTypeNode new.			node description: (tokens at: 2).			node name: (tokens at: 5) inputValue.			node addFields: (tokens at: 6).			node position: (tokens at: 5) start.			node addComments: (tokens atAll: #(1 3 7)) ]</body><body package="GraphQLBeta-Parser" selector="interfaceTypeExtension">interfaceTypeExtension	"Return a GQLSInterfaceTypeNode instance with the enumTypeName, the values and the position on the text schema"	^ super interfaceTypeExtension		performs: [ :tokens | 			| node |			node := GQLSInterfaceTypeNode new.			node name: (tokens at: 2) inputValue.			node addFields: (tokens at: 3).			node position: (tokens at: 2) start.			node addComments: (tokens atAll: #(4)) ]</body><body package="GraphQLBeta-Parser" selector="objectType">objectType	"Return a GQLSObjectTypeNode instance with the objectTypeName, the fields and the position on the text schema"	^ super objectType		performs: [ :tokens | 			| node |			node := GQLSObjectTypeNode new.			node description: (tokens at: 2).			node name: (tokens at: 5) inputValue.			node addFields: (tokens at: 7).			node implements: (tokens at: 6).			node position: (tokens at: 5) start.			node addComments: (tokens atAll: #(1 3 8)) ]</body><body package="GraphQLBeta-Parser" selector="objectTypeExtension">objectTypeExtension	"Return a GQLSObjectTypeNode instance with the objectTypeName, the fields and the position on the text schema"	^ super objectTypeExtension		performs: [ :tokens | 			| node |			node := GQLSObjectTypeNode new.			node name: (tokens at: 2) inputValue.			node addFields: (tokens at: 4).			node implements: (tokens at: 3).			node position: (tokens at: 2) start.			node addComments: (tokens atAll: #(5)) ]</body><body package="GraphQLBeta-Parser" selector="parameter">parameter	"Return a GQLSParameterNode instance with the parameterName, inputType and the position on the text schema"	^ super parameter		performs: [ :tokens | 			| node |			node := GQLSInputObjectFieldNode new.			node description: (tokens at: 1).			node name: (tokens at: 2) inputValue.			node type: (tokens at: 4).			node position: (tokens at: 2) start.			node ]</body><body package="GraphQLBeta-Parser" selector="rootOperationType">rootOperationType	"Return a GQLSRootOperationType instance with the name and position on the text schema"	^ super rootOperationType		performs: [ :tokens | 			| node |			node := GQLSRootOperationTypeNode new.			node key: (tokens at: 2) inputValue.			node name: (tokens at: 4) inputValue.			node position: (tokens at: 2) start.			node addComments: (tokens atAll: #(1 5)).			node ]</body><body package="GraphQLBeta-Parser" selector="schema">schema	"Return a GQLSchemaNode instance with the types defined on the text schema"	^ super schema		performs: [ :tokens | 			| node |			node := GQLSSchemaNode new.			node				addTypes: (tokens reject: [ :item | item isTypeExtensionNode ]).			node				addTypeExtensions: (tokens select: [ :item | item isTypeExtensionNode ]) ]</body><body package="GraphQLBeta-Parser" selector="schemaDefinition">schemaDefinition	"Return a GQLSSchemaDefinition instance with the rootOperationTypes, position and comments"	^ super schemaDefinition		performs: [ :tokens | 			| node |			node := GQLSSchemaDefinitionNode new.			node rootOperationTypes: (tokens at: 3).			node position: (tokens at: 2) start.			node addComments: (tokens atAll: #(1 4)) ]</body><body package="GraphQLBeta-Parser" selector="typeSystemExtension">typeSystemExtension	^ super typeSystemExtension		performs: [ :tokens | 			| node value |			node := GQLSTypeSystemExtension new.			value := tokens at: 3.			node value: value.			node name: value name.			node position: value position.			node addComments: (tokens atAll: #(1)).			node ]</body><body package="GraphQLBeta-Parser" selector="unionType">unionType	"Return a GQLSUnionTypeNode instance with the union name, the values and the position on the text schema"	^ super unionType		performs: [ :tokens | 			| node |			node := GQLSUnionTypeNode new.			node description: (tokens at: 2).			node name: (tokens at: 5) inputValue.			node addTypes: (tokens at: 7).			node position: (tokens at: 5) start.			node addComments: (tokens atAll: #(1 3 8)) ]</body><body package="GraphQLBeta-Parser" selector="unionTypeExtension">unionTypeExtension	"Return a GQLSUnionTypeNode instance with the union name, the values and the position on the text schema"	^ super unionTypeExtension		performs: [ :tokens | 			| node |			node := GQLSUnionTypeNode new.			node name: (tokens at: 2) inputValue.			node addTypes: (tokens at: 4).			node position: (tokens at: 2) start.			node addComments: (tokens atAll: #(5)) ]</body><body package="GraphQLBeta-Parser" selector="unionValuesList">unionValuesList	"Return an array"	^ super unionValuesList		performs: [ :tokens | tokens reject: #isCharacter thenCollect: #inputValue ]</body></methods><methods><class-id>GraphQLBeta.GQLSchemaGrammarEvaluator</class-id> <category>accessing</category><body package="GraphQLBeta-Parser" selector="booleanType">booleanType	"Return a GQLSBooleanType instance"	^ super booleanType		performs: [ :tokens | 			| node |			node := GQLSBooleanTypeNode new.			node ]</body><body package="GraphQLBeta-Parser" selector="enumValueList">enumValueList	"Return an array"	^ super enumValueList performs: [ :tokens | tokens ]</body><body package="GraphQLBeta-Parser" selector="fieldInputObjectSet">fieldInputObjectSet	"Return the fields"	^ super fieldInputObjectSet performs: [ :tokens | tokens at: 2 ]</body><body package="GraphQLBeta-Parser" selector="fieldSet">fieldSet	"Return the fields"	^ super fieldSet performs: [ :tokens | tokens at: 2 ]</body><body package="GraphQLBeta-Parser" selector="floatType">floatType	"Return a GQLSFloatType instance"	^ super floatType		performs: [ :tokens | 			| node |			node := GQLSFloatTypeNode new.			node ]</body><body package="GraphQLBeta-Parser" selector="idType">idType	"Return a GQLSIDType instance"	^ super idType		performs: [ :tokens | 			| node |			node := GQLSIDTypeNode new.			node ]</body><body package="GraphQLBeta-Parser" selector="inputType">inputType	"Return the tokens"	^ super inputType performs: [ :tokens | tokens ]</body><body package="GraphQLBeta-Parser" selector="intType">intType	"Return a GQLSIntType instance"	^ super intType		performs: [ :tokens | 			| node |			node := GQLSIntTypeNode new.			node position: tokens start.			node ]</body><body package="GraphQLBeta-Parser" selector="listInputType">listInputType	"Return a GQLSListTypeNode instance with the innerInputType and if is null"	^ super listInputType		performs: [ :tokens | 			| node |			node := GQLSListTypeNode new.			node wrappedType: (tokens at: 2).			node position: (tokens at: 2) position.			node ]</body><body package="GraphQLBeta-Parser" selector="listType">listType	"Return a GQLSListTypeNode instance with the innerTypeNode"	^ super listType		performs: [ :tokens | 			| node |			node := GQLSListTypeNode new.			node wrappedType: (tokens at: 2).			node position: (tokens at: 2) position.			node ]</body><body package="GraphQLBeta-Parser" selector="namedType">namedType	"Return a GQLSNamedTypeNode instance with the wrapped type"	^ super namedType		performs: [ :tokens | 			| node |			node := GQLSNamedTypeNode new.			node name: tokens inputValue.			node position: tokens start.			node ]</body><body package="GraphQLBeta-Parser" selector="nonNullInputType">nonNullInputType	"Return a GQLSNonNullInputTypeNode instance with the wrapped type"	^ super nonNullInputType		performs: [ :tokens | 			| node |			node := GQLSNonNullTypeNode new.			node wrappedType: (tokens at: 1).			node position: (tokens at: 1) position.			node ]</body><body package="GraphQLBeta-Parser" selector="nonNullType">nonNullType	"Return a GQLSNonNullTypeNode instance with the wrapped type"	^ super nonNullType		performs: [ :tokens | 			| node |			node := GQLSNonNullTypeNode new.			node wrappedType: (tokens at: 1).			node position: (tokens at: 1) position.			node ]</body><body package="GraphQLBeta-Parser" selector="objectTypeExtWithInterface">objectTypeExtWithInterface	^ super objectTypeExtWithInterface		performs: [ :tokens | 			| node |			node := GQLSObjectTypeNode new.			node name: (tokens at: 2) inputValue.			node implements: (tokens at: 3).			node position: (tokens at: 2) start.			node addComments: (tokens atAll: #(4)) ]</body><body package="GraphQLBeta-Parser" selector="parameters">parameters	"Return the list of parameter"	^ super parameters performs: [ :tokens | tokens at: 2 ]</body><body package="GraphQLBeta-Parser" selector="rootOperationTypes">rootOperationTypes	"Return the [rootOperationType]"	^ super rootOperationTypes performs: [ :tokens | tokens at: 2 ]</body><body package="GraphQLBeta-Parser" selector="start">start	"Return a parser accepting schema and then the input ends"	^ schema end</body><body package="GraphQLBeta-Parser" selector="stringType">stringType	"Return a GQLSStringType instance"	^ super stringType		performs: [ :tokens | 			| node |			node := GQLSStringTypeNode new.			node ]</body><body package="GraphQLBeta-Parser" selector="typeSystemToExtend">typeSystemToExtend	^ super typeSystemToExtend performs: [ :tokens | tokens ]</body></methods><methods><class-id>GraphQLBeta.GQLVariableGrammar</class-id> <category>accessing</category><body package="GraphQLBeta-Parser" selector="start">start	"Return a parser accepting the variableSet and success at the end of the input"	^ variableSet end</body><body package="GraphQLBeta-Parser" selector="tokenValue">tokenValue	"[~Const] IntValue FloatValue StringValue BooleanValue 	 NullValue EnumValue ListValue[~Const] ObjectValue[~Const]"	^ floatValue / intValue / stringValue / booleanValue / nullValue		/ enumValue / listValue / objectValue</body></methods><methods><class-id>GraphQLBeta.GQLVariableGrammar</class-id> <category>grammar</category><body package="GraphQLBeta-Parser" selector="variableSet">variableSet	"Return a parser accepting:  { Variable+ }"	^ (${ asParser trim: ignored) , (variableValue trim: ignored) plus		, ($} asParser trim: ignored)</body><body package="GraphQLBeta-Parser" selector="variableValue">variableValue	"Return a parser accepting:	stringValue : tokenValue"	^ (stringValue trimRight: insignificantToken)		, ($: asParser trimRight: insignificantToken)		, (tokenValue trimRight: insignificantToken)</body></methods><methods><class-id>GraphQLBeta.GQLVariableGrammarEvaluator</class-id> <category>accessing</category><body package="GraphQLBeta-Parser" selector="booleanValue">booleanValue	"Return the boolean value"	^ super booleanValue		performs: [ :tokens | 			| node |			node := GQLBooleanNode new.			node value: tokens inputValue.			node ]</body><body package="GraphQLBeta-Parser" selector="enumValue">enumValue	"Return the enum value"	^ super enumValue		performs: [ :tokens | 			| node |			node := GQLEnumNode new.			node value: tokens inputValue.			node ]</body><body package="GraphQLBeta-Parser" selector="floatValue">floatValue	"Return the variable"	^ super floatValue		performs: [ :tokens | 			| node |			node := GQLFloatNode new.			node value: tokens inputValue.			node ]</body><body package="GraphQLBeta-Parser" selector="intValue">intValue	"Return the intValue"	^ super intValue		performs: [ :tokens | 			| node |			node := GQLIntNode new.			node value: tokens inputValue.			node ]</body><body package="GraphQLBeta-Parser" selector="listValue">listValue	"Return the list value"	^ super listValue		performs: [ :tokens | 			| node |			node := GQLListNode new.			node value: (tokens at: 2).			node ]</body><body package="GraphQLBeta-Parser" selector="nullValue">nullValue	"Return the nullValue"	^ super nullValue		performs: [ :tokens | 			| node |			node := GQLNullNode new.			node value: tokens inputValue.			node ]</body><body package="GraphQLBeta-Parser" selector="objectField">objectField	"Return a GQLObjectFieldNode instance with the information from the request"	^ super objectField		performs: [ :tokens | 			| node |			node := GQLObjectFieldNode new.			node name: (tokens at: 1) inputValue.			node value: (tokens at: 3).			node ]</body><body package="GraphQLBeta-Parser" selector="objectValue">objectValue	"Return the objectValue"	^ super objectValue		performs: [ :tokens | 			| node |			node := GQLObjectNode new.			node objectFields: (tokens at: 2).			node ]</body><body package="GraphQLBeta-Parser" selector="stringValue">stringValue	"Return the string value"	^ super stringValue		performs: [ :tokens | 			| node |			node := GQLStringNode new.			node value: tokens inputValue.			node ]</body><body package="GraphQLBeta-Parser" selector="variableSet">variableSet	"Return the variableValues parsed"	^ super variableSet performs: [ :tokens | tokens at: 2 ]</body></methods><methods><class-id>GraphQLBeta.GQLVariableGrammarEvaluator</class-id> <category>grammar</category><body package="GraphQLBeta-Parser" selector="variableValue">variableValue	"Return a instance of GQLVariableDefinitionNode with the information of the parser"	^ super variableValue		performs: [ :tokens | 			| node |			node := GQLVariableDefinitionNode new.			node name: ((tokens at: 1) executeOn: nil with: nil using: nil).			node value: (tokens at: 3).			node ]</body></methods><methods><class-id>GraphQLBeta.GQLRequestGrammarEvaluator</class-id> <category>accessing</category><body package="GraphQLBeta-Parser" selector="comment">comment	"Return a GQLComment instance"	^ super comment		performs: [ :tokens | 			| node |			node := GQLComment new.			node value: tokens inputValue trim.			node position: tokens start.			node ]</body><body package="GraphQLBeta-Parser" selector="comments">comments	"Return a [GQLComment]"	^ super comments performs: [ :tokens | tokens ]</body></methods><methods><class-id>GraphQLBeta.GQLRequestGrammarEvaluator</class-id> <category>grammar</category><body package="GraphQLBeta-Parser" selector="alias">alias	"Return the alias"	^ super alias performs: [ :tokens | (tokens at: 1) inputValue ]</body><body package="GraphQLBeta-Parser" selector="argument">argument	"Return a GQLArgumentNode instance with the information parsed of the request"	^ super argument		performs: [ :tokens | 			| node |			node := GQLArgumentNode new.			node name: (tokens at: 1) inputValue.			node value: (tokens at: 3).			node position: (tokens at: 1) start.			node ]</body><body package="GraphQLBeta-Parser" selector="arguments">arguments	"Return the arguments"	^ super arguments performs: [ :tokens | tokens at: 2 ]</body><body package="GraphQLBeta-Parser" selector="booleanType">booleanType	"Return a GQLSBooleanType instance"	^ super booleanType		performs: [ :tokens | 			| node |			node := GQLSBooleanTypeNode new.			node ]</body><body package="GraphQLBeta-Parser" selector="booleanValue">booleanValue	"Return the boolean value"	^ super booleanValue		performs: [ :tokens | 			| node |			node := GQLBooleanNode new.			node				value: tokens inputValue;				position: tokens start.			node ]</body><body package="GraphQLBeta-Parser" selector="defaultValue">defaultValue	"Return the default value"	^ super defaultValue performs: [ :tokens | tokens at: 2 ]</body><body package="GraphQLBeta-Parser" selector="directive">directive	"Return a GQLDirectiveNode instance with the information of the request"	^ super directive		performs: [ :tokens | 			| node |			node := GQLDirectiveNode new.			node name: (tokens at: 2) inputValue.			node arguments: (tokens at: 3).			node addComments: (Array with: (tokens at: 4)).			node ]</body><body package="GraphQLBeta-Parser" selector="document">document	"Return a instance of GQLDocumentNode with the information of the parser"	^ super document		performs: [ :tokens | 			| node |			node := GQLDocumentNode new.			node definitions: tokens ]</body><body package="GraphQLBeta-Parser" selector="enumValue">enumValue	"Return the enum value"	^ super enumValue		performs: [ :tokens | 			| node |			node := GQLEnumNode new.			node				value: tokens inputValue;				position: tokens start.			node ]</body><body package="GraphQLBeta-Parser" selector="floatType">floatType	"Return a GQLSFloatTypeNode instance"	^ super floatType		performs: [ :tokens | 			| node |			node := GQLSFloatTypeNode new.			node position: tokens start.			node ]</body><body package="GraphQLBeta-Parser" selector="floatValue">floatValue	"Return the variable"	^ super floatValue		performs: [ :tokens | 			| node |			node := GQLFloatNode new.			node				value: tokens inputValue;				position: tokens start.			node ]</body><body package="GraphQLBeta-Parser" selector="fragmentDefinition">fragmentDefinition	"Return a instance of GQLFragmentNode with the information of the request"	^ super fragmentDefinition		performs: [ :tokens | 			| node |			node := GQLFragmentNode new.			node name: (tokens at: 4) inputValue.			node typeCondition: (tokens at: 5).			node directives: (tokens at: 6).			node selectionSet: (tokens at: 7).			node position: (tokens at: 4) start.			node addComments: (tokens atAll: #(1 8)).			node ]</body><body package="GraphQLBeta-Parser" selector="fragmentName">fragmentName	"Return the fragmentName"	^ super fragmentName performs: [ :tokens | tokens at: 2 ]</body><body package="GraphQLBeta-Parser" selector="fragmentSpread">fragmentSpread	"Return a instance of GQLFragmentSpreadNode with the information of the request"	^ super fragmentSpread		performs: [ :tokens | 			| node |			node := GQLFragmentSpreadNode new.			node name: (tokens at: 3) inputValue.			node directives: (tokens at: 4).			node position: (tokens at: 3) start.			node addComments: (tokens atAll: #(1 5)).			node ]</body><body package="GraphQLBeta-Parser" selector="idType">idType	"Return a GQLSIDType instance"	^ super idType		performs: [ :tokens | 			| node |			node := GQLSIDTypeNode new.			node ]</body><body package="GraphQLBeta-Parser" selector="inlineFragment">inlineFragment	"Return a instance of GQLInlineFragmentNode with the information of the request"	^ super inlineFragment		performs: [ :tokens | 			| node |			node := GQLInlineFragmentNode new				typeCondition: (tokens at: 3);				directives: (tokens at: 4);				selectionSet: (tokens at: 5);				addComments: (tokens atAll: #(1 6)).			node ]</body><body package="GraphQLBeta-Parser" selector="intType">intType	"Return a GQLSIntTypeNode instance"	^ super intType		performs: [ :tokens | 			| node |			node := GQLSIntTypeNode new.			node position: tokens start.			node ]</body><body package="GraphQLBeta-Parser" selector="intValue">intValue	"Return the intValue"	^ super intValue		performs: [ :tokens | 			| node |			node := GQLIntNode new.			node				value: tokens inputValue;				position: tokens start.			node ]</body><body package="GraphQLBeta-Parser" selector="listType">listType	"Return a list type"	^ super listType		performs: [ :tokens | 			| node |			node := GQLSListTypeNode new.			node wrappedType: (tokens at: 2).			node position: (tokens at: 2) position.			node ]</body><body package="GraphQLBeta-Parser" selector="listValue">listValue	"Return the list value"	^ super listValue		performs: [ :tokens | 			| node |			node := GQLListNode new.			node position: (tokens at: 1) start.			node value: (tokens at: 2).			node ]</body><body package="GraphQLBeta-Parser" selector="named">named	"Return a GQLSNamedTypeNode instance with his name and the position on the request"	^ super named		performs: [ :tokens | 			| node |			node := GQLSNamedTypeNode new.			node name: tokens inputValue.			node position: tokens start.			node ]</body><body package="GraphQLBeta-Parser" selector="nonNullType">nonNullType	"Return the non null type"	^ super nonNullType		performs: [ :tokens | 			| node |			node := GQLSNonNullTypeNode new.			node wrappedType: (tokens at: 1).			node position: (tokens at: 1) position.			node ]</body><body package="GraphQLBeta-Parser" selector="nonScalarField">nonScalarField	"Return a GQLNonScalarNode instance with the information of the request parsed"	^ super nonScalarField		performs: [ :tokens | 			| node |			node := GQLNonScalarFieldNode new.			node alias: (tokens at: 2).			node name: (tokens at: 3) inputValue.			node arguments: (tokens at: 4).			node selectionSet: (tokens at: 6).			node position: (tokens at: 3) start.			node addComments: (tokens atAll: #(1 7)).			node ]</body><body package="GraphQLBeta-Parser" selector="nullValue">nullValue	"Return the nullValue"	^ super nullValue		performs: [ :tokens | 			| node |			node := GQLNullNode new.			node				value: tokens inputValue;				position: tokens start.			node ]</body><body package="GraphQLBeta-Parser" selector="objectField">objectField	"Return a GQLObjectFieldNode instance with the information from the request"	^ super objectField		performs: [ :tokens | 			| node |			node := GQLObjectFieldNode new.			node name: (tokens at: 1) inputValue.			node position: (tokens at: 1) start.			node value: (tokens at: 3).			node ]</body><body package="GraphQLBeta-Parser" selector="objectValue">objectValue	"Return the objectValue"	^ super objectValue		performs: [ :tokens | 			| node |			node := GQLObjectNode new.			node objectFields: (tokens at: 2).			node ]</body><body package="GraphQLBeta-Parser" selector="operation">operation	"Return a instance of GQLOperationNode with the information of the parser"	^ super operation		performs: [ :tokens | 			| node |			node := GQLOperationNode new.			node type: (tokens at: 2).			node name: (tokens at: 4).			node variableDefinitions: (tokens at: 5).			node directives: (tokens at: 6).			node selectionSet: (tokens at: 7).			node addComments: (tokens atAll: #(1 8)) ]</body><body package="GraphQLBeta-Parser" selector="scalarField">scalarField	"Return a GQLScalarFieldNode instance with the information from the request"	^ super scalarField		performs: [ :tokens | 			| node |			node := GQLScalarFieldNode new.			node alias: (tokens at: 2).			node name: (tokens at: 3) inputValue.			node arguments: (tokens at: 4).			node directives: (tokens at: 5).			node position: (tokens at: 3) start.			node addComments: (tokens atAll: #(1 6)).			node ]</body><body package="GraphQLBeta-Parser" selector="selectionSet">selectionSet	"Return a set of selections"	^ super selectionSet		performs: [ :tokens | 			| node |			node := GQLSelectionSetNode new.			node selections: (tokens at: 3).			node addComments: (tokens atAll: #(1 5)).			node ]</body><body package="GraphQLBeta-Parser" selector="stringType">stringType	"Return a GQLSStringType instance"	^ super stringType		performs: [ :tokens | 			| node |			node := GQLSStringTypeNode new.			node ]</body><body package="GraphQLBeta-Parser" selector="stringValue">stringValue	"Return the string value"	^ super stringValue		performs: [ :tokens | 			| node |			node := GQLStringNode new.			node				value: tokens inputValue;				position: tokens start.			node ]</body><body package="GraphQLBeta-Parser" selector="typeCondition">typeCondition	"Return the type condition"	^ super typeCondition performs: [ :tokens | tokens at: 3 ]</body><body package="GraphQLBeta-Parser" selector="variable">variable	"Return a GQLVariableNode instance with the value assigned"	^ super variable		performs: [ :tokens | 			GQLVariableNode new				value: (tokens inputValue copyWithout: $$);				position: tokens start ]</body><body package="GraphQLBeta-Parser" selector="variableDefinition">variableDefinition	"Return a GQLVariableDefinitionNode instance with the name, type and the default value of the variable"	^ super variableDefinition		performs: [ :tokens | 			| node |			node := GQLVariableDefinitionNode new.			node name: (tokens at: 1) value.			node position: (tokens at: 1) position.			node type: (tokens at: 3).			node defaultValue: (tokens at: 4).			node ]</body><body package="GraphQLBeta-Parser" selector="variableDefinitions">variableDefinitions	"Return the variable definitions"	^ super variableDefinitions		performs: [ :tokens | (tokens at: 2) reject: [ :var | var isCharacter ] ]</body></methods><methods><class-id>GraphQLBeta.GQLSingleAnonimousQueryGrammar</class-id> <category>grammar</category><body package="GraphQLBeta-Parser" selector="document">document	"Return a definition"	^ (definition trim: insignificantTokenNoComment) plus</body><body package="GraphQLBeta-Parser" selector="schemaField">schemaField	"Return a parser accepting:- aliasOptional tokenName argumentsOptional directivesOptional selectionSet"	^ comments , alias optional		, ('__schema' asParser flatten token trimRight: insignificantToken)		, (directives optional trimRight: insignificantToken)		, (selectionSet trimRight: insignificantTokenNoComment) , comments</body><body package="GraphQLBeta-Parser" selector="selectionSet">selectionSet	"Return a parser accepting:{ selection+ }"	^ comments , ${ asParser token		, (selection trim: ignoredNoComment) plus , $} asParser , comments</body><body package="GraphQLBeta-Parser" selector="typeField">typeField	"Return a parser accepting:- aliasOptional tokenName argumentsOptional directivesOptional selectionSet"	^ comments , alias optional		, ('__type' asParser flatten token trimRight: insignificantToken)		, (arguments trimRight: insignificantToken)		, (directives optional trimRight: insignificantToken)		, (selectionSet trimRight: insignificantTokenNoComment) , comments</body></methods><methods><class-id>GraphQLBeta.GQLSingleAnonimousQueryGrammar</class-id> <category>accessing</category><body package="GraphQLBeta-Parser" selector="field">field	^ schemaField / typeField / typenameField / nonScalarField		/ scalarField</body><body package="GraphQLBeta-Parser" selector="selection">selection	"Return a field or fragmentSpread"	^ field / fragmentSpread / inlineFragment</body><body package="GraphQLBeta-Parser" selector="start">start	"Return a parser accepting a document and then the end of the input"	^ document end</body><body package="GraphQLBeta-Parser" selector="typenameField">typenameField	"Return a parser accepting:- aliasOptional tokenName argumentsOptional directivesOptional selectionSet"	^ comments , alias optional		,			('__typename' asParser flatten token				trimRight: insignificantTokenNoComment)		, (directives optional trimRight: insignificantTokenNoComment)		, comments</body></methods><methods><class-id>GraphQLBeta.GQLSingleAnonimousQueryEvaluator</class-id> <category>accessing</category><body package="GraphQLBeta-Parser" selector="alias">alias	"Return the alias"	^ super alias performs: [ :tokens | (tokens at: 1) inputValue ]</body><body package="GraphQLBeta-Parser" selector="argument">argument	"Return an instance of GQLArgumentNode with  information about the query"	^ super argument		performs: [ :tokens | 			| node |			node := GQLArgumentNode new.			node name: (tokens at: 1) inputValue.			node value: (tokens at: 3).			node position: (tokens at: 1) start.			node ]</body><body package="GraphQLBeta-Parser" selector="arguments">arguments	"Return the arguments parsed"	^ super arguments performs: [ :tokens | tokens at: 2 ]</body><body package="GraphQLBeta-Parser" selector="booleanType">booleanType	"Return a GQLSBooleanType instance"	^ super booleanType		performs: [ :tokens | 			| node |			node := GQLSBooleanTypeNode new.			node position: tokens start.			node ]</body><body package="GraphQLBeta-Parser" selector="booleanValue">booleanValue	"Return GQLBooleanNode instances with the information of the query"	^ super booleanValue		performs: [ :tokens | 			| node |			node := GQLBooleanNode new.			node value: tokens inputValue.			node position: tokens start ]</body><body package="GraphQLBeta-Parser" selector="comment">comment	"Return a GQLComment instance"	^ super comment		performs: [ :tokens | 			| node |			node := GQLComment new.			node value: tokens inputValue trim.			node position: tokens start.			node ]</body><body package="GraphQLBeta-Parser" selector="comments">comments	"Return a [GQLComment]"	^ super comments performs: [ :tokens | tokens ]</body><body package="GraphQLBeta-Parser" selector="defaultValue">defaultValue	"Return the default value"	^ super defaultValue performs: [ :tokens | tokens at: 2 ]</body><body package="GraphQLBeta-Parser" selector="directive">directive	"Return the directive"	^ super directive		performs: [ :tokens | 			| node |			node := GQLDirectiveNode new: (tokens at: 2) inputValue.			node name: (tokens at: 2) inputValue.			node arguments: (tokens at: 3).			node position: (tokens at: 2) start.			node addComments: (Array with: (tokens at: 4)) ]</body><body package="GraphQLBeta-Parser" selector="document">document	"Return a instance of GQLDocumentNode with the information of the parser"	^ super document		performs: [ :tokens | 			| node |			node := GQLDocumentNode new.			node definitions: tokens ]</body><body package="GraphQLBeta-Parser" selector="enumValue">enumValue	"Return GQLEnumNode instance with the information of the request parsed"	^ super enumValue		performs: [ :tokens | 			| node |			node := GQLEnumNode new.			node value: tokens inputValue.			node position: tokens start ]</body><body package="GraphQLBeta-Parser" selector="floatType">floatType	"Return a GQLSFloatTypeNode instance"	^ super floatType		performs: [ :tokens | 			| node |			node := GQLSFloatTypeNode new.			node ]</body><body package="GraphQLBeta-Parser" selector="floatValue">floatValue	"Return GQLFloatNode instance of input type float with the information of the request parsed"	^ super floatValue		performs: [ :tokens | 			| node |			node := GQLFloatNode new.			node value: tokens inputValue.			node position: tokens start ]</body><body package="GraphQLBeta-Parser" selector="fragmentDefinition">fragmentDefinition	"Return a instance of GQLFragmentNode with the information of the request"	^ super fragmentDefinition		performs: [ :tokens | 			| node |			node := GQLFragmentNode new				name: (tokens at: 4) inputValue;				typeCondition: (tokens at: 5);				directives: (tokens at: 6);				selectionSet: (tokens at: 7);				position: (tokens at: 4) start;				addComments: (tokens atAll: #(1 8)).			node ]</body><body package="GraphQLBeta-Parser" selector="fragmentName">fragmentName	"Return the fragmentName"	^ super fragmentName performs: [ :tokens | tokens at: 2 ]</body><body package="GraphQLBeta-Parser" selector="fragmentSpread">fragmentSpread	"Return a instance of GQLFragmentSpreadNode with the information of the request"	^ super fragmentSpread		performs: [ :tokens | 			| node |			node := GQLFragmentSpreadNode new				name: (tokens at: 3) inputValue;				directives: (tokens at: 4);				position: (tokens at: 3) start;				addComments: (tokens atAll: #(1 5)).			node ]</body><body package="GraphQLBeta-Parser" selector="idType">idType	"Return a GQLSIDType instance"	^ super idType		performs: [ :tokens | 			| node |			node := GQLSIDTypeNode new.			node position: tokens start.			node ]</body><body package="GraphQLBeta-Parser" selector="inlineFragment">inlineFragment	"Return a instance of GQLInlineFragmentNode with the information of the request"	^ super inlineFragment		performs: [ :tokens | 			| node |			node := GQLInlineFragmentNode new				position: (tokens at: 2) start;				typeCondition: (tokens at: 3);				directives: (tokens at: 4);				selectionSet: (tokens at: 5);				addComments: (tokens atAll: #(1 6)).			node ]</body><body package="GraphQLBeta-Parser" selector="intType">intType	"Return a GQLSIntTypeNode instance"	^ super intType		performs: [ :tokens | 			| node |			node := GQLSIntTypeNode new.			node position: tokens start.			node ]</body><body package="GraphQLBeta-Parser" selector="intValue">intValue	"Return GQLIntNode instance of input type Int with the information of the request parsed"	^ super intValue		performs: [ :tokens | 			| node |			node := GQLIntNode new.			node value: tokens inputValue.			node position: tokens start ]</body><body package="GraphQLBeta-Parser" selector="listType">listType	"Return a list type"	^ super listType		performs: [ :tokens | 			| node |			node := GQLSListTypeNode new.			node wrappedType: (tokens at: 2).			node position: (tokens at: 2) position.			node ]</body><body package="GraphQLBeta-Parser" selector="listValue">listValue	"Return GQLListNode instance of input type List with the information of the request parsed"	^ super listValue		performs: [ :tokens | 			| node |			node := GQLListNode new.			node value: (tokens at: 2).			node ]</body><body package="GraphQLBeta-Parser" selector="named">named	"Return a GQLSNamedTypeNode instance with his name and the position on the request"	^ super named		performs: [ :tokens | 			| node |			node := GQLSNamedTypeNode new.			node name: tokens inputValue.			node position: tokens start.			node ]</body><body package="GraphQLBeta-Parser" selector="nonScalarField">nonScalarField	"Return a GQLNonScalarNode instance with the information of the request parsed"	^ super nonScalarField		performs: [ :tokens | 			| node |			node := GQLNonScalarFieldNode new.			node alias: (tokens at: 2).			node name: (tokens at: 3) inputValue.			node arguments: (tokens at: 4).			node directives: (tokens at: 5).			node selectionSet: (tokens at: 6).			node position: (tokens at: 3) start.			node addComments: (tokens atAll: #(1 7)).			node ]</body><body package="GraphQLBeta-Parser" selector="nullValue">nullValue	"Return GQLNullNode instance of input type null with the information of the request parsed"	^ super nullValue		performs: [ :tokens | 			| node |			node := GQLNullNode new.			node value: tokens inputValue.			node position: tokens start ]</body><body package="GraphQLBeta-Parser" selector="objectField">objectField	"Return GQLObjectFieldNode instance with the information of the request parsed"	^ super objectField		performs: [ :tokens | 			| node |			node := GQLObjectFieldNode new.			node name: (tokens at: 1) inputValue.			node position: (tokens at: 1) start.			node value: (tokens at: 3) ]</body><body package="GraphQLBeta-Parser" selector="objectValue">objectValue	"Return GQLObjectNode instance of input type Object with the information of the request parsed"	^ super objectValue		performs: [ :tokens | 			| node |			node := GQLObjectNode new.			node objectFields: (tokens at: 2).			node ]</body><body package="GraphQLBeta-Parser" selector="operation">operation	"Return a instance of GQLOperationNode"	^ super operation		performs: [ :tokens | 			| node |			node := GQLOperationNode new				type: (tokens at: 2);				name: (tokens at: 4);				variableDefinitions: (tokens at: 5);				directives: (tokens at: 6);				selectionSet: (tokens at: 7);				position: (tokens at: 4) start;				addComments: (tokens atAll: #(1 8)).			node ]</body><body package="GraphQLBeta-Parser" selector="scalarField">scalarField	"Return a GQLScalarFieldNode instance with the information of the request parsed"	^ super scalarField		performs: [ :tokens | 			| node |			node := GQLScalarFieldNode new.			node alias: (tokens at: 2).			node name: (tokens at: 3) inputValue.			node arguments: (tokens at: 4).			node directives: (tokens at: 5).			node position: (tokens at: 3) start.			node addComments: (tokens atAll: #(1 6)).			node ]</body><body package="GraphQLBeta-Parser" selector="selection">selection	"Return the tokens parsed"	^ super selection performs: [ :tokens | tokens ]</body><body package="GraphQLBeta-Parser" selector="stringType">stringType	"Return a GQLSStringType instance"	^ super stringType		performs: [ :tokens | 			| node |			node := GQLSStringTypeNode new.			node position: tokens start.			node ]</body><body package="GraphQLBeta-Parser" selector="stringValue">stringValue	"Return GQLStringNode instance of input type String with the information of the request parsed"	^ super stringValue		performs: [ :tokens | 			| node |			node := GQLStringNode new.			node value: tokens inputValue.			node position: tokens start ]</body><body package="GraphQLBeta-Parser" selector="typeCondition">typeCondition	"Return the type condition"	^ super typeCondition performs: [ :tokens | tokens at: 3 ]</body><body package="GraphQLBeta-Parser" selector="variableDefinitions">variableDefinitions	"Return the variable definitions"	^ super variableDefinitions		performs: [ :tokens | (tokens at: 2) reject: [ :var | var isCharacter ] ]</body></methods><methods><class-id>GraphQLBeta.GQLSingleAnonimousQueryEvaluator</class-id> <category>grammar</category><body package="GraphQLBeta-Parser" selector="nonNullType">nonNullType	"Return the non null type"	^ super nonNullType		performs: [ :tokens | 			| node |			node := GQLSNonNullTypeNode new.			node wrappedType: (tokens at: 1).			node position: (tokens at: 1) position.			node ]</body><body package="GraphQLBeta-Parser" selector="schemaField">schemaField	"Return a GQLNonScalarNode instance with the information of the request parsed"	^ super schemaField		performs: [ :tokens | 			| node |			node := GQLSchemaFieldNode new.			node alias: (tokens at: 2).			node name: (tokens at: 3) inputValue.			node directives: (tokens at: 4).			node selectionSet: (tokens at: 5).			node position: (tokens at: 3) start.			node addComments: (tokens atAll: #(1 6)).			node ]</body><body package="GraphQLBeta-Parser" selector="selectionSet">selectionSet	"Return a instance of GQLSelectionSetNode with the information of the parser"	^ super selectionSet		performs: [ :tokens | 			| node val |			val := tokens at: 3.			node := GQLSelectionSetNode new.			node				selections: val;				position: (tokens at: 2) start;				addComments: (tokens atAll: #(1 5)) ]</body><body package="GraphQLBeta-Parser" selector="typeField">typeField	"Return a GQLNonScalarNode instance with the information of the request parsed"	^ super typeField		performs: [ :tokens | 			| node |			node := GQLTypeFieldNode new.			node alias: (tokens at: 2).			node name: (tokens at: 3) inputValue.			node arguments: (tokens at: 4).			node directives: (tokens at: 5).			node selectionSet: (tokens at: 6).			node position: (tokens at: 3) start.			node addComments: (tokens atAll: #(1 7)).			node ]</body><body package="GraphQLBeta-Parser" selector="typenameField">typenameField	"Return a GQLNonScalarNode instance with the information of the request parsed"	^ super typenameField		performs: [ :tokens | 			| node |			node := GQLTypenameFieldNode new.			node alias: (tokens at: 2).			node name: (tokens at: 3) inputValue.			node directives: (tokens at: 4).			node position: (tokens at: 3) start.			node addComments: (tokens atAll: #(1 5)).			node ]</body><body package="GraphQLBeta-Parser" selector="variable">variable	"Return GQLVariableNode instance of input type variable with the information of the request parsed"	^ super variable		performs: [ :tokens | 			GQLVariableNode new				value: (tokens inputValue copyWithout: $$);				position: tokens start ]</body><body package="GraphQLBeta-Parser" selector="variableDefinition">variableDefinition	"Return a GQLVariableDefinitionNode instance with the name, type and the default value of the variable"	^ super variableDefinition		performs: [ :tokens | 			| node |			node := GQLVariableDefinitionNode new.			node name: (tokens at: 1) value.			node position: (tokens at: 1) position.			node type: (tokens at: 3).			node defaultValue: (tokens at: 4).			node ]</body></methods><methods><class-id>GraphQLBeta.GraphQLBetaDemoSite</class-id> <category>accessing</category><body package="GraphQLBeta-Demo" selector="graphql">graphql	^ graphql</body></methods><methods><class-id>GraphQLBeta.GraphQLBetaDemoSite</class-id> <category>server</category><body package="GraphQLBeta-Demo" selector="answerForTools:">answerForTools: aRequest	| dict query operation variables shouldValidate |	[ dict := STON fromString: aRequest contents ]		on: Error		do: [ :ex | 			dict := ZnResourceMetaUtils				parseQueryFrom: aRequest contents readStream ].	query := (self value: dict ofKey: 'query') trim.	operation := self value: dict ofKey: 'operationName'.	variables := self value: dict ofKey: 'variables'.	shouldValidate := (self value: dict ofKey: 'shouldValidate') = 'true'.	^ graphql		operation: operation;		variables: variables;		shouldValidate: shouldValidate;		handleRequest: query</body><body package="GraphQLBeta-Demo" selector="answerTo:">answerTo: aRequest	^ GraphQLPlatform current okResponse: GraphQLBetaDemoHTML htmlPage</body><body package="GraphQLBeta-Demo" selector="configure">configure	graphql := GraphQL new.	graphql createSchema: GQLQuery schema</body><body package="GraphQLBeta-Demo" selector="request:at:">request: aRequest at: nameQuery	^ GraphQLPlatform current request: aRequest at: nameQuery</body><body package="GraphQLBeta-Demo" selector="value:ofKey:">value: aDict ofKey: aString	| response |	response := ''.	aDict		at: aString		ifPresent: [ :val | val ifNotNil: [ response := val ] ].	^ response</body></methods><methods><class-id>GraphQLBeta.GQLInlineFragmentNode</class-id> <category>accessing</category><body package="GraphQLBeta-Nodes" selector="selectionSet">selectionSet	"Return the selection set"	^ selectionSet</body><body package="GraphQLBeta-Nodes" selector="selectionSet:">selectionSet: anObject	"Set the selection set"	selectionSet := anObject</body><body package="GraphQLBeta-Nodes" selector="targetSpreads">targetSpreads	"Return the fragment spreads used on the selection set"	^ selectionSet targetSpreads</body><body package="GraphQLBeta-Nodes" selector="typeCondition">typeCondition	"Return the type condition"	^ typeCondition</body><body package="GraphQLBeta-Nodes" selector="typeCondition:">typeCondition: anObject	"Set the type condition"	typeCondition := anObject</body></methods><methods><class-id>GraphQLBeta.GQLInlineFragmentNode</class-id> <category>utils</category><body package="GraphQLBeta-Nodes" selector="collectVariablesOn:with:">collectVariablesOn: context with: visitedFragments	"Collect variables of inline fragments based on their selection set"	^ self		collectVarSelectionSet: selectionSet		using: context		with: visitedFragments</body><body package="GraphQLBeta-Nodes" selector="ifField:ifFragment:ifInline:">ifField: aFieldBlock ifFragment: aFragmentBlock ifInline: aInlineBlock	^ aInlineBlock value</body></methods><methods><class-id>GraphQLBeta.GQLInlineFragmentNode</class-id> <category>visiting</category><body package="GraphQLBeta-Nodes" selector="accept:">accept: visitor	visitor visitInlineFragmentNode: self</body></methods><methods><class-id>GraphQLBeta.GQLTypenameFieldNode</class-id> <category>initialization</category><body package="GraphQLBeta-Nodes" selector="initialize">initialize	super initialize.	arguments := #()</body></methods><methods><class-id>GraphQLBeta.GQLTypenameFieldNode</class-id> <category>action</category><body package="GraphQLBeta-Nodes" selector="executeOn:with:using:">executeOn: resolver with: context using: schema	"Given a resolver, an context and the schema, execute the request"	^ resolver className</body></methods><methods><class-id>GraphQLBeta.GQLTypenameFieldNode</class-id> <category>visiting</category><body package="GraphQLBeta-Nodes" selector="accept:">accept: visitor	visitor visitTypenameFieldNode: self</body></methods><methods><class-id>GraphQLBeta.GQLValidator</class-id> <category>public</category><body package="GraphQLBeta-Validation" selector="execute">execute	| errors |	context := GQLContext new		addFragments: document fragments;		operationName: operationName;		variables: variables.	shouldValidate		ifFalse: [ ^ self executeDocument ].	errors := self validate.	^ errors		ifEmpty: [ self executeDocument ]		ifNotEmpty: [ ^ Dictionary new				at: 'errors' put: errors;				yourself ]</body><body package="GraphQLBeta-Validation" selector="executeDocument">executeDocument	^ document executeOn: rootInstance with: context using: schema</body><body package="GraphQLBeta-Validation" selector="validate">validate	| errors locationBlock |	errors := OrderedCollection new.	self shouldValidate		ifFalse: [ ^ errors ].	visitors		do: [ :visitor | 			visitor				text: text;				schema: schema;				context: context;				errors: OrderedCollection new.			document accept: visitor.			errors addAll: visitor errors ].	locationBlock := [ :a :b | 	a line = b line		ifTrue: [ a column &lt; b column ]		ifFalse: [ a line &lt; b line ]	"a and b are GQLPosition" ].	errors copy		do: [ :error | 			| repitedErrors sortedLocations |			repitedErrors := errors select: [ :e | e message = error message ].			repitedErrors size &gt; 1				ifTrue: [ 2 to: repitedErrors size do: [ :index | 						| e |						e := repitedErrors at: index.						errors remove: e.						error addLocations: e locations ].					sortedLocations := error locations asSet asOrderedCollection.					sortedLocations sort: locationBlock.					error locations: sortedLocations ] ].	errors		sort:			[ :a :b | locationBlock value: a locations first value: b locations first ].	^ errors</body></methods><methods><class-id>GraphQLBeta.GQLValidator</class-id> <category>accessing</category><body package="GraphQLBeta-Validation" selector="document:">document: doc	document := doc</body><body package="GraphQLBeta-Validation" selector="operationName:">operationName: string	operationName := string</body><body package="GraphQLBeta-Validation" selector="rootInstance">rootInstance	^ rootInstance</body><body package="GraphQLBeta-Validation" selector="rootInstance:">rootInstance: anObject	rootInstance := anObject</body><body package="GraphQLBeta-Validation" selector="schema:">schema: sc	schema := sc</body><body package="GraphQLBeta-Validation" selector="shouldValidate">shouldValidate	^ shouldValidate</body><body package="GraphQLBeta-Validation" selector="shouldValidate:">shouldValidate: bool	shouldValidate := bool</body><body package="GraphQLBeta-Validation" selector="text:">text: string	text := string</body><body package="GraphQLBeta-Validation" selector="variables:">variables: vars	variables := vars</body></methods><methods><class-id>GraphQLBeta.GQLValidator</class-id> <category>initialization</category><body package="GraphQLBeta-Validation" selector="initialize">initialize	super initialize.	self shouldValidate: true.	visitors := OrderedCollection new		add: GQLFragmentsVisitor new;		"first to indetify the recursive fragments"			add: GQLOperationsVisitor new;		add: GQLFieldsVisitor new;		add: GQLArgumentsVisitor new;		add: GQLValuesVisitor new;		add: GQLDirectivesVisitor new;		add: GQLVariablesVisitor new;		yourself</body></methods><methods><class-id>GraphQLBeta.GQLSAbstractNode</class-id> <category>initialization</category><body package="GraphQLBeta-NodesSchema" selector="initialize">initialize	"The default position is 0"	position := 0</body></methods><methods><class-id>GraphQLBeta.GQLSAbstractNode</class-id> <category>accessing</category><body package="GraphQLBeta-NodesSchema" selector="position">position	^ position</body><body package="GraphQLBeta-NodesSchema" selector="position:">position: anObject	position := anObject</body></methods><methods><class-id>GraphQLBeta.GQLSDescription</class-id> <category>accessing</category><body package="GraphQLBeta-NodesSchema" selector="value">value	"return the value"	^ value</body><body package="GraphQLBeta-NodesSchema" selector="value:">value: anObject	value := anObject</body></methods><methods><class-id>GraphQLBeta.GQLSNode</class-id> <category>accessing</category><body package="GraphQLBeta-NodesSchema" selector="comments">comments	^ comments</body><body package="GraphQLBeta-NodesSchema" selector="comments:">comments: anObject	comments := anObject</body><body package="GraphQLBeta-NodesSchema" selector="description">description	^ description value</body><body package="GraphQLBeta-NodesSchema" selector="description:">description: anObject	description := anObject</body></methods><methods><class-id>GraphQLBeta.GQLSNode</class-id> <category>initialization</category><body package="GraphQLBeta-NodesSchema" selector="initialize">initialize	"The default position is 0 and description is nil"	description := nil.	comments := OrderedCollection new</body></methods><methods><class-id>GraphQLBeta.GQLSNode</class-id> <category>testing</category><body package="GraphQLBeta-NodesSchema" selector="isNullType">isNullType	^ false</body><body package="GraphQLBeta-NodesSchema" selector="isSchemaDefinitionNode">isSchemaDefinitionNode	^ false</body><body package="GraphQLBeta-NodesSchema" selector="isTypeExtensionNode">isTypeExtensionNode	^ false</body><body package="GraphQLBeta-NodesSchema" selector="isTypeNode">isTypeNode	^ false</body></methods><methods><class-id>GraphQLBeta.GQLSNode</class-id> <category>adding</category><body package="GraphQLBeta-NodesSchema" selector="addComments:">addComments: aArray	aArray		do: [ :aArr | 			(aArr isNotNil and: [ aArr isNotEmpty ])				ifTrue: [ comments addAll: aArr ] ]</body></methods><methods><class-id>GraphQLBeta.GQLSDirectiveNode</class-id> <category>accessing</category><body package="GraphQLBeta-NodesSchema" selector="args">args	^ arguments</body><body package="GraphQLBeta-NodesSchema" selector="arguments">arguments	^ arguments</body><body package="GraphQLBeta-NodesSchema" selector="arguments:">arguments: anObject	arguments := anObject</body><body package="GraphQLBeta-NodesSchema" selector="directiveLocations">directiveLocations	^ directiveLocations</body><body package="GraphQLBeta-NodesSchema" selector="directiveLocations:">directiveLocations: anObject	directiveLocations := anObject</body><body package="GraphQLBeta-NodesSchema" selector="locations">locations	^ #('FIELD' 'FRAGMENT_SPREAD' 'INLINE_FRAGMENT')</body><body package="GraphQLBeta-NodesSchema" selector="name">name	^ name</body><body package="GraphQLBeta-NodesSchema" selector="name:">name: anObject	name := anObject</body></methods><methods><class-id>GraphQLBeta.GQLSTypeSystemExtension</class-id> <category>accessing</category><body package="GraphQLBeta-NodesSchema" selector="name">name	^ name</body><body package="GraphQLBeta-NodesSchema" selector="name:">name: anObject	name := anObject</body><body package="GraphQLBeta-NodesSchema" selector="value">value	^ value</body><body package="GraphQLBeta-NodesSchema" selector="value:">value: anObject	value := anObject</body></methods><methods><class-id>GraphQLBeta.GQLSTypeSystemExtension</class-id> <category>testing</category><body package="GraphQLBeta-NodesSchema" selector="isTypeExtensionNode">isTypeExtensionNode	^ true</body></methods><methods><class-id>GraphQLBeta.GQLSEnumValue</class-id> <category>accessing</category><body package="GraphQLBeta-NodesSchema" selector="name">name	^ value</body><body package="GraphQLBeta-NodesSchema" selector="value">value	^ value</body><body package="GraphQLBeta-NodesSchema" selector="value:">value: anObject	value := anObject</body></methods><methods><class-id>GraphQLBeta.GQLSEnumValue</class-id> <category>as yet unclassified</category><body package="GraphQLBeta-NodesSchema" selector="deprecationReason">deprecationReason	^ nil</body></methods><methods><class-id>GraphQLBeta.GQLSEnumValue</class-id> <category>comparing</category><body package="GraphQLBeta-NodesSchema" selector="=">= otherObject	^ otherObject class = self class and: [ otherObject value = value ]</body><body package="GraphQLBeta-NodesSchema" selector="hash">hash	^ value hash</body></methods><methods><class-id>GraphQLBeta.GQLSEnumValue</class-id> <category>testing</category><body package="GraphQLBeta-NodesSchema" selector="isDeprecated">isDeprecated	^ false</body></methods><methods><class-id>GraphQLBeta.GQLSFieldNode</class-id> <category>initialization</category><body package="GraphQLBeta-NodesSchema" selector="initialize">initialize	super initialize.	description := GQLSDescription new.	arguments := OrderedDictionary new</body></methods><methods><class-id>GraphQLBeta.GQLSFieldNode</class-id> <category>accessing</category><body package="GraphQLBeta-NodesSchema" selector="args">args	^ arguments values</body><body package="GraphQLBeta-NodesSchema" selector="arguments">arguments	"Return the arguments"	^ arguments</body><body package="GraphQLBeta-NodesSchema" selector="fullName">fullName	"Return the full name"	fullName		ifNil: [ | write |			write := WriteStream on: String new.			write nextPutAll: self name.			self arguments				ifNotEmpty: [ :ags | 					ags keys						doWithIndex: [ :na :i | 							i = 1								ifTrue: [ write										nextPutAll: na capitalized;										nextPut: $: ]								ifFalse: [ write										nextPutAll: na;										nextPut: $: ] ] ].			fullName := write contents ].	^ fullName</body><body package="GraphQLBeta-NodesSchema" selector="getArgument:">getArgument: aString	"Return a argument given his name"	(arguments includesKey: aString)		ifTrue: [ ^ arguments at: aString ].	^ nil</body><body package="GraphQLBeta-NodesSchema" selector="name">name	"Return the name"	^ name</body><body package="GraphQLBeta-NodesSchema" selector="name:">name: aName	"Set the name"	name := aName</body><body package="GraphQLBeta-NodesSchema" selector="type">type	"Return the type"	^ type</body><body package="GraphQLBeta-NodesSchema" selector="type:">type: aType	"Set the type"	type := aType</body></methods><methods><class-id>GraphQLBeta.GQLSFieldNode</class-id> <category>as yet unclassified</category><body package="GraphQLBeta-NodesSchema" selector="deprecationReason">deprecationReason	^ nil</body></methods><methods><class-id>GraphQLBeta.GQLSFieldNode</class-id> <category>adding</category><body package="GraphQLBeta-NodesSchema" selector="addArguments:">addArguments: aArray	"Given a collection puts the values on a dictionary for improve the search"	aArray		ifNotNil:			[ :array | array do: [ :argument | arguments at: argument name put: argument ] ]</body></methods><methods><class-id>GraphQLBeta.GQLSFieldNode</class-id> <category>printing</category><body package="GraphQLBeta-NodesSchema" selector="printFullOn:">printFullOn: stream	stream nextPutAll: self name.	self arguments		ifNotEmpty: [ stream nextPutAll: '('.			self arguments				do: [ :arg | arg printFullOn: stream ]				separatedBy: [ stream nextPutAll: ', ' ].			stream nextPutAll: ')' ].	stream nextPutAll: ': '.	self type printOn: stream</body></methods><methods><class-id>GraphQLBeta.GQLSFieldNode</class-id> <category>testing</category><body package="GraphQLBeta-NodesSchema" selector="isDeprecated">isDeprecated	^ false</body></methods><methods><class-id>GraphQLBeta.GQLSTypeNode</class-id> <category>as yet unclassified</category><body package="GraphQLBeta-NodesSchema" selector="enumValuesIncludeDeprecated:">enumValuesIncludeDeprecated: aBoolean	^ nil</body><body package="GraphQLBeta-NodesSchema" selector="fieldOfName:using:">fieldOfName: aString using: aSchema	^ (aSchema getType: GQLSTypeNode new className) getField: aString</body><body package="GraphQLBeta-NodesSchema" selector="fieldsIncludeDeprecated:">fieldsIncludeDeprecated: aBoolean	^ nil</body><body package="GraphQLBeta-NodesSchema" selector="inputFields">inputFields	^ nil</body><body package="GraphQLBeta-NodesSchema" selector="ofType">ofType	^ self subclassResponsibility</body></methods><methods><class-id>GraphQLBeta.GQLSTypeNode</class-id> <category>accessing</category><body package="GraphQLBeta-NodesSchema" selector="description">description	^ super description value</body><body package="GraphQLBeta-NodesSchema" selector="getField:">getField: string	^ nil</body><body package="GraphQLBeta-NodesSchema" selector="interfaces">interfaces	^ nil</body><body package="GraphQLBeta-NodesSchema" selector="kind">kind	^ self subclassResponsibility</body><body package="GraphQLBeta-NodesSchema" selector="name">name	^ name</body><body package="GraphQLBeta-NodesSchema" selector="name:">name: aString	name := aString</body><body package="GraphQLBeta-NodesSchema" selector="possibleTypes">possibleTypes	^ nil</body></methods><methods><class-id>GraphQLBeta.GQLSTypeNode</class-id> <category>testing</category><body package="GraphQLBeta-NodesSchema" selector="basicCoerce:on:">basicCoerce: value on: schema	self subclassResponsibility</body><body package="GraphQLBeta-NodesSchema" selector="canCoerce:on:">canCoerce: value on: schema	^ value class = GQLNullNode		ifTrue: [ true ]		ifFalse: [ self basicCoerce: value on: schema ]</body><body package="GraphQLBeta-NodesSchema" selector="isInputType">isInputType	"Return if is a input type"	^ false</body><body package="GraphQLBeta-NodesSchema" selector="isInterfaceType">isInterfaceType	"Return if is a interface type"	^ false</body><body package="GraphQLBeta-NodesSchema" selector="isObjectInputType:">isObjectInputType: schema	^ false</body><body package="GraphQLBeta-NodesSchema" selector="isObjectType">isObjectType	"Return if is a object type"	^ false</body><body package="GraphQLBeta-NodesSchema" selector="isScalarType">isScalarType	"Return if is a scalar type"	^ false</body><body package="GraphQLBeta-NodesSchema" selector="isTypeNode">isTypeNode	^ true</body><body package="GraphQLBeta-NodesSchema" selector="isUnionType">isUnionType	"Return if is a union type"	^ false</body><body package="GraphQLBeta-NodesSchema" selector="isValidateClass">isValidateClass	"Respondes if a type needs to be searched on the image of Pharo"	^ false</body><body package="GraphQLBeta-NodesSchema" selector="isWrappedType">isWrappedType	"Return if is a wrapped type"	^ false</body></methods><methods><class-id>GraphQLBeta.GQLSTypeNode</class-id> <category>coercion</category><body package="GraphQLBeta-NodesSchema" selector="coerceValue:on:">coerceValue: value on: schema	value isVariableNode		ifTrue: [ ^ value ].	(self canCoerce: value on: schema)		ifFalse: [ self error: 'invalid input' ].	^ value</body></methods><methods><class-id>GraphQLBeta.GQLSNullTypeNode</class-id> <category>accessing</category><body package="GraphQLBeta-NodesSchema" selector="getField:">getField: string	^ self</body><body package="GraphQLBeta-NodesSchema" selector="isNullType">isNullType	^ true</body><body package="GraphQLBeta-NodesSchema" selector="rawType:">rawType: schema	^ self</body><body package="GraphQLBeta-NodesSchema" selector="type">type	^ self</body></methods><methods><class-id>GraphQLBeta.GQLSNullTypeNode class</class-id> <category>accessing</category><body package="GraphQLBeta-NodesSchema" selector="instance">instance	^ instance ifNil: [ instance := self new ]</body></methods><methods><class-id>GraphQLBeta.GQLSSchemaDefinitionNode</class-id> <category>accessing</category><body package="GraphQLBeta-NodesSchema" selector="name">name	^ name</body><body package="GraphQLBeta-NodesSchema" selector="rootOperationTypes">rootOperationTypes	rootOperationTypes isEmpty		ifTrue: [ self rootOperationTypes: rootOperationTypes values ].	^ rootOperationTypes</body><body package="GraphQLBeta-NodesSchema" selector="rootOperationTypes:">rootOperationTypes: aList	aList isEmpty		ifTrue:			[ rootOperationTypes at: 'query' put: (defaultRootOpTypes at: 'query') ]		ifFalse: [ aList				do: [ :rootOpType | 					rootOpType						executeBlock: [ :key | self addRootOpType: rootOpType withKey: key ] ] ]</body></methods><methods><class-id>GraphQLBeta.GQLSSchemaDefinitionNode</class-id> <category>initialization</category><body package="GraphQLBeta-NodesSchema" selector="initialize">initialize	rootOperationTypes := Dictionary new.	self initDefaultRootOpTypes</body></methods><methods><class-id>GraphQLBeta.GQLSSchemaDefinitionNode</class-id> <category>adding</category><body package="GraphQLBeta-NodesSchema" selector="addRootOpType:withKey:">addRootOpType: aRootOpType withKey: aKey	rootOperationTypes		at: aKey		ifPresent: [ :value | value add: aRootOpType ]		ifAbsentPut: [ OrderedCollection new				add: aRootOpType;				yourself ]</body></methods><methods><class-id>GraphQLBeta.GQLSSchemaDefinitionNode</class-id> <category>testing</category><body package="GraphQLBeta-NodesSchema" selector="isSchemaDefinitionNode">isSchemaDefinitionNode	^ true</body></methods><methods><class-id>GraphQLBeta.GQLSSchemaDefinitionNode</class-id> <category>as yet unclassified</category><body package="GraphQLBeta-NodesSchema" selector="initDefaultRootOpTypes">initDefaultRootOpTypes	defaultRootOpTypes := Dictionary new		at: 'query'			put:			(Array				with:					(GQLSRootOperationTypeNode new						name: 'GQLQuery';						yourself));		at: 'mutation'			put:			(Array				with:					(GQLSRootOperationTypeNode new						name: 'GQLMutation';						yourself));		at: 'subscription'			put:			(Array				with:					(GQLSRootOperationTypeNode new						name: 'Subscription';						yourself));		yourself</body></methods><methods><class-id>GraphQLBeta.GQLSRootOperationTypeNode</class-id> <category>accessing</category><body package="GraphQLBeta-NodesSchema" selector="key:">key: aString	key := aString</body><body package="GraphQLBeta-NodesSchema" selector="name">name	^ name</body><body package="GraphQLBeta-NodesSchema" selector="name:">name: aName	name := aName</body></methods><methods><class-id>GraphQLBeta.GQLSRootOperationTypeNode</class-id> <category>adding</category><body package="GraphQLBeta-NodesSchema" selector="executeBlock:">executeBlock: aBlock	^ aBlock value: key</body></methods><methods><class-id>GraphQLBeta.GQLSWrapTypeNode</class-id> <category>as yet unclassified</category><body package="GraphQLBeta-NodesSchema" selector="ofType">ofType	^ self wrappedType</body></methods><methods><class-id>GraphQLBeta.GQLSWrapTypeNode</class-id> <category>accessing</category><body package="GraphQLBeta-NodesSchema" selector="name">name	^ self wrappedType name</body><body package="GraphQLBeta-NodesSchema" selector="rawType:">rawType: schema	^ self wrappedType rawType: schema</body><body package="GraphQLBeta-NodesSchema" selector="wrappedType">wrappedType	"Return the wrappedType"	^ wrappedType</body><body package="GraphQLBeta-NodesSchema" selector="wrappedType:">wrappedType: aType	"Set the wrappedType"	wrappedType := aType</body></methods><methods><class-id>GraphQLBeta.GQLSWrapTypeNode</class-id> <category>testing</category><body package="GraphQLBeta-NodesSchema" selector="isInputType">isInputType	"Return if the wrappedType is a inputType"	^ self wrappedType isInputType</body><body package="GraphQLBeta-NodesSchema" selector="isObjectInputType:">isObjectInputType: schema	^ self wrappedType isObjectInputType: schema</body><body package="GraphQLBeta-NodesSchema" selector="isWrappedType">isWrappedType	"Return if has a wrapped type"	^ true</body></methods><methods><class-id>GraphQLBeta.GQLSListTypeNode</class-id> <category>accessing</category><body package="GraphQLBeta-NodesSchema" selector="kind">kind	^ 'LIST'</body><body package="GraphQLBeta-NodesSchema" selector="name">name	^ nil</body></methods><methods><class-id>GraphQLBeta.GQLSListTypeNode</class-id> <category>printing</category><body package="GraphQLBeta-NodesSchema" selector="printOn:">printOn: stream	stream nextPutAll: '['.	self wrappedType printOn: stream.	stream nextPutAll: ']'</body></methods><methods><class-id>GraphQLBeta.GQLSListTypeNode</class-id> <category>coercion</category><body package="GraphQLBeta-NodesSchema" selector="coerceValue:on:">coerceValue: value on: schema	value isVariableNode		ifTrue: [ ^ value ].	value class = GQLNullNode		ifTrue: [ ^ value ].	(self canCoerce: value on: schema)		ifFalse: [ value class = GQLListNode				ifFalse: [ self error: 'invalid input' ] ].	value class = GQLListNode		ifTrue: [ ^ GQLListNode new				value:					(value value						collect: [ :v | self wrappedType coerceValue: v on: schema ]);				position: value position ].	^ GQLListNode new		value: (Array with: (self wrappedType coerceValue: value on: schema));		position: value position</body></methods><methods><class-id>GraphQLBeta.GQLSListTypeNode</class-id> <category>testing</category><body package="GraphQLBeta-NodesSchema" selector="basicCoerce:on:">basicCoerce: value on: schema	(wrappedType canCoerce: value on: schema)		ifTrue: [ ^ true ].	^ value class = GQLListNode		and:			[ value value allSatisfy: [ :v | wrappedType canCoerce: v on: schema ] ]</body></methods><methods><class-id>GraphQLBeta.GQLSSchemaNode</class-id> <category>adding</category><body package="GraphQLBeta-NodesSchema" selector="addImplementors">addImplementors	schemaTypes		select: #isInterfaceType		thenDo: [ :type | type implementors: OrderedCollection new ].	schemaTypes		select: #isObjectType		thenDo: [ :type | 			type interfaces				do: [ :s | 					| interface |					interface := schemaTypes at: s.					interface						ifNil: [ ^ GQLValidationException new								node: type;								messageText: 'Error: Invalid schema';								raise ].					interface implementors add: type ] ]</body><body package="GraphQLBeta-NodesSchema" selector="addScalarsInSchema">addScalarsInSchema	scalarTypes keys		do:			[ :scalarTypeName | schemaTypes at: scalarTypeName put: (scalarTypes at: scalarTypeName) ]</body><body package="GraphQLBeta-NodesSchema" selector="addSchemaExtensions:">addSchemaExtensions: aSchemaExtensions	(aSchemaExtensions isNotNil and: [ aSchemaExtensions isNotEmpty ])		ifTrue: [ schemaExtensions isNotEmpty				ifTrue: [ aSchemaExtensions						do: [ :aSchemaExt | 							schemaExtensions first rootOperationTypes								addAll: aSchemaExt rootOperationTypes ] ]				ifFalse: [ schemaExtensions := aSchemaExtensions ] ]</body><body package="GraphQLBeta-NodesSchema" selector="addTypeExtensions:">addTypeExtensions: aCollection	"Given a collection puts the values on a dictionary for improve the search"	| conditionBlock |	conditionBlock := [ :item | item value class = GQLSSchemaDefinitionNode ].	self		schemaExtensions:			(aCollection				select: conditionBlock				thenCollect: [ :item | item value ]).	aCollection		reject: conditionBlock		thenDo: [ :item | typeExtensions at: item name put: item value ]</body><body package="GraphQLBeta-NodesSchema" selector="addTypeExtensions:with:">addTypeExtensions: dictTypeExtension with: resolvers	| keysSchemaTypes |	keysSchemaTypes := schemaTypes keys.	dictTypeExtension associations		do: [ :assoc | 			(keysSchemaTypes includes: assoc key)				ifTrue: [ | res |					res := (schemaTypes at: assoc key)						verifyAndInclude: assoc value						with: resolvers.					(res isKindOf: GQLValidationException)						ifTrue: [ ^ res ]						ifFalse: [ (res isKindOf: Dictionary)								ifTrue: [ dictFieldsWithResolvers addAll: res ] ] ]				ifFalse: [ ^ GQLValidationException new						node: assoc value;						messageText: 'The namedType has not been defined';						raise ] ]</body><body package="GraphQLBeta-NodesSchema" selector="addTypes:">addTypes: aCollection	"Given a collection puts the values on a dictionary for improve the search"	self		schemaDefinitions:			(aCollection select: [ :item | item class = GQLSSchemaDefinitionNode ]).	aCollection		reject: [ :type | type class = GQLSSchemaDefinitionNode ]		thenDo: [ :type | schemaTypes at: type name put: type ]</body><body package="GraphQLBeta-NodesSchema" selector="addTypes:with:">addTypes: dictTypes with: resolvers	dictTypes		ifNotNil: [ dictTypes associations				do: [ :assoc | 					(schemaTypes includesKey: assoc key)						ifTrue: [ | res |							res := (schemaTypes at: assoc key)								verifyAndInclude: assoc value								with: resolvers.							(res isKindOf: GQLValidationException)								ifTrue: [ ^ res ]								ifFalse: [ dictFieldsWithResolvers addAll: res ] ]						ifFalse: [ schemaTypes add: assoc ] ] ]</body><body package="GraphQLBeta-NodesSchema" selector="addTypeSystemExtension:with:">addTypeSystemExtension: schemaNode with: resolvers	| blockCondition |	blockCondition := [ :value | 	(value isKindOf: GQLValidationException)		ifTrue: [ ^ value ] ].	blockCondition		value: (self addSchemaExtensions: schemaNode schemaExtensions).	blockCondition		value: (self addTypes: schemaNode schemaTypes with: resolvers).	blockCondition		value: (self addTypeExtensions: schemaNode typeExtensions with: resolvers)</body><body package="GraphQLBeta-NodesSchema" selector="getNameType:">getNameType: aString	| typeName |	typeName := GQLSSchemaNode typeOfName: aString.	typeName		ifNotNil: [ ^ self getType: typeName ]		ifNil: [ typeName := aString , 'Input'.			schemaTypes				at: typeName				ifPresent: [ :value | 					value class = GQLSInputObjectTypeNode						ifTrue: [ ^ schemaTypes at: typeName ] ].			^ scalarTypes at: aString ifAbsent: [ nil ] ]</body></methods><methods><class-id>GraphQLBeta.GQLSSchemaNode</class-id> <category>initialization</category><body package="GraphQLBeta-NodesSchema" selector="initialize">initialize	super initialize.	self initializeScalarTypes.	self initializeDefaultDirectives.	schemaDefinitions := OrderedCollection new		add: GQLSSchemaDefinitionNode new;		yourself.	schemaTypes := Dictionary new.	schemaExtensions := OrderedCollection new.	typeExtensions := Dictionary new.	dictFieldsWithResolvers := Dictionary new</body><body package="GraphQLBeta-NodesSchema" selector="initializeDefaultDirectives">initializeDefaultDirectives	| args locations |	defaultDirectives := Dictionary new.	locations := Array		with: GQLNonScalarFieldNode		with: GQLScalarFieldNode		with: GQLFragmentSpreadNode		with: GQLInlineFragmentNode.	args := Array		with:			(GQLSInputObjectFieldNode new				name: 'if';				type: (GQLSNonNullTypeNode new wrappedType: GQLSBooleanTypeNode new)).	defaultDirectives		at: 'skip'		put:			(GQLSDirectiveNode new				name: 'skip';				arguments: args;				directiveLocations: locations).	defaultDirectives		at: 'include'		put:			(GQLSDirectiveNode new				name: 'include';				arguments: args;				directiveLocations: locations)</body><body package="GraphQLBeta-NodesSchema" selector="initializeScalarTypes">initializeScalarTypes	"Creates a dictionary with the default scalar types"	scalarTypes := Dictionary new.	scalarTypes at: 'Int' put: GQLSIntTypeNode new.	scalarTypes at: 'String' put: GQLSStringTypeNode new.	scalarTypes at: 'ID' put: GQLSIDTypeNode new.	scalarTypes at: 'Boolean' put: GQLSBooleanTypeNode new.	scalarTypes at: 'Float' put: GQLSFloatTypeNode new</body></methods><methods><class-id>GraphQLBeta.GQLSSchemaNode</class-id> <category>development support</category><body package="GraphQLBeta-NodesSchema" selector="validate">validate	"Verify that all the input types and types exist on smalltalk, interfaces has uniqueness field names and all types implemented interfaces satisfy the object type validation."	^ self validate: nil with: (Array new: 0)</body><body package="GraphQLBeta-NodesSchema" selector="validateObjectTypes">validateObjectTypes	"Return self if all the object types that implemented interfaces are consistent, if not raise a GQLValidationException"	| objectTypes interfaces |	objectTypes := self types select: #isObjectType.	objectTypes		detect: [ :objectType | 			| fields |			fields := Set new.			interfaces := Set new.			objectType interfaces				do: [ :nameInterface | 					| interface |					interface := self getInterface: nameInterface.					fields addAll: interface fields values.					interfaces add: interface ].			objectType interfaces: interfaces.			(objectType implementsFields: fields) not ]		ifFound: [ :objectType | 			^ GQLValidationException new				node: objectType;				messageText:					'Missing fields on object type 													for implementing interface';				raise ]</body><body package="GraphQLBeta-NodesSchema" selector="validateRootOpTypes:">validateRootOpTypes: aAssociations	"Return the object types or input objects"	| keyValidTypes includesQuery |	includesQuery := false.	keyValidTypes := self validatedTypes keys.	aAssociations		do: [ :assoc | 			(keyValidTypes includes: assoc value)				ifFalse: [ "self halt."					^ GQLValidationException new						node: GQLSSchemaDefinitionNode;						messageText:							'Error: Specified ' , assoc key , ' type \"' , assoc value								, '\" not found in document';						raise ].			includesQuery := includesQuery or: [ assoc key = 'query' ] ].	includesQuery		ifFalse: [ ^ GQLValidationException new				node: GQLSSchemaDefinitionNode;				messageText: 'Must provide a query root';				raise ]</body><body package="GraphQLBeta-NodesSchema" selector="validateSchemaDefinition">validateSchemaDefinition	"Return self if all the object types that implemented interfaces are consistent, if not raise a GQLValidationException"	| rootOpTypes |	self schemaDefinitions size ~= 1		ifTrue: [ ^ GQLValidationException new				node: GQLSSchemaDefinitionNode;				messageText: 'Error: Must provide only one schema definition.';				raise ].	rootOpTypes := self schemaDefinitions first rootOperationTypes.	^ self validateRootSchemaDefinition: rootOpTypes</body><body package="GraphQLBeta-NodesSchema" selector="validateUnionTypes">validateUnionTypes	"Return self if all the union types has values as object types, if not raise a GQLValidationException"	| unions |	unions := self types select: #isUnionType.	unions		detect: [ :union | 			(union namedTypes				allSatisfy: [ :name | (self getType: name) isObjectType ]) not ]		ifFound: [ :union | 			^ GQLValidationException new				node: union;				messageText: 'The values of union are not object type';				raise ].	unions		do: [ :union | 			union namedTypes				collect: [ :name | self getType: name ]				thenDo: [ :types | union addPossibleType: types ] ].	^ self</body><body package="GraphQLBeta-NodesSchema" selector="validateWithImage">validateWithImage	"Return self if all the types exist on the smalltalk image and also the fields, if not raise a GQLValidationException"	| allClasses |	allClasses := Smalltalk globals allClasses.	self validatedTypes		do: [ :assoc | 			| class fields nameAssoc |			nameAssoc := assoc name.			(nameAssoc endsWith: 'Input')				ifTrue: [ nameAssoc := nameAssoc copyFrom: 1 to: nameAssoc size - 5 ].			nameAssoc := nameAssoc asSymbol.			class := allClasses				detect: [ :c | c name = nameAssoc ]				ifNone: [ ^ GQLValidationException new						node: assoc value;						messageClassText ].			fields := assoc value fields values.			fields				do: [ :field | 					class allMethods						detect: [ :method | method selector = field fullName asSymbol ]						ifNone: [ dictFieldsWithResolvers								at: field fullName asSymbol								ifAbsent: [ ^ GQLValidationException new										node: field;										messageMethodText: assoc ] ] ] ]</body></methods><methods><class-id>GraphQLBeta.GQLSSchemaNode</class-id> <category>as yet unclassified</category><body package="GraphQLBeta-NodesSchema" selector="dictFieldsResolvers">dictFieldsResolvers	^ dictFieldsWithResolvers</body><body package="GraphQLBeta-NodesSchema" selector="mutationType">mutationType	^ schemaDefinitions first rootOperationTypes		at: 'mutation'		ifPresent: [ :val | schemaTypes at: val first name ]		ifAbsent: [ nil ]</body><body package="GraphQLBeta-NodesSchema" selector="queryType">queryType	^ schemaTypes		at: (schemaDefinitions first rootOperationTypes at: 'query') first name</body><body package="GraphQLBeta-NodesSchema" selector="subscriptionType">subscriptionType	^ schemaDefinitions first rootOperationTypes		at: 'subscription'		ifPresent: [ :val | schemaTypes at: val first name ]		ifAbsent: [ nil ]</body><body package="GraphQLBeta-NodesSchema" selector="validate:with:">validate: schemaNodes with: resolvers	"Verify that all the input types and types exist on smalltalk, interfaces has uniqueness field names and all types implemented interfaces satisfy the object type validation."	| validators blockCondition |	blockCondition := [ :value | 	(value isKindOf: GQLValidationException)		ifTrue: [ ^ value ] ].	blockCondition		value:			(self				addTypeSystemExtension: GQLSSchemaNode metaSchema				with: (Array new: 0)).	(schemaNodes isNil or: [ schemaNodes isEmpty ])		ifTrue: [ blockCondition value: (self addSchemaExtensions: schemaExtensions).			blockCondition				value: (self addTypeExtensions: typeExtensions with: resolvers).			blockCondition value: self addScalarsInSchema ]		ifFalse: [ schemaNodes				do: [ :schemaNode | 					blockCondition						value: (self addTypeSystemExtension: schemaNode with: resolvers) ] ].	blockCondition value: self addImplementors.	validators := Array		with: #validateSchemaDefinition		with: #validateSchemaExtensions		with: #validateWithImage		with: #validateObjectTypes		with: #validateUnionTypes.	validators		do: [ :validator | blockCondition value: (self perform: validator) ]</body><body package="GraphQLBeta-NodesSchema" selector="validateRootSchemaDefinition:">validateRootSchemaDefinition: aRootOpTypes	aRootOpTypes associations		detect: [ :assoc | assoc value size &gt; 1 ]		ifFound: [ :assoc | 			^ GQLValidationException new				node: assoc value;				messageText: 'Must provide only one ' , assoc key , ' type in schema';				raise ]		ifNone: [ ^ self				validateRootOpTypes:					(aRootOpTypes associations						select: [ :assoc | assoc value isNotEmpty ]						thenCollect: [ :assoc | assoc key -&gt; assoc value first name ]) ]</body><body package="GraphQLBeta-NodesSchema" selector="validateSchemaExtensions">validateSchemaExtensions	"Return self if the schemaExtension is only, if not raise a GQLValidationException"	schemaExtensions		ifNotEmpty: [ ^ self				validateRootSchemaDefinition:					(schemaDefinitions first rootOperationTypes						addAll: schemaExtensions first rootOperationTypes;						yourself) ]</body></methods><methods><class-id>GraphQLBeta.GQLSSchemaNode</class-id> <category>accessing</category><body package="GraphQLBeta-NodesSchema" selector="directives">directives	^ defaultDirectives values</body><body package="GraphQLBeta-NodesSchema" selector="getDirective:">getDirective: aDirectiveName	"Return the directive corresponding to the given directive name"	(defaultDirectives includesKey: aDirectiveName asString)		ifTrue: [ ^ defaultDirectives at: aDirectiveName asString ].	^ nil</body><body package="GraphQLBeta-NodesSchema" selector="getInterface:">getInterface: anInterfaceName	"Return the interface corresponding to the given name"	((schemaTypes includesKey: anInterfaceName asString)		and: [ (schemaTypes at: anInterfaceName asString) isInterfaceType ])		ifTrue: [ ^ schemaTypes at: anInterfaceName asString ]</body><body package="GraphQLBeta-NodesSchema" selector="getType:">getType: aTypeName	"Return the type corresponding to the given type name"	| typeNameString |	typeNameString := aTypeName asString.	(schemaTypes includesKey: typeNameString)		ifTrue: [ ^ schemaTypes at: typeNameString ].	^ self getNameType: typeNameString</body><body package="GraphQLBeta-NodesSchema" selector="getTypeExtension:">getTypeExtension: aTypeExtensionName	"Return the extension type corresponding to the given type extension name"	^ typeExtensions at: aTypeExtensionName</body><body package="GraphQLBeta-NodesSchema" selector="query">query	^ query</body><body package="GraphQLBeta-NodesSchema" selector="root:">root: anInstance	"Set an instance as root and his class as the query"	root := anInstance.	query := self getType: anInstance class name</body><body package="GraphQLBeta-NodesSchema" selector="schemaDefinitions">schemaDefinitions	^ schemaDefinitions</body><body package="GraphQLBeta-NodesSchema" selector="schemaDefinitions:">schemaDefinitions: aSchemaDefinitions	aSchemaDefinitions isNotEmpty		ifTrue: [ schemaDefinitions := aSchemaDefinitions ]</body><body package="GraphQLBeta-NodesSchema" selector="schemaExtensions">schemaExtensions	^ schemaExtensions</body><body package="GraphQLBeta-NodesSchema" selector="schemaExtensions:">schemaExtensions: anObject	schemaExtensions := anObject</body><body package="GraphQLBeta-NodesSchema" selector="schemaTypes">schemaTypes	"Return the types"	^ schemaTypes</body><body package="GraphQLBeta-NodesSchema" selector="typeExtensions">typeExtensions	^ typeExtensions</body><body package="GraphQLBeta-NodesSchema" selector="types">types	"Return the types"	^ schemaTypes values</body><body package="GraphQLBeta-NodesSchema" selector="validatedTypes">validatedTypes	"Return the object types or input objects"	^ schemaTypes select: #isValidateClass</body></methods><methods><class-id>GraphQLBeta.GQLSSchemaNode</class-id> <category>printing</category><body package="GraphQLBeta-NodesSchema" selector="printOn:">printOn: stream	stream		nextPutAll: 'schema{';		cr;		tab;		nextPutAll: 'query: '.	self query printOn: stream.	stream		cr;		nextPutAll: '}';		cr.	self schemaTypes		do: [ :t | 			t printFullOn: stream.			stream cr ]</body></methods><methods><class-id>GraphQLBeta.GQLSSchemaNode class</class-id> <category>class initialization</category><body package="GraphQLBeta-NodesSchema" selector="initialize">initialize	dictNameTypesMetaSchema := nil.	metaSchema := nil</body></methods><methods><class-id>GraphQLBeta.GQLSSchemaNode class</class-id> <category>accessing</category><body package="GraphQLBeta-NodesSchema" selector="dictNameTypesMetaSchema">dictNameTypesMetaSchema	^ dictNameTypesMetaSchema		ifNil: [ dictNameTypesMetaSchema := Dictionary new				at: 'Schema' put: 'GQLSSchemaNode';				at: 'Type'					put:					#('GQLSTypeNode' 'GQLSEnumTypeNode' 'GQLSInterfaceTypeNode' 'GQLSInputObjectTypeNode' 'GQLSInputObjectFieldNode' 'GQLSObjectTypeNode' 'GQLSStringTypeNode' 'GQLSUnionTypeNode' 'GQLSIntTypeNode' 'GQLSNonNullTypeNode' 'GQLSIDTypeNode' 'GQLSListTypeNode' 'GQLSBooleanTypeNode' 'GQLSFloatTypeNode');				at: 'Field' put: 'GQLSFieldNode';				at: 'InputValue' put: 'GQLSInputObjectFieldNode';				at: 'EnumValue' put: 'GQLSEnumValue';				at: 'Directive' put: 'GQLSDirectiveNode';				yourself.			dictNameTypesMetaSchema keys copy				do: [ :k | 					dictNameTypesMetaSchema						at: '__' , k						put: (dictNameTypesMetaSchema at: k) ].			dictNameTypesMetaSchema ]</body><body package="GraphQLBeta-NodesSchema" selector="metaSchema">metaSchema	metaSchema		ifNil: [ metaSchema := GQLSchemaGrammarEvaluator				parse:					' 	type GQLSSchemaNode {  		types: [GQLSTypeNode!]!  		queryType: GQLSTypeNode!  		mutationType: GQLSTypeNode  		subscriptionType:  GQLSTypeNode  		directives: [GQLSDirectiveNode!]!	}	type GQLSTypeNode {  		kind: __TypeKind!  		name: String  		description: String	  	# OBJECT and INTERFACE only  	  	fields(includeDeprecated: Boolean): [GQLSFieldNode!]  		# OBJECT only	  	interfaces: [GQLSTypeNode!]		# INTERFACE and UNION only  		possibleTypes: [GQLSTypeNode!]  		# ENUM only  		enumValues(includeDeprecated: Boolean): [GQLSEnumValue!]  		# INPUT_OBJECT only  		inputFields: [GQLSInputObjectFieldNode!]  		# NON_NULL and LIST only  		ofType: GQLSTypeNode	}	type GQLSFieldNode {  		name: String!  		description: String  		args: [GQLSInputObjectFieldNode!]!  		type: GQLSTypeNode!  		isDeprecated: Boolean!  		deprecationReason: String	}	type GQLSInputObjectFieldNode {  		name: String!  		description: String  		type: GQLSTypeNode!  		defaultValue: String	}	type GQLSEnumValue {  		name: String!  		description: String  		isDeprecated: Boolean!  		deprecationReason: String	}	enum __TypeKind {  		SCALAR  		OBJECT  		INTERFACE  		UNION  		ENUM  		INPUT_OBJECT  		LIST  		NON_NULL	}	type GQLSDirectiveNode {  		name: String!  		description: String  		locations: [__DirectiveLocation!]!  		args: [GQLSInputObjectFieldNode!]!	}	enum __DirectiveLocation {  		QUERY  		MUTATION  		SUBSCRIPTION  		FIELD  		FRAGMENT_DEFINITION  		FRAGMENT_SPREAD  		INLINE_FRAGMENT  		SCHEMA  		SCALAR  		OBJECT  		FIELD_DEFINITION  		ARGUMENT_DEFINITION  		INTERFACE  		UNION  		ENUM  		ENUM_VALUE  		INPUT_OBJECT  		INPUT_FIELD_DEFINITION	}' ].	^ metaSchema</body><body package="GraphQLBeta-NodesSchema" selector="typeOfName:">typeOfName: aString	self dictNameTypesMetaSchema		at: aString		ifPresent: [ :val | 			^ val isArray				ifTrue: [ val first ]				ifFalse: [ val ] ]		ifAbsent: [ dictNameTypesMetaSchema				valuesDo: [ :val | 					val isArray						ifTrue: [ val								detect: [ :aName | aName = aString ]								ifFound: [ ^ 'GQLSTypeNode' ] ] ] ].	^ nil</body></methods><methods><class-id>GraphQLBeta.GQLSInputObjectFieldNode</class-id> <category>defaults</category><body package="GraphQLBeta-NodesSchema" selector="defaultValue">defaultValue	^ nil</body></methods><methods><class-id>GraphQLBeta.GQLSInputObjectFieldNode</class-id> <category>printing</category><body package="GraphQLBeta-NodesSchema" selector="printFullOn:">printFullOn: stream	stream		nextPutAll: self name;		nextPutAll: ': '.	self type printOn: stream</body></methods><methods><class-id>GraphQLBeta.GQLSNonNullTypeNode</class-id> <category>accessing</category><body package="GraphQLBeta-NodesSchema" selector="kind">kind	^ 'NON_NULL'</body><body package="GraphQLBeta-NodesSchema" selector="name">name	^ nil</body></methods><methods><class-id>GraphQLBeta.GQLSNonNullTypeNode</class-id> <category>printing</category><body package="GraphQLBeta-NodesSchema" selector="printOn:">printOn: stream	self wrappedType printOn: stream.	stream nextPutAll: '!'</body></methods><methods><class-id>GraphQLBeta.GQLSNonNullTypeNode</class-id> <category>testing</category><body package="GraphQLBeta-NodesSchema" selector="canCoerce:on:">canCoerce: value on: schema	^ value class = GQLNullNode		ifTrue: [ ^ false ]		ifFalse: [ wrappedType canCoerce: value on: schema ]</body></methods><methods><class-id>GraphQLBeta.GQLSNonNullTypeNode</class-id> <category>coercion</category><body package="GraphQLBeta-NodesSchema" selector="coerceValue:on:">coerceValue: value on: schema	^ self wrappedType coerceValue: value on: schema</body></methods><methods><class-id>GraphQLBeta.GQLVariablesValidationTest</class-id> <category>tests</category><body package="GraphQLBeta-Tests-Validation" selector="testAllVariablesUsed01">testAllVariablesUsed01	"All variables defined by an operation must be used in that operation or a fragment transitively included by that operation. Unused variables cause a validation error."	| result |	result := self		operation: 'variableUnused'		variables: '{"atOtherHomes": true}'		jsonRequest:			'query variableUnused($atOtherHomes: Boolean) {  dog {    isHousetrained  }}'.	self		assert: result		equals:			'{	"errors" : [		{			"message" : "Variable \"$atOtherHomes\" is never used in operation \"variableUnused\".",			"locations" : [				{					"line" : 2,					"column" : 22				}			]		}	]}'</body><body package="GraphQLBeta-Tests-Validation" selector="testAllVariablesUsed02">testAllVariablesUsed02	"All variables defined by an operation must be used in that operation or a fragment transitively included by that operation. Unused variables cause a validation error."	| result |	result := self		operation: 'variableUsedInFragment'		variables: '{"atOtherHomes": true}'		jsonRequest:			'query variableUsedInFragment($atOtherHomes: Boolean) {  dog {    ...isHousetrainedFragment  }}fragment isHousetrainedFragment on GQLDog {  isHousetrained(atOtherHomes: $atOtherHomes)}'.	self		assert: result		equals:			'{	"data" : {		"dog" : {			"isHousetrained" : false		}	}}'</body><body package="GraphQLBeta-Tests-Validation" selector="testAllVariablesUsed03">testAllVariablesUsed03	"All variables defined by an operation must be used in that operation or a fragment transitively included by that operation. Unused variables cause a validation error."	| result |	result := self		operation: 'variableNotUsedWithinFragment'		variables: '{"atOtherHomes": true}'		jsonRequest:			'query variableNotUsedWithinFragment($atOtherHomes: Boolean) {  dog {    ...isHousetrainedWithoutVariableFragment  }}fragment isHousetrainedWithoutVariableFragment on GQLDog {  isHousetrained}'.	self		assert: result		equals:			'{	"errors" : [		{			"message" : "Variable \"$atOtherHomes\" is never used in operation \"variableNotUsedWithinFragment\".",			"locations" : [				{					"line" : 2,					"column" : 37				}			]		}	]}'</body><body package="GraphQLBeta-Tests-Validation" selector="testAllVariablesUsed04">testAllVariablesUsed04	"All variables defined by an operation must be used in that operation or a fragment transitively included by that operation. Unused variables cause a validation error."	| result |	result := self		operation: 'queryWithUsedVar'		variables: '{"atOtherHomes": true, "extra": 10}'		jsonRequest:			'query queryWithUsedVar($atOtherHomes: Boolean) {  dog {    ...isHousetrainedFragment  }}query queryWithExtraVar($atOtherHomes: Boolean, $extra: Int) {  dog {    ...isHousetrainedFragment  }}fragment isHousetrainedFragment on GQLDog {  isHousetrained(atOtherHomes: $atOtherHomes)}'.	self		assert: result		equals:			'{	"errors" : [		{			"message" : "Variable \"$extra\" is never used in operation \"queryWithExtraVar\".",			"locations" : [				{					"line" : 8,					"column" : 49				}			]		}	]}'</body><body package="GraphQLBeta-Tests-Validation" selector="testAllVariablesUsed05">testAllVariablesUsed05	"All variables defined by an operation must be used in that operation or a fragment transitively included by that operation. Unused variables cause a validation error."	| result |	result := self		operation: 'queryWithUsedVar'		variables: '{"foo": true}'		jsonRequest:			'query queryWithUsedVar($foo: Boolean!) {  dog {    ...isHousetrainedFragment @skip(if: $foo)  }}fragment isHousetrainedFragment on GQLDog {  isHousetrained }'.	self		assert: result		equals:			'{	"data" : {		"dog" : { }	}}'</body><body package="GraphQLBeta-Tests-Validation" selector="testAllVariableUsagesAreAllowed01">testAllVariableUsagesAreAllowed01	"Variable usages must be compatible with the arguments they are passed to.Validation failures occur when variables are used in the context of types that are complete mismatches, or if a nullable type in a variable is passed to a nonânull argument type."	| result |	result := self		operation: 'intCannotGoIntoBoolean'		variables: '{"intArg": 1}'		jsonRequest:			'query intCannotGoIntoBoolean($intArg: Int) {  arguments {    booleanArgField(booleanArg: $intArg)  }}'.	self		assert: result		equals:			'{	"errors" : [		{			"message" : "Variable \"intArg\" of type \"Int\" used in position expecting type \"Boolean\".",			"locations" : [				{					"line" : 2,					"column" : 30				},				{					"line" : 4,					"column" : 33				}			]		}	]}'</body><body package="GraphQLBeta-Tests-Validation" selector="testAllVariableUsagesAreAllowed02">testAllVariableUsagesAreAllowed02	"Variable usages must be compatible with the arguments they are passed to.Validation failures occur when variables are used in the context of types that are complete mismatches, or if a nullable type in a variable is passed to a nonânull argument type."	| result |	result := self		operation: 'booleanListCannotGoIntoBoolean'		variables: '{"booleanListArg": []}'		jsonRequest:			'query booleanListCannotGoIntoBoolean($booleanListArg: [Boolean]) {  arguments {    booleanArgField(booleanArg: $booleanListArg)  }}'.	self		assert: result		equals:			'{	"errors" : [		{			"message" : "Variable \"booleanListArg\" of type \"[Boolean]\" used in position expecting type \"Boolean\".",			"locations" : [				{					"line" : 2,					"column" : 38				},				{					"line" : 4,					"column" : 33				}			]		}	]}'</body><body package="GraphQLBeta-Tests-Validation" selector="testAllVariableUsagesAreAllowed03">testAllVariableUsagesAreAllowed03	"Variable usages must be compatible with the arguments they are passed to.Validation failures occur when variables are used in the context of types that are complete mismatches, or if a nullable type in a variable is passed to a nonânull argument type."	| result |	result := self		operation: 'booleanArgQuery'		variables: '{"booleanArg": []}'		jsonRequest:			'query booleanArgQuery($booleanArg: Boolean) {  arguments {    nonNullBooleanArgField(nonNullBooleanArg: $booleanArg)  }}'.	self		assert: result		equals:			'{	"errors" : [		{			"message" : "Variable \"$booleanArg\" got invalid value []. Expected type \"Boolean\".",			"locations" : [				{					"line" : 2,					"column" : 23				}			]		},		{			"message" : "Variable \"booleanArg\" of type \"Boolean\" used in position expecting type \"Boolean!\".",			"locations" : [				{					"line" : 2,					"column" : 23				},				{					"line" : 4,					"column" : 47				}			]		}	]}'</body><body package="GraphQLBeta-Tests-Validation" selector="testAllVariableUsagesAreAllowed04">testAllVariableUsagesAreAllowed04	"Variable usages must be compatible with the arguments they are passed to.Validation failures occur when variables are used in the context of types that are complete mismatches, or if a nullable type in a variable is passed to a nonânull argument type."	| result |	result := self		operation: 'nonNullListToList'		variables: '{"nonNullBooleanList": [true]}'		jsonRequest:			'query nonNullListToList($nonNullBooleanList: [Boolean]!) {  arguments {    booleanListArgField(booleanListArg: $nonNullBooleanList)  }}'.	self		assert: result		equals:			'{	"data" : {		"arguments" : {			"booleanListArgField" : [				true			]		}	}}'</body><body package="GraphQLBeta-Tests-Validation" selector="testAllVariableUsagesAreAllowed05">testAllVariableUsagesAreAllowed05	"Variable usages must be compatible with the arguments they are passed to.Validation failures occur when variables are used in the context of types that are complete mismatches, or if a nullable type in a variable is passed to a nonânull argument type."	| result |	result := self		operation: 'listToNonNullList'		variables: '{"booleanList": [true]}'		jsonRequest:			'query listToNonNullList($booleanList: [Boolean]) {  arguments {    nonNullBooleanListField(nonNullBooleanListArg: $booleanList)  }}'.	self		assert: result		equals:			'{	"errors" : [		{			"message" : "Variable \"booleanList\" of type \"[Boolean]\" used in position expecting type \"[Boolean]!\".",			"locations" : [				{					"line" : 2,					"column" : 25				},				{					"line" : 4,					"column" : 52				}			]		}	]}'</body><body package="GraphQLBeta-Tests-Validation" selector="testAllVariableUsagesAreAllowed06">testAllVariableUsagesAreAllowed06	"Variable usages must be compatible with the arguments they are passed to.Validation failures occur when variables are used in the context of types that are complete mismatches, or if a nullable type in a variable is passed to a nonânull argument type."	| result |	result := self		operation: 'booleanArgQueryWithDefault'		variables: '{"booleanArg": [true]}'		jsonRequest:			'query booleanArgQueryWithDefault($booleanArg: Boolean) {  arguments {    optionalNonNullBooleanArgField(optionalBooleanArg: $booleanArg)  }}'.	self		assert: result		equals:			'{	"errors" : [		{			"message" : "Variable \"$booleanArg\" got invalid value [true]. Expected type \"Boolean\".",			"locations" : [				{					"line" : 2,					"column" : 34				}			]		},		{			"message" : "Variable \"booleanArg\" of type \"Boolean\" used in position expecting type \"Boolean!\".",			"locations" : [				{					"line" : 2,					"column" : 34				},				{					"line" : 4,					"column" : 56				}			]		}	]}'</body><body package="GraphQLBeta-Tests-Validation" selector="testAllVariableUsagesAreAllowed07">testAllVariableUsagesAreAllowed07	"Variable usages must be compatible with the arguments they are passed to.Validation failures occur when variables are used in the context of types that are complete mismatches, or if a nullable type in a variable is passed to a nonânull argument type."	| result |	self		flag:			'TODO, schema needs to use default values in order to compleate this rule'.	"Allowing optional variables when default values existA notable exception to typical variable type compatibility is allowing a variable definition with a nullable type to be provided to a nonânull location as long as either that variable or that location provides a default value."	true		ifTrue: [ ^ self ].	result := self		operation: 'booleanArgQueryWithDefault'		variables: '{"booleanArg": [true]}'		jsonRequest:			'query booleanArgQueryWithDefault($booleanArg: Boolean = true) {  arguments {    nonNullBooleanArgField(nonNullBooleanArg: $booleanArg)  }}'.	self assert: result equals: ''</body><body package="GraphQLBeta-Tests-Validation" selector="testAllVariableUsagesAreAllowed08">testAllVariableUsagesAreAllowed08	"Variable usages must be compatible with the arguments they are passed to.Validation failures occur when variables are used in the context of types that are complete mismatches, or if a nullable type in a variable is passed to a nonânull argument type."	| result |	"Allowing optional variables when default values existA notable exception to typical variable type compatibility is allowing a variable definition with a nullable type to be provided to a nonânull location as long as either that variable or that location provides a default value."	result := self		operation: 'intArgQuery'		jsonRequest:			'query intArgQuery($x: Int = 2.3) {  arguments {    intArgField(intArg: $x)  }}'.	self		assert: result		equals:			'{	"errors" : [		{			"message" : "Expected type Int, found 2.3.",			"locations" : [				{					"line" : 2,					"column" : 29				}			]		}	]}'</body><body package="GraphQLBeta-Tests-Validation" selector="testAllVariableUsesDefined01">testAllVariableUsesDefined01	"Variables are scoped on a perâoperation basis. That means that any variable used within the context of an operation must be defined at the top level of that operation"	| result |	result := self		operation: 'variableIsDefined'		variables: '{"atOtherHomes": true}'		jsonRequest:			'query variableIsDefined($atOtherHomes: Boolean) {  dog {    isHousetrained(atOtherHomes: $atOtherHomes)  }}'.	self		assert: result		equals:			'{	"data" : {		"dog" : {			"isHousetrained" : false		}	}}'</body><body package="GraphQLBeta-Tests-Validation" selector="testAllVariableUsesDefined02">testAllVariableUsesDefined02	"Variables are scoped on a perâoperation basis. That means that any variable used within the context of an operation must be defined at the top level of that operation"	| result |	result := self		operation: 'variableIsNotDefined'		jsonRequest:			'query variableIsNotDefined {  dog {    isHousetrained(atOtherHomes: $atOtherHomes)  }}'.	self		assert: result		equals:			'{	"errors" : [		{			"message" : "Variable \"atOtherHomes\" is not defined by operation \"variableIsNotDefined\".",			"locations" : [				{					"line" : 4,					"column" : 34				},				{					"line" : 2,					"column" : 7				}			]		}	]}'</body><body package="GraphQLBeta-Tests-Validation" selector="testAllVariableUsesDefined03">testAllVariableUsesDefined03	"Variables are scoped on a perâoperation basis. That means that any variable used within the context of an operation must be defined at the top level of that operation"	| result |	result := self		jsonRequest:			'{  dog {    isHousetrained(atOtherHomes: $atOtherHomes)  }}'.	self		assert: result		equals:			'{	"errors" : [		{			"message" : "Variable \"atOtherHomes\" is not defined.",			"locations" : [				{					"line" : 4,					"column" : 34				},				{					"line" : 2,					"column" : 1				}			]		}	]}'</body><body package="GraphQLBeta-Tests-Validation" selector="testAllVariableUsesDefined04">testAllVariableUsesDefined04	"Variables are scoped on a perâoperation basis. That means that any variable used within the context of an operation must be defined at the top level of that operation"	| result |	result := self		operation: 'variableIsDefinedUsedInSingleFragment'		variables: '{"atOtherHomes": true}'		jsonRequest:			'query variableIsDefinedUsedInSingleFragment($atOtherHomes: Boolean) {  dog {    ...isHousetrainedFragment  }}fragment isHousetrainedFragment on GQLDog {  isHousetrained(atOtherHomes: $atOtherHomes)}'.	self		assert: result		equals:			'{	"data" : {		"dog" : {			"isHousetrained" : false		}	}}'</body><body package="GraphQLBeta-Tests-Validation" selector="testAllVariableUsesDefined05">testAllVariableUsesDefined05	"Variables are scoped on a perâoperation basis. That means that any variable used within the context of an operation must be defined at the top level of that operation"	| result |	result := self		operation: 'variableIsNotDefinedUsedInSingleFragment'		jsonRequest:			'query variableIsNotDefinedUsedInSingleFragment {  dog {    ...isHousetrainedFragment  }}fragment isHousetrainedFragment on GQLDog {  isHousetrained(atOtherHomes: $atOtherHomes)}'.	self		assert: result		equals:			'{	"errors" : [		{			"message" : "Variable \"atOtherHomes\" is not defined by operation \"variableIsNotDefinedUsedInSingleFragment\".",			"locations" : [				{					"line" : 9,					"column" : 32				},				{					"line" : 2,					"column" : 7				}			]		}	]}'</body><body package="GraphQLBeta-Tests-Validation" selector="testAllVariableUsesDefined06">testAllVariableUsesDefined06	"Variables are scoped on a perâoperation basis. That means that any variable used within the context of an operation must be defined at the top level of that operation"	| result |	result := self		operation: 'variableIsNotDefinedUsedInNestedFragment'		jsonRequest:			'query variableIsNotDefinedUsedInNestedFragment {  dog {    ...outerHousetrainedFragment  }}fragment outerHousetrainedFragment on GQLDog {  ...isHousetrainedFragment}fragment isHousetrainedFragment on GQLDog {  isHousetrained(atOtherHomes: $atOtherHomes)}'.	self		assert: result		equals:			'{	"errors" : [		{			"message" : "Variable \"atOtherHomes\" is not defined by operation \"variableIsNotDefinedUsedInNestedFragment\".",			"locations" : [				{					"line" : 13,					"column" : 32				},				{					"line" : 2,					"column" : 7				}			]		}	]}'</body><body package="GraphQLBeta-Tests-Validation" selector="testAllVariableUsesDefined07">testAllVariableUsesDefined07	"Variables are scoped on a perâoperation basis. That means that any variable used within the context of an operation must be defined at the top level of that operation"	| result |	result := self		operation: 'housetrainedQueryOne'		variables: '{"atOtherHomes": true}'		jsonRequest:			'query housetrainedQueryOne($atOtherHomes: Boolean) {  dog {    ...isHousetrainedFragment  }}query housetrainedQueryTwo($atOtherHomes: Boolean) {  dog {    ...isHousetrainedFragment  }}fragment isHousetrainedFragment on GQLDog {  isHousetrained(atOtherHomes: $atOtherHomes)}'.	self		assert: result		equals:			'{	"data" : {		"dog" : {			"isHousetrained" : false		}	}}'</body><body package="GraphQLBeta-Tests-Validation" selector="testAllVariableUsesDefined08">testAllVariableUsesDefined08	"Variables are scoped on a perâoperation basis. That means that any variable used within the context of an operation must be defined at the top level of that operation"	| result |	result := self		operation: 'housetrainedQueryOne'		variables: '{"atOtherHomes": true}'		jsonRequest:			'query housetrainedQueryOne($atOtherHomes: Boolean) {  dog {    ...isHousetrainedFragment  }}query housetrainedQueryTwoNotDefined {  dog {    ...isHousetrainedFragment  }}fragment isHousetrainedFragment on GQLDog {  isHousetrained(atOtherHomes: $atOtherHomes)}'.	self		assert: result		equals:			'{	"errors" : [		{			"message" : "Variable \"atOtherHomes\" is not defined by operation \"housetrainedQueryTwoNotDefined\".",			"locations" : [				{					"line" : 15,					"column" : 32				},				{					"line" : 8,					"column" : 7				}			]		}	]}'</body><body package="GraphQLBeta-Tests-Validation" selector="testVariablesAreInputTypes01">testVariablesAreInputTypes01	"Variables can only be input types. Objects, unions, and interfaces cannot be used as inputs."	| result |	result := self		operation: 'takesComplexInput'		variables:			'{"complexInput": {name: "lobo"}, "atOtherHomes": true, "booleans": [true] }'		jsonRequest:			'query takesBoolean($atOtherHomes: Boolean) {  dog {    isHousetrained(atOtherHomes: $atOtherHomes)  }}query takesComplexInput($complexInput: GQLDogInput) {  findDog(complex: $complexInput) {    name  }}query TakesListOfBooleanBang($booleans: [Boolean!]) {  booleanList(booleanListArg: $booleans)}'.	self		assert: result		equals:			'{	"data" : {		"findDog" : {			"name" : "lobo"		}	}}'</body><body package="GraphQLBeta-Tests-Validation" selector="testVariablesAreInputTypes02">testVariablesAreInputTypes02	"Variables can only be input types. Objects, unions, and interfaces cannot be used as inputs."	| result |	result := self		operation: 'takesComplexInput'		jsonRequest:			'query takesCat($cat: GQLCat) {	dog { name }}query takesDogBang($dog: GQLDog!) {	dog { name }}query takesListOfPet($pets: [GQLPet]) {	dog { name }}query takesCatOrDog($catOrDog: CatOrDog) {	dog { name }}'.	self		assert: result		equals:			'{	"errors" : [		{			"message" : "Variable \"$cat\" is never used in operation \"takesCat\".",			"locations" : [				{					"line" : 2,					"column" : 16				}			]		},		{			"message" : "Variable \"$cat\" cannot be non-input type \"GQLCat\".",			"locations" : [				{					"line" : 2,					"column" : 16				}			]		},		{			"message" : "Variable \"$dog\" is never used in operation \"takesDogBang\".",			"locations" : [				{					"line" : 6,					"column" : 20				}			]		},		{			"message" : "Variable \"$dog\" of required type \"GQLDog!\" was not provided.",			"locations" : [				{					"line" : 6,					"column" : 20				}			]		},		{			"message" : "Variable \"$dog\" cannot be non-input type \"GQLDog!\".",			"locations" : [				{					"line" : 6,					"column" : 20				}			]		},		{			"message" : "Variable \"$pets\" is never used in operation \"takesListOfPet\".",			"locations" : [				{					"line" : 10,					"column" : 22				}			]		},		{			"message" : "Variable \"$pets\" cannot be non-input type \"[GQLPet]\".",			"locations" : [				{					"line" : 10,					"column" : 22				}			]		},		{			"message" : "Variable \"$catOrDog\" is never used in operation \"takesCatOrDog\".",			"locations" : [				{					"line" : 14,					"column" : 21				}			]		},		{			"message" : "Variable \"$catOrDog\" cannot be non-input type \"CatOrDog\".",			"locations" : [				{					"line" : 14,					"column" : 21				}			]		}	]}'</body><body package="GraphQLBeta-Tests-Validation" selector="testVariableUniqueness01">testVariableUniqueness01	"If any operation defines more than one variable with the same name, it is ambiguous and invalid. It is invalid even if the type of the duplicate variable is the same."	| result |	result := self		operation: 'houseTrainedQuery'		variables: '{"atOtherHomes": true}'		jsonRequest:			'query houseTrainedQuery($atOtherHomes: Boolean, $atOtherHomes: Boolean) {  dog {    isHousetrained(atOtherHomes: $atOtherHomes)  }}'.	self		assert: result		equals:			'{	"errors" : [		{			"message" : "There can be only one variable named \"atOtherHomes\".",			"locations" : [				{					"line" : 2,					"column" : 25				},				{					"line" : 2,					"column" : 49				}			]		}	]}'</body><body package="GraphQLBeta-Tests-Validation" selector="testVariableUniqueness02">testVariableUniqueness02	"If any operation defines more than one variable with the same name, it is ambiguous and invalid. It is invalid even if the type of the duplicate variable is the same."	| result |	result := self		operation: 'A'		variables: '{"atOtherHomes": true}'		jsonRequest:			'query A($atOtherHomes: Boolean) {  ...HouseTrainedFragment}query B($atOtherHomes: Boolean) {  ...HouseTrainedFragment}fragment HouseTrainedFragment on GQLQueryRoot{  dog {    isHousetrained(atOtherHomes: $atOtherHomes)  }}'.	self		assert: result		equals:			'{	"data" : {		"dog" : {			"isHousetrained" : false		}	}}'</body></methods><methods><class-id>GraphQLBeta.GQLNullNode</class-id> <category>printing</category><body package="GraphQLBeta-Nodes" selector="printOn:">printOn: stream	stream nextPutAll: 'null'</body></methods><methods><class-id>GraphQLBeta.GQLNullNode</class-id> <category>action</category><body package="GraphQLBeta-Nodes" selector="executeOn:with:using:">executeOn: resolver with: context using: schema	"Execute the input value according to the resolver, the enviroment and the schema"	^ nil</body></methods><methods><class-id>GraphQLBeta.GQLOperationsValidationTest</class-id> <category>tests</category><body package="GraphQLBeta-Tests-Validation" selector="testLoneAnonymousOperation01">testLoneAnonymousOperation01	| result |	"This document is the valid"	result := self		jsonRequest:			'{  dog {    name  }}'.	self		assertJSONEquals: result		and:			'{	"data" : { 		"dog" : {			"name" : "lobo"		}	}}'</body><body package="GraphQLBeta-Tests-Validation" selector="testLoneAnonymousOperation02">testLoneAnonymousOperation02	| result |	"This document is the invalid"	result := self		jsonRequest:			'{  dog {    name  }}query getName {  dog {    owner {      name    }  }}'.	self		assert: result		equals:			'{	"errors" : [		{			"message" : "GraphQL allows a shortâhand form for defining query operations when only that one operation exists in the document.",			"locations" : [				{					"line" : 3,					"column" : 1				}			]		}	]}'</body><body package="GraphQLBeta-Tests-Validation" selector="testOperationUniqueName01">testOperationUniqueName01	| result |	"This document is the valid"	result := self		operation: 'getDogName'		jsonRequest:			'query getDogName {  dog {    name  }}query getOwnerName {  dog {    owner {      name    }  }}'.	self		assertJSONEquals: result		and:			'{	"data" : { 		"dog" : {			"name" : "lobo"		}	}}'</body><body package="GraphQLBeta-Tests-Validation" selector="testOperationUniqueName02">testOperationUniqueName02	| result |	"This is document is invalid"	result := self		operation: 'getName'		jsonRequest:			'query getName {  dog {    name  }}query getName {  dog {    owner {      name    }  }}'.	self		assert: result		equals:			'{	"errors" : [		{			"message" : "Each named operation definition must be unique: \"getName\"",			"locations" : [				{					"line" : 2,					"column" : 7				},				{					"line" : 8,					"column" : 7				}			]		}	]}'</body><body package="GraphQLBeta-Tests-Validation" selector="testOperationUniqueName03">testOperationUniqueName03	| result |	"This is document is invalid even if the type of each operation is different"	result := self		operation: 'getName'		jsonRequest:			'query dogOperation {  dog {    name  }}mutation dogOperation {  mutateDog {    id  }}'.	self		assert: result		equals:			'{	"errors" : [		{			"message" : "Each named operation definition must be unique: \"dogOperation\"",			"locations" : [				{					"line" : 2,					"column" : 7				},				{					"line" : 8,					"column" : 10				}			]		},		{			"message" : "mutation not supported, review schema definition.",			"locations" : [				{					"line" : 8,					"column" : 10				}			]		}	]}'</body></methods><methods><class-id>GraphQLBeta.GraphQLHeroTest</class-id> <category>tests</category><body package="GraphQLBeta-Test-Utils" selector="createHeroClass">createHeroClass	| c |	c := Object		subclass: 'Hero'		instanceVariableNames: 'name planet'		classVariableNames: ''		package: 'DummyPackage'.	c compile: 'name ^ name'.	c		compile:			'name: aString	name := aString'.	c compile: 'planet ^ planet'.	c		compile:			'planet: aString	planet := aString'.	^ c</body><body package="GraphQLBeta-Test-Utils" selector="testOnHero">testOnHero	| c g res pkg |	c := self createHeroClass.	g := GraphQL new.	g rootInstance: self.	g createSchema: self schema.	res := g		handleRequest:			'{	heroes{		name		planet		}}'.	res := res at: 'data'.	self assert: (res at: 'heroes') class equals: OrderedCollection.	c removeFromSystem.	pkg := 'DummyPackage' asPackageIfAbsent: [  ].	pkg ifNotNil: [ pkg removeFromSystem ]</body></methods><methods><class-id>GraphQLBeta.GraphQLHeroTest</class-id> <category>accessing</category><body package="GraphQLBeta-Test-Utils" selector="heroes">heroes	| c clazz |	c := OrderedCollection new.	clazz := GraphQLPlatform current classAt: #Hero.	c		add:			(clazz new				name: 'Superman';				planet: 'Krypton');		add:			(clazz new				name: 'Mars pathfinder';				planet: 'Mars');		add:			(clazz new				name: 'Curiosity';				planet: 'Mars');		add:			(clazz new				name: 'Philae';				planet: 'comet 67P/ChuryumovâGerasimenko').	^ c</body><body package="GraphQLBeta-Test-Utils" selector="schema">schema	^ '	schema{		query: GraphQLHeroTest	}	type GraphQLHeroTest{		heroes: [ Hero ]	},	type Hero{		name : String		planet : String	}'</body></methods><methods><class-id>GraphQLBeta.GQLRequestGrammarEvaluatorTest</class-id> <category>tests</category><body package="GraphQLBeta-Tests-Grammar" selector="testFragmentSpreadWithDirectives">testFragmentSpreadWithDirectives	| document nestedFragments firstSubSelection firstFragment directive |	document := self		parseRequest:			'query withNestedFragments {  				user(id: 4) {    					...familiarFields @skip(if: $someTest)  				}	}'.	self assert: document class: GQLDocumentNode.	nestedFragments := document operations first.	self assert: nestedFragments class: GQLOperationNode.	self assert: nestedFragments type: 'query'.	self assert: nestedFragments name: 'withNestedFragments'.	firstSubSelection := nestedFragments selectionSet selections first.	self assert: firstSubSelection class: GQLNonScalarFieldNode.	self assert: firstSubSelection name: 'user'.	self assertArguments: firstSubSelection withNames: #('id').	self assertArguments: firstSubSelection ofClasses: #('GQLIntNode').	self assertArguments: firstSubSelection withValues: #('4').	firstFragment := firstSubSelection selectionSet selections first.	self assert: firstFragment name: 'familiarFields'.	directive := firstFragment directives first.	self assert: directive name: 'skip'.	self assertArguments: directive withNames: #('if').	self assertArguments: directive withValues: #('someTest')</body><body package="GraphQLBeta-Tests-Grammar" selector="testInlineFragmentWithDirectives">testInlineFragmentWithDirectives	| text document inlineFragmentTyping firstSubSelection firstFragment |	text := 'query inlineFragmentNoType($expandedInfo: Boolean) {  				user(handle: "zuck") {    					id    					... @include(if: $expandedInfo) {      					firstName    					}  				}	}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: GQLDocumentNode.	inlineFragmentTyping := document operations first.	self assert: inlineFragmentTyping class equals: GQLOperationNode.	self assert: inlineFragmentTyping type equals: 'query'.	self assert: inlineFragmentTyping name equals: 'inlineFragmentNoType'.	self		assert: inlineFragmentTyping variableDefinitions first type class		equals: GQLSBooleanTypeNode.	self		assert: inlineFragmentTyping variableDefinitions first name value		equals: 'expandedInfo'.	firstSubSelection := inlineFragmentTyping selectionSet selections		first.	self assert: firstSubSelection class equals: GQLNonScalarFieldNode.	self assert: firstSubSelection name equals: 'user'.	self assert: firstSubSelection arguments first name equals: 'handle'.	self		assert: firstSubSelection arguments first value class		equals: GQLStringNode.	self		assert: firstSubSelection arguments first value value		equals: '"zuck"'.	firstFragment := firstSubSelection selectionSet selections second.	self assert: firstFragment directives first name equals: 'include'.	self		assert: firstFragment directives first arguments first name		equals: 'if'.	self		assert: firstFragment directives first arguments first value class		equals: GQLVariableNode.	self		assert: firstFragment directives first arguments first value value		equals: 'expandedInfo'.	self		assert: firstFragment selectionSet selections first name		equals: 'firstName'</body><body package="GraphQLBeta-Tests-Grammar" selector="testOperationWithDirective">testOperationWithDirective	| text document operation firstField |	text := 'query @skip(if: $foo) { 				 field			}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: GQLDocumentNode.	operation := document operations first.	self assert: operation class equals: GQLOperationNode.	self assert: operation type equals: 'query'.	self assert: operation directives first name equals: 'skip'.	self		assert: operation directives first arguments first name		equals: 'if'.	self		assert: operation directives first arguments first value class		equals: GQLVariableNode.	self		assert: operation directives first arguments first value value		equals: 'foo'.	firstField := operation selectionSet selections first.	self assert: firstField class equals: GQLScalarFieldNode.	self assert: firstField name equals: 'field'</body><body package="GraphQLBeta-Tests-Grammar" selector="testOperationWithVariableDefaultValue">testOperationWithVariableDefaultValue	| text document operation field |	text := 'query myQuery($atOtherHomes: Boolean = true) {  				isHousetrained(atOtherHomes: $atOtherHomes)				}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: GQLDocumentNode.	operation := document operations first.	self assert: operation class equals: GQLOperationNode.	self assert: operation name equals: 'myQuery'.	self assert: operation type equals: 'query'.	self		assert: operation variableDefinitions first name class		equals: ByteString.	self		assert: operation variableDefinitions first name value		equals: 'atOtherHomes'.	self		assert: operation variableDefinitions first type class		equals: GQLSBooleanTypeNode.	self		assert: operation variableDefinitions first defaultValue class		equals: GQLBooleanNode.	field := operation selectionSet selections first.	self assert: field class equals: GQLScalarFieldNode.	self assert: field name equals: 'isHousetrained'.	self assert: field arguments first name equals: 'atOtherHomes'.	self		assert: field arguments first value class		equals: GQLVariableNode.	self assert: field arguments first value value equals: 'atOtherHomes'</body><body package="GraphQLBeta-Tests-Grammar" selector="testOperationWithVariableDefinitions">testOperationWithVariableDefinitions	| text document operation field |	text := 'query myQuery($someTest: Boolean) {  				experimentalField @include(if: $someTest)				}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: GQLDocumentNode.	operation := document operations first.	self assert: operation class equals: GQLOperationNode.	self assert: operation name equals: 'myQuery'.	self assert: operation type equals: 'query'.	self		assert: operation variableDefinitions first name class		equals: ByteString.	self		assert: operation variableDefinitions first name value		equals: 'someTest'.	self		assert: operation variableDefinitions first type class		equals: GQLSBooleanTypeNode.	field := operation selectionSet selections first.	self assert: field class equals: GQLScalarFieldNode.	self assert: field name equals: 'experimentalField'.	self assert: field directives first name equals: 'include'.	self assert: field directives first arguments size equals: 1.	self assert: field directives first arguments first name equals: 'if'.	self		assert: field directives first arguments first value class		equals: GQLVariableNode.	self		assert: field directives first arguments first value value		equals: 'someTest'</body><body package="GraphQLBeta-Tests-Grammar" selector="testVariableListType">testVariableListType	| text document operation field |	text := 'query myQuery($someTest: [ Boolean ]) {  				experimentalField				}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: GQLDocumentNode.	operation := document operations first.	self assert: operation class equals: GQLOperationNode.	self assert: operation name equals: 'myQuery'.	self assert: operation type equals: 'query'.	self		assert: operation variableDefinitions first name class		equals: ByteString.	self		assert: operation variableDefinitions first name value		equals: 'someTest'.	self		assert: operation variableDefinitions first type class		equals: GQLSListTypeNode.	self		assert: operation variableDefinitions first type wrappedType class		equals: GQLSBooleanTypeNode.	field := operation selectionSet selections first.	self assert: field class equals: GQLScalarFieldNode.	self assert: field name equals: 'experimentalField'</body><body package="GraphQLBeta-Tests-Grammar" selector="testVariableListTypeNamed">testVariableListTypeNamed	| text document operation field |	text := 'query myQuery($someTest: [ Some ]) {  				experimentalField				}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: GQLDocumentNode.	operation := document operations first.	self assert: operation class equals: GQLOperationNode.	self assert: operation name equals: 'myQuery'.	self assert: operation type equals: 'query'.	self		assert: operation variableDefinitions first name class		equals: ByteString.	self		assert: operation variableDefinitions first name value		equals: 'someTest'.	self		assert: operation variableDefinitions first type class		equals: GQLSListTypeNode.	self		assert: operation variableDefinitions first type wrappedType class		equals: GQLSNamedTypeNode.	self		assert: operation variableDefinitions first type wrappedType name		equals: 'Some'.	field := operation selectionSet selections first.	self assert: field class equals: GQLScalarFieldNode.	self assert: field name equals: 'experimentalField'</body><body package="GraphQLBeta-Tests-Grammar" selector="testVariableListTypeNonNull">testVariableListTypeNonNull	| text document operation field |	text := 'query myQuery($someTest: [ Int! ]) {  				experimentalField				}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: GQLDocumentNode.	operation := document operations first.	self assert: operation class equals: GQLOperationNode.	self assert: operation name equals: 'myQuery'.	self assert: operation type equals: 'query'.	self		assert: operation variableDefinitions first name class		equals: ByteString.	self		assert: operation variableDefinitions first name value		equals: 'someTest'.	self		assert: operation variableDefinitions first type class		equals: GQLSListTypeNode.	self		assert: operation variableDefinitions first type wrappedType class		equals: GQLSNonNullTypeNode.	self		assert: operation variableDefinitions first type wrappedType wrappedType class		equals: GQLSIntTypeNode.	field := operation selectionSet selections first.	self assert: field class equals: GQLScalarFieldNode.	self assert: field name equals: 'experimentalField'</body><body package="GraphQLBeta-Tests-Grammar" selector="testVariableListTypeNonNullNamed">testVariableListTypeNonNullNamed	| text document operation field |	text := 'query myQuery($someTest: [ Some! ]) {  				experimentalField				}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: GQLDocumentNode.	operation := document operations first.	self assert: operation class equals: GQLOperationNode.	self assert: operation name equals: 'myQuery'.	self assert: operation type equals: 'query'.	self		assert: operation variableDefinitions first name class		equals: ByteString.	self		assert: operation variableDefinitions first name value		equals: 'someTest'.	self		assert: operation variableDefinitions first type class		equals: GQLSListTypeNode.	self		assert: operation variableDefinitions first type wrappedType class		equals: GQLSNonNullTypeNode.	self		assert: operation variableDefinitions first type wrappedType wrappedType class		equals: GQLSNamedTypeNode.	self		assert: operation variableDefinitions first type wrappedType wrappedType name		equals: 'Some'.	field := operation selectionSet selections first.	self assert: field class equals: GQLScalarFieldNode.	self assert: field name equals: 'experimentalField'</body><body package="GraphQLBeta-Tests-Grammar" selector="testVariableNamedType">testVariableNamedType	| text document operation field |	text := 'query myQuery($someTest: Some) {  				experimentalField				}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: GQLDocumentNode.	operation := document operations first.	self assert: operation class equals: GQLOperationNode.	self assert: operation name equals: 'myQuery'.	self assert: operation type equals: 'query'.	self		assert: operation variableDefinitions first name class		equals: ByteString.	self		assert: operation variableDefinitions first name value		equals: 'someTest'.	self		assert: operation variableDefinitions first type class		equals: GQLSNamedTypeNode.	self		assert: operation variableDefinitions first type name		equals: 'Some'.	field := operation selectionSet selections first.	self assert: field class equals: GQLScalarFieldNode.	self assert: field name equals: 'experimentalField'</body><body package="GraphQLBeta-Tests-Grammar" selector="testVariableNonNullListType">testVariableNonNullListType	| text document operation field |	text := 'query myQuery($someTest: [ Float ]!) {  				experimentalField				}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: GQLDocumentNode.	operation := document operations first.	self assert: operation class equals: GQLOperationNode.	self assert: operation name equals: 'myQuery'.	self assert: operation type equals: 'query'.	self		assert: operation variableDefinitions first name class		equals: ByteString.	self		assert: operation variableDefinitions first name value		equals: 'someTest'.	self		assert: operation variableDefinitions first type class		equals: GQLSNonNullTypeNode.	self		assert: operation variableDefinitions first type wrappedType class		equals: GQLSListTypeNode.	self		assert: operation variableDefinitions first type wrappedType wrappedType class		equals: GQLSFloatTypeNode.	field := operation selectionSet selections first.	self assert: field class equals: GQLScalarFieldNode.	self assert: field name equals: 'experimentalField'</body><body package="GraphQLBeta-Tests-Grammar" selector="testVariableNonNullListTypeNamed">testVariableNonNullListTypeNamed	| text document operation field |	text := 'query myQuery($someTest: [ Some ]!) {  				experimentalField				}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: GQLDocumentNode.	operation := document operations first.	self assert: operation class equals: GQLOperationNode.	self assert: operation name equals: 'myQuery'.	self assert: operation type equals: 'query'.	self		assert: operation variableDefinitions first name class		equals: ByteString.	self		assert: operation variableDefinitions first name value		equals: 'someTest'.	self		assert: operation variableDefinitions first type class		equals: GQLSNonNullTypeNode.	self		assert: operation variableDefinitions first type wrappedType class		equals: GQLSListTypeNode.	self		assert: operation variableDefinitions first type wrappedType wrappedType class		equals: GQLSNamedTypeNode.	self		assert: operation variableDefinitions first type wrappedType wrappedType name		equals: 'Some'.	field := operation selectionSet selections first.	self assert: field class equals: GQLScalarFieldNode.	self assert: field name equals: 'experimentalField'</body><body package="GraphQLBeta-Tests-Grammar" selector="testVariableNonNullListTypeNonNull">testVariableNonNullListTypeNonNull	| text document operation field |	text := 'query myQuery($someTest: [ Boolean! ]!) {  				experimentalField				}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: GQLDocumentNode.	operation := document operations first.	self assert: operation class equals: GQLOperationNode.	self assert: operation name equals: 'myQuery'.	self assert: operation type equals: 'query'.	self		assert: operation variableDefinitions first name class		equals: ByteString.	self		assert: operation variableDefinitions first name value		equals: 'someTest'.	self		assert: operation variableDefinitions first type class		equals: GQLSNonNullTypeNode.	self		assert: operation variableDefinitions first type wrappedType class		equals: GQLSListTypeNode.	self		assert: operation variableDefinitions first type wrappedType wrappedType class		equals: GQLSNonNullTypeNode.	self		assert:			operation variableDefinitions first type wrappedType wrappedType				wrappedType class		equals: GQLSBooleanTypeNode.	field := operation selectionSet selections first.	self assert: field class equals: GQLScalarFieldNode.	self assert: field name equals: 'experimentalField'</body><body package="GraphQLBeta-Tests-Grammar" selector="testVariableNonNullListTypeNonNullNamed">testVariableNonNullListTypeNonNullNamed	| text document operation field |	text := 'query myQuery($someTest: [ Some! ]!) {  				experimentalField				}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: GQLDocumentNode.	operation := document operations first.	self assert: operation class equals: GQLOperationNode.	self assert: operation name equals: 'myQuery'.	self assert: operation type equals: 'query'.	self		assert: operation variableDefinitions first name class		equals: ByteString.	self		assert: operation variableDefinitions first name value		equals: 'someTest'.	self		assert: operation variableDefinitions first type class		equals: GQLSNonNullTypeNode.	self		assert: operation variableDefinitions first type wrappedType class		equals: GQLSListTypeNode.	self		assert: operation variableDefinitions first type wrappedType wrappedType class		equals: GQLSNonNullTypeNode.	self		assert:			operation variableDefinitions first type wrappedType wrappedType				wrappedType class		equals: GQLSNamedTypeNode.	self		assert:			operation variableDefinitions first type wrappedType wrappedType				wrappedType name		equals: 'Some'.	field := operation selectionSet selections first.	self assert: field class equals: GQLScalarFieldNode.	self assert: field name equals: 'experimentalField'</body><body package="GraphQLBeta-Tests-Grammar" selector="testVariableNonNullNamedType">testVariableNonNullNamedType	| text document operation field |	text := 'query myQuery($someTest: Some!) {  				experimentalField				}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: GQLDocumentNode.	operation := document operations first.	self assert: operation class equals: GQLOperationNode.	self assert: operation name equals: 'myQuery'.	self assert: operation type equals: 'query'.	self		assert: operation variableDefinitions first name class		equals: ByteString.	self		assert: operation variableDefinitions first name value		equals: 'someTest'.	self		assert: operation variableDefinitions first type class		equals: GQLSNonNullTypeNode.	self		assert: operation variableDefinitions first type wrappedType class		equals: GQLSNamedTypeNode.	self		assert: operation variableDefinitions first type wrappedType name		equals: 'Some'.	field := operation selectionSet selections first.	self assert: field class equals: GQLScalarFieldNode.	self assert: field name equals: 'experimentalField'</body><body package="GraphQLBeta-Tests-Grammar" selector="testVariableNonNullScalarType">testVariableNonNullScalarType	| text document operation field |	text := 'query myQuery($someTest: ID!) {  				experimentalField				}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: GQLDocumentNode.	operation := document operations first.	self assert: operation class equals: GQLOperationNode.	self assert: operation name equals: 'myQuery'.	self assert: operation type equals: 'query'.	self		assert: operation variableDefinitions first name class		equals: ByteString.	self		assert: operation variableDefinitions first name value		equals: 'someTest'.	self		assert: operation variableDefinitions first type class		equals: GQLSNonNullTypeNode.	self		assert: operation variableDefinitions first type wrappedType class		equals: GQLSIDTypeNode.	field := operation selectionSet selections first.	self assert: field class equals: GQLScalarFieldNode.	self assert: field name equals: 'experimentalField'</body><body package="GraphQLBeta-Tests-Grammar" selector="testVariableScalarType">testVariableScalarType	| text document operation field |	text := 'query myQuery($someTest: String) {  				experimentalField				}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: GQLDocumentNode.	operation := document operations first.	self assert: operation class equals: GQLOperationNode.	self assert: operation name equals: 'myQuery'.	self assert: operation type equals: 'query'.	self		assert: operation variableDefinitions first name class		equals: ByteString.	self		assert: operation variableDefinitions first name value		equals: 'someTest'.	self		assert: operation variableDefinitions first type class		equals: GQLSStringTypeNode.	field := operation selectionSet selections first.	self assert: field class equals: GQLScalarFieldNode.	self assert: field name equals: 'experimentalField'</body></methods><methods><class-id>GraphQLBeta.GQLRequestGrammarEvaluatorTest</class-id> <category>test-grammar-values</category><body package="GraphQLBeta-Tests-Grammar" selector="testArgumentsCompositeObjectValue">testArgumentsCompositeObjectValue	| document field values objectField |	document := self		parseRequest:			'{  				nearestThing(countries: [{ name: "Bolivia" , continent: "America" } , 												{ name : "Chile" , continent: "America"}])	}'.	self assert: document class: GQLDocumentNode.	field := document operations first selections first.	self assert: field name: 'nearestThing'.	self assert: field arguments size equals: 1.	self assertArguments: field withNames: #('countries').	self assertArguments: field ofClasses: #('GQLListNode').	values := field arguments first value value.	self assertList: values class: GQLObjectNode.	objectField := values first.	self assertObjectField: objectField withNames: #('name' 'continent').	self		assertObjectField: objectField		withValues: #('"Bolivia"' '"America"').	objectField := values second.	self assertObjectField: objectField withNames: #('name' 'continent').	self		assertObjectField: objectField		withValues: #('"Chile"' '"America"')</body><body package="GraphQLBeta-Tests-Grammar" selector="testArgumentsEnumValue">testArgumentsEnumValue	| document filmsField |	document := self		parseRequest:			'{				films(ofGender: FavoriteGender){					rating					name				}			}'.	self assert: document class: GQLDocumentNode.	filmsField := document operations first selections first.	self assert: filmsField name: 'films'.	self assert: filmsField arguments size equals: 1.	self assertArguments: filmsField withNames: #('ofGender').	self assertArguments: filmsField ofClasses: #('GQLEnumNode').	self assertArguments: filmsField withValues: #('FavoriteGender')</body><body package="GraphQLBeta-Tests-Grammar" selector="testArgumentsListScalarValue">testArgumentsListScalarValue	| document filmsField argument valueArgument |	document := self		parseRequest:			'{				films(inYears: [ 2016, 2012, 2000], withActors: [ "Adam Sandler", "Cris Rock" ]){					rating					name				}			}'.	self assert: document class: GQLDocumentNode.	filmsField := document operations first selections first.	self assert: filmsField name: 'films'.	self assert: filmsField arguments size equals: 2.	self assertArguments: filmsField withNames: #('inYears' 'withActors').	self		assertArguments: filmsField		ofClasses: #('GQLListNode' 'GQLListNode').	argument := filmsField arguments first.	valueArgument := argument value value.	self assertList: valueArgument class: GQLIntNode.	self assertList: valueArgument withValues: #('2016' '2012' '2000').	argument := filmsField arguments second.	valueArgument := argument value value.	self assertList: valueArgument class: GQLStringNode.	self		assertList: valueArgument		withValues: #('"Adam Sandler"' '"Cris Rock"')</body><body package="GraphQLBeta-Tests-Grammar" selector="testArgumentsNullValue">testArgumentsNullValue	| document filmsField |	document := self		parseRequest:			'{				films(inYear: 2016, visual: null){					rating					name				}			}'.	self assert: document class: GQLDocumentNode.	filmsField := document operations first selections first.	self assert: filmsField name: 'films'.	self assert: filmsField arguments size equals: 2.	self assertArguments: filmsField withNames: #('inYear' 'visual').	self		assertArguments: filmsField		ofClasses: #('GQLIntNode' 'GQLNullNode').	self assertArguments: filmsField withValues: #('2016' 'null').	self assertSelections: filmsField withNames: #('rating' 'name')</body><body package="GraphQLBeta-Tests-Grammar" selector="testArgumentsObjectValue">testArgumentsObjectValue	| document field objectValue |	document := self		parseRequest:			'{  				nearestThing(location: { lon: 12.43, lat: -53.211 })	}'.	self assert: document class: GQLDocumentNode.	field := document operations first selections first.	self assert: field name: 'nearestThing'.	self assert: field arguments size equals: 1.	self assert: field arguments first name: 'location'.	objectValue := field arguments first value.	self assert: objectValue class: GQLObjectNode.	self assertList: objectValue objectFields class: GQLObjectFieldNode.	self assertObjectField: objectValue withNames: #('lon' 'lat').	self assertObjectField: objectValue withValues: #('12.43' '-53.211')</body><body package="GraphQLBeta-Tests-Grammar" selector="testArgumentsSimpleScalarValue">testArgumentsSimpleScalarValue	| document filmsField actorsField |	document := self		parseRequest:			'{				films(inYear: 2016, minorRating: 5.5){					rating				}				actors(inMovie : "Star wars", active : true){					name				}			}'.	self assert: document class: GQLDocumentNode.	filmsField := document operations first selections first.	self assert: filmsField name: 'films'.	self assert: filmsField arguments size equals: 2.	self assertArguments: filmsField withNames: #('inYear' 'minorRating').	self		assertArguments: filmsField		ofClasses: #('GQLIntNode' 'GQLFloatNode').	self assertArguments: filmsField withValues: #('2016' '5.5').	actorsField := document operations first selections second.	self assert: actorsField name: 'actors'.	self assert: actorsField arguments size equals: 2.	self assertArguments: actorsField withNames: #('inMovie' 'active').	self		assertArguments: actorsField		ofClasses: #('GQLStringNode' 'GQLBooleanNode').	self assertArguments: actorsField withValues: #('"Star wars"' 'true')</body><body package="GraphQLBeta-Tests-Grammar" selector="testArgumentsVariableValue">testArgumentsVariableValue	| document filmsField |	document := self		parseRequest:			'{				films(inYears: $years withActors: $actors){					rating					name				}			}'.	self assert: document class: GQLDocumentNode.	filmsField := document operations first selections first.	self assert: filmsField name: 'films'.	self assert: filmsField arguments size equals: 2.	self assertArguments: filmsField withNames: #('inYears' 'withActors').	self		assertArguments: filmsField		ofClasses: #('GQLVariableNode' 'GQLVariableNode').	self assertArguments: filmsField withValues: #('years' 'actors')</body></methods><methods><class-id>GraphQLBeta.GQLRequestGrammarEvaluatorTest</class-id> <category>test-grammar-fields</category><body package="GraphQLBeta-Tests-Grammar" selector="testFieldsAlias">testFieldsAlias	| document userField subField |	document := self		parseRequest:			'{  				user(id: 4) {    					name    					smallPic: profilePic(size: 64)    					bigPic: profilePic(size: 1024)  			}		}'.	self assert: document class: GQLDocumentNode.	userField := document operations first selections first.	self assert: userField class: GQLNonScalarFieldNode.	self assert: userField name: 'user'.	self assert: userField arguments first name: 'id'.	self		assertSelections: userField		withNames: #('name' 'profilePic' 'profilePic').	subField := userField selectionSet selections second.	self assert: subField alias equals: 'smallPic'.	self assertArguments: subField withValues: #('64').	subField := userField selectionSet selections third.	self assert: subField alias equals: 'bigPic'.	self assertArguments: subField withValues: #('1024')</body><body package="GraphQLBeta-Tests-Grammar" selector="testFieldsIncomplete">testFieldsIncomplete	| document |	document := self		parseRequest:			'{  				user(id: 4) {    					name    					bigPic: profilePic(size: 1024)  					}'.	self assert: document class: PPFailure.	document := self		parseRequest:			'{  				user(id: 4) {    					name    					bigPic: profilePic(size: )  				}		}'.	self assert: document class equals: PPFailure.	document := self		parseRequest:			'query myQuery {  				experimentalField @skip(if: )			}'.	self assert: document class equals: PPFailure</body><body package="GraphQLBeta-Tests-Grammar" selector="testFieldsWithArguments">testFieldsWithArguments	| document filmsField actorsField |	document := self		parseRequest:			'{				films(inYear: 2016){					rating				}				actors(inMovie : "Star wars", active : true){					name				}			}'.	self assert: document class: GQLDocumentNode.	self		assertList: document operations first selections		class: GQLNonScalarFieldNode.	filmsField := document operations first selections first.	self assert: filmsField name: 'films'.	self assert: filmsField arguments size equals: 1.	self assertArguments: filmsField withNames: #('inYear').	self assertArguments: filmsField ofClasses: #('GQLIntNode').	self assertArguments: filmsField withValues: #('2016').	self assertSelections: filmsField withNames: #('rating').	actorsField := document operations first selections second.	self assert: actorsField name: 'actors'.	self assert: actorsField arguments size equals: 2.	self assertArguments: actorsField withNames: #('inMovie' 'active').	self		assertArguments: actorsField		ofClasses: #('GQLStringNode' 'GQLBooleanNode').	self assertArguments: actorsField withValues: #('"Star wars"' 'true')</body><body package="GraphQLBeta-Tests-Grammar" selector="testFieldsWithDirectives">testFieldsWithDirectives	| document operation field variable directive |	document := self		parseRequest:			'query myQuery($someTest: Boolean) {  				experimentalField @skip(if: $someTest)			}'.	self assert: document class: GQLDocumentNode.	operation := document operations first.	self assert: operation class: GQLOperationNode.	self assert: operation name: 'myQuery'.	self assert: operation type: 'query'.	variable := operation variableDefinitions first.	self assert: variable name class: ByteString.	self assert: variable name value equals: 'someTest'.	self assert: variable type class: GQLSBooleanTypeNode.	field := operation selectionSet selections first.	self assert: field class: GQLScalarFieldNode.	self assert: field name: 'experimentalField'.	directive := field directives first.	self assert: directive name equals: 'skip'.	self assert: directive arguments size equals: 1.	self assertArguments: directive withNames: #('if').	self assertArguments: directive ofClasses: #('GQLVariableNode').	self assertArguments: directive withValues: #('someTest')</body><body package="GraphQLBeta-Tests-Grammar" selector="testSimpleFields">testSimpleFields	| text document principalSelection firstSubSelection secondSubSelection |	text := '{				allFilms{					name					actors{						name					}				}			}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: GQLDocumentNode.	principalSelection := document operations first.	self assert: principalSelection class equals: GQLSelectionSetNode.	self		assert: principalSelection selections first class		equals: GQLNonScalarFieldNode.	self		assert: principalSelection selections first name		equals: 'allFilms'.	firstSubSelection := principalSelection selections first selectionSet.	self assert: firstSubSelection class equals: GQLSelectionSetNode.	self assert: firstSubSelection selections first name equals: 'name'.	self		assert: firstSubSelection selections second name		equals: 'actors'.	secondSubSelection := firstSubSelection selections second		selectionSet.	self assert: secondSubSelection selections first name equals: 'name'</body></methods><methods><class-id>GraphQLBeta.GQLRequestGrammarEvaluatorTest</class-id> <category>test-grammar-fragmentSpread</category><body package="GraphQLBeta-Tests-Grammar" selector="testFragmentSpread">testFragmentSpread	| document nestedFragments firstSubSelection secondFragment |	document := self		parseRequest:			'query withNestedFragments {  				user(id: 4) {    					...familiarFields    					mutualFriends(first: 10) {      					...friendFields    					}  				}	}'.	self assert: document class: GQLDocumentNode.	nestedFragments := document operations first.	self assert: nestedFragments class: GQLOperationNode.	self assert: nestedFragments type: 'query'.	self assert: nestedFragments name: 'withNestedFragments'.	firstSubSelection := nestedFragments selectionSet selections first.	self assert: firstSubSelection class: GQLNonScalarFieldNode.	self assert: firstSubSelection name: 'user'.	self assertArguments: firstSubSelection withNames: #('id').	self assertArguments: firstSubSelection ofClasses: #('GQLIntNode').	self assertArguments: firstSubSelection withValues: #('4').	self		assertSelections: firstSubSelection		withNames: #('familiarFields' 'mutualFriends').	secondFragment := firstSubSelection selectionSet selections second.	self assertSelections: secondFragment withNames: #('friendFields')</body><body package="GraphQLBeta-Tests-Grammar" selector="testFragmentSpreadIncorrect">testFragmentSpreadIncorrect	| text document |	document := self		parseRequest:			'query withNestedFragments {  				user(id: 4) {    					...familiarFields @skip(if: $someTest){						user					}  				}	}'.	self assert: document class: PPFailure.	document := self		parseRequest:			'query withNestedFragments {  				user(id: 4) {    					...familiarFields @skip(if: $someTest){					}  				}	}'.	self assert: document class: PPFailure.	document := self		parseRequest:			'query withNestedFragments {  				user(id: 4) {    					...familiarFields{						name					}  				}	}'.	self assert: document class: PPFailure</body></methods><methods><class-id>GraphQLBeta.GQLRequestGrammarEvaluatorTest</class-id> <category>test-grammar-inlineFragment</category><body package="GraphQLBeta-Tests-Grammar" selector="testInlineFragmentIncomplete">testInlineFragmentIncomplete	| text document |	text := 'query inlineFragmentNoType($expandedInfo: Boolean) {    					... @include(if: ) {      					firstName      					birthday    					}	}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: PPFailure.	text := 'query inlineFragmentNoType($expandedInfo: Boolean) {    					.. on User {      					firstName      					birthday    					}	}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: PPFailure</body><body package="GraphQLBeta-Tests-Grammar" selector="testInlineFragmentWithTypeCondition">testInlineFragmentWithTypeCondition	| text document inlineFragmentTyping firstSubSelection firstFragment secondFragment |	text := 'query inlineFragmentTyping {  				profiles(handles: ["zuck", "cocacola"]) {   					handle    					... on User {      					friends {        						count      					}    					}    					... on Page {      					likers {        						count      					}    					}  				}			}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: GQLDocumentNode.	inlineFragmentTyping := document operations first.	self assert: inlineFragmentTyping class equals: GQLOperationNode.	self assert: inlineFragmentTyping type equals: 'query'.	self assert: inlineFragmentTyping name equals: 'inlineFragmentTyping'.	firstSubSelection := inlineFragmentTyping selectionSet selections		first selectionSet.	self assert: firstSubSelection class equals: GQLSelectionSetNode.	self assert: firstSubSelection selections first name equals: 'handle'.	firstFragment := firstSubSelection selections second.	self		assert: firstFragment typeCondition class		equals: GQLSNamedTypeNode.	self assert: firstFragment typeCondition name equals: 'User'.	self		assert: firstFragment selectionSet selections first name		equals: 'friends'.	self		assert:			firstFragment selectionSet selections first selectionSet selections				first name		equals: 'count'.	secondFragment := firstSubSelection selections third.	self		assert: secondFragment typeCondition class		equals: GQLSNamedTypeNode.	self assert: secondFragment typeCondition name equals: 'Page'.	self		assert: secondFragment selectionSet selections first name		equals: 'likers'.	self		assert:			secondFragment selectionSet selections first selectionSet selections				first name		equals: 'count'</body></methods><methods><class-id>GraphQLBeta.GQLRequestGrammarEvaluatorTest</class-id> <category>test-grammar-operation</category><body package="GraphQLBeta-Tests-Grammar" selector="testOperationFail">testOperationFail	| text document |	text := 'mutation { 				likeStory(storyID: 12345) { 			 	story {    				}  			}		}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: PPFailure.	text := 'mutation { 				likeStory(storyID: .12345) {  			}		}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: PPFailure.	text := '{ 				likeStor(storyID: 12345) {  			}		}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: PPFailure</body><body package="GraphQLBeta-Tests-Grammar" selector="testOperationMutation">testOperationMutation	| text document operation firstField subField |	text := 'mutation { 				likeStory(storyID: 12345) { 			 	story {      				likeCount    				}  			}		}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: GQLDocumentNode.	operation := document operations first.	self assert: operation class equals: GQLOperationNode.	self assert: operation type equals: 'mutation'.	firstField := operation selectionSet selections first.	self assert: firstField class equals: GQLNonScalarFieldNode.	self assert: firstField name equals: 'likeStory'.	self assert: firstField arguments first name equals: 'storyID'.	self		assert: firstField arguments first value class		equals: GQLIntNode.	self assert: firstField arguments first value value equals: '12345'.	subField := firstField selectionSet selections first.	self assert: subField name equals: 'story'.	self		assert: subField selectionSet selections first name		equals: 'likeCount'</body></methods><methods><class-id>GraphQLBeta.GQLRequestGrammarEvaluatorTest</class-id> <category>as yet unclassified</category><body package="GraphQLBeta-Tests-Grammar" selector="requestEvaluator">requestEvaluator	^ GQLRequestGrammarEvaluator</body></methods><methods><class-id>GraphQLBeta.GQLRequestGrammarEvaluatorTest</class-id> <category>test-grammar-fragment</category><body package="GraphQLBeta-Tests-Grammar" selector="testFragment">testFragment	| document withFragment fragment fieldSpread field |	document := self		parseRequest:			'query withFragment {      			...friendFields			}			fragment friendFields on User { 				name 				profilePic(size: 50)	}'.	self assert: document class: GQLDocumentNode.	withFragment := document operations first.	self assert: withFragment class: GQLOperationNode.	self assert: withFragment type: 'query'.	self assert: withFragment name: 'withFragment'.	fieldSpread := withFragment selectionSet selections first.	self assert: fieldSpread class: GQLFragmentSpreadNode.	self assert: fieldSpread name: 'friendFields'.	fragment := document fragments first.	self assert: fragment class: GQLFragmentNode.	self assert: fragment name: 'friendFields'.	self assert: fragment typeCondition class: GQLSNamedTypeNode.	self assert: fragment typeCondition name: 'User'.	self assertSelections: fragment withNames: #('name' 'profilePic').	field := fragment selectionSet selections second.	self assertArguments: field withNames: #('size').	self assertArguments: field ofClasses: #('GQLIntNode').	self assertArguments: field withValues: #('50')</body><body package="GraphQLBeta-Tests-Grammar" selector="testFragmentIncorrect">testFragmentIncorrect	| document |	document := self		parseRequest:			'query withFragment {      			...friendFields			}			fragment on User { 				name 				profilePic(size: 50)	}'.	self assert: document class: PPFailure.	document := self		parseRequest:			'query withFragment {      			...friendFields			}			fragment friendFields { 				name 				profilePic(size: 50)	}'.	self assert: document class: PPFailure.	document := self		parseRequest:			'query withFragment {      			...friendFields			}			fragment friendFields on User {	}'.	self assert: document class: PPFailure</body><body package="GraphQLBeta-Tests-Grammar" selector="testFragmentWithDirectives">testFragmentWithDirectives	| text document withFragment fragment |	text := 'query withFragment {      			...friends			}			fragment friends on User @directiveBehavior { 				id	}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: GQLDocumentNode.	withFragment := document operations first.	self assert: withFragment class equals: GQLOperationNode.	self assert: withFragment type equals: 'query'.	self assert: withFragment name equals: 'withFragment'.	self		assert: withFragment selectionSet selections first class		equals: GQLFragmentSpreadNode.	self		assert: withFragment selectionSet selections first name		equals: 'friends'.	fragment := document fragments first.	self assert: fragment class equals: GQLFragmentNode.	self assert: fragment name equals: 'friends'.	self assert: fragment typeCondition class equals: GQLSNamedTypeNode.	self assert: fragment typeCondition name equals: 'User'.	self		assert: fragment directives first name		equals: 'directiveBehavior'.	self assert: fragment selectionSet selections first name equals: 'id'</body></methods><methods><class-id>GraphQLBeta.GQLRequestGrammarEvaluatorTest</class-id> <category>test-grammar-comment</category><body package="GraphQLBeta-Tests-Grammar" selector="testComment">testComment	| document node |	document := self		parseRequest:			'{  		#field hello		helloAt: hello #returns a String	}'.	self assert: document class: GQLDocumentNode.	node := document operations first selections first.	self assert: node alias = 'helloAt'.	self		assertComments: node comments		equals: #('#field hello' '#returns a String').	document := self		parseRequest:			'{		#field hello		hello #skip directive 		@skip(if : true)	}'.	self assert: document class: GQLDocumentNode.	node := document operations first selections first.	self assert: node class: GQLScalarFieldNode.	self assertComments: node comments equals: #('#field hello').	document := self		parseRequest:			'{		hello #include directive 		@include(if : true)	}'.	self assert: document class: GQLDocumentNode.	node := document operations first selections first.	self assert: node comments isEmpty.	document := self		parseRequest:			'{		#field helloTo		helloTo(name: "Alex") #returns a String	}'.	self assert: document class: GQLDocumentNode.	node := document operations first selections first.	self		assertComments: node comments		equals: #('#field helloTo' '#returns a String').	document := self		parseRequest:			'		mutation #comment of mutation		pointCreation($x : #of type int		Int) {		createPoint(x: $x, y: 2){			x y		}		}'.	self assert: document class: GQLDocumentNode.	node := document operations first comments isEmpty.	document := self		parseRequest:			'{		classification(gender: #enum type		ACTION)	}'.	self assert: document class: GQLDocumentNode.	node := document operations first.	self assert: node comments isEmpty</body><body package="GraphQLBeta-Tests-Grammar" selector="testCommentInVariables">testCommentInVariables	| document |	document := self		parseRequest:			'{		{"name": #comment incorrect		"Mary"}	}'.	self assert: document class: PPFailure</body></methods><methods><class-id>GraphQLBeta.GQLSNamedTypeNode</class-id> <category>as yet unclassified</category><body package="GraphQLBeta-NodesSchema" selector="ofType">ofType	^ nil</body><body package="GraphQLBeta-NodesSchema" selector="verifyAndInclude:with:">verifyAndInclude: otherNamedType with: resolvers	^ self subclassResponsibility</body></methods><methods><class-id>GraphQLBeta.GQLSNamedTypeNode</class-id> <category>accessing</category><body package="GraphQLBeta-NodesSchema" selector="nameOfClass:">nameOfClass: aName	self subclassResponsibility</body><body package="GraphQLBeta-NodesSchema" selector="rawType:">rawType: schema	^ schema getType: name</body></methods><methods><class-id>GraphQLBeta.GQLSNamedTypeNode</class-id> <category>testing</category><body package="GraphQLBeta-NodesSchema" selector="basicCoerce:on:">basicCoerce: value on: schema	| type |	type := schema getType: self name.	type = self		ifTrue: [ self error: 'Override canCoerce in this class' ].	^ type canCoerce: value on: schema</body><body package="GraphQLBeta-NodesSchema" selector="isObjectInputType:">isObjectInputType: schema	| type |	type := schema getType: self name.	^ type class = GQLSInputObjectTypeNode</body></methods><methods><class-id>GraphQLBeta.GQLSNamedTypeNode</class-id> <category>printing</category><body package="GraphQLBeta-NodesSchema" selector="printOn:">printOn: stream	stream nextPutAll: name</body></methods><methods><class-id>GraphQLBeta.GQLSNamedTypeNode</class-id> <category>coercion</category><body package="GraphQLBeta-NodesSchema" selector="coerceValue:on:">coerceValue: value on: schema	| type |	schema ifNil: [ ^ super coerceValue: value on: schema ].	type := schema getType: self name.	type = self		ifTrue: [ ^ super coerceValue: value on: schema ].	^ type coerceValue: value on: schema</body></methods><methods><class-id>GraphQLBeta.GQLSScalarTypeNode</class-id> <category>testing</category><body package="GraphQLBeta-NodesSchema" selector="isInputType">isInputType	"Return if is a input type"	^ true</body><body package="GraphQLBeta-NodesSchema" selector="isScalarType">isScalarType	"Return if is a scalar type"	^ true</body></methods><methods><class-id>GraphQLBeta.GQLSScalarTypeNode</class-id> <category>accessing</category><body package="GraphQLBeta-NodesSchema" selector="kind">kind	^ 'SCALAR'</body></methods><methods><class-id>GraphQLBeta.GQLSScalarTypeNode</class-id> <category>printing</category><body package="GraphQLBeta-NodesSchema" selector="printFullOn:">printFullOn: stream	stream		nextPutAll: 'scalar ';		nextPutAll: self name</body></methods><methods><class-id>GraphQLBeta.GQLSStringTypeNode</class-id> <category>initialization</category><body package="GraphQLBeta-NodesSchema" selector="initialize">initialize	super initialize.	name := 'String'</body></methods><methods><class-id>GraphQLBeta.GQLSStringTypeNode</class-id> <category>testing</category><body package="GraphQLBeta-NodesSchema" selector="basicCoerce:on:">basicCoerce: value on: schema	^ value class = GQLStringNode</body></methods><methods><class-id>GraphQLBeta.GQLSInputObjectTypeNode</class-id> <category>testing</category><body package="GraphQLBeta-NodesSchema" selector="basicCoerce:on:">basicCoerce: value on: schema	^ value class = GQLObjectNode</body><body package="GraphQLBeta-NodesSchema" selector="isInputType">isInputType	"Return if if a input type"	^ true</body><body package="GraphQLBeta-NodesSchema" selector="isValidateClass">isValidateClass	"Respondes if a type needs to be searched on the image of Pharo"	^ true</body></methods><methods><class-id>GraphQLBeta.GQLSInputObjectTypeNode</class-id> <category>initialization</category><body package="GraphQLBeta-NodesSchema" selector="initialize">initialize	super initialize.	fieldSet := Dictionary new</body></methods><methods><class-id>GraphQLBeta.GQLSInputObjectTypeNode</class-id> <category>as yet unclassified</category><body package="GraphQLBeta-NodesSchema" selector="inputFields">inputFields	^ self fields</body><body package="GraphQLBeta-NodesSchema" selector="verifyAndInclude:with:">verifyAndInclude: otherNamedType with: resolvers	(otherNamedType class = self class		and: [ (fieldSet keys includesAny: otherNamedType fields keys) not ])		ifTrue: [ fieldSet addAll: otherNamedType fields ]		ifFalse: [ ^ GQLValidationException new				node: otherNamedType;				messageText:					'The namedType is not InputObject type or its fields already have been defined';				raise ]</body></methods><methods><class-id>GraphQLBeta.GQLSInputObjectTypeNode</class-id> <category>accessing</category><body package="GraphQLBeta-NodesSchema" selector="fields">fields	^ fieldSet</body><body package="GraphQLBeta-NodesSchema" selector="getField:">getField: aFieldName	"Return the field given his name"	| res |	res := (fieldSet includesKey: aFieldName)		ifTrue: [ fieldSet at: aFieldName ]		ifFalse: [ nil ].	^ res</body><body package="GraphQLBeta-NodesSchema" selector="kind">kind	^ 'INPUT_OBJECT'</body><body package="GraphQLBeta-NodesSchema" selector="nameOfClass:">nameOfClass: aName	(aName endsWith: 'Input')		ifTrue: [ ^ aName copyFrom: 1 to: aName size - 5 ]		ifFalse: [ ^ GQLException new				node: self;				messageText: 'Error with variables';				raise ]</body></methods><methods><class-id>GraphQLBeta.GQLSInputObjectTypeNode</class-id> <category>printing</category><body package="GraphQLBeta-NodesSchema" selector="printFullOn:">printFullOn: stream	stream		nextPutAll: 'input ';		nextPutAll: self name.	stream		nextPutAll: '{';		cr.	self fields		do: [ :field | 			stream tab.			field printFullOn: stream ]		separatedBy: [ stream cr ].	stream		cr;		nextPutAll: '}'</body></methods><methods><class-id>GraphQLBeta.GQLSInputObjectTypeNode</class-id> <category>coercion</category><body package="GraphQLBeta-NodesSchema" selector="coerceValue:on:">coerceValue: value on: schema	value isVariableNode		ifTrue: [ ^ value ].	value class = GQLNullNode		ifTrue: [ ^ value ].	value class = GQLObjectNode		ifFalse: [ self error: 'invalid input' ].	^ value</body></methods><methods><class-id>GraphQLBeta.GQLSInputObjectTypeNode</class-id> <category>adding</category><body package="GraphQLBeta-NodesSchema" selector="addFields:">addFields: aArray	"Given a collection puts the values on a dictionary for improve the search"	aArray do: [ :field | fieldSet at: field name put: field ]</body></methods><methods><class-id>GraphQLBeta.GQLSBooleanTypeNode</class-id> <category>initialization</category><body package="GraphQLBeta-NodesSchema" selector="initialize">initialize	super initialize.	name := 'Boolean'</body></methods><methods><class-id>GraphQLBeta.GQLSBooleanTypeNode</class-id> <category>testing</category><body package="GraphQLBeta-NodesSchema" selector="basicCoerce:on:">basicCoerce: value on: schema	^ value class = GQLBooleanNode</body></methods><methods><class-id>GraphQLBeta.GQLSInterfaceTypeNode</class-id> <category>initialization</category><body package="GraphQLBeta-NodesSchema" selector="initialize">initialize	super initialize.	fields := Dictionary new</body></methods><methods><class-id>GraphQLBeta.GQLSInterfaceTypeNode</class-id> <category>as yet unclassified</category><body package="GraphQLBeta-NodesSchema" selector="fieldsIncludeDeprecated:">fieldsIncludeDeprecated: aBoolean	^ self fields</body><body package="GraphQLBeta-NodesSchema" selector="possibleTypes">possibleTypes	^ self implementors</body><body package="GraphQLBeta-NodesSchema" selector="verifyAndInclude:with:">verifyAndInclude: otherNamedType with: resolvers	(otherNamedType class = self class		and: [ (fields keys includesAny: otherNamedType fields keys) not ])		ifTrue: [ fields addAll: otherNamedType fields ]		ifFalse: [ ^ GQLValidationException new				node: otherNamedType;				messageText:					'The namedType is not Interface type or its fields already have been defined';				raise ]</body></methods><methods><class-id>GraphQLBeta.GQLSInterfaceTypeNode</class-id> <category>accessing</category><body package="GraphQLBeta-NodesSchema" selector="fields">fields	"Return the fields"	^ fields</body><body package="GraphQLBeta-NodesSchema" selector="getField:">getField: aFieldName	"Return the field given his name"	| res |	res := (fields includesKey: aFieldName)		ifTrue: [ fields at: aFieldName ]		ifFalse: [ nil ].	^ res</body><body package="GraphQLBeta-NodesSchema" selector="implementors">implementors	^ implementors</body><body package="GraphQLBeta-NodesSchema" selector="implementors:">implementors: anArray	implementors := anArray</body><body package="GraphQLBeta-NodesSchema" selector="kind">kind	^ 'INTERFACE'</body></methods><methods><class-id>GraphQLBeta.GQLSInterfaceTypeNode</class-id> <category>testing</category><body package="GraphQLBeta-NodesSchema" selector="isInterfaceType">isInterfaceType	"Return if is a interface type"	^ true</body></methods><methods><class-id>GraphQLBeta.GQLSInterfaceTypeNode</class-id> <category>printing</category><body package="GraphQLBeta-NodesSchema" selector="printFullOn:">printFullOn: stream	stream		nextPutAll: 'interface ';		nextPutAll: self name.	stream		nextPutAll: '{';		cr.	self fields		do: [ :field | 			stream tab.			field printFullOn: stream ]		separatedBy: [ stream cr ].	stream		cr;		nextPutAll: '}'</body></methods><methods><class-id>GraphQLBeta.GQLSInterfaceTypeNode</class-id> <category>adding</category><body package="GraphQLBeta-NodesSchema" selector="addFields:">addFields: aArray	"Puts the fields of the array on a dictionary"	aArray do: [ :field | fields at: field name put: field ]</body></methods><methods><class-id>GraphQLBeta.GQLSUnionTypeNode</class-id> <category>initialization</category><body package="GraphQLBeta-NodesSchema" selector="initialize">initialize	super initialize.	possibleTypes := OrderedCollection new</body></methods><methods><class-id>GraphQLBeta.GQLSUnionTypeNode</class-id> <category>as yet unclassified</category><body package="GraphQLBeta-NodesSchema" selector="verifyAndInclude:with:">verifyAndInclude: otherNamedType with: resolvers	(otherNamedType class = self class		and: [ (namedTypes includesAny: otherNamedType namedTypes) not ])		ifTrue: [ namedTypes := (OrderedCollection new				addAll: namedTypes;				addAll: otherNamedType namedTypes;				yourself) asArray ]		ifFalse: [ ^ GQLValidationException new				node: otherNamedType;				messageText:					'The namedType is not Union type or its values already have been defined';				raise ]</body></methods><methods><class-id>GraphQLBeta.GQLSUnionTypeNode</class-id> <category>accessing</category><body package="GraphQLBeta-NodesSchema" selector="addPossibleType:">addPossibleType: anObject	possibleTypes add: anObject</body><body package="GraphQLBeta-NodesSchema" selector="getField:">getField: fieldName	^ fieldName = '__typename'		ifTrue: [ GQLSFieldNode new				name: '__typename';				type: GQLSStringTypeNode new;				fullName;				yourself ]		ifFalse: [  ]</body><body package="GraphQLBeta-NodesSchema" selector="kind">kind	^ 'UNION'</body><body package="GraphQLBeta-NodesSchema" selector="namedTypes">namedTypes	"Return the named types"	^ namedTypes</body><body package="GraphQLBeta-NodesSchema" selector="possibleTypes">possibleTypes	^ possibleTypes</body></methods><methods><class-id>GraphQLBeta.GQLSUnionTypeNode</class-id> <category>adding</category><body package="GraphQLBeta-NodesSchema" selector="addTypes:">addTypes: nameValues	"Given a collection puts the values on a dictionary for improve the search"	namedTypes := nameValues</body></methods><methods><class-id>GraphQLBeta.GQLSUnionTypeNode</class-id> <category>printing</category><body package="GraphQLBeta-NodesSchema" selector="printFullOn:">printFullOn: stream	stream		nextPutAll: 'union ';		nextPutAll: self name;		nextPutAll: ' = '.	self namedTypes		do: [ :n | stream nextPutAll: n ]		separatedBy: [ stream nextPutAll: ' | ' ]</body></methods><methods><class-id>GraphQLBeta.GQLSUnionTypeNode</class-id> <category>testing</category><body package="GraphQLBeta-NodesSchema" selector="isUnionType">isUnionType	"Return if is a union type"	^ true</body></methods><methods><class-id>GraphQLBeta.GQLSIDTypeNode</class-id> <category>initialization</category><body package="GraphQLBeta-NodesSchema" selector="initialize">initialize	super initialize.	name := 'ID'</body></methods><methods><class-id>GraphQLBeta.GQLSIDTypeNode</class-id> <category>testing</category><body package="GraphQLBeta-NodesSchema" selector="basicCoerce:on:">basicCoerce: value on: schema	^ value class = GQLStringNode or: [ value class = GQLIntNode ]</body></methods><methods><class-id>GraphQLBeta.GQLSObjectTypeNode</class-id> <category>testing</category><body package="GraphQLBeta-NodesSchema" selector="implementsFields:">implementsFields: aCollection	"Check if has all the fields on interface with the same argumentsHERE MUST CHECK THE TYPE OF FIELD AND ARGUMENT ACCORD: 3.1.2.3 SPEC GRAPHQL"	^ aCollection		allSatisfy: [ :field | 			(self fields includesKey: field name)				and: [ (self getField: field name) arguments = field arguments ] ]</body><body package="GraphQLBeta-NodesSchema" selector="isObjectType">isObjectType	"Return if is a object type"	^ true</body><body package="GraphQLBeta-NodesSchema" selector="isValidateClass">isValidateClass	"Respondes if a type needs to be searched on the image of Pharo"	^ true</body></methods><methods><class-id>GraphQLBeta.GQLSObjectTypeNode</class-id> <category>initialization</category><body package="GraphQLBeta-NodesSchema" selector="initialize">initialize	super initialize.	fieldSet := Dictionary new.	interfaces := Set new</body></methods><methods><class-id>GraphQLBeta.GQLSObjectTypeNode</class-id> <category>as yet unclassified</category><body package="GraphQLBeta-NodesSchema" selector="fieldsIncludeDeprecated:">fieldsIncludeDeprecated: aBoolean	^ self fields values</body><body package="GraphQLBeta-NodesSchema" selector="fieldsRelated:to:">fieldsRelated: fields to: resolvers		(name asClass selectors		includesAll: (fields collect: [ :field | field fullName asSymbol ]))		ifFalse: [ | dictFieldWithResolver |			dictFieldWithResolver := Dictionary new.			resolvers				do: [ :resolver | 					fields						select:							[ :fieldNode | resolver selectors includes: fieldNode fullName asSymbol ]						thenDo: [ :fieldNode | 							dictFieldWithResolver								at: fieldNode fullName asSymbol								ifAbsentPut: [ resolver ] ] ].			dictFieldWithResolver size = fields size				ifTrue: [ ^ dictFieldWithResolver ]				ifFalse: [ ^ GQLValidationException new						node: self;						messageText: 'The resolvers dont find some fields defined in the schema';						raise ] ]</body><body package="GraphQLBeta-NodesSchema" selector="verifyAndInclude:with:">verifyAndInclude: otherNamedType with: resolvers	((otherNamedType class = self class		and: [ (fieldSet keys includesAny: otherNamedType fields keys) not ])		and: [ (interfaces includesAny: otherNamedType interfaces) not ])		ifTrue: [ fieldSet addAll: otherNamedType fields.			interfaces := (interfaces asOrderedCollection				addAll: otherNamedType interfaces;				yourself) asArray.			^ self fieldsRelated: otherNamedType fields values to: resolvers ]		ifFalse: [ ^ GQLValidationException new				node: otherNamedType;				messageText:					'The namedType is not Object type or its fields already have been defined';				raise ]</body></methods><methods><class-id>GraphQLBeta.GQLSObjectTypeNode</class-id> <category>accessing</category><body package="GraphQLBeta-NodesSchema" selector="fields">fields	"Return the fields"	^ fieldSet</body><body package="GraphQLBeta-NodesSchema" selector="getField:">getField: aFieldName	"Return the field given his name"	^ fieldSet at: aFieldName ifAbsent: [ nil ]</body><body package="GraphQLBeta-NodesSchema" selector="getFieldType:">getFieldType: aFieldName	"Return the type of a field"	| res |	res := (fieldSet includesKey: aFieldName)		ifTrue: [ (fieldSet at: aFieldName) type ]		ifFalse: [ nil ].	^ res</body><body package="GraphQLBeta-NodesSchema" selector="implements:">implements: aArray	"Set the interfaces that implements"	aArray		ifNotNil: [ interfaces := aArray collect: [ :item | item value ] ]</body><body package="GraphQLBeta-NodesSchema" selector="interfaces">interfaces	"Return the interfaces"	^ interfaces</body><body package="GraphQLBeta-NodesSchema" selector="interfaces:">interfaces: anObject	interfaces := anObject.	^ interfaces</body><body package="GraphQLBeta-NodesSchema" selector="kind">kind	^ 'OBJECT'</body><body package="GraphQLBeta-NodesSchema" selector="nameOfClass:">nameOfClass: aName	^ aName</body></methods><methods><class-id>GraphQLBeta.GQLSObjectTypeNode</class-id> <category>printing</category><body package="GraphQLBeta-NodesSchema" selector="printFullOn:">printFullOn: stream	stream		nextPutAll: 'type ';		nextPutAll: self name.	self interfaces		ifNotEmpty: [ stream nextPutAll: ' implements '.			self interfaces				do: [ :i | 					(i isKindOf: GQLSInterfaceTypeNode)						ifTrue: [ stream nextPutAll: i name ]						ifFalse: [ stream nextPutAll: i ] ]				separatedBy: [ ":i |" stream nextPutAll: ' &amp; ' ] ].	stream		nextPutAll: '{';		cr.	self fields		do: [ :field | 			stream tab.			field printFullOn: stream ]		separatedBy: [ stream cr ].	stream		cr;		nextPutAll: '}'</body></methods><methods><class-id>GraphQLBeta.GQLSObjectTypeNode</class-id> <category>adding</category><body package="GraphQLBeta-NodesSchema" selector="addFields:">addFields: aArray	"Given a collection puts the values on a dictionary for improve the search"	aArray do: [ :field | fieldSet at: field name put: field ]</body></methods><methods><class-id>GraphQLBeta.GQLSFloatTypeNode</class-id> <category>initialization</category><body package="GraphQLBeta-NodesSchema" selector="initialize">initialize	super initialize.	name := 'Float'</body></methods><methods><class-id>GraphQLBeta.GQLSFloatTypeNode</class-id> <category>coercion</category><body package="GraphQLBeta-NodesSchema" selector="coerceValue:on:">coerceValue: value on: schema	value isVariableNode		ifTrue: [ ^ value ].	value class = GQLNullNode		ifTrue: [ ^ value ].	(self canCoerce: value on: schema)		ifFalse: [ self error: 'invalid input' ].	value class = GQLIntNode		ifTrue: [ ^ GQLFloatNode new				value: value value , '.0';				position: value position ].	^ value</body></methods><methods><class-id>GraphQLBeta.GQLSFloatTypeNode</class-id> <category>testing</category><body package="GraphQLBeta-NodesSchema" selector="basicCoerce:on:">basicCoerce: value on: schema	^ value class = GQLFloatNode or: [ value class = GQLIntNode ]</body></methods><methods><class-id>GraphQLBeta.GQLSEnumTypeNode</class-id> <category>as yet unclassified</category><body package="GraphQLBeta-NodesSchema" selector="enumValuesIncludeDeprecated:">enumValuesIncludeDeprecated: aBoolean	^ enumValues</body><body package="GraphQLBeta-NodesSchema" selector="verifyAndInclude:with:">verifyAndInclude: otherNamedType with: resolvers	(otherNamedType class = self class		and: [ (enumValues includesAny: otherNamedType values) not ])		ifTrue: [ enumValues := (OrderedCollection new				addAll: enumValues;				addAll: otherNamedType values;				yourself) asArray ]		ifFalse: [ ^ GQLValidationException new				node: otherNamedType;				messageText:					'The namedType is not Enum type or its values already have been defined';				raise ]</body></methods><methods><class-id>GraphQLBeta.GQLSEnumTypeNode</class-id> <category>testing</category><body package="GraphQLBeta-NodesSchema" selector="basicCoerce:on:">basicCoerce: value on: schema	^ value class = GQLEnumNode		and: [ self stringValues includes: value value ]</body><body package="GraphQLBeta-NodesSchema" selector="isInputType">isInputType	"Return if is input type"	^ true</body><body package="GraphQLBeta-NodesSchema" selector="isScalarType">isScalarType	^ true</body></methods><methods><class-id>GraphQLBeta.GQLSEnumTypeNode</class-id> <category>accessing</category><body package="GraphQLBeta-NodesSchema" selector="kind">kind	^ 'ENUM'</body><body package="GraphQLBeta-NodesSchema" selector="nameOfClass:">nameOfClass: aName	^ self class name</body><body package="GraphQLBeta-NodesSchema" selector="stringValues">stringValues	^ enumValues collect: [ :val | val value ]</body><body package="GraphQLBeta-NodesSchema" selector="values">values	"Return the string values"	^ enumValues</body></methods><methods><class-id>GraphQLBeta.GQLSEnumTypeNode</class-id> <category>printing</category><body package="GraphQLBeta-NodesSchema" selector="printFullOn:">printFullOn: stream	stream		nextPutAll: 'enum ';		nextPutAll: self name;		nextPutAll: '{ '.	self stringValues		do: [ :v | stream nextPutAll: v ]		separatedBy: [ stream nextPutAll: ', ' ].	stream nextPutAll: ' }'</body></methods><methods><class-id>GraphQLBeta.GQLSEnumTypeNode</class-id> <category>adding</category><body package="GraphQLBeta-NodesSchema" selector="addValues:">addValues: values	"Set the string of values "	enumValues := values</body></methods><methods><class-id>GraphQLBeta.GQLOperationsVisitor</class-id> <category>visiting</category><body package="GraphQLBeta-Visitors" selector="visitDocumentNode:">visitDocumentNode: node	| ocurrences |	ocurrences := node operations		groupedBy: [ :op | 			op class = GQLOperationNode				ifTrue: [ op name ]				ifFalse: [ '' ] ].	((ocurrences includesKey: '') and: [ ocurrences size &gt; 1 ])		ifTrue: [ self				addErrorMessage:					'GraphQL allows a shortâhand form for defining query operations when only that one operation exists in the document.'				nodes: (ocurrences at: '') ].	ocurrences		keysAndValuesDo: [ :k :list | 			(list size &gt; 1 and: [ k ~= '' ])				ifTrue: [ self						addErrorMessage: 'Each named operation definition must be unique: "' , k , '"'						nodes: list ] ]</body></methods><methods><class-id>GraphQLBeta.GQLValidationException</class-id> <category>message</category><body package="GraphQLBeta-Core" selector="messageClassText">messageClassText	"Message for class that doesn't exist on the image of Smalltalk"	| writer |	writer := WriteStream on: String new.	writer		nextPutAll: 'No exist the class ';		nextPutAll: node name.	self messageText: writer contents</body><body package="GraphQLBeta-Core" selector="messageMethodText:">messageMethodText: aClass	"Message for the method that doesn't exist on the Class"	| writer |	writer := WriteStream on: String new.	writer		nextPutAll: 'No exist the method ';		nextPutAll: node fullName;		nextPutAll: ' on the class ';		nextPutAll: aClass name.	self messageText: writer contents</body></methods><methods><class-id>GraphQLBeta.GQLArgumentsTest</class-id> <category>tests</category><body package="GraphQLBeta-Tests-Validation" selector="testArgumentCompatibleValues01">testArgumentCompatibleValues01	"Literal values must be compatible with the type defined by the argument they are being provided to, as per the coercion rules defined in the Type System"	"This document is valid"	| result |	result := self		jsonRequest:			'{	arguments { 		... goodBooleanArg		... coercedIntIntoFloatArg	} }fragment goodBooleanArg on GQLArguments {  booleanArgField(booleanArg: true)}fragment coercedIntIntoFloatArg on GQLArguments {  floatArgField(floatArg: 1)}'.	self		assertJSONEquals: result		and:			'{	"data": { 		"arguments" : {			"booleanArgField" : false,			"floatArgField" : 1		}	}}'</body><body package="GraphQLBeta-Tests-Validation" selector="testArgumentCompatibleValues02">testArgumentCompatibleValues02	"Literal values must be compatible with the type defined by the argument they are being provided to, as per the coercion rules defined in the Type System"	"This document is invalid"	| result |	result := self		jsonRequest:			'{	arguments { 		... stringIntoInt	} }fragment stringIntoInt on GQLArguments {  intArgField(intArg: "3")}'.	self		assert: result		equals:			'{	"errors" : [		{			"message" : "Argument \"intArg\" has invalid value \"3\". Expected type \"Int\".",			"locations" : [				{					"line" : 8,					"column" : 23				}			]		}	]}'</body><body package="GraphQLBeta-Tests-Validation" selector="testArgumentCompatibleValues03">testArgumentCompatibleValues03	"Literal values must be compatible with the type defined by the argument they are being provided to, as per the coercion rules defined in the Type System"	"This document is invalid"	| result |	result := self		jsonRequest:			'{	arguments { 		... stringIntoBool	} }fragment stringIntoBool on GQLArguments {  booleanArgField(booleanArg: "true")}'.	self		assert: result		equals:			'{	"errors" : [		{			"message" : "Argument \"booleanArg\" has invalid value \"true\". Expected type \"Boolean\".",			"locations" : [				{					"line" : 8,					"column" : 31				}			]		}	]}'</body><body package="GraphQLBeta-Tests-Validation" selector="testArgumentCompatibleValues04">testArgumentCompatibleValues04	"Literal values must be compatible with the type defined by the argument they are being provided to, as per the coercion rules defined in the Type System"	"This document is invalid"	| result |	result := self		jsonRequest:			'{	arguments { 		... numberIntoString	} }fragment numberIntoString on GQLArguments {  singleString(string: 3.1416)}'.	self		assert: result		equals:			'{	"errors" : [		{			"message" : "Argument \"string\" has invalid value 3.1416. Expected type \"String\".",			"locations" : [				{					"line" : 8,					"column" : 24				}			]		}	]}'</body><body package="GraphQLBeta-Tests-Validation" selector="testArgumentCompatibleValues05">testArgumentCompatibleValues05	"Literal values must be compatible with the type defined by the argument they are being provided to, as per the coercion rules defined in the Type System"	"This document is invalid"	| result |	result := self		jsonRequest:			'{	arguments { 		... booleanToId	} }fragment booleanToId on GQLArguments {  singleID(id: true)}'.	self		assert: result		equals:			'{	"errors" : [		{			"message" : "Argument \"id\" has invalid value true. Expected type \"ID\".",			"locations" : [				{					"line" : 8,					"column" : 16				}			]		}	]}'</body><body package="GraphQLBeta-Tests-Validation" selector="testArgumentCompatibleValues06">testArgumentCompatibleValues06	"Literal values must be compatible with the type defined by the argument they are being provided to, as per the coercion rules defined in the Type System"	"This document is invalid"	| result |	result := self		jsonRequest:			'{	arguments { 		... floatToId	} }fragment floatToId on GQLArguments {  singleID(id: 3.1416)}'.	self		assert: result		equals:			'{	"errors" : [		{			"message" : "Argument \"id\" has invalid value 3.1416. Expected type \"ID\".",			"locations" : [				{					"line" : 8,					"column" : 16				}			]		}	]}'</body><body package="GraphQLBeta-Tests-Validation" selector="testArgumentCompatibleValues07">testArgumentCompatibleValues07	"Literal values must be compatible with the type defined by the argument they are being provided to, as per the coercion rules defined in the Type System"	"This document is invalid"	| result |	result := self		jsonRequest:			'{	dog { 		... nonExistingEnumValue	} }fragment nonExistingEnumValue on GQLDog {	doesKnowCommand(dogCommand: RUN_FAST)}'.	self		assert: result		equals:			'{	"errors" : [		{			"message" : "Argument \"dogCommand\" has invalid value RUN_FAST. Expected type \"DogCommand!\".",			"locations" : [				{					"line" : 8,					"column" : 30				}			]		}	]}'</body><body package="GraphQLBeta-Tests-Validation" selector="testArgumentNames01">testArgumentNames01	"Every argument provided to a field or directive must be defined in the set of possible arguments of that field or directive."	| result |	"This document is valid"	result := self		jsonRequest:			'{	dog { 		...argOnRequiredArg		...argOnOptional	} }fragment argOnRequiredArg on GQLDog {	doesKnowCommand(dogCommand: SIT)}fragment argOnOptional on GQLDog {	isHousetrained(atOtherHomes: true) @include(if: true)}'.	self		assertJSONEquals: result		and:			'{	"data": { 		"dog" : {			"doesKnowCommand" : true,			"isHousetrained" : false		}	}}'</body><body package="GraphQLBeta-Tests-Validation" selector="testArgumentNames02">testArgumentNames02	"Every argument provided to a field or directive must be defined in the set of possible arguments of that field or directive."	| result |	"This document is invalid"	result := self		jsonRequest:			'{	dog { 		...invalidArgName	} }fragment invalidArgName on GQLDog {	doesKnowCommand(command: CLEAN_UP_HOUSE)}'.	self		assert: result		equals:			'{	"errors" : [		{			"message" : "Field \"doesKnowCommand\" argument \"dogCommand\" of type \"DogCommand!\" is required but not provided.",			"locations" : [				{					"line" : 8,					"column" : 2				}			]		},		{			"message" : "Unknown argument \"command\" on field \"doesKnowCommand\" on type \"GQLDog\".",			"locations" : [				{					"line" : 8,					"column" : 18				}			]		}	]}'</body><body package="GraphQLBeta-Tests-Validation" selector="testArgumentNames03">testArgumentNames03	"Every argument provided to a field or directive must be defined in the set of possible arguments of that field or directive."	"This document is invalid"	| result |	result := self		jsonRequest:			'{	dog { 		...invalidArgName	} }fragment invalidArgName on GQLDog {  isHousetrained(atOtherHomes: true) @include(unless: false)}'.	self		assert: result		equals:			'{	"errors" : [		{			"message" : "Directive \"@include\" argument \"if\" of type \"Boolean!\" is required but not provided.",			"locations" : [				{					"line" : 8,					"column" : 39				}			]		},		{			"message" : "Unknown argument \"unless\" on directive \"@include\".",			"locations" : [				{					"line" : 8,					"column" : 47				}			]		}	]}'</body><body package="GraphQLBeta-Tests-Validation" selector="testArgumentNames04">testArgumentNames04	"Every argument provided to a field or directive must be defined in the set of possible arguments of that field or directive."	| result |	"This document is valid"	result := self		jsonRequest:			'{	arguments { 		...multipleArgsReverseOrder		...multipleArgs	} }fragment multipleArgs on GQLArguments {  multipleReqs(x: 1, y: 2)}fragment multipleArgsReverseOrder on GQLArguments {  multipleReqs(y: 2, x: 1)}'.	self		assert: result		equals:			'{	"data" : {		"arguments" : {			"multipleReqs" : 3		}	}}'</body><body package="GraphQLBeta-Tests-Validation" selector="testArgumentUniqueness01">testArgumentUniqueness01	"Fields and directives treat arguments as a mapping of argument name to value. More than one argument with the same name in an argument set is ambiguous and invalid."	"This document is invalid"	| result |	result := self		jsonRequest:			'{	arguments { 		multipleReqs(x: 1, x: 2)	} }'.	self		assert: result		equals:			'{	"errors" : [		{			"message" : "Field \"multipleReqs\" argument \"y\" of type \"Int!\" is required but not provided.",			"locations" : [				{					"line" : 4,					"column" : 3				}			]		},		{			"message" : "There can be only one argument named \"x\".",			"locations" : [				{					"line" : 4,					"column" : 16				},				{					"line" : 4,					"column" : 22				}			]		}	]}'</body><body package="GraphQLBeta-Tests-Validation" selector="testArgumentUniqueness02">testArgumentUniqueness02	"Fields and directives treat arguments as a mapping of argument name to value. More than one argument with the same name in an argument set is ambiguous and invalid."	"This document is invalid"	| result |	result := self		jsonRequest:			'{	arguments { 		multipleReqs(x: 1, y: 2) @include(if:true, if: false)	} }'.	self		assert: result		equals:			'{	"errors" : [		{			"message" : "There can be only one argument named \"if\".",			"locations" : [				{					"line" : 4,					"column" : 37				},				{					"line" : 4,					"column" : 46				}			]		}	]}'</body><body package="GraphQLBeta-Tests-Validation" selector="testRequiredNonNullArguments01">testRequiredNonNullArguments01	"Arguments can be required. Arguments are required if the type of the argument is nonânull. If it is not nonânull, the argument is optional. When an argument type is nonânull, and is required, the explicit value null may also not be provided."	| result |	"This document is valid"	result := self		jsonRequest:			'{	arguments { 		... goodBooleanArg		... goodNonNullArg	} }fragment goodBooleanArg on GQLArguments {  booleanArgField(booleanArg: true)}fragment goodNonNullArg on GQLArguments {  nonNullBooleanArgField(nonNullBooleanArg: true)}'.	self		assertJSONEquals: result		and:			'{	"data": {		"arguments" : {			"booleanArgField" : false,			"nonNullBooleanArgField" : false		}	}}'</body><body package="GraphQLBeta-Tests-Validation" selector="testRequiredNonNullArguments02">testRequiredNonNullArguments02	"Arguments can be required. Arguments are required if the type of the argument is nonânull. If it is not nonânull, the argument is optional. When an argument type is nonânull, and is required, the explicit value null may also not be provided."	| result |	"This document is valid"	result := self		jsonRequest:			'{	arguments { 		... goodBooleanArgDefault	} }fragment goodBooleanArgDefault on GQLArguments {  booleanArgField}'.	self		assertJSONEquals: result		and:			'{	"data" : { 		"arguments" : {			"booleanArgField" : true		}	}}'</body><body package="GraphQLBeta-Tests-Validation" selector="testRequiredNonNullArguments03">testRequiredNonNullArguments03	"Arguments can be required. Arguments are required if the type of the argument is nonânull. If it is not nonânull, the argument is optional. When an argument type is nonânull, and is required, the explicit value null may also not be provided."	| result |	"This document is invalid"	result := self		jsonRequest:			'{	arguments { 		... missingRequiredArg	} }fragment missingRequiredArg on GQLArguments {  nonNullBooleanArgField @include}'.	self		assert: result		equals:			'{	"errors" : [		{			"message" : "Field \"nonNullBooleanArgField\" argument \"nonNullBooleanArg\" of type \"Boolean!\" is required but not provided.",			"locations" : [				{					"line" : 8,					"column" : 3				}			]		},		{			"message" : "Directive \"@include\" argument \"if\" of type \"Boolean!\" is required but not provided.",			"locations" : [				{					"line" : 8,					"column" : 27				}			]		}	]}'</body></methods><methods><class-id>GraphQLBeta.GQLTestQueryType</class-id> <category>accessing</category><body package="GraphQLBeta-Test-Utils" selector="boxOffice">boxOffice	^ boxOffice</body><body package="GraphQLBeta-Test-Utils" selector="boxOffice:">boxOffice: anObject	boxOffice := anObject</body><body package="GraphQLBeta-Test-Utils" selector="description">description	^ description</body><body package="GraphQLBeta-Test-Utils" selector="description:">description: anObject	description := anObject</body><body package="GraphQLBeta-Test-Utils" selector="featuresFilm:">featuresFilm: aGQLFilm	^ aGQLFilm filmName</body><body package="GraphQLBeta-Test-Utils" selector="filmName:rating:">filmName: aName rating: aRating	^ self films		detect: [ :film | film name = aName &amp; (film rating = aRating) ]</body><body package="GraphQLBeta-Test-Utils" selector="films">films	| data |	data := OrderedCollection new.	data		add:			(GQLTestFilm				new: 1				name: 'harry potter y la piedra filosofal'				rating: 9				gender: 'SCIENCE_FICTION').	data		addLast:			(GQLTestFilm				new: 2				name: 'el seÃ±or de los anillos'				rating: 8				gender: 'SCIENCE_FICTION').	data		addLast:			(GQLTestFilm				new: 3				name: 'terminator'				rating: 5				gender: 'SCIENCE_FICTION').	data		addLast:			(GQLTestFilm				new: 4				name: 'rambo'				rating: 5				gender: 'ACTION').	data		addLast:			(GQLTestFilm				new: 5				name: 'robocop'				rating: 5				gender: 'SCIENCE_FICTION').	data		addLast:			(GQLTestFilm				new: 6				name: 'alien'				rating: 7				gender: 'SCIENCE_FICTION').	data		addLast:			(GQLTestFilm				new: 7				name: 'annie'				rating: 6				gender: 'COMEDY').	^ data</body><body package="GraphQLBeta-Test-Utils" selector="filmsWithRating:">filmsWithRating: aRating	aRating &lt; 0		ifTrue: [ ^ nil ].	^ self films select: [ :film | film rating = aRating ]</body><body package="GraphQLBeta-Test-Utils" selector="gender">gender	^ gender</body><body package="GraphQLBeta-Test-Utils" selector="gender:">gender: anObject	gender := anObject</body><body package="GraphQLBeta-Test-Utils" selector="hello">hello	^ 'hello world'</body><body package="GraphQLBeta-Test-Utils" selector="helloToName:">helloToName: aName	aName ifNil: [ ^ nil ].	^ 'hello ' , aName</body><body package="GraphQLBeta-Test-Utils" selector="isBoxOffice">isBoxOffice	^ isBoxOffice</body><body package="GraphQLBeta-Test-Utils" selector="isBoxOffice:">isBoxOffice: anObject	isBoxOffice := anObject</body><body package="GraphQLBeta-Test-Utils" selector="listOfIntsInts:">listOfIntsInts: list	^ list</body><body package="GraphQLBeta-Test-Utils" selector="pointX:y:">pointX: x y: y	x ifNil: [ ^ nil ].	^ x @ y</body><body package="GraphQLBeta-Test-Utils" selector="rating">rating	^ rating</body><body package="GraphQLBeta-Test-Utils" selector="rating:">rating: anObject	rating := anObject</body><body package="GraphQLBeta-Test-Utils" selector="totalInformationFilm:">totalInformationFilm: aArrayGQLTestQueryType	^ aArrayGQLTestQueryType</body></methods><methods><class-id>GraphQLBeta.GQLTestQueryType</class-id> <category>as yet unclassified</category><body package="GraphQLBeta-Test-Utils" selector="classificationGender:">classificationGender: aClassification	(self classifications includes: aClassification)		ifTrue: [ ^ aClassification ]		ifFalse: [ ^ nil ]</body><body package="GraphQLBeta-Test-Utils" selector="classifications">classifications	^ #('COMEDY' 'SCIENCE_FICTION' 'ACTION')</body><body package="GraphQLBeta-Test-Utils" selector="detailedInformationFilm:">detailedInformationFilm: aGQLTestQueryType	^ GQLTestQueryType new: aGQLTestQueryType</body><body package="GraphQLBeta-Test-Utils" selector="filmsOfGender:">filmsOfGender: aGender	^ self films select: [ :f | f gender = aGender ]</body><body package="GraphQLBeta-Test-Utils" selector="filmsOnGenders:">filmsOnGenders: listGender	^ self films select: [ :f | listGender includes: f gender ]</body><body package="GraphQLBeta-Test-Utils" selector="informationFilm:">informationFilm: aGQLTestFilm	self description: aGQLTestFilm description.	^ GQLTestFilm		new: aGQLTestFilm id		name: aGQLTestFilm description		rating: aGQLTestFilm rating		gender: aGQLTestFilm gender</body><body package="GraphQLBeta-Test-Utils" selector="informationInputFilm:">informationInputFilm: aGQLFilm	^ GQLTestQueryType new		description: aGQLFilm filmName;		gender: 'gender'</body></methods><methods><class-id>GraphQLBeta.GQLTestQueryType class</class-id> <category>accessing</category><body package="GraphQLBeta-Test-Utils" selector="schema">schema	^ '	schema { 		query: GQLTestQueryType		mutation: GQLTestMutationType	}type GQLTestMutationType{	createPoint(x:Int, y:Int) : Point}type Point{	x : Int	y : Int}input GQLTestFilmInput{	id: Int	filmName: String}input GQLTestQueryTypeInput{	description: String	gender: String}type GQLTestQueryType{	hello : String	helloTo(name:String) : String	films : [ GQLTestFilm ]	filmsWith(rating : Int) : [ GQLTestFilm ]	information(film: GQLTestFilmInput) : GQLTestFilm	detailedInformation(film: GQLTestQueryTypeInput): GQLTestQueryType	totalInformation(film: [GQLTestQueryTypeInput]): [ GQLTestQueryType]	informationInput(film: GQLFilmInput): GQLTestQueryType	features(film: GQLFilmInput): String	classification(gender: MovieType): String	filmsOf(gender: MovieType): [ GQLTestFilm ]	filmsOn(genders: [MovieType]): [ GQLTestFilm ]	film(name:String, rating: Int): GQLFilm	listOfInts(ints: [Int]): [ Int ]	gender: String	boxOffice: Float	rating: Int	isBoxOffice: Bool	description: String},type GQLFilm implements NamedEntity &amp; IdentifiedEntity{	filmName : String	id : Int	get(filmName: String): String},type GQLTestFilm{	id : String	name : String	film: GQLFilm	rating : Int	description: String},input GQLFilmInput {	filmName: String	id: Int}interface NamedEntity{	filmName: String}interface IdentifiedEntity{	id: Int}enum MovieType{COMEDY, SCIENCE_FICTION, DRAMA, ACTION}'</body></methods><methods><class-id>GraphQLBeta.GQLTestQueryType class</class-id> <category>instance creation</category><body package="GraphQLBeta-Test-Utils" selector="new:">new: aGQLTestQueryType	| instance |	instance := GQLTestQueryType new.	instance rating: aGQLTestQueryType rating.	instance boxOffice: aGQLTestQueryType boxOffice.	instance gender: aGQLTestQueryType gender.	instance isBoxOffice: aGQLTestQueryType isBoxOffice.	instance description: aGQLTestQueryType description.	instance gender: aGQLTestQueryType gender.	^ instance</body></methods><methods><class-id>GraphQLBeta.GQLTestSchema</class-id> <category>accessing</category><body package="GraphQLBeta-Test-Utils" selector="entity">entity	^ self entities first</body><body package="GraphQLBeta-Test-Utils" selector="firstExtendedSearchObject">firstExtendedSearchObject	| collection |	collection := OrderedCollection new		add: self firstSearchObject;		add:			(GQLCat new				name: 'Misi';				nickname: 'misi');		add:			(GQLDog new				name: 'Firulais';				nickname: 'firulais');		yourself.	^ collection at: (1 to: collection size) first</body><body package="GraphQLBeta-Test-Utils" selector="firstSearchObject">firstSearchObject	| collection |	collection := OrderedCollection new		add: 2.4 @ 4.5;		add: (Rectangle origin: 2.4 @ 5 corner: 4 @ 5);		yourself.	^ collection at: (1 to: collection size) first</body><body package="GraphQLBeta-Test-Utils" selector="name">name	^ self className</body><body package="GraphQLBeta-Test-Utils" selector="totalFilms">totalFilms	^ self films size</body></methods><methods><class-id>GraphQLBeta.GQLTestSchema</class-id> <category>as yet unclassified</category><body package="GraphQLBeta-Test-Utils" selector="cats">cats	^ OrderedCollection new		add:			(GQLCat new				name: 'Misi';				nickname: 'Misifus';				yourself);		add:			(GQLCat new				name: 'Figaro';				nickname: 'Figaro';				yourself);		add:			(GQLCat new				name: 'Minino';				nickname: 'Mini';				yourself);		yourself</body><body package="GraphQLBeta-Test-Utils" selector="filmsSortedByName:">filmsSortedByName: aBoolean	aBoolean		ifTrue: [ ^ self films sort: [ :film1 :film2 | film1 name &lt; film2 name ] ]		ifFalse: [ ^ self films ]</body><body package="GraphQLBeta-Test-Utils" selector="filmsWithNullRating:">filmsWithNullRating: aRating	^ (self films select: [ :film | film rating = aRating ])		add: nil;		yourself</body><body package="GraphQLBeta-Test-Utils" selector="filteredFilmId:">filteredFilmId: aId	^ self films		detect: [ :film | film id = aId asNumber ]		ifNone: [ nil ]</body><body package="GraphQLBeta-Test-Utils" selector="genders">genders	^ (self films collect: [ :film | film gender ]) asSet</body><body package="GraphQLBeta-Test-Utils" selector="informationInputFilm:">informationInputFilm: aGQLTestFilm	| gqlTestQuery |	gqlTestQuery := aGQLTestFilm.	aGQLTestFilm filmName		ifNil: [ gqlTestQuery := self filteredFilmId: aGQLTestFilm id ].	^ GQLTestQueryType new		description: gqlTestQuery filmName;		gender: gqlTestQuery gender</body><body package="GraphQLBeta-Test-Utils" selector="informFilm:id:">informFilm: aGQLFilm id: aInt	| film |	film := self filteredFilmId: aInt.	film isNil		ifTrue: [ film := aGQLFilm ].	^ film</body><body package="GraphQLBeta-Test-Utils" selector="listOfArrays:">listOfArrays: aListOfList	^ aListOfList</body><body package="GraphQLBeta-Test-Utils" selector="nameGendersListGender:">nameGendersListGender: aMovieTypes	aMovieTypes isNotNil		ifTrue: [ (self genders includesAll: aMovieTypes)				ifTrue: [ ^ aMovieTypes ] ].	^ nil</body><body package="GraphQLBeta-Test-Utils" selector="nameOfItem:">nameOfItem: aNamedEntity	^ aNamedEntity name</body><body package="GraphQLBeta-Test-Utils" selector="squareRootOf:">squareRootOf: aFloat	^ aFloat sqrt round: 2</body></methods><methods><class-id>GraphQLBeta.GQLTestSchema</class-id> <category>testing</category><body package="GraphQLBeta-Test-Utils" selector="isEvenNumber:">isEvenNumber: aInt	^ aInt even</body></methods><methods><class-id>GraphQLBeta.GQLTestSchema</class-id> <category>constants</category><body package="GraphQLBeta-Test-Utils" selector="pi">pi	^ Float pi round: 4</body></methods><methods><class-id>GraphQLBeta.GQLTestSchema</class-id> <category>plugin interface</category><body package="GraphQLBeta-Test-Utils" selector="entities">entities	^ OrderedCollection new		add:			(GQLTestFilm new				name: 'Rambo';				rating: 5;				yourself);		add:			(GQLTestFilm new				name: 'Harry Potter';				rating: 7;				yourself);		add:			(GQLCat new				name: 'Misi';				nickname: 'Misifus';				yourself);		add:			(GQLCat new				name: 'Figaro';				nickname: 'Figaro';				yourself);		add:			(GQLCat new				name: 'Minino';				nickname: 'Mini';				yourself);		yourself</body></methods><methods><class-id>GraphQLBeta.GQLTestSchema</class-id> <category>converting</category><body package="GraphQLBeta-Test-Utils" selector="asTextNumber:">asTextNumber: aNumber	^ aNumber asString</body></methods><methods><class-id>GraphQLBeta.GQLListNode</class-id> <category>accessing</category><body package="GraphQLBeta-Nodes" selector="name:using:">name: aName using: schema	value isEmpty		ifTrue: [ ^ aName ]		ifFalse: [ ^ value first name: aName using: schema ]</body></methods><methods><class-id>GraphQLBeta.GQLListNode</class-id> <category>printing</category><body package="GraphQLBeta-Nodes" selector="printOn:">printOn: stream	stream nextPutAll: '['.	self value		do: [ :v | v printOn: stream ]		separatedBy: [ stream nextPutAll: ', ' ].	stream nextPutAll: ']'</body></methods><methods><class-id>GraphQLBeta.GQLListNode</class-id> <category>action</category><body package="GraphQLBeta-Nodes" selector="executeOn:with:using:">executeOn: resolver with: context using: schema	"Execute the input value according to the resolver, the enviroment and the schema"	^ value		collect:			[ :e | e executeOn: resolver with: context using: schema ]</body></methods><methods><class-id>GraphQLBeta.GQLSIntTypeNode</class-id> <category>initialization</category><body package="GraphQLBeta-NodesSchema" selector="initialize">initialize	super initialize.	name := 'Int'</body></methods><methods><class-id>GraphQLBeta.GQLSIntTypeNode</class-id> <category>testing</category><body package="GraphQLBeta-NodesSchema" selector="basicCoerce:on:">basicCoerce: value on: schema	^ value class = GQLIntNode		and:			[ value value asNumber between: self class min and: self class max ]</body></methods><methods><class-id>GraphQLBeta.GQLSIntTypeNode class</class-id> <category>class initialization</category><body package="GraphQLBeta-NodesSchema" selector="initialize">initialize	super initialize.	"https://facebook.github.io/graphql/October2016/#sec-Int"	MAX := 2 raisedTo: 31.	MIN := MAX negated.	MAX := MAX - 1</body></methods><methods><class-id>GraphQLBeta.GQLSIntTypeNode class</class-id> <category>accessing</category><body package="GraphQLBeta-NodesSchema" selector="max">max	^ MAX</body><body package="GraphQLBeta-NodesSchema" selector="min">min	^ MIN</body></methods><methods><class-id>GraphQLBeta.GQLSSchemaNodeTest</class-id> <category>tests</category><body package="GraphQLBeta-Tests-Nodes" selector="testFailValidateObjectTypesInterface">testFailValidateObjectTypesInterface	schema := self		parseSchema:			'						interface GQLTest{							name : String							rating : Int						}						type GQLTestFilm implements GQLTest{             					id : String            					name : String         					}'.	self		should: [ schema validateObjectTypes ]		raise: GQLValidationException</body><body package="GraphQLBeta-Tests-Nodes" selector="testFailValidateObjectTypesInterfaceMultiple">testFailValidateObjectTypesInterfaceMultiple	schema := self		parseSchema:			'						interface NamedEntity{							name : String						}						interface ClassName{							nameMethod: String						}						type GQLTestFilm implements NamedEntity &amp; ClassName{             					id : String            					name : String								className: String         				}'.	self		should: [ schema validateObjectTypes ]		raise: GQLValidationException</body><body package="GraphQLBeta-Tests-Nodes" selector="testFailValidateObjectTypesInterfaceWithArguments">testFailValidateObjectTypesInterfaceWithArguments	schema := self		parseSchema:			'						interface GQLTest{							name(arg1 : Int, arg2 : String) : String						}						type GQLTestFilm implements GQLTest{             					id : String            					name(arg1 : Int) : String         					}'.	self		should: [ schema validateObjectTypes ]		raise: GQLValidationException</body><body package="GraphQLBeta-Tests-Nodes" selector="testFailValidateSchemaDefinition">testFailValidateSchemaDefinition	schema := self		parseSchema:			'						schema{							query: Query							query: GQLTestQueryType						}						type GQLTestFilm {             					id : String            					name: String         				}'.	self		should: [ schema validateSchemaDefinition ]		raise: GQLValidationException.	schema := self		parseSchema:			'						schema { 							query: Query						}						type GQLTestFilm { 							id: String							name: String						}'.	self		should: [ schema validateSchemaDefinition ]		raise: GQLValidationException.	schema := self		parseSchema:			'						schema { 							mutation: GQLTestFilm						}						type GQLTestFilm { 							id: String							name: String						}'.	self		should: [ schema validateSchemaDefinition ]		raise: GQLValidationException.	schema := self		parseSchema:			'						schema { 							query: GQLTestFilm							mutation: GQLTestQueryType						}						type GQLTestFilm { 							id: String							name: String						}'.	self		should: [ schema validateSchemaDefinition ]		raise: GQLValidationException</body><body package="GraphQLBeta-Tests-Nodes" selector="testFullName">testFullName	| objectType field |	schema := self		parseSchema:			'type GQLTestFilm{             id : String            name : String         }'.	objectType := schema getType: 'GQLTestFilm'.	self assert: objectType name: 'GQLTestFilm'.	field := objectType getField: 'name'.	self assert: field fullName: 'name'.	field := objectType getField: 'id'.	self assert: field fullName: 'id'</body><body package="GraphQLBeta-Tests-Nodes" selector="testFullNameWithParameters">testFullNameWithParameters	| objectType field |	schema := self		parseSchema:			'type GQLIBType{             					some (name : String, parameters : String) : String         					}'.	objectType := schema getType: 'GQLIBType'.	self assert: objectType name: 'GQLIBType'.	field := objectType getField: 'some'.	self assert: field fullName: 'someName:parameters:'</body><body package="GraphQLBeta-Tests-Nodes" selector="testInvalidateSimpleClass">testInvalidateSimpleClass	schema := self		parseSchema:			'type GQLTestFilm{             					actors : String         					}'.	self assert: schema validate class: GQLValidationException</body><body package="GraphQLBeta-Tests-Nodes" selector="testInvalidateSimpleClassWithParameters">testInvalidateSimpleClassWithParameters	schema := self		parseSchema:			'type GQLIBType{             					some (name : String) : String         					}'.	self assert: schema validate class: GQLValidationException</body><body package="GraphQLBeta-Tests-Nodes" selector="testNodesParametersPosition">testNodesParametersPosition	| type field parameter |	schema := self		parseSchema:			'type GQLTestFilm{             id : String            name (id : String) : String         }'.	type := schema getType: 'GQLTestFilm'.	field := type getField: 'id'.	self assert: type position: 6.	self assert: field position: 32.	field := type getField: 'name'.	self assert: field position: 56.	parameter := field getArgument: 'id'.	self assert: parameter position: 62</body><body package="GraphQLBeta-Tests-Nodes" selector="testNodesPosition">testNodesPosition	| type field |	schema := self		parseSchema:			'type GQLTestFilm{             					id : String            					name : String         					}'.	type := schema getType: 'GQLTestFilm'.	field := type getField: 'name'.	self assert: type position: 6.	self assert: field position: 66.	field := type getField: 'id'.	self assert: field position: 37</body><body package="GraphQLBeta-Tests-Nodes" selector="testValidateInputObject">testValidateInputObject	schema := self		parseSchema:			'							schema{								query: GQLTestQueryType							}							type GQLTestQueryType{								information(film: GQLTestQueryTypeInput): GQLTestQueryType							}							input GQLTestQueryTypeInput{             					description : String            					gender : String!         					}'.	self assert: schema validate class: GQLSSchemaNode</body><body package="GraphQLBeta-Tests-Nodes" selector="testValidateInterface">testValidateInterface	schema := self		parseSchema:			'							schema{								query: GQLTestFilm							}							interface MyObject{								name : String							}							type GQLTestFilm implements MyObject{             					id : String            					name : String         					}'.	self assert: schema validate class: GQLSSchemaNode</body><body package="GraphQLBeta-Tests-Nodes" selector="testValidateObjectTypesInterface">testValidateObjectTypesInterface	schema := self		parseSchema:			'						interface GQLTest{							name : String						}						type GQLTestFilm implements GQLTest{             					id : String            					name : String         					}'.	self assert: schema validateObjectTypes class: GQLSSchemaNode</body><body package="GraphQLBeta-Tests-Nodes" selector="testValidateObjectTypesInterfaceMultiple">testValidateObjectTypesInterfaceMultiple	schema := self		parseSchema:			'						interface NamedEntity{							name : String						}						interface ClassName{							className: String						}						type GQLTestFilm implements NamedEntity &amp; ClassName{             					id : String            					name : String								className: String         				}'.	self assert: schema validateObjectTypes class: GQLSSchemaNode</body><body package="GraphQLBeta-Tests-Nodes" selector="testValidateSchemaWithListNamedType">testValidateSchemaWithListNamedType	schema := self		parseSchema:			'					schema { 						query: GQLTestQueryType					}					type GQLTestQueryType { 						films : [ GQLTestfilm] !					 }					type GQLTestFilm{             				id : String            				name : String							film : GQLFilm         			}					type GQLFilm { 							id : String 					}						'.	self assert: schema validate class: GQLSSchemaNode</body><body package="GraphQLBeta-Tests-Nodes" selector="testValidateSimpleClass">testValidateSimpleClass	schema := self		parseSchema:			'							schema { 								query: GQLTestFilm							}							type GQLTestFilm{             					id : String            					name : String         					}'.	self assert: schema validate class: GQLSSchemaNode</body><body package="GraphQLBeta-Tests-Nodes" selector="testValidateSimpleClassWithInputObject">testValidateSimpleClassWithInputObject	schema := self		parseSchema:			'					schema{						query: GQLTestQueryType					}					type GQLTestQueryType { 						films : [ GQLTestfilm] !						information(film: GQLTestQueryTypeInput): GQLTestQueryType					 }					type GQLTestFilm{             				id : String            				name : String         			}					input GQLTestQueryTypeInput { 							description : String					}'.	self assert: schema validate class: GQLSSchemaNode</body><body package="GraphQLBeta-Tests-Nodes" selector="testValidateSimpleClassWithListInputObject">testValidateSimpleClassWithListInputObject	schema := self		parseSchema:			'					schema { 						query: GQLTestQueryType					}					type GQLTestQueryType { 						films : [ GQLTestfilm ] !						totalInformation(film: [GQLInputFilm]): [GQLFilm]					 }					type GQLTestFilm{             				id : String            				name : String							film : GQLFilm         			}					type GQLFilm { 							id : String 					}						'.	self assert: schema validate class: GQLSSchemaNode</body><body package="GraphQLBeta-Tests-Nodes" selector="testValidateSimpleClassWithManyNamedType">testValidateSimpleClassWithManyNamedType	schema := self		parseSchema:			'					schema { 						query: GQLTestQueryType					}					type GQLTestQueryType { 						films : [ GQLTestfilm ] !					 }					type GQLTestFilm{             				id : String            				name : String							film : GQLFilm         			}					type GQLFilm { 							id : String 					}						'.	self assert: schema validate class: GQLSSchemaNode</body><body package="GraphQLBeta-Tests-Nodes" selector="testValidateSimpleClassWithNamedType">testValidateSimpleClassWithNamedType	schema := self		parseSchema:			'type A {					id: InternalCount					isB: BooleanType					size: Int					idA: ID_A					values: [ Int ! ]					params (name: StringName, prom: FloatingPoint, key: String): [Int]				}'.	self		assert: (schema schemaTypes at: 'A') class			equals: GQLSObjectTypeNode;		assert: ((schema schemaTypes at: 'A') getField: 'id') type class			equals: GQLSNamedTypeNode;		assert: ((schema schemaTypes at: 'A') getField: 'id') type name			equals: 'InternalCount';		assert: ((schema schemaTypes at: 'A') getField: 'isB') type class			equals: GQLSNamedTypeNode;		assert: ((schema schemaTypes at: 'A') getField: 'isB') type name			equals: 'BooleanType';		assert: ((schema schemaTypes at: 'A') getField: 'size') type class			equals: GQLSIntTypeNode;		assert: ((schema schemaTypes at: 'A') getField: 'idA') type class			equals: GQLSNamedTypeNode;		assert: ((schema schemaTypes at: 'A') getField: 'values') type class			equals: GQLSListTypeNode;		assert:			((schema schemaTypes at: 'A') getField: 'values') type wrappedType				class			equals: GQLSNonNullTypeNode;		assert: ((schema schemaTypes at: 'A') getField: 'params') type class			equals: GQLSListTypeNode;		assert:			(((schema schemaTypes at: 'A') getField: 'params') arguments				at: 'name') type class			equals: GQLSNamedTypeNode;		assert:			(((schema schemaTypes at: 'A') getField: 'params') arguments				at: 'prom') type class			equals: GQLSNamedTypeNode;		assert:			(((schema schemaTypes at: 'A') getField: 'params') arguments at: 'key')				type class			equals: GQLSStringTypeNode</body><body package="GraphQLBeta-Tests-Nodes" selector="testValidateSimpleClassWithParameters">testValidateSimpleClassWithParameters	schema := self		parseSchema:			'							schema { 								query: GQLIQueryType							}							type GQLIQueryType{             					sum (nums: [Int]) : Int         					}'.	self assert: schema validate class: GQLSSchemaNode</body><body package="GraphQLBeta-Tests-Nodes" selector="testValidateSimpleClassWithParametersAndInputObject">testValidateSimpleClassWithParametersAndInputObject	schema := self		parseSchema:			'					schema { 						query: GQLTestFilm					}					type GQLTestFilm{             				id : String            				name : String							film : GQLFilm         			}					type GQLFilm { 							id : String 					}						'.	self assert: schema validate class: GQLSSchemaNode</body><body package="GraphQLBeta-Tests-Nodes" selector="testValidateUnion">testValidateUnion	schema := self		parseSchema:			'							union Filmed = GQLTestFilm | Film							interface MyObject{								name : String							}							type GQLTestFilm implements MyObject{             					id : String            					name : String         					}							type Film implements MyObject{             					name : String								rating : Int         					}'.	self assert: schema validateUnionTypes class: GQLSSchemaNode</body></methods><methods><class-id>GraphQLBeta.GQLSSchemaNodeTest</class-id> <category>tests-visiting</category><body package="GraphQLBeta-Tests-Nodes" selector="testDescription">testDescription	| typeA argument |	schema := self		parseSchema:			'							schema { 								query: A							}							"type A contains three fields"							type A {								b (id: Int): B								c (p1: [Int], p2:String): [Int]								d (param:String)	:String 							},							"the last field is validated"							type B {								someName 	: [String ! ]								someName 	:String 							}'.	typeA := schema getType: 'A'.	argument := (typeA getField: 'd') getArgument: 'param'.	self assert: typeA class: GQLSObjectTypeNode.	self assert: argument class: GQLSInputObjectFieldNode.	self assert: argument type class: GQLSStringTypeNode.	self assert: (typeA getField: 'b') type class: GQLSNamedTypeNode.	argument := (typeA getField: 'c') getArgument: 'p1'.	self assert: argument type class: GQLSListTypeNode</body><body package="GraphQLBeta-Tests-Nodes" selector="testEvaluate">testEvaluate	| typeA argument |	schema := self		parseSchema:			'type A {								b (id: Int): B								c (p1: [Int], p2:String): [Int]								d (param:String)	:String 							},							type B {								someName 	: [String ! ]								someName 	:String 							}'.	typeA := schema getType: 'A'.	argument := (typeA getField: 'd') getArgument: 'param'.	self assert: typeA class: GQLSObjectTypeNode.	self assert: argument class: GQLSInputObjectFieldNode.	self assert: argument type class: GQLSStringTypeNode.	self assert: (typeA getField: 'b') type class: GQLSNamedTypeNode.	argument := (typeA getField: 'c') getArgument: 'p1'.	self assert: argument type class: GQLSListTypeNode</body></methods><methods><class-id>GraphQLBeta.GQLSSchemaNodeTest</class-id> <category>initialization</category><body package="GraphQLBeta-Tests-Nodes" selector="initDictSchema">initDictSchema	^ Dictionary new		at: 'wrongDefinedObjExtensionManySchemas'			put:			(Array				with:					(Array						with:							'		schema{			query: GQLTestQueryType		}		type GQLTestQueryType {			helloTo(name: String): String		}'						with:							'		extend type GQLTestQueryType { 			cats: [ GQLCat ]		}		type GQLCat{ 			name: String		}')				with: (Array with: GQLTestQueryType));		at: 'wrongDefinedObjExtensionOneSchema'			put:			(Array				with:					(Array						with:							'		schema{			query: GQLTestQueryType		}		type GQLTestQueryType {			helloTo(name: String): String		}		extend type GQLTestQueryType {			cats: [ GQLCat ]		}		type GQLCat {			name : String		}')				with: (Array with: GQLTestQueryType));		at: 'wrongDefinedObjExtensWithInterface'			put:			(Array				with:					(Array						with:							'		interface NamedEntity { 			name: String		}		schema{			query: GQLTestSchema		}		type GQLTestSchema {			filmsSortedBy(name: Boolean): [ GQLTestFilm ]		}		type GQLTestFilm {			rating : Int		}'						with:							'		extend interface NamedEntity{			id: String		}		extend type GQLTestFilm implements NamedEntity {			name: String		}')				with: (Array with: GQLTestSchema));		at: 'wrongDefinedObjectExtensWithResolvers'			put:			(Array				with:					(Array						with:							'		schema{			query: GQLTestQueryType		}		type GQLTestQueryType {			hello: String		}'						with:							'		extend type GQLTestQueryType {			asText(number: Int): String		}')				with: (Array with: GQLTestQueryType with: GQLFilm));		at: 'wrongInterfaceExtensManySchemas'			put:			(Array				with:					(Array						with:							'		schema{			query: GQLTestQueryType		}		interface DataEntity{			name: String		}		type GQLTestQueryType {			films: [ GQLTestFilm ]		}		type GQLTestFilm implements DataEntity{ 			name: String		}'						with:							'		extend interface DataEntity {			name: String		}')				with: (Array with: GQLTestQueryType));		at: 'wrongInterfaceExtensOneSchema'			put:			(Array				with:					(Array						with:							'		schema{			query: GQLTestQueryType		}		interface DataEntity{			id: String		}		type GQLTestQueryType {			films: [ GQLTestFilm ]		}		type GQLTestFilm implements DataEntity{ 			name: String			id: String		}		extend interface DataEntity { 			id: String		}		')				with: (Array with: GQLTestQueryType));		at: 'wrongUnionExtensionManySchemas'			put:			(Array				with:					(Array						with:							'		schema { 			query: GQLTestSchema		}	   union SearchObject = Point | Rectangle		type GQLTestSchema {			firstExtendedSearchObject: SearchObject		}		type Point{			x: Float			y: Float		}		type Rectangle{			origin: Point			corner: Point		}		'						with:							'extend union SearchObject = Point | GQLDog		type GQLDog { 			name: String		}		')				with: (Array with: GQLTestSchema));		at: 'wrongUnionExtensionOneSchema'			put:			(Array				with:					(Array						with:							'		schema {			query: GQLTestSchema		}		union SearchObject = Point | Rectangle		type GQLTestSchema{			firstExtendedSearchObject: SearchObject		}		type Point{			x: Float			y: Float		}		type Rectangle{			origin: Point			corner: Point		}		type GQLDog { 			name: String		}		extend union SearchObject = Rectangle | GQLDog		')				with: (Array with: GQLTestSchema));		at: 'wrongEnumExtensionManySchemas'			put:			(Array				with:					(Array						with:							'		schema{			query: GQLTestQueryType		}		enum MovieType{COMEDY, SCIENCE_FICTION}		type GQLTestQueryType{			classification(gender: MovieType): String		}'						with: 'extend enum MovieType { COMEDY }')				with: (Array with: GQLTestQueryType));		at: 'wrongEnumExtensionOneSchema'			put:			(Array				with:					(Array						with:							'		schema{			query: GQLTestQueryType		}		enum MovieType{COMEDY,  DRAMA}		type GQLTestQueryType{			classification(gender: MovieType): String		}		extend enum MovieType { DRAMA }')				with: (Array with: GQLTestQueryType));		at: 'wrongInputObjectExtensManySchemas'			put:			(Array				with:					(Array						with:							'		schema { 			query: GQLTestSchema		}		type GQLTestSchema { 			inform(film: GQLFilmInput, id: Int): GQLFilm		}		type GQLFilm{			id: Int			filmName: String		}		input GQLFilmInput {			id: Int!		}'						with:							'		extend input GQLFilmInput {			id: Int!		}')				with: (Array with: GQLTestSchema));		at: 'wrongInputObjectExtensionOneSchema'			put:			(Array				with:					(Array						with:							'		schema { 			query: GQLTestSchema		}		type GQLTestSchema { 			inform(film: GQLFilmInput, id: Int): GQLFilm		}		type GQLFilm{			id: Int			filmName: String		}		input GQLFilmInput {			filmName: String		}		extend input GQLFilmInput {			filmName : String		}')				with: (Array with: GQLTestSchema));		yourself	"Array of schemas"	"Array of resolvers"</body><body package="GraphQLBeta-Tests-Nodes" selector="setUp">setUp	dictSchema := self initDictSchema</body></methods><methods><class-id>GraphQLBeta.GQLSSchemaNodeTest</class-id> <category>tests-extension</category><body package="GraphQLBeta-Tests-Nodes" selector="testFailValidateEnumTypeExtension">testFailValidateEnumTypeExtension	schema := self		parseSchema:			'	schema { 		query: GQLTestQueryType	}	enum MovieType{COMEDY, SCIENCE_FICTION}	type GQLTestQueryType{		classification(gender: MovieType): String	}	extend enum MovieTypeOther { DRAMA }'.	self should: [ schema validate ] raise: GQLValidationException.	schema := self		parseSchema:			'	schema { 		query: GQLTestQueryType	}	enum MovieType{COMEDY, SCIENCE_FICTION}	type GQLTestQueryType{		classification(gender: MovieType): String	}	extend enum MovieType { COMEDY }	'.	self should: [ schema validate ] raise: GQLValidationException</body><body package="GraphQLBeta-Tests-Nodes" selector="testFailValidateInputObjectTypeExtension">testFailValidateInputObjectTypeExtension	schema := self		parseSchema:			'							schema { 								query: GQLTestQueryTypeInput							}							type GQLTestQueryType { 								description: String							}							input GQLTestQueryTypeInput{             					description : String         					}							extend input GQLTestQueryTypeInputOther{								gender: String!							}'.	self should: [ schema validate ] raise: GQLValidationException.	schema := self		parseSchema:			'							schema { 								query: GQLTestQueryType							}							type GQLTestQueryType { 								description: String							}							input GQLTestQueryTypeInput{             					description : String         					}							extend input GQLTestQueryTypeInput{								gender: String!								description: String							}'.	self should: [ schema validate ] raise: GQLValidationException</body><body package="GraphQLBeta-Tests-Nodes" selector="testFailValidateInterfaceTypeExtension">testFailValidateInterfaceTypeExtension	| valid |	schema := self		parseSchema:			'						schema { 							query: Query						}						type GQLFilm implements RelevantData { 							name: String						}						interface RelevantData{							name : String						}						extend interface OtherInterface{							id: String						}'.	self should: [ schema validate ] raise: GQLValidationException.	schema := self		parseSchema:			'						schema { 							query: Query						}						type GQLFilm implements RelevantData { 							name: String						}						interface RelevantData{							name : String						}						extend interface RelevantData{							name: String							id: String						}'.	self should: [ schema validate ] raise: GQLValidationException.	schema := self		parseSchema:			'						schema { 							query: GQLTestFilm						}						interface NamedEntity{							name: String						}						extend interface NamedEntity{							id: String						}						type GQLTestFilm implements NamedEntity{							name: String						}'.	self should: [ schema validate ] raise: GQLValidationException.	schema := self		parseSchema:			'						schema { 							query: GQLTestFilm						}						interface NamedEntity{							name: String						}						extend interface NamedEntity{							id: String						}						type GQLTestFilm{							filmName: String						}						extend type GQLTestFilm implements NamedEntity{							id: String						}'.	valid := schema validate.	self should: [ schema validate ] raise: GQLValidationException</body><body package="GraphQLBeta-Tests-Nodes" selector="testFailValidateObjectTypeExtension">testFailValidateObjectTypeExtension	| valid |	schema := self		parseSchema:			'						schema { 							query: GQLTestFilm						}						type GQLTestFilm{							id: String						}						extend type GQLTestQueryType{							name: String						}'.	self should: [ schema validate ] raise: GQLValidationException.	schema := self		parseSchema:			'						schema { 							query: GQLTestFilm						}						type GQLTestFilm{							id: String						}						input GQLTestQueryTypeInput{             					description : String         				}						extend type GQLTestQueryTypeInput{							gender: String						}'.	self should: [ schema validate ] raise: GQLValidationException.	schema := self		parseSchema:			'						schema { 							query: GQLTestFilm						}						type GQLTestFilm{							id: String						}						extend type GQLTestFilm{							id: String							filmName: String						}'.	self should: [ schema validate ] raise: GQLValidationException.	schema := self		parseSchema:			'						schema { 							query: GQLTestFilm						}						interface NamedEntity{							name: String						}						type GQLTestFilm implements NamedEntity{							id: String							name: String						}						extend type GQLTestFilm implements NamedEntity{							filmName: String						}'.	valid := schema validate.	self should: [ schema validate ] raise: GQLValidationException.	schema := self		parseSchema:			'						schema { 							query: GQLTestFilm						}						interface NamedEntity{							name: String						}						type GQLTestFilm implements NamedEntity{							id: String						}						extend type GQLTestFilm {							filmName: String						}'.	self should: [ schema validate ] raise: GQLValidationException</body><body package="GraphQLBeta-Tests-Nodes" selector="testFailValidateSchemaExtension">testFailValidateSchemaExtension	schema := self		parseSchema:			'	extend schema { 		query: Query	}	extend schema{		mutation: GQLTestMutationType		mutation: Query	}	type Query{		hello: String	}	type GQLTestMutationType{		createPoint(x: Int, y: Int): Point	}	type Point{		x: Int		y: Int	}	'.	self should: [ schema validate ] raise: GQLValidationException.	schema := self		parseSchema:			'	extend schema { 		query: GQLTestQueryType		query: Query	}	type GQLTestQueryType { 		helloTo(name: String): String	}	type Query{		hello: String	}	'.	self		should: [ schema validateSchemaExtensions ]		raise: GQLValidationException.	schema := self		parseSchema:			'	extend schema { 		mutation: GQLTestMutationType		mutation: Query	}	type Query{		hello: String	}	type GQLTestMutationType { 		createPoint(x: Int, y: Int): Point	}	type Point { 		x: Int		y: Int	}	'.	self		should: [ schema validateSchemaExtensions ]		raise: GQLValidationException</body><body package="GraphQLBeta-Tests-Nodes" selector="testFailValidateUnionTypeExtension">testFailValidateUnionTypeExtension	schema := self		parseSchema:			'							schema { 								query: GQLTestQueryType							}							union Filmed = GQLTestFilm | Film							type GQLTestQueryType{								description: String							}							type GQLTestFilm {             					id : String            					name : String         					}							type Film {             					name : String								rating : Int         					}							extend union OtherUnion = GQLTestQueryType'.	self should: [ schema validate ] raise: GQLValidationException.	schema := self		parseSchema:			'							schema { 								query: GQLTestQueryType							}							union Filmed = GQLTestFilm | Film							type GQLTestQueryType{								description: String							}							type GQLTestFilm {             					id : String            					name : String         					}							type Film {             					name : String								rating : Int         					}							extend union Filmed = GQLTestQueryType | GQLTestFilm'.	self should: [ schema validate ] raise: GQLValidationException</body><body package="GraphQLBeta-Tests-Nodes" selector="testValidateEnumTypeExtension">testValidateEnumTypeExtension	schema := self		parseSchema:			'	schema { 		query: GQLTestQueryType	}	enum MovieType{COMEDY, SCIENCE_FICTION}	type GQLTestQueryType{		classification(gender: MovieType): String	}	extend enum MovieType { DRAMA }	'.	self assert: schema validate class: GQLSSchemaNode</body><body package="GraphQLBeta-Tests-Nodes" selector="testValidateInputObjectTypeExtension">testValidateInputObjectTypeExtension	schema := self		parseSchema:			'							schema { 								query: GQLTestQueryType							}							type GQLTestQueryType { 								hello: String							}							input GQLTestQueryTypeInput{             					description : String         					}							extend input GQLTestQueryTypeInput{								gender: String!							}'.	self assert: schema validate class: GQLSSchemaNode</body><body package="GraphQLBeta-Tests-Nodes" selector="testValidateInterfaceTypeExtension">testValidateInterfaceTypeExtension	schema := self		parseSchema:			'						schema { 							query: GQLTestFilm						}						type GQLTestFilm { 							name: String						}						interface RelevantData{							name : String						}						extend interface RelevantData{							id: String						}'.	self assert: schema validate class: GQLSSchemaNode.	schema := self		parseSchema:			'						schema { 							query: GQLTestFilm						}						interface RelevantData{							name: String						}						extend interface RelevantData{							id: String						}						type GQLTestFilm implements RelevantData{							name: String						}						extend type GQLTestFilm { 							id: String						}						'.	self assert: schema validate class: GQLSSchemaNode.	schema := self		parseSchema:			'						schema { 							query: GQLTestFilm						}						interface RelevantData{							name : String						}						extend interface RelevantData{							id: String						}						type GQLTestFilm {							name: String							filmName: String						}						extend type GQLTestFilm implements RelevantData{ 							id: String						}'.	self assert: schema validate class: GQLSSchemaNode</body><body package="GraphQLBeta-Tests-Nodes" selector="testValidateObjectTypeExtension">testValidateObjectTypeExtension	schema := self		parseSchema:			'						schema { 							query: GQLTestFilm						}						type GQLTestFilm{							id: String						}						extend type GQLTestFilm{							name: String						}'.	self assert: schema validate class: GQLSSchemaNode.	schema := self		parseSchema:			'						schema { 							query: GQLTestFilm						}						interface NamedEntity { 							name: String						}						type GQLTestFilm implements NamedEntity{							id: String						}						extend type GQLTestFilm{							name: String						}'.	self assert: schema validate class: GQLSSchemaNode.	schema := self		parseSchema:			'						schema { 							query: GQLTestFilm						}						interface NamedEntity { 							name: String						}						type GQLTestFilm{							id: String							name: String						}						extend type GQLTestFilm implements NamedEntity'.	self assert: schema validate class: GQLSSchemaNode.	schema := self		parseSchema:			'						schema { 							query: GQLTestFilm						}						interface NamedEntity { 							name: String						}						interface Identifier{							id: String						}						type GQLTestFilm implements NamedEntity &amp; Identifier{							description: String							id: String						}						extend type GQLTestFilm{							name: String						}'.	self assert: schema validate class: GQLSSchemaNode.	schema := self		parseSchema:			'						schema { 							query: GQLTestFilm						}						interface NamedEntity { 							name: String						}						interface Identifier{							id: String						}						type GQLTestFilm implements NamedEntity {							description: String							id: String						}						extend type GQLTestFilm implements Identifier{							name: String						}'.	self assert: schema validate class: GQLSSchemaNode.	schema := self		parseSchema:			'						schema { 							query: GQLTestFilm						}						interface NamedEntity { 							name: String						}						interface Identifier{							id: String						}						type GQLTestFilm implements NamedEntity {							description: String						}						extend type GQLTestFilm implements Identifier{							name: String							id: String						}'.	self assert: schema validate class: GQLSSchemaNode</body><body package="GraphQLBeta-Tests-Nodes" selector="testValidateSchemaExtension">testValidateSchemaExtension	schema := self		parseSchema:			'	schema {		query: GQLTestQueryType	} 	extend schema { 		mutation: GQLTestMutationType	}	type GQLTestQueryType { 		hello: String	}	type GQLTestMutationType { 		createPoint(x:Int, y:Int) : Point	}	type Point { 		x: Float		y: Float	}	'.	self assert: schema validateSchemaExtensions class: GQLSSchemaNode.	schema := self		parseSchema:			'	schema {		query: GQLTestQueryType	} 	extend schema { 		query: Query		mutation: GQLTestMutationType	}	type Query { 		hello: String	}	type GQLTestQueryType { 		hello: String	}	type GQLTestMutationType { 		createPoint(x:Int, y:Int) : Point	}	type Point { 		x: Float		y: Float	}	'.	self assert: schema validateSchemaExtensions class: GQLSSchemaNode</body><body package="GraphQLBeta-Tests-Nodes" selector="testValidateUnionTypeExtension">testValidateUnionTypeExtension	schema := self		parseSchema:			'							schema { 								query: GQLTestQueryType							}							union Filmed = GQLTestFilm | Film							type GQLTestQueryType{								description: String							}							type GQLTestFilm {             					id : String            					name : String         					}							type Film {             					name : String								rating : Int         					}							extend union Filmed = GQLTestQueryType'.	self assert: schema validate class: GQLSSchemaNode</body></methods><methods><class-id>GraphQLBeta.GQLSSchemaNodeTest</class-id> <category>tests-introspection</category><body package="GraphQLBeta-Tests-Nodes" selector="testValidateIntrospectionEnum">testValidateIntrospectionEnum	schema := self		parseSchema:			'	enum __TypeKind {  		SCALAR  		OBJECT  		INTERFACE  		UNION  		ENUM  		INPUT_OBJECT  		LIST  		NON_NULL	}'.	self assert: schema validateObjectTypes class: GQLSSchemaNode.	schema := self		parseSchema:			'enum __DirectiveLocation {  		QUERY  		MUTATION  		SUBSCRIPTION  		FIELD  		FRAGMENT_DEFINITION  		FRAGMENT_SPREAD  		INLINE_FRAGMENT  		SCHEMA  		SCALAR  		OBJECT  		FIELD_DEFINITION  		ARGUMENT_DEFINITION  		INTERFACE  		UNION  		ENUM  		ENUM_VALUE  		INPUT_OBJECT  		INPUT_FIELD_DEFINITION	}'.	self assert: schema validateObjectTypes class: GQLSSchemaNode</body><body package="GraphQLBeta-Tests-Nodes" selector="testValidateIntrospectionType">testValidateIntrospectionType	schema := self		parseSchema:			'		type __Schema { 			types: [ __Type! ]!			queryType: __Type!			mmutationType: __Type			subscriptionType: __Type			directives: [ __Directives! ]!		}'.	self assert: schema validateObjectTypes class: GQLSSchemaNode.	schema := self		parseSchema:			'		type __Type { 			kind: __TypeKind!			name: String			description: String  			fields(includeDeprecated: Boolean): [__Field!]  			interfaces: [__Type!]  			possibleTypes: [__Type!]  			enumValues(includeDeprecated: Boolean): [__EnumValue!]  			inputFields: [__InputValue!]  			ofType: __Type		}'.	self assert: schema validateObjectTypes class: GQLSSchemaNode.	schema := self		parseSchema:			'	type __Field {  name: String!  description: String  args: [__InputValue!]!  type: __Type!  isDeprecated: Boolean!  deprecationReason: String}'.	self assert: schema validateObjectTypes class: GQLSSchemaNode.	schema := self		parseSchema:			'	type __InputValue {  name: String!  description: String  type: __Type!  defaultValue: String}'.	self assert: schema validateObjectTypes class: GQLSSchemaNode.	schema := self		parseSchema:			'	type __EnumValue {  name: String!  description: String  isDeprecated: Boolean!  deprecationReason: String}'.	self assert: schema validateObjectTypes class: GQLSSchemaNode.	schema := self		parseSchema:			'	type __Directive {  name: String!  description: String  locations: [__DirectiveLocation!]!  args: [__InputValue!]!}'.	self assert: schema validateObjectTypes class: GQLSSchemaNode</body><body package="GraphQLBeta-Tests-Nodes" selector="testValidateSchemaIntrospection">testValidateSchemaIntrospection	| schemaNode type |	schema := self		parseSchema:			'					schema { 						query: GQLTestFilm					}					type GQLTestFilm{             				id : String            				name : String							film : GQLFilm         			}					type GQLFilm { 							id : String 					}						'.	schemaNode := schema validate.	self assert: schemaNode class: GQLSSchemaNode.	self assert: schemaNode types size equals: 15.	type := schemaNode getType: '__Schema'.	self assert: type name equals: 'GQLSSchemaNode'.	self assert: type fields size equals: 5.	self		assertCollection: type fields keys		hasSameElements: #('types' 'queryType' 'directives' 'mutationType' 'subscriptionType').	type := schemaNode getType: '__Type'.	self assert: type name equals: 'GQLSTypeNode'.	self		assertCollection: type fields keys		hasSameElements:			#('kind' 'name' 'description' 'fields' 'interfaces' 'possibleTypes' 'enumValues' 'inputFields' 'ofType').	type := schemaNode getType: '__Field'.	self assert: type name equals: 'GQLSFieldNode'.	self		assertCollection: type fields keys		hasSameElements:			#('name' 'description' 'args' 'type' 'isDeprecated' 'deprecationReason').	type := schemaNode getType: '__InputValue'.	self assert: type name equals: 'GQLSInputObjectFieldNode'.	self		assertCollection: type fields keys		hasSameElements: #('name' 'description' 'type' 'defaultValue').	type := schemaNode getType: '__EnumValue'.	self assert: type name equals: 'GQLSEnumValue'.	self		assertCollection: type fields keys		hasSameElements: #('name' 'description' 'isDeprecated' 'deprecationReason').	type := schemaNode getType: '__Directive'.	self assert: type name equals: 'GQLSDirectiveNode'.	self		assertCollection: type fields keys		hasSameElements: #('name' 'description' 'locations' 'args')</body></methods><methods><class-id>GraphQLBeta.GraphQLDemoWorldMenu class</class-id> <category>as yet unclassified</category><body package="GraphQLBeta-Demo" selector="menuCommandOn:">menuCommandOn: aBuilder	&lt;worldMenu&gt;	(aBuilder item: 'GraphQL') icon: self image.	(aBuilder item: 'start' asSymbol)		order: 0.001;		parent: 'GraphQL';		label: 'Start server';		icon: (Smalltalk ui icons iconNamed: #smallDoIt);		action: [ GraphQLBetaDemoSite demoStart.			WebBrowser openOn: 'http://localhost:8888' ].	(aBuilder item: 'stop' asSymbol)		order: 0.001;		parent: 'GraphQL';		label: 'Stop server';		icon: (Smalltalk ui icons iconNamed: #stop);		action: [ GraphQLBetaDemoSite demoStop ];		withSeparatorAfter.	(aBuilder item: 'schema' asSymbol)		order: 0.001;		parent: 'GraphQL';		label: 'Edit the demo schema';		icon: (Smalltalk ui icons iconNamed: #workspace);		action: [ (GQLQuery class &gt;&gt; #schema) browse ].	(aBuilder item: 'example' asSymbol)		order: 0.001;		parent: 'GraphQL';		label: 'See an example';		icon: (Smalltalk ui icons iconNamed: #workspace);		action: [ Transcript				open;				clear;				show: self requestExample ].	(aBuilder item: 'git' asSymbol)		order: 0.001;		parent: 'GraphQL';		label: 'Github page';		icon: (Smalltalk ui icons iconNamed: #github);		action: [ WebBrowser openOn: 'https://github.com/OBJECTSEMANTICS/GraphQL' ].	(aBuilder item: 'report' asSymbol)		order: 0.001;		parent: 'GraphQL';		label: 'Report an issue';		icon: (Smalltalk ui icons iconNamed: #glamorousBug);		action: [ WebBrowser				openOn: 'https://github.com/OBJECTSEMANTICS/GraphQL/issues/new' ]</body></methods><methods><class-id>GraphQLBeta.GraphQLBenchmark class</class-id> <category>benchmarking</category><body package="GraphQLBeta-Test-Benchmark" selector="benchmark01">benchmark01	"This benchmark print resutl for the excel document	 Variable or expression expected -&gt;https://goo.gl/kSdX2S"	&lt;script: 'self benchmark01'&gt;	Transcript		show: Smalltalk version;		cr;		show:			(Smalltalk vm wordSize = 4				ifTrue: [ 32 ]				ifFalse: [ 64 ]);		show: ' bits'.	#('{queryPoints}' '{queryPoints { x y } }' '{queryPoints { x } }' '{queryPoints { y } }')		do: [ :query | 			"Transcript cr; cr; show: 'Query: '; show: query."			#(5000000 4000000 200000 100000)				do:					[ :s | "Transcript cr; show: 'Points size: '; show: s." self benchmarkTimePoints: s query: query ]				displayingProgress: [ :s | 'Processing bench01 for: ' , s asString , ' points ' ] ]		displayingProgress: [ :q | 'Processing for: ' , q ]</body><body package="GraphQLBeta-Test-Benchmark" selector="benchmark02">benchmark02	&lt;script: 'self benchmark02'&gt;	Transcript		show: Smalltalk version;		cr;		show:			(Smalltalk vm wordSize = 4				ifTrue: [ 32 ]				ifFalse: [ 64 ]);		show: ' bits'.	#('{queryRectangles}' '{queryRectangles { origin corner } }' '{queryRectangles { origin } }' '{queryRectangles { corner } }' '{queryRectangles { origin { x y } } } ')		do: [ :query | 			"Transcript cr; show: 'Query: '; show: query."			#(1000000 800000 600000)				do:					[ :s | "Transcript cr; cr; show: 'Rectangles size: ', s asString." self benchmarkTimeRectangles: s query: query ]				displayingProgress: [ :s | 'Processing bench02 for: ' , s asString , ' rectangles' ] ]		displayingProgress: [ :q | 'Processing for: ' , q ]</body></methods><methods><class-id>GraphQLBeta.GraphQLBenchmark class</class-id> <category>initialization</category><body package="GraphQLBeta-Test-Benchmark" selector="cleanMemory">cleanMemory	&lt;script: 'self cleanMemory'&gt;	3 timesRepeat: [ Smalltalk garbageCollect ].	Object		new;		new;		new.	3 timesRepeat: [ Smalltalk garbageCollect ]</body><body package="GraphQLBeta-Test-Benchmark" selector="initializePoints:">initializePoints: size	&lt;script: 'self initializePoints: 10'&gt;	objects := OrderedCollection new: size.	1 to: size do: [ :i | objects add: i asPoint ].	lastSize := size</body><body package="GraphQLBeta-Test-Benchmark" selector="initializeRectangles:">initializeRectangles: size	&lt;script: 'self initializeRectangles: 10'&gt;	objects := OrderedCollection new: size.	1 to: size do:		[ :i | objects add: (Rectangle origin: i asPoint corner: i asPoint negated) ].	lastSize := size</body><body package="GraphQLBeta-Test-Benchmark" selector="reset">reset	&lt;script: 'self reset'&gt;	objects := nil.	lastSize := nil</body></methods><methods><class-id>GraphQLBeta.GraphQLBetaDemoHTML class</class-id> <category>html sources</category><body package="GraphQLBeta-Demo" selector="exportHTMLFile:">exportHTMLFile: fileName	"Export the html content to the file name, in order to edit it"	&lt;script: 'self exportHTMLFile: ''foo.html'' '&gt;	| file s |	file := fileName asFileReference.	file exists		ifTrue: [ file delete ].	s := file writeStream.	[ s		nextPutAll: (self htmlPage copyReplaceAll: String cr with: String crlf) ]		ensure: [ s close ].	self inform: 'exported!!!'</body><body package="GraphQLBeta-Demo" selector="importHTMLFile:">importHTMLFile: fileName	"Import the html from a file document, in order to save it in the smalltalk image"	&lt;script: 'self importHTMLFile: ''foo.html'' '&gt;	| content code |	content := ((fileName asFileReference readStream contents		copyReplaceAll: ''''		with: '"') copyReplaceAll: String cr with: '')		copyReplaceAll: String lf		with: String cr.	code := 'htmlPage	"DO NOT EDIT"	^ ''' , content , ''''.	self class compile: code classified: 'dependencies'.	self inform: 'Imported html!!!'</body></methods><methods><class-id>GraphQLBeta.GraphQLBetaDemoSite class</class-id> <category>demo</category><body package="GraphQLBeta-Demo" selector="demoStart">demoStart	&lt;script: 'self demoStart'&gt;	| inst |	inst := self new.	GraphQLPlatform current registerDemoServer: inst.	inst configure.	self inform: 'demo start'</body><body package="GraphQLBeta-Demo" selector="demoStop">demoStop	&lt;script: 'self demoStop'&gt;	GraphQLPlatform current serverStop.	self inform: 'demo stop'</body></methods><methods><class-id>GraphQLBeta.GQLSSchemaNode</class-id> <category>inspector</category><body package="GraphQLBeta-NodesSchema" selector="gtTextIn:">gtTextIn: composite	&lt;gtInspectorPresentationOrder: -10&gt;	composite text		title: 'Schema';		display: [ | s |			s := String new writeStream.			self printOn: s.			s contents ]</body></methods><initialize><class-id>GraphQLBeta.GQLSSchemaNode</class-id></initialize><initialize><class-id>GraphQLBeta.GQLSIntTypeNode</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>PPCompositeParser</name><environment>PetitParser</environment><super>PetitParser.PPDelegateParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dependencies </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Tools</category><attributes><package>PetitParser</package></attributes></class><class><name>TestCase</name><environment>SUnit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnitToo</package></attributes></class><class><name>PPCompositeParserTest</name><environment>PetitTests</environment><super>PetitTests.PPAbstractParserTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parser result debugResult </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitTests-Core</category><attributes><package>PetitTests</package></attributes></class><class><name>Exception</name><environment>Core</environment><super>Core.GenericException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class></st-source>