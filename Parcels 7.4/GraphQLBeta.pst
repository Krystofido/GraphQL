<?xml version="1.0"?><st-source><!-- Name: GraphQLBetaBundleName: GraphQLBetaBundleStructure: a Store.BundleForParcelParcel: #('GraphQLBeta')ParcelName: GraphQLBetaDate: 5:41:37 pm July 27, 2018 --><time-stamp>From VisualWorksÂ®, 7.4 of December 5, 2005 on July 27, 2018 at 5:41:37 pm</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>GraphQLBeta</name><environment>Smalltalk</environment><private>false</private><imports>			private PetitParser.*			private Smalltalk.*			private PetitTests.*			</imports><category>GraphQLBeta</category><attributes><package>GraphQLBeta</package></attributes></name-space><class><name>GQLAbstractGrammarTest</name><environment>GraphQLBeta</environment><super>PetitTests.PPCompositeParserTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Tests-Grammar</category><attributes><package>GraphQLBeta-Tests-Grammar</package></attributes></class><comment><class-id>GraphQLBeta.GQLAbstractGrammarTest</class-id><body>A GQLAbstractGrammarTest is a test class for testing the behavior of GQLAbstractGrammar</body></comment><class><name>GQLSingleAnonimousQueryGrammarTest</name><environment>GraphQLBeta</environment><super>PetitTests.PPCompositeParserTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Tests-Grammar</category><attributes><package>GraphQLBeta-Tests-Grammar</package></attributes></class><comment><class-id>GraphQLBeta.GQLSingleAnonimousQueryGrammarTest</class-id><body>A GQLSingleAnonimousQueryGrammarTest is a test class for testing the behavior of GQLSingleAnonimousQueryGrammar</body></comment><class><name>GQLIQueryType</name><environment>GraphQLBeta</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Test-Trash</category><attributes><package>GraphQLBeta-Test-Trash</package></attributes></class><comment><class-id>GraphQLBeta.GQLIQueryType</class-id><body>Example class query  for testsPublic API and Key Messages- a- aId:- hello- helloName:- sumNums:</body></comment><class><name>GraphQLObject</name><environment>GraphQLBeta</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta</category><attributes><package>GraphQLBeta</package></attributes></class><comment><class-id>GraphQLBeta.GraphQLObject</class-id><body>I'm the default parent of the classes of the package GraphQLBeta.</body></comment><class><name>GQLFilm</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GraphQLObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id filmName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Test-Utils</category><attributes><package>GraphQLBeta-Test-Utils</package></attributes></class><comment><class-id>GraphQLBeta.GQLFilm</class-id><body>Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:For the Class part:  State a one line summary. For example, "I represent a paragraph of text".For the Responsibility part: Three sentences about my main responsibilities - what I do, what I know.For the Collaborators Part: State my main collaborators and one line about how I interact with them. Public API and Key Messages- message one   - message two - (for bonus points) how to create instances.   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Instance Variables	name:		&lt;Object&gt;    Implementation Points</body></comment><class><name>GraphQLBenchmark</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GraphQLObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>objects lastSize </class-inst-vars><imports></imports><category>GraphQLBeta-Test-Benchmark</category><attributes><package>GraphQLBeta-Test-Benchmark</package></attributes></class><comment><class-id>GraphQLBeta.GraphQLBenchmark</class-id><body>I am a simple class that contains benchmarks for this project</body></comment><class><name>GQLAbstractGrammar</name><environment>GraphQLBeta</environment><super>PetitParser.PPCompositeParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>sourceCharacter unicodeBOM whiteSpace lineTerminator commentChar comment comma token punctuator tokenName intValue floatValue stringValue integerPart nonZeroDigit digit fractionalPart exponentPart exponentIndicator sign stringDelimiter stringCharacter escapedUnicode escapedCharacter ignored booleanValue insignificantToken intType floatType scalarType stringType booleanType idType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Parser</category><attributes><package>GraphQLBeta-Parser</package></attributes></class><comment><class-id>GraphQLBeta.GQLAbstractGrammar</class-id><body>I represent a abstract grammar.Public API and Key Messages- booleanValue- comma- comment- commentChar- digit- escapedCharacter - escapedUnicode - exponentIndicator - exponentPart - floatValue - fractionalPart -ignored - insignificantToken - intValue - integerPart - lineTerminator - nonZeroDigit - punctuator - sign - sourceCharacter - start- stringCharacter - stringDelimiter - stringValue - token- tokenName- unicodeBOM- whiteSpace </body></comment><class><name>GQLRequestGrammar</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLAbstractGrammar</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selection field fragmentSpread inlineFragment alias arguments argument value fragmentName typeCondition namedType variable nullValue enumValue listValue objectValue variableDefinition type listType nonNullType directive definition operationDefinition fragmentDefinition operationType variableDefinitions directives selectionSet document defaultValue objectField operation nonNullNamedType nonNullListType named scalarField nonScalarField </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Parser</category><attributes><package>GraphQLBeta-Parser</package></attributes></class><comment><class-id>GraphQLBeta.GQLRequestGrammar</class-id><body>I represent the grammar defined for a graphql request.Public API and Key Messages- alias- argument- arguments- defaultValue- definition- directive- document- enumValue- field- fragmentDefinition- fragmentName- fragmentSpread- inlineFragment- listType- listValue- namedType- nonNullType- nullValue- objectField- objectValue- operationDefinition- operationType- selection- selectionSet- start- type- typeCondition- value- variable- variableDefinition- variableDefinitions</body></comment><class><name>GQLSingleAnonimousQueryGrammar</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLRequestGrammar</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Parser</category><attributes><package>GraphQLBeta-Parser</package></attributes></class><comment><class-id>GraphQLBeta.GQLSingleAnonimousQueryGrammar</class-id><body>I represent a  part of the grammar for the graphql request.Only fields with arguments. No fragments, no alias.Public API and Key Messages- document- field- selection- selectionSet- start</body></comment><class><name>GQLVariableGrammar</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLRequestGrammar</super><private>false</private><indexed-type>none</indexed-type><inst-vars>variableSet tokenValue variableValue </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Parser</category><attributes><package>GraphQLBeta-Parser</package></attributes></class><comment><class-id>GraphQLBeta.GQLVariableGrammar</class-id><body>I represent a  part of the grammar for the graphql request.Only the assignments of variables. Public API and Key Messages- variableSet- variableValue- tokenValue</body></comment><class><name>GQLSelectionSetNodeTest</name><environment>GraphQLBeta</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selectionSet objectNode1 innerEscalar objectNode2 field1 field2 context </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Tests-Nodes</category><attributes><package>GraphQLBeta-Tests-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLSelectionSetNodeTest</class-id><body>A GQLSelectionSetNodeTest is a test class for testing the behavior of GQLSelectionSetNode</body></comment><class><name>GQLFieldNodeTest</name><environment>GraphQLBeta</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>schema scalarField nonScalarField context </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Tests-Nodes</category><attributes><package>GraphQLBeta-Tests-Nodes</package></attributes></class><class><name>GQLSNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GraphQLObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>position </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-NodesSchema</category><attributes><package>GraphQLBeta-NodesSchema</package></attributes></class><comment><class-id>GraphQLBeta.GQLSNode</class-id><body>I represent a node generated by parsing the schema textPublic API and Key Messages- acceptVisitor:- initialize- position- position:    Instance Variables	position:		&lt;Integer&gt;</body></comment><class><name>GQLSTypeNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLSNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-NodesSchema</category><attributes><package>GraphQLBeta-NodesSchema</package></attributes></class><comment><class-id>GraphQLBeta.GQLSTypeNode</class-id><body>I represent a type node.For more information see my subclasses</body></comment><class><name>GQLSWrapTypeNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLSTypeNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>wrappedType </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-NodesSchema</category><attributes><package>GraphQLBeta-NodesSchema</package></attributes></class><comment><class-id>GraphQLBeta.GQLSWrapTypeNode</class-id><body>I represent a wrap type. Public API and Key Messages- wrappedType- wrappedType:    Instance Variables	wrappedType:		&lt;GQLSTypeNode&gt;</body></comment><class><name>GQLSArgumentFieldNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLSNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name type </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-NodesSchema</category><attributes><package>GraphQLBeta-NodesSchema</package></attributes></class><comment><class-id>GraphQLBeta.GQLSArgumentFieldNode</class-id><body>I represent an argument of a field node, like:name : String! number : Intother : ObjectPublic API and Key Messages- name- name: - type- type:    Instance Variables	name:		&lt;String&gt;	type:		&lt;GQLSTypeNode&gt;    Implementation Points</body></comment><class><name>GQLSSchemaNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLSNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>schemaTypes scalarTypes defaultDirectives root query </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-NodesSchema</category><attributes><package>GraphQLBeta-NodesSchema</package></attributes></class><comment><class-id>GraphQLBeta.GQLSSchemaNode</class-id><body>I represent a schema node, I have different types.Public API and Key Messages- addTypes:- getType:- types- validate    Instance Variables	scalarTypes:		&lt;Dictionary&gt;	schemaTypes:		&lt;Dictionary&gt;    Implementation Points</body></comment><class><name>GQLException</name><environment>GraphQLBeta</environment><super>Core.Exception</super><private>false</private><indexed-type>none</indexed-type><inst-vars>node </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta</category><attributes><package>GraphQLBeta</package></attributes></class><comment><class-id>GraphQLBeta.GQLException</class-id><body>I represent an exception of graphql, I know the node that raise some kind of exception on the parsing or the validation or the type checking of the schema.Public API and Key Messages- node      - node: - signal   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Instance Variables	node:		&lt;Object&gt;    Implementation Points</body></comment><class><name>GQLValidationException</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta</category><attributes><package>GraphQLBeta</package></attributes></class><comment><class-id>GraphQLBeta.GQLValidationException</class-id><body>I represent an exception of validation on graphql, I'm only called if the GQLSchema has a problem validating the parts of the schema vs the image of Smalltalk.Public API and Key Messages- messageClassText- messageMethodText:  aClassInstance Variables	node:		&lt;Object&gt;GQLValidationException new 			node: field; 			messageMethodText: Object</body></comment><class><name>GQLEvaluationException</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta</category><attributes><package>GraphQLBeta</package></attributes></class><comment><class-id>GraphQLBeta.GQLEvaluationException</class-id><body>I represent an exception of evaluation on graphql, I'm only called if the GQLTypeValidator has a problem with visiting the parts of the document.Public API and Key Messages- node      - node: - signal    Instance Variables	node:		&lt;GQLNode&gt;GQLEvaluationException new 			node: aGQLArgumentNode; 			signal</body></comment><class><name>GQLNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GraphQLObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>position </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLNode</class-id><body>I represent a node of a graphql request Public API and Key Messages- acceptVisitor:  - executeOn:with:using:To see more information go to the subclasses</body></comment><class><name>GQLSelectionNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>directives </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLSelectionNode</class-id><body>I represent a selection on a request.Public API and Key Messages- directives    Instance Variables	directives:		&lt;Array&gt;    Implementation Points</body></comment><class><name>GQLFragmentSpreadNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLSelectionNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLFragmentSpreadNode</class-id><body>I represent a fragment spread on a request.Public API and Key Messages- name    Instance Variables	name:		&lt;String&gt;    Implementation Points</body></comment><class><name>GQLDefinitionNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLDefinitionNode</class-id><body>I represent a definition on the request.For more information see my subclasses.</body></comment><class><name>GQLOperationDefinitionNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLDefinitionNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLOperationDefinitionNode</class-id><body>I represent the definition of an operation on the request.To more information see my subclasses.</body></comment><class><name>GQLVariableDefinitionNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name type defaultValue value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLVariableDefinitionNode</class-id><body>I represent a variable definition on the request.Public API and Key Messages- defaultValue- name- type    Instance Variables	defaultValue:		&lt;GQLValueNode&gt;	name:		&lt;String&gt;	type:		&lt;GQLSTypeNode&gt;    Implementation Points</body></comment><class><name>GQLSelectionSetNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLOperationDefinitionNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selections </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLSelectionSetNode</class-id><body>I represent a selection set on a request.Public API and Key Messages- selections- collectFields- mergeSelectionSet:with:    Instance Variables	selections:		&lt;Array&gt;    Implementation Points</body></comment><class><name>GQLSchemaGrammarTest</name><environment>GraphQLBeta</environment><super>PetitTests.PPCompositeParserTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Tests-Grammar</category><attributes><package>GraphQLBeta-Tests-Grammar</package></attributes></class><comment><class-id>GraphQLBeta.GQLSchemaGrammarTest</class-id><body>A GQLSchemaGrammarTest is a test class for testing the behavior of GQLSchemaGrammar</body></comment><class><name>GQLObjectFieldNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLObjectFieldNode</class-id><body>I represent a field of an object value.Public API and Key Messages- name- value    Instance Variables	name:		&lt;String&gt;	value:		&lt;GQLValueNode&gt;    Implementation Points</body></comment><class><name>GraphQLBetaDemoHTML</name><environment>GraphQLBeta</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Demo</category><attributes><package>GraphQLBeta-Demo</package></attributes></class><comment><class-id>GraphQLBeta.GraphQLBetaDemoHTML</class-id><body>I have the html page resources</body></comment><class><name>GQLRequestGrammarTest</name><environment>GraphQLBeta</environment><super>PetitTests.PPCompositeParserTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Tests-Grammar</category><attributes><package>GraphQLBeta-Tests-Grammar</package></attributes></class><comment><class-id>GraphQLBeta.GQLRequestGrammarTest</class-id><body>A GQLSchemaGrammarTest is a test class for testing the behavior of GQLSchemaGrammar</body></comment><class><name>GQLSFieldNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLSNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name type arguments fullName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-NodesSchema</category><attributes><package>GraphQLBeta-NodesSchema</package></attributes></class><comment><class-id>GraphQLBeta.GQLSFieldNode</class-id><body>I represent a field node, I'm present on object and interface types.Public API and Key Messages- addArguments: - arguments- arguments: - fullName - getArgument: - name- name: - type- type:    Instance Variables	arguments:		&lt;Dictionary&gt;	fullName:		&lt;String&gt;	name:		&lt;String&gt;	type:		&lt;GQLSTypeNode&gt;</body></comment><class><name>GQLVariableGrammarEvaluator</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLVariableGrammar</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Parser</category><attributes><package>GraphQLBeta-Parser</package></attributes></class><comment><class-id>GraphQLBeta.GQLVariableGrammarEvaluator</class-id><body>I represent a evaluator of variables assignmentsPublic API and Key Messages- variableSet- variableValue- tokenValue</body></comment><class><name>GQLDirectiveNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name arguments </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLDirectiveNode</class-id><body>I represent a directive on a request.Public API and Key Messages- arguments- name    Instance Variables	arguments:		&lt;Array&gt;	name:		&lt;String&gt;    Implementation Points</body></comment><class><name>GraphQLPlatform</name><environment>GraphQLBeta</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>instance </class-inst-vars><imports></imports><category>GraphQLBeta</category><attributes><package>GraphQLBeta</package></attributes></class><comment><class-id>GraphQLBeta.GraphQLPlatform</class-id><body>I am a class for compatibility between different types of smalltalk, like VisualWorks</body></comment><class><name>GQLTestMutationType</name><environment>GraphQLBeta</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Test-Utils</category><attributes><package>GraphQLBeta-Test-Utils</package></attributes></class><class><name>GraphQL</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GraphQLObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>rootInstance schema context </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta</category><attributes><package>GraphQLBeta</package></attributes></class><comment><class-id>GraphQLBeta.GraphQL</class-id><body>I handle a request given a schema and an entry point. For default the schema will be always in the class side of the class Query.Public API and Key Messages- createSchema: - handleRequest:- schema- schema:Internal Representation and Key Implementation Points.    Instance Variables	rootInstance:		&lt;Query&gt;	schema:		&lt;GQLSchema&gt;	validator:		&lt;GQLTypeValidator&gt;    Implementation Points</body></comment><class><name>GQLSNonNullTypeNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLSWrapTypeNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-NodesSchema</category><attributes><package>GraphQLBeta-NodesSchema</package></attributes></class><comment><class-id>GraphQLBeta.GQLSNonNullTypeNode</class-id><body>I represent a non null type.</body></comment><class><name>GQLTestQueryType</name><environment>GraphQLBeta</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>description gender rating boxOffice isBoxOffice </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Test-Utils</category><attributes><package>GraphQLBeta-Test-Utils</package></attributes></class><comment><class-id>GraphQLBeta.GQLTestQueryType</class-id><body>I represent a test query to test graphql requestPublic API and Key Messages- films- hello</body></comment><class><name>GQLTest</name><environment>GraphQLBeta</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars>schema rootInstance </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Tests-Nodes</category><attributes><package>GraphQLBeta-Tests-Nodes</package></attributes></class><class><name>GraphQLBetaTest</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>graphQL </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Tests-Nodes</category><attributes><package>GraphQLBeta-Tests-Nodes</package></attributes></class><class><name>GraphQLHeroTest</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Test-Utils</category><attributes><package>GraphQLBeta-Test-Utils</package></attributes></class><class><name>GQLSSchemaNodeTest</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Tests-Nodes</category><attributes><package>GraphQLBeta-Tests-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLSSchemaNodeTest</class-id><body>A GQLSNodeEvaluatorTest is a test class for testing the behavior of GQLSNodeEvaluator</body></comment><class><name>GQLRequestGrammarEvaluatorTest</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Tests-Grammar</category><attributes><package>GraphQLBeta-Tests-Grammar</package></attributes></class><class><name>GQLDocumentNodeTest</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Tests-Nodes</category><attributes><package>GraphQLBeta-Tests-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLDocumentNodeTest</class-id><body>A GQLDocumentNodeTest is a test class for testing the behavior of GQLDocumentNode</body></comment><class><name>GQLSchemaGrammar</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLAbstractGrammar</super><private>false</private><indexed-type>none</indexed-type><inst-vars>type listType nonNull objectType objectTypeName fieldSet fieldType field fieldName schema schemaType parameterName parameters parameter inputType ignoredSpaces listInputType enumType interfaceType unionType inputObjectType enumTypeName enumValueList interfaceTypeName unionTypeName unionValuesList fieldInputObjectSet fieldInputObject inputObjectTypeName nullValue namedType nonNullType nonNullListType nonNullNamedType baseType nonNullInputType nonNullBaseType nonNullListInputType namedInputType interfaceList </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Parser</category><attributes><package>GraphQLBeta-Parser</package></attributes></class><comment><class-id>GraphQLBeta.GQLSchemaGrammar</class-id><body>I represent the grammar of the schema.Public API and Key Messages-  booleanType- field- fieldName- fieldSet- fieldType- floatType- idType- inputType- listInputType- listType- nonNull- objectType- obectTypeName- parameter- parameterName- parameters- scalarType- schema- singleInputType- singleType- start- stringType- type</body></comment><class><name>GQLRequestGrammarEvaluator</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLRequestGrammar</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Parser</category><attributes><package>GraphQLBeta-Parser</package></attributes></class><comment><class-id>GraphQLBeta.GQLRequestGrammarEvaluator</class-id><body>I represent a evaluator of the graphql request.</body></comment><class><name>GQLOperationNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLOperationDefinitionNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>type name variableDefinitions directives selectionSet rootInstance </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLOperationNode</class-id><body>I represent an operation node of a request.Public API and Key Messages- directives- name- selectionSet- type- variableDefinitions    Instance Variables	directives:		&lt;Array&gt;	name:		&lt;String&gt;	selectionSet:		&lt;GQLSelectionSetNode&gt;	type:		&lt;GQLSTypeNode&gt;	variableDefinitions:		&lt;Array&gt;    Implementation Points</body></comment><class><name>GQLA</name><environment>GraphQLBeta</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Test-Trash</category><attributes><package>GraphQLBeta-Test-Trash</package></attributes></class><comment><class-id>GraphQLBeta.GQLA</class-id><body>Example class for testsPublic API and Key Messages- hey- heyID- id:   One simple example is simply gorgeous.	| anObject |	anObject := A new id: 1000.	anObject heyID.     Instance Variables	id:		Int</body></comment><class><name>GQLSingleAnonimousQueryEvaluatorTest</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Tests-Grammar</category><attributes><package>GraphQLBeta-Tests-Grammar</package></attributes></class><comment><class-id>GraphQLBeta.GQLSingleAnonimousQueryEvaluatorTest</class-id><body>A GQLSingleAnonimousQueryEvaluatorTest is a test class for testing the behavior of GQLSingleAnonimousQueryEvaluator</body></comment><class><name>GQLFragmentNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLDefinitionNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name typeCondition directives selectionSet </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLFragmentNode</class-id><body>I represent a fragment on the request.Public API and Key Messages- directives- name- selectionSet- typeCondition    Instance Variables	directives:		&lt;Array&gt;	name:		&lt;String&gt;	selectionSet:		&lt;GQLSelectionSetNode&gt;	typeCondition:		&lt;GQLSTypeNode&gt;</body></comment><class><name>Mutation</name><environment>GraphQLBeta</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta</category><attributes><package>GraphQLBeta</package></attributes></class><class><name>GQLContext</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GraphQLObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fragments variables operationName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta</category><attributes><package>GraphQLBeta</package></attributes></class><comment><class-id>GraphQLBeta.GQLContext</class-id><body>I represent a context on a request.Public API and Key Messages- fragments- operationName- variables Internal Representation and Key Implementation Points.    Instance Variables	fragments:		&lt;Dictionary&gt;	variables:		&lt;Dictionary&gt;</body></comment><class><name>GQLTestFilm</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GraphQLObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>id filmName rating film description gender </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Test-Utils</category><attributes><package>GraphQLBeta-Test-Utils</package></attributes></class><comment><class-id>GraphQLBeta.GQLTestFilm</class-id><body>I represent a film to test the graphql request.Public API and Key Messages- id   - initialize:name:rating:- name- rating- toDictionaryInternal Representation and Key Implementation Points.    Instance Variables	filmName:		&lt;String&gt;	id:		&lt;String&gt;	rating:		&lt;Integer&gt;Example	GQLTestFilm new: 1 name: 'Bella' rating: 7</body></comment><class><name>GQLSInputObjectFieldNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLSFieldNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-NodesSchema</category><attributes><package>GraphQLBeta-NodesSchema</package></attributes></class><comment><class-id>GraphQLBeta.GQLSInputObjectFieldNode</class-id><body>I represent a field of a input object type. My type only could be: scalar, enum or an input object.</body></comment><class><name>GQLArgumentNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLArgumentNode</class-id><body>I represent an argument on the request.Public API and Key Messages- name- name:- value- value:- executeOn:with:using:    Instance Variables	name:		&lt;String&gt;	value:		&lt;GQLValueNode&gt;</body></comment><class><name>GQLValueNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLValueNode</class-id><body>I represent a value on a request.Public API and Key Messages- value    Instance Variables	value:		&lt;String&gt;    Implementation Points</body></comment><class><name>GQLVariableNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLValueNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLVariableNode</class-id><body>I represent a variable value.</body></comment><class><name>GQLIntNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLValueNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLIntNode</class-id><body>I represent a int value.Public API and Key Messages- executeOn:with:using:    Implementation Points</body></comment><class><name>GQLBooleanNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLValueNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLBooleanNode</class-id><body>I represent a boolean value.Public API and Key Messages- executeOn:with:using:    Implementation Points</body></comment><class><name>GQLListNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLValueNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLListNode</class-id><body>I represent a list value. My value is an array of other valuesPublic API and Key Messages- executeOn:with:using:    Implementation Points</body></comment><class><name>GQLNullNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLValueNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLNullNode</class-id><body>I represent a null value on a request.</body></comment><class><name>GQLInlineFragmentNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLSelectionNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>typeCondition selectionSet </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLInlineFragmentNode</class-id><body>I represent an inline fragment on a request.Public API and Key Messages- selectionSet- typeCondition    Instance Variables	selectionSet:		&lt;GQLSelectionSetNode&gt;	typeCondition:		&lt;GQLSTypeNode&gt;    Implementation Points</body></comment><class><name>GQLObjectNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLValueNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>objectFields </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLObjectNode</class-id><body>I represent a object value. I'm a complex value, so I have object fields, like:{ name : "Juan", lastName : "Fernandez" }Public API and Key Messages- objectFields    Instance Variables	objectFields:		&lt;Array&gt;    Implementation Points</body></comment><class><name>GQLStringNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLValueNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLStringNode</class-id><body>I represent a string value.Public API and Key Messages- executeOn:with:using:    Implementation Points</body></comment><class><name>GQLDefaultDirectiveNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLDirectiveNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLDefaultDirectiveNode</class-id><body>I represent an default directive defined by GraphQL specifications.Public API and Key Messages- execute</body></comment><class><name>GQLIncludeDirectiveNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLDefaultDirectiveNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLIncludeDirectiveNode</class-id><body>I represent an include directive, my argument is only one of name 'if' and type Boolean.Public API and Key Messages- condition- isInclude</body></comment><class><name>GQLSkipDirectiveNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLDefaultDirectiveNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLSkipDirectiveNode</class-id><body>I represent a skip directive, my argument is only one of name 'if' and type Boolean.Public API and Key Messages- condition- isSkip</body></comment><class><name>Query</name><environment>GraphQLBeta</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta</category><attributes><package>GraphQLBeta</package></attributes></class><comment><class-id>GraphQLBeta.Query</class-id><body>On my class side is defined the schema text and at my instance side are defined all the methods that are called by the schema. </body></comment><class><name>GQLSNamedTypeNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLSTypeNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-NodesSchema</category><attributes><package>GraphQLBeta-NodesSchema</package></attributes></class><comment><class-id>GraphQLBeta.GQLSNamedTypeNode</class-id><body>I represent a named type. Public API and Key Messages- name- name:    Instance Variables	name:		&lt;String&gt;</body></comment><class><name>GQLSInterfaceTypeNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLSNamedTypeNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fields </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-NodesSchema</category><attributes><package>GraphQLBeta-NodesSchema</package></attributes></class><comment><class-id>GraphQLBeta.GQLSInterfaceTypeNode</class-id><body>I represent a interface type. I have fields.Public API and Key Messages- addFields:- fields- getField:   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Instance Variables	fields:		&lt;Object&gt;    Implementation Points</body></comment><class><name>GQLSEnumTypeNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLSNamedTypeNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stringValues </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-NodesSchema</category><attributes><package>GraphQLBeta-NodesSchema</package></attributes></class><comment><class-id>GraphQLBeta.GQLSEnumTypeNode</class-id><body>I represent a enum type. I have several values.Public API and Key Messages- addValues:- values    Instance Variables	stringValues:		&lt;Array&gt;    Implementation Points</body></comment><class><name>GQLSInputObjectTypeNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLSNamedTypeNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fieldSet </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-NodesSchema</category><attributes><package>GraphQLBeta-NodesSchema</package></attributes></class><comment><class-id>GraphQLBeta.GQLSInputObjectTypeNode</class-id><body>I represent a input object type. I'm a input type, used as type of an argument.Public API and Key Messages- addFields:- getField:    Instance Variables	fieldSet:		&lt;Dictionary&gt;    Implementation Points</body></comment><class><name>GQLSObjectTypeNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLSNamedTypeNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>fieldSet interfaces </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-NodesSchema</category><attributes><package>GraphQLBeta-NodesSchema</package></attributes></class><comment><class-id>GraphQLBeta.GQLSObjectTypeNode</class-id><body>I represent a object type, i have fields and maybe some interfaces.Public API and Key Messages- addFields:- fields- getField:- implements:- interfaces    Instance Variables	fieldSet:		&lt;Dictionary&gt;	interfaces:		&lt;Array&gt;    Implementation Points</body></comment><class><name>GQLSScalarTypeNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLSNamedTypeNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-NodesSchema</category><attributes><package>GraphQLBeta-NodesSchema</package></attributes></class><comment><class-id>GraphQLBeta.GQLSScalarTypeNode</class-id><body>I represent a scalar type.Public API and Key Messages- isInputTypeFor more information see my subclasses.</body></comment><class><name>GQLSFloatTypeNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLSScalarTypeNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-NodesSchema</category><attributes><package>GraphQLBeta-NodesSchema</package></attributes></class><comment><class-id>GraphQLBeta.GQLSFloatTypeNode</class-id><body>I represent a Float type.</body></comment><class><name>GQLSStringTypeNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLSScalarTypeNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-NodesSchema</category><attributes><package>GraphQLBeta-NodesSchema</package></attributes></class><comment><class-id>GraphQLBeta.GQLSStringTypeNode</class-id><body>I represent a string type.</body></comment><class><name>GQLSIntTypeNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLSScalarTypeNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-NodesSchema</category><attributes><package>GraphQLBeta-NodesSchema</package></attributes></class><comment><class-id>GraphQLBeta.GQLSIntTypeNode</class-id><body>I represent a int type.</body></comment><class><name>GQLSBooleanTypeNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLSScalarTypeNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-NodesSchema</category><attributes><package>GraphQLBeta-NodesSchema</package></attributes></class><comment><class-id>GraphQLBeta.GQLSBooleanTypeNode</class-id><body>I represent a boolean type.</body></comment><class><name>GQLSUnionTypeNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLSNamedTypeNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>namedTypes </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-NodesSchema</category><attributes><package>GraphQLBeta-NodesSchema</package></attributes></class><comment><class-id>GraphQLBeta.GQLSUnionTypeNode</class-id><body>I represent a union type and i have types.Public API and Key Messages- addTypes:- namedTypes    Instance Variables	namedTypes:		&lt;Dictionary&gt;</body></comment><class><name>GQLSListTypeNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLSWrapTypeNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-NodesSchema</category><attributes><package>GraphQLBeta-NodesSchema</package></attributes></class><comment><class-id>GraphQLBeta.GQLSListTypeNode</class-id><body>I represent a list type.</body></comment><class><name>GQLSchemaGrammarEvaluatorTest</name><environment>GraphQLBeta</environment><super>SUnit.TestCase</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Tests-Grammar</category><attributes><package>GraphQLBeta-Tests-Grammar</package></attributes></class><comment><class-id>GraphQLBeta.GQLSchemaGrammarEvaluatorTest</class-id><body>A GQLSchemaGrammarEvaluatorTest is a test class for testing the behavior of GQLSchemaGrammarEvaluator</body></comment><class><name>GQLFieldNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLSelectionNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>alias name arguments fullName </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLFieldNode</class-id><body>I represent a field on a request.Public API and Key Messages- alias- arguments- fullName- isScalar- name    Instance Variables	alias:		&lt;String&gt;	arguments:		&lt;Array&gt;	fullName:		&lt;String&gt;	name:		&lt;String&gt;    Implementation Points</body></comment><class><name>GQLScalarFieldNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLFieldNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLScalarFieldNode</class-id><body>I represent a scalar field on a request.Public API and Key Messages- isScalar</body></comment><class><name>GQLEnumNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLValueNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLEnumNode</class-id><body>I represent a enum value on the request.</body></comment><class><name>GQLNodeVisitor</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GraphQLObject</super><private>false</private><indexed-type>none</indexed-type><inst-vars>schemaContextStack schema </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Visitors</category><attributes><package>GraphQLBeta-Visitors</package></attributes></class><comment><class-id>GraphQLBeta.GQLNodeVisitor</class-id><body>I represent the validator to evaluate the document with the schema.Public API and Key Messages- initalize- schema"- visitArgumentNode:- visitDocumentNode:- visitInputValueNode:- visitObjectNode:- visitScalarNode:- visitSelectionSetNode:    Instance Variables	schema:		&lt;GQLSchema&gt;	schemaContextStack:		&lt;Stack&gt;For more information see the class GQLTypeValidator</body></comment><class><name>Person</name><environment>GraphQLBeta</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name age </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Demo</category><attributes><package>GraphQLBeta-Demo</package></attributes></class><comment><class-id>GraphQLBeta.Person</class-id><body>I am a basic object person for this demo of graphql</body></comment><class><name>GQLSIDTypeNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLSScalarTypeNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-NodesSchema</category><attributes><package>GraphQLBeta-NodesSchema</package></attributes></class><comment><class-id>GraphQLBeta.GQLSIDTypeNode</class-id><body>I represent a id type.</body></comment><class><name>GQLSchemaGrammarEvaluator</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLSchemaGrammar</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Parser</category><attributes><package>GraphQLBeta-Parser</package></attributes></class><comment><class-id>GraphQLBeta.GQLSchemaGrammarEvaluator</class-id><body>I represent a evaluator for the schema grammar.Public API and Key Messages- field- fieldSet- inputType- listInputType- listType- objectType- parameter- parameters- schema- singleInputType- singleType- start</body></comment><class><name>GQLTypeValidator</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLNodeVisitor</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Visitors</category><attributes><package>GraphQLBeta-Visitors</package></attributes></class><comment><class-id>GraphQLBeta.GQLTypeValidator</class-id><body>I represent the validator of the request with the schema. I see if the types of the request are the same of the schema.Public API and Key Messages- validate:withSchema:  - visitArgumentNode: - visitInputValueNode:- visitObjectNode:- visitScalarNode:Example	validator := GQLTypeValidator new.	res := validator validate: document withSchema: schema.</body></comment><class><name>GraphQLBetaDemoSite</name><environment>GraphQLBeta</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>graphql </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Demo</category><attributes><package>GraphQLBeta-Demo</package></attributes></class><comment><class-id>GraphQLBeta.GraphQLBetaDemoSite</class-id><body>I am a class that creates a simple demo webapp that responds to requets and create the language of graphql</body></comment><class><name>GQLSingleAnonimousQueryEvaluator</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLSingleAnonimousQueryGrammar</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Parser</category><attributes><package>GraphQLBeta-Parser</package></attributes></class><comment><class-id>GraphQLBeta.GQLSingleAnonimousQueryEvaluator</class-id><body>I represent a evaluator of the graphql query single.Public API and Key Messages- argument- arguments- booleanValue- document- enumValue- field- floatValue- intValue- listValue- nullValue- objectField- objectValue- selection- selectionSet- stringValue- variable</body></comment><class><name>Film</name><environment>GraphQLBeta</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name rating director gender </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Demo</category><attributes><package>GraphQLBeta-Demo</package></attributes></class><comment><class-id>GraphQLBeta.Film</class-id><body>I am a basic object film for this demo of graphql</body></comment><class><name>GQLFloatNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLValueNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLFloatNode</class-id><body>I represent a float value.Public API and Key Messages- executeOn:with:using:    Implementation Points</body></comment><class><name>GQLNonScalarFieldNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLFieldNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>selectionSet </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLNonScalarFieldNode</class-id><body>I represent a non scalar field. This means that I have a selectionSet. For examplefieldNonScalar{	fieldScalar}Public API and Key Messages- isScalar- selectionSet    Instance Variables	selectionSet:		&lt;GQLSelectionSetNode&gt;    Implementation Points</body></comment><class><name>GQLDocumentNode</name><environment>GraphQLBeta</environment><super>GraphQLBeta.GQLNode</super><private>false</private><indexed-type>none</indexed-type><inst-vars>operations fragments </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLBeta-Nodes</category><attributes><package>GraphQLBeta-Nodes</package></attributes></class><comment><class-id>GraphQLBeta.GQLDocumentNode</class-id><body>I represent a document. The principal node of the request.Public API and Key Messages- definitions- executeOn:with:using:    Instance Variables	definitions:		&lt;Array&gt;    Implementation Points</body></comment><methods><class-id>GraphQLBeta.GQLAbstractGrammarTest</class-id> <category>tests</category><body package="GraphQLBeta-Tests-Grammar" selector="testBooleanValue">testBooleanValue	"boolean value"	self parse: 'true' rule: #booleanValue.	self parse: 'false' rule: #booleanValue.	self fail: 'anyOtherValue' rule: #booleanValue.	self fail: '1' rule: #booleanValue.	self fail: '0' rule: #booleanValue.</body><body package="GraphQLBeta-Tests-Grammar" selector="testComma">testComma	"comma"	self parse: ',' rule: #comma.	self fail: 'any other text' rule: #comma.</body><body package="GraphQLBeta-Tests-Grammar" selector="testComment">testComment	self parse: '#some comment' rule: #comment.	self parse: '###' rule: #comment.	self fail: '#dsfd' rule: #comment.	self fail: 'asdf' rule: #comment.	self fail: ' ' rule: #comment.</body><body package="GraphQLBeta-Tests-Grammar" selector="testCommentChar">testCommentChar"	self parse: '###' rule: #commentChar."	self parse: 's' rule: #commentChar.	 '+_)(*&amp;^%$#@!~.}{:"?&gt;&lt;|\][;. 		' do: [ :each | self parse: each asString rule:  #commentChar ].	self fail: ' 	' rule: #commentChar</body><body package="GraphQLBeta-Tests-Grammar" selector="testFloatValue">testFloatValue	"float value"	self parse: '2312.12' rule: #floatValue.	self parse: '-123.23e12' rule: #floatValue.	self parse: '-123.23E12' rule: #floatValue.	self fail: '12' rule: #floatValue.	self fail: 'a123' rule: #floatValue.	self fail: '123.123a' rule: #floatValue.</body><body package="GraphQLBeta-Tests-Grammar" selector="testIgnored">testIgnored	"UnicodeBOM"	"self parse: '""' rule: #ignored."	"self fail: '""any other text but " "' rule: #ignored."	"Whitespace"	self parse: ' ' rule: #ignored.	self parse: '	' rule: #ignored.	"LineTerminator"	self parse: '' rule: #ignored.	"Comment"	self parse: '#some comment' rule: #ignored.	self parse: '###' rule: #ignored.	"comma"	self parse: ',' rule: #ignored.</body><body package="GraphQLBeta-Tests-Grammar" selector="testInsignificantToken">testInsignificantToken		'	 		' do: [ :each | self parse: each asString rule:  #insignificantToken ].</body><body package="GraphQLBeta-Tests-Grammar" selector="testIntValue">testIntValue	"int value"	self parse: '2312' rule: #intValue.	self parse: '-123' rule: #intValue.	self parse: '+444' rule: #intValue.	self fail: '123.123' rule: #intValue.	self fail: '123.123e12' rule: #intValue.</body><body package="GraphQLBeta-Tests-Grammar" selector="testLineTerminator">testLineTerminator	"LineTerminator"	self parse: '' rule: #lineTerminator.	self fail: ' ' rule: #lineTerminator.</body><body package="GraphQLBeta-Tests-Grammar" selector="testNonZeroDigit">testNonZeroDigit	self parse: '1' rule: #nonZeroDigit.	self fail: '0' rule: #nonZeroDigit.</body><body package="GraphQLBeta-Tests-Grammar" selector="testPunctuator">testPunctuator	"punctuator"	self parse: '{' rule: #punctuator.	self parse: '}' rule: #punctuator.	self parse: '...' rule: #punctuator.	self parse: '[' rule: #punctuator.	self parse: ']' rule: #punctuator.	self parse: '!' rule: #punctuator.	self parse: '$' rule: #punctuator.	self parse: '|' rule: #punctuator.	self parse: ':' rule: #punctuator.	self parse: '@' rule: #punctuator.	self parse: '=' rule: #punctuator.	self fail: 'any other character' rule: #punctuator.</body><body package="GraphQLBeta-Tests-Grammar" selector="testStringValue">testStringValue	"string value"	self parse: '""' rule: #stringValue.	self parse: '"any other kind of text +_)(*&amp;^%$#@ |}{:?&gt;&lt;][/;.,"' rule: #stringValue.	self parse: '"\u00f3 \\ \/ \b \f \n \r \t"' rule: #stringValue.	self fail: '"any other text but " "' rule: #stringValue.</body><body package="GraphQLBeta-Tests-Grammar" selector="testToken">testToken	"punctuator"	self parse: '{' rule: #punctuator.	self parse: '}' rule: #punctuator.	self parse: '...' rule: #punctuator.	self parse: '[' rule: #punctuator.	self parse: ']' rule: #punctuator.	self parse: '!' rule: #punctuator.	self parse: '$' rule: #punctuator.	self parse: '|' rule: #punctuator.	self parse: ':' rule: #punctuator.	self parse: '@' rule: #punctuator.	self parse: '=' rule: #punctuator.	"names"	self parse: '_Name23' rule: #token.	self parse: 'some_Name' rule: #token.	self parse: 'S' rule: #token.	self parse: '_' rule: #token.	"int value"	self parse: '2312' rule: #token.	self parse: '-123' rule: #token.	self parse: '+444' rule: #token.	"float value"	self parse: '2312.12' rule: #token.	self parse: '-123.23e12' rule: #token.	self parse: '-123.23E12' rule: #token.	"boolean value"	self parse: 'true' rule: #token.	self parse: 'false' rule: #token.	"string value"	self parse: '""' rule: #token.	self parse: '"any other kind of text +_)(*&amp;^%$#@ |}{:?&gt;&lt;][/;.,"' rule: #token.	self parse: '"\u00f3 \\ \/ \b \f \n \r \t"' rule: #token.</body><body package="GraphQLBeta-Tests-Grammar" selector="testTokenName">testTokenName	"names"	self parse: '_Name23' rule: #tokenName.	self parse: 'some_Name' rule: #tokenName.	self parse: 'S' rule: #tokenName.	self parse: '_' rule: #tokenName.	self fail: '' rule: #tokenName.	self fail: ' someName' rule: #tokenName.</body><body package="GraphQLBeta-Tests-Grammar" selector="testWhiteSpace">testWhiteSpace	"WhiteSpace"	self parse: ' ' rule: #whiteSpace.	self parse: '	' rule: #whiteSpace.	self fail: 'any other text but  ' rule: #whiteSpace.</body></methods><methods><class-id>GraphQLBeta.GQLAbstractGrammarTest</class-id> <category>accessing</category><body package="GraphQLBeta-Tests-Grammar" selector="parserClass">parserClass	^ GQLAbstractGrammar </body></methods><methods><class-id>GraphQLBeta.GQLSingleAnonimousQueryGrammarTest</class-id> <category>tests</category><body package="GraphQLBeta-Tests-Grammar" selector="testComposedDocument">testComposedDocument	| text |	text := '{		films { 			id 			name 			rating 		}	}'.		self parse: text rule: #document</body><body package="GraphQLBeta-Tests-Grammar" selector="testComposedDocumentWithArguments">testComposedDocumentWithArguments	| text |	text := '{		films (ids:["1", "2"]){ 			id			name 			rating (stringify: true)		}	}'.		self parse: text rule: #document</body><body package="GraphQLBeta-Tests-Grammar" selector="testComposedDocumentWithDirectives">testComposedDocumentWithDirectives	| text |		text := '{		films (ids:["1", "2"]) @skip(if : true){ 			id			name 			rating (stringify: true)		}	}'.		self parse: text rule: #document</body><body package="GraphQLBeta-Tests-Grammar" selector="testComposedDocumentWithFragments">testComposedDocumentWithFragments	| text |	text := '{		films (ids:["1", "2"]) @skip(if : true){ 			id			name 			rating (stringify: true)		}	}	fragment filmFeatures on Film { 		rating(stringify: true)		name	}	'.		self parse: text rule: #document</body><body package="GraphQLBeta-Tests-Grammar" selector="testComposedDocumentWithInlineFragments">testComposedDocumentWithInlineFragments	| text |	text := '{		films (ids:["1", "2"]) @skip(if : true){ 			id			... {				rating(stringify: true)				name			}		}	}	'.		self parse: text rule: #document</body><body package="GraphQLBeta-Tests-Grammar" selector="testComposedDocumentWithInlineFragmentsDirectives">testComposedDocumentWithInlineFragmentsDirectives	| text |	text := '{		films (ids:["1", "2"]) @skip(if : true){ 			id			... on Film @skip(if:true) @include(if:true){				rating(stringify: true)				name			}		}	}	'.		self parse: text rule: #document</body><body package="GraphQLBeta-Tests-Grammar" selector="testComposedDocumentWithInlineFragmentsType">testComposedDocumentWithInlineFragmentsType	| text |	text := '{		films (ids:["1", "2"]) @skip(if : true){ 			id			... on Film{				rating(stringify: true)				name			}		}	}	'.		self parse: text rule: #document</body><body package="GraphQLBeta-Tests-Grammar" selector="testComposedDocumentWithSpreadFragments">testComposedDocumentWithSpreadFragments	| text |	text := '{		films (ids:["1", "2"]) @skip(if : true){ 			id			...filmFeatures @include(if : true)		}	}	fragment filmFeatures on Film { 		rating(stringify: true)		name	}	'.		self parse: text rule: #document</body><body package="GraphQLBeta-Tests-Grammar" selector="testSimpleDocument">testSimpleDocument	| text |	text := '{  			firstName  			lastName		}'.		self parse: text rule: #document.</body><body package="GraphQLBeta-Tests-Grammar" selector="testSimpleDocumentWithArguments">testSimpleDocumentWithArguments	| text |	text := '{  			firstName (upercase:true)  			lastName		}'.		self parse: text rule: #document.</body><body package="GraphQLBeta-Tests-Grammar" selector="testSimpleDocumentWithDirectives">testSimpleDocumentWithDirectives	| text |	text := '{  			firstName (upercase:true) @include(if : true)  			lastName		}'.		self parse: text rule: #document.</body><body package="GraphQLBeta-Tests-Grammar" selector="testSimpleDocumentWithFragments">testSimpleDocumentWithFragments	| text |	text := '{  			firstName (upercase:true) @include(if : true)  			lastName		}		fragment names on Person{			firstName (upercase:true) @include(if : true)  			lastName		}		fragment first on Person{			name		}		'.		self parse: text rule: #document.</body><body package="GraphQLBeta-Tests-Grammar" selector="testSimpleDocumentWithInlineFragment">testSimpleDocumentWithInlineFragment	| text |	text := '{  			...{			firstName (upercase:true) @include(if : true)  			lastName			name			}		}'.		self parse: text rule: #document.</body><body package="GraphQLBeta-Tests-Grammar" selector="testSimpleDocumentWithInlineFragmentDirectives">testSimpleDocumentWithInlineFragmentDirectives	| text |	text := '{  			... @skip(if:true){			firstName (upercase:true) @include(if : true)  			lastName			name			}		}'.		self parse: text rule: #document.</body><body package="GraphQLBeta-Tests-Grammar" selector="testSimpleDocumentWithInlineFragmentType">testSimpleDocumentWithInlineFragmentType	| text |	text := '{  			... on Person{			firstName (upercase:true) @include(if : true)  			lastName			name			}		}'.		self parse: text rule: #document.</body><body package="GraphQLBeta-Tests-Grammar" selector="testSimpleDocumentWithSpreadFragments">testSimpleDocumentWithSpreadFragments	| text |	text := '{  			...names		}		fragment names on Person{			firstName (upercase:true) @include(if : true)  			lastName			...name @skip(if : true)		}		fragment first on Person{			name		}		'.		self parse: text rule: #document.</body></methods><methods><class-id>GraphQLBeta.GQLSingleAnonimousQueryGrammarTest</class-id> <category>accessing</category><body package="GraphQLBeta-Tests-Grammar" selector="parserClass">parserClass	^ GQLSingleAnonimousQueryGrammar </body></methods><methods><class-id>GraphQLBeta.GQLIQueryType</class-id> <category>accessing</category><body package="GraphQLBeta-Test-Trash" selector="a">a	^ GQLA new id: 1.</body><body package="GraphQLBeta-Test-Trash" selector="aId:">aId: aID	^ GQLA new id: aID</body><body package="GraphQLBeta-Test-Trash" selector="anGqla:">anGqla: aGQLA	^ aGQLA.</body><body package="GraphQLBeta-Test-Trash" selector="hello">hello ^ #helloWorld</body><body package="GraphQLBeta-Test-Trash" selector="helloName:">helloName: aString	^ #hello , aString.</body><body package="GraphQLBeta-Test-Trash" selector="sumNums:">sumNums: aCollection	^ aCollection reduce: [ :a :b | a + b ].</body></methods><methods><class-id>GraphQLBeta.GQLFilm</class-id> <category>accessing</category><body package="GraphQLBeta-Test-Utils" selector="filmName">filmName	^ filmName</body><body package="GraphQLBeta-Test-Utils" selector="filmName:">filmName: aFilmName	filmName := aFilmName </body><body package="GraphQLBeta-Test-Utils" selector="initialize:">initialize: aName	filmName := aName</body><body package="GraphQLBeta-Test-Utils" selector="initialize:id:">initialize: aName id: aId	filmName := aName.	id := aId</body></methods><methods><class-id>GraphQLBeta.GQLFilm</class-id> <category>as yet unclassified</category><body package="GraphQLBeta-Test-Utils" selector="getFilmName:">getFilmName: aFilmName	^ aFilmName </body><body package="GraphQLBeta-Test-Utils" selector="id">id	^ id</body></methods><methods><class-id>GraphQLBeta.GraphQLBenchmark</class-id> <category>accessing</category><body package="GraphQLBeta-Test-Benchmark" selector="queryPoints">queryPoints	^ self class objects</body><body package="GraphQLBeta-Test-Benchmark" selector="queryRectangles">queryRectangles	^ self class objects</body></methods><methods><class-id>GraphQLBeta.GraphQLBenchmark class</class-id> <category>benchmarking</category><body package="GraphQLBeta-Test-Benchmark" selector="benchmarkPoints:query:">benchmarkPoints: numberOfPoints query: query	| g res result |	g := GraphQL new.	g rootInstance: self new.	g createSchema: self schema.	result := g handleRequest: query.	res := result at: 'queryPoints'.	self		assert: res size = numberOfPoints.	result := GraphQLPlatform current toJson: result.	self assert: result isString.		</body><body package="GraphQLBeta-Test-Benchmark" selector="benchmarkRectangles:query:">benchmarkRectangles: numberOfRectangles query: query	| g res result |	g := GraphQL new.	g rootInstance: self new.	g createSchema: self schema.	result := g handleRequest: query.	res := result at: 'queryRectangles'.	self		assert: res size = numberOfRectangles.	result := GraphQLPlatform current toJson: result.	self assert: result isString.		</body><body package="GraphQLBeta-Test-Benchmark" selector="benchmarkTimePoints:query:">benchmarkTimePoints: numberOfPoints query: query	"for an array with numberOfPoints instances of points"	"self benchmarkTimePoints: 1000000 query: '{queryPoints}' "	self lastSize = numberOfPoints 		ifFalse: [ self initializePoints: numberOfPoints ].	self cleanMemory.	Transcript		cr;		"show: 'Bench01 for: ';		show: numberOfPoints;		show: ' points';		cr;		show: 'Time: ';"		show: [ self benchmarkPoints: numberOfPoints query: query ] timeToRun asSeconds</body><body package="GraphQLBeta-Test-Benchmark" selector="benchmarkTimeRectangles:query:">benchmarkTimeRectangles: numberOfRectangles query: query	"for an array with numberOfRectangles instances of points"	"self benchmarkTimePoints: 1000000 query: '{queryPoints}' "	self lastSize = numberOfRectangles 		ifFalse: [ self initializeRectangles: numberOfRectangles ].	self cleanMemory.	Transcript		cr;		"show: 'Bench02 for: ';		show: numberOfRectangles;		show: ' rectangles';		cr;		show: 'Time: ';"		show: [ self benchmarkRectangles: numberOfRectangles query: query ] timeToRun asSeconds</body></methods><methods><class-id>GraphQLBeta.GraphQLBenchmark class</class-id> <category>accessing</category><body package="GraphQLBeta-Test-Benchmark" selector="lastSize">lastSize	^ lastSize ifNil: [ 0 ].</body><body package="GraphQLBeta-Test-Benchmark" selector="objects">objects	^ objects</body><body package="GraphQLBeta-Test-Benchmark" selector="schema">schema"The text of the schema"	^ '	type GraphQLBenchmark{		queryPoints: [ Point ]		queryRectangles: [ Rectangle ]	},	type Rectangle{		origin: Point		corner: Point	},	type Point{		x : Float		y : Float	}'</body></methods><methods><class-id>GraphQLBeta.GQLAbstractGrammar</class-id> <category>accessing</category><body package="GraphQLBeta-Parser" selector="booleanType">booleanType	"Return a token of a parser accepting Boolean"	^ ('Boolean' asParser , #word asParser not , $_ asParser not) token</body><body package="GraphQLBeta-Parser" selector="floatType">floatType"Return a token of parser Float"	^ ('Float' asParser , #word asParser not , $_ asParser not) token</body><body package="GraphQLBeta-Parser" selector="idType">idType"Return a token of parser ID"		^ ('ID' asParser , #word asParser not , $_ asParser not) token</body><body package="GraphQLBeta-Parser" selector="intType">intType"Return a token of parse Int"	^ ('Int' asParser , #word asParser not , $_ asParser not) token</body><body package="GraphQLBeta-Parser" selector="nullValue">nullValue"Return a token of parsing: null"	^ 'null' asParser token</body><body package="GraphQLBeta-Parser" selector="scalarType">scalarType"Return a parser accepting:intTypefloatTypestringTypebooleanTypeidType"	^ intType / floatType / stringType / booleanType / idType</body><body package="GraphQLBeta-Parser" selector="stringType">stringType"Return a token of parse String"	^ ('String' asParser , #word asParser not , $_ asParser not) token</body></methods><methods><class-id>GraphQLBeta.GQLAbstractGrammar</class-id> <category>grammar</category><body package="GraphQLBeta-Parser" selector="booleanValue">booleanValue	"Return a token accepting true or false"	^ ('true' asParser / 'false' asParser)		flatten token</body><body package="GraphQLBeta-Parser" selector="comma">comma	"Return a parser accepting the comma"	^ $, asParser</body><body package="GraphQLBeta-Parser" selector="comment">comment	"Return a parser accepting the char # followed by a parser accepting the list of comment chars"	^ $# asParser , commentChar star</body><body package="GraphQLBeta-Parser" selector="commentChar">commentChar	"Return a parser that succes when fails accepting the newline and followed by a parser accepting the sourceCharacter"	^ #newline asParser not , sourceCharacter</body><body package="GraphQLBeta-Parser" selector="digit">digit"Return a parser accepting a digit"	^ #digit asParser</body><body package="GraphQLBeta-Parser" selector="escapedCharacter">escapedCharacter	"Return a parser accepting all the characters associated with a escape, like: \t \r"	^ $" asParser / $\ asParser / $/ asParser		/ $b asParser / $f asParser / $n asParser		/ $r asParser / $t asParser</body><body package="GraphQLBeta-Parser" selector="escapedUnicode">escapedUnicode"Return a parser accepting word four times"	^ #word asParser times: 4</body><body package="GraphQLBeta-Parser" selector="exponentIndicator">exponentIndicator"Return a parser accepting the char e or the char E"	^ $e asParser / $E asParser</body><body package="GraphQLBeta-Parser" selector="exponentPart">exponentPart	"Return a parser accepting a exponentIndicator follow by a parser accepting a optional sign follow by a parser accepting a list of digits"	^ exponentIndicator , sign optional		, digit plus</body><body package="GraphQLBeta-Parser" selector="floatValue">floatValue	"Return a parser accepting:	- integerPart fractionalPart exponentPart	- integerPart fractionalPart	- integerPart exponentPart"	^ (integerPart , fractionalPart		, exponentPart) flatten token		/			(integerPart , fractionalPart) flatten token		/ (integerPart , exponentPart) flatten token	"^ integerPart , ((fractionalPart , exponentPart) / fractionalPart / exponentPart )"</body><body package="GraphQLBeta-Parser" selector="fractionalPart">fractionalPart"Return a parser accepting . followed by a parser accepting one or more digits"	^ $. asParser , digit plus</body><body package="GraphQLBeta-Parser" selector="ignored">ignored	"Return the parsers accepting the list of things we want to ignore"	^ comment / lineTerminator / unicodeBOM		/ whiteSpace / comma</body><body package="GraphQLBeta-Parser" selector="insignificantToken">insignificantToken	"Return a parser accepting the list of insignificant token"	^ whiteSpace / comment / lineTerminator</body><body package="GraphQLBeta-Parser" selector="integerPart">integerPart	"Return a parser accepting:	- sign optional 0	- sign optional nonZero digitList"	^ sign optional		, ($0 asParser / (nonZeroDigit , digit star))</body><body package="GraphQLBeta-Parser" selector="intValue">intValue	"Return a token representing the integerPart"	^ integerPart flatten token</body><body package="GraphQLBeta-Parser" selector="lineTerminator">lineTerminator 	"New Line (U+000A)	Carriage Return (U+000D)New Line (U+000A)	Carriage Return (U+000D)New Line (U+000A)"	^ #newline asParser </body><body package="GraphQLBeta-Parser" selector="nonZeroDigit">nonZeroDigit	"Return a parser that succes when fails accepting the $0 and followed by a parser accepting the digit"	^ $0 asParser not , digit</body><body package="GraphQLBeta-Parser" selector="punctuator">punctuator"Return a parser accepting one of! $ ( ) ... : = @ [ ] { | }"	^ $! asParser / $$ asParser / $( asParser		/ $) asParser / '...' asParser		/ $: asParser / $= asParser		/ $@ asParser / $[ asParser		/ $] asParser / ${ asParser		/ $| asParser / $} asParser</body><body package="GraphQLBeta-Parser" selector="sign">sign	"Return a parser accepting the char + or -"	^ $+ asParser / $- asParser</body><body package="GraphQLBeta-Parser" selector="sourceCharacter">sourceCharacter	"/[\u0009\u000A\u000D\u0020-\uFFFF]/ "	^ #any asParser</body><body package="GraphQLBeta-Parser" selector="start">start	"Return a parser accepting the sourceCharacter and success at the end of the input"	^ sourceCharacter end</body><body package="GraphQLBeta-Parser" selector="stringCharacter">stringCharacter	"Return a parser accepting:	- SourceCharacter but not stringDelimiter or  \	- \u escapedUnicode	- \ escapedCharacter"	^ (stringDelimiter not , $\ asParser not		, sourceCharacter)		/ ('\u' asParser , escapedUnicode)		/ ('\' asParser , escapedCharacter)</body><body package="GraphQLBeta-Parser" selector="stringDelimiter">stringDelimiter	"Return a parser accepting the quotation symbol"	^ $" asParser</body><body package="GraphQLBeta-Parser" selector="stringValue">stringValue	"Return a parser accepting a string delimited by quotation symbol"	^ (stringDelimiter , stringCharacter star		, stringDelimiter) flatten token</body><body package="GraphQLBeta-Parser" selector="token">token	"Return the parser that accepts the lexical tokens: a punctuator or tokename or float value or int value or string value"	^ punctuator / tokenName / floatValue		/ intValue / stringValue</body><body package="GraphQLBeta-Parser" selector="tokenName">tokenName	"Return a parser accepting: _ letter _ wordList"	^ ($_ asParser / #letter asParser		, ($_ asParser / #word asParser) star)		flatten token</body><body package="GraphQLBeta-Parser" selector="unicodeBOM">unicodeBOM	"Byte Order Mark (U+FEFF)"	^ 'U+FEFF' asParser  </body><body package="GraphQLBeta-Parser" selector="whiteSpace">whiteSpace	"Horizontal Tab (U+0009)	 Space (U+0020)"	^ #blank asParser</body></methods><methods><class-id>GraphQLBeta.GQLRequestGrammar</class-id> <category>grammar</category><body package="GraphQLBeta-Parser" selector="alias">alias"Return a parser accepting: tokenName :"	^ (tokenName trimRight: insignificantToken)		, ($: asParser trim: insignificantToken)</body><body package="GraphQLBeta-Parser" selector="directives">directives	"Return a parser accepting:	Directive+"	^ (directive trim: ignored) plus</body><body package="GraphQLBeta-Parser" selector="field">field	"Return a parser accepting:	nonScalarField	scalarField"	^ nonScalarField / scalarField </body><body package="GraphQLBeta-Parser" selector="fragmentSpread">fragmentSpread"Return a parser accepting: ... FragmentName DirectivesOptional"	^ '...' asParser , (fragmentName trim: ignored)		, directives optional</body><body package="GraphQLBeta-Parser" selector="listType">listType"Return a parser accepting:[ type ]"	^ ($[ asParser trimRight: ignored) , (type trimRight: ignored) , ($] asParser trimRight: insignificantToken)</body><body package="GraphQLBeta-Parser" selector="named">named"Return a name"	^ tokenName </body><body package="GraphQLBeta-Parser" selector="namedType">namedType"Return a parser accepting:	-scalarType	-named"	^ scalarType / named</body><body package="GraphQLBeta-Parser" selector="nonNullListType">nonNullListType"Return a parser accepting:- listType !"	^ listType, $! asParser</body><body package="GraphQLBeta-Parser" selector="nonNullNamedType">nonNullNamedType"Return a parser accepting:- namedType !"	^ (namedType trim: ignored) , ($! asParser)</body><body package="GraphQLBeta-Parser" selector="nonNullType">nonNullType"Return a parser accepting:- nonNullNamedType- nonNullListType"	^ (nonNullNamedType / nonNullListType) trim: insignificantToken </body><body package="GraphQLBeta-Parser" selector="nonScalarField">nonScalarField"Return a parser accepting:- aliasOptional tokenName argumentsOptional directivesOptional selectionSet"	^ alias optional		, (tokenName trimRight: insignificantToken)		,			(arguments optional				trimRight: insignificantToken)		,			(directives optional				trimRight: insignificantToken),			(selectionSet trimRight: insignificantToken)</body><body package="GraphQLBeta-Parser" selector="objectField">objectField"Return a parser accepting: tokenName : value"	^ tokenName		, ($: asParser trim: insignificantToken)		, value</body><body package="GraphQLBeta-Parser" selector="operation">operation"Return a parser accepting:- operationType tokenName variableDefinitionsOptional directivesOptional selectionSet"	^ operationType , whiteSpace plus				, tokenName optional				,					(variableDefinitions optional						trim: insignificantToken)				,					(directives optional						trimRight: insignificantToken)				, (selectionSet trimRight: insignificantToken)</body><body package="GraphQLBeta-Parser" selector="operationDefinition">operationDefinition"Return a parser accepting:- selection set- operation"	^ selectionSet / operation</body><body package="GraphQLBeta-Parser" selector="scalarField">scalarField"Return a parser accepting:aliasOptional tokenName argumentsOptional directivesOptional"	^ alias optional		, (tokenName trimRight: insignificantToken)		,			(arguments optional				trimRight: insignificantToken)		,			(directives optional				trimRight: insignificantToken)</body><body package="GraphQLBeta-Parser" selector="selectionSet">selectionSet	"Return a parser accepting:  { Selection+ }"	^ ${ asParser		, (selection trim: ignored) plus		, $} asParser</body><body package="GraphQLBeta-Parser" selector="variableDefinitions">variableDefinitions"Return a parser accepting:( variableDefinition+ )"	^ $( asParser , (((variableDefinition trim: insignificantToken)  separatedBy: comma))		, $) asParser</body></methods><methods><class-id>GraphQLBeta.GQLRequestGrammar</class-id> <category>accessing</category><body package="GraphQLBeta-Parser" selector="argument">argument"Return a parser accepting:tokenName : Value"	^ tokenName		, ($: asParser trim: insignificantToken)		, value</body><body package="GraphQLBeta-Parser" selector="arguments">arguments	"Return a parser accepting:( Argument+ )"	^ ($( asParser trimRight: ignored)		, (argument trimRight: ignored) plus		, $) asParser</body><body package="GraphQLBeta-Parser" selector="defaultValue">defaultValue"Return a parser accepting:= value"	^ ($= asParser trimRight: insignificantToken) , value</body><body package="GraphQLBeta-Parser" selector="definition">definition	"Return a parser accepting operationDefinition or fragmentDefinition"	^ operationDefinition / fragmentDefinition</body><body package="GraphQLBeta-Parser" selector="directive">directive"Return a parser accepting:@ tokenName ArgumentsOptional"	^ $@ asParser		, (tokenName trimRight: insignificantToken)		, arguments optional</body><body package="GraphQLBeta-Parser" selector="document">document	"Return a parser accepting one or more definitions"	^ definition plus</body><body package="GraphQLBeta-Parser" selector="enumValue">enumValue"Return a parser accepting a tokenName but not a booleanValue or null"	^ (booleanValue not , nullValue not		, tokenName) flatten token</body><body package="GraphQLBeta-Parser" selector="fragmentDefinition">fragmentDefinition"Return a parser accepting:fragment fragmentName typeCondition directiveOptional selectionSet"	^ 'fragment' asParser , whiteSpace plus,		 (fragmentName trimRight: insignificantToken),		 (typeCondition trimRight: insignificantToken),		 (directives optional				trimRight: insignificantToken),		 (selectionSet trimRight: insignificantToken)</body><body package="GraphQLBeta-Parser" selector="fragmentName">fragmentName"Return a parser accepting a token name but not on"	^ ('on' asParser not) , tokenName</body><body package="GraphQLBeta-Parser" selector="inlineFragment">inlineFragment"Return a parser accepting:... typeConditionOptional directivesOptional selectionSet"	^ ('...' asParser trimRight: insignificantToken)		, (typeCondition optional trimRight: insignificantToken)		, (directives optional trimRight: insignificantToken) , selectionSet</body><body package="GraphQLBeta-Parser" selector="listValue">listValue	"Return a parser accepting:	[]	[ Value* ]"	^ ($[ asParser trimRight: ignored)		, (value trimRight: ignored) star		, $] asParser token</body><body package="GraphQLBeta-Parser" selector="objectValue">objectValue	"Return a parser accepting: - { } - { ObjectField* }"	^ (${ asParser trimRight: ignored)		, (objectField trimRight: ignored) star		, $} asParser token</body><body package="GraphQLBeta-Parser" selector="operationType">operationType"Return a parser accepting:- query- mutation"	^ 'query' asParser / 'mutation' asParser</body><body package="GraphQLBeta-Parser" selector="selection">selection"Return a token for a field or fragmentSpread or inlineFragment"	^ (field / fragmentSpread / inlineFragment)</body><body package="GraphQLBeta-Parser" selector="start">start	"Return a parser accepting a document, transform this to a token and then end the input"	^ document end</body><body package="GraphQLBeta-Parser" selector="type">type"Return a parser accepting:- nonNullType- namedType- listType"	^ nonNullType / namedType / listType</body><body package="GraphQLBeta-Parser" selector="typeCondition">typeCondition"Return a parser accepting:on namedType"	^ 'on' asParser , whiteSpace plus , namedType</body><body package="GraphQLBeta-Parser" selector="value">value	"[~Const]Variable IntValue FloatValue StringValue BooleanValue 	 NullValue EnumValue ListValue[~Const] ObjectValue[~Const]"		^ variable / floatValue / intValue / stringValue / booleanValue / nullValue / enumValue / listValue /  objectValue</body><body package="GraphQLBeta-Parser" selector="variable">variable"Return a token input from parse:$ tokenName"	^ ($$ asParser , tokenName) flatten token</body><body package="GraphQLBeta-Parser" selector="variableDefinition">variableDefinition"Return a parser accepting:variable : type defaultValueOptional"	^ variable , ($: asParser trim: insignificantToken) , (type trimRight: insignificantToken)		, defaultValue optional</body></methods><methods><class-id>GraphQLBeta.GQLSingleAnonimousQueryGrammar</class-id> <category>accessing</category><body package="GraphQLBeta-Parser" selector="document">document"Return a definition"	^  (definition trim: insignificantToken) plus</body><body package="GraphQLBeta-Parser" selector="selection">selection"Return a field or fragmentSpread"	^ field / fragmentSpread / inlineFragment</body><body package="GraphQLBeta-Parser" selector="selectionSet">selectionSet"Return a parser accepting:{ selection+ }"	^ ${ asParser		, (selection trim: ignored) plus		, $} asParser</body><body package="GraphQLBeta-Parser" selector="start">start"Return a parser accepting a document and then the end of the input"	^ document end</body></methods><methods><class-id>GraphQLBeta.GQLVariableGrammar</class-id> <category>accessing</category><body package="GraphQLBeta-Parser" selector="start">start	"Return a parser accepting the variableSet and success at the end of the input"	^ variableSet end</body><body package="GraphQLBeta-Parser" selector="tokenValue">tokenValue	"[~Const] IntValue FloatValue StringValue BooleanValue 	 NullValue EnumValue ListValue[~Const] ObjectValue[~Const]"		^ floatValue / intValue / stringValue / booleanValue / nullValue / enumValue / listValue /  objectValue</body></methods><methods><class-id>GraphQLBeta.GQLVariableGrammar</class-id> <category>grammar</category><body package="GraphQLBeta-Parser" selector="variableSet">variableSet	"Return a parser accepting:  { Variable+ }"	^ ${ asParser 		, (variableValue trim: ignored) plus		, $} asParser</body><body package="GraphQLBeta-Parser" selector="variableValue">variableValue	"Return a parser accepting:	stringValue : tokenValue"	^ (stringValue trimRight: insignificantToken)		, ($: asParser trimRight: insignificantToken)		, (tokenValue trimRight: insignificantToken)</body></methods><methods><class-id>GraphQLBeta.GQLSelectionSetNodeTest</class-id> <category>tests-accessing</category><body package="GraphQLBeta-Tests-Nodes" selector="testCollectFieldsDistintComposed">testCollectFieldsDistintComposed	| res |	objectNode1 name: 'film'.	innerEscalar := Array with: (GQLFieldNode new name: 'name').	objectNode1 selectionSet: (GQLSelectionSetNode new selections: innerEscalar).		objectNode2 name: 'allFilms'.	innerEscalar := Array with: (GQLFieldNode new name: 'rating').	objectNode2 selectionSet: (GQLSelectionSetNode new selections: innerEscalar).	selectionSet selections: (Array with: objectNode1 with: objectNode2).		res := selectionSet collectFields: context.	self assert: res keys size equals: 2.</body><body package="GraphQLBeta-Tests-Nodes" selector="testCollectFieldsDistintSimple">testCollectFieldsDistintSimple	| res |	field1 name: 'hello'.	field2 name: 'text'.	selectionSet selections: (Array with: field1 with: field2).		res := selectionSet collectFields: context.	self assert: res keys size equals: 2.</body><body package="GraphQLBeta-Tests-Nodes" selector="testCollectFieldsSameComposed">testCollectFieldsSameComposed	| res |	objectNode1 name: 'film'.	innerEscalar := Array with: (GQLFieldNode new name: 'name').	objectNode1 selectionSet: (GQLSelectionSetNode new selections: innerEscalar).		objectNode2 name: 'film'.	innerEscalar := Array with: (GQLFieldNode new name: 'rating').	objectNode2 selectionSet: (GQLSelectionSetNode new selections: innerEscalar).		selectionSet selections: (Array with: objectNode1 with: objectNode2).		res := selectionSet collectFields: context.	self assert: res keys size equals: 1.</body><body package="GraphQLBeta-Tests-Nodes" selector="testCollectFieldsSameSimple">testCollectFieldsSameSimple	| res |	field1 name: 'hello'.	field2 name: 'hello'.	selectionSet selections: (Array with: field1 with: field2).		res := selectionSet collectFields: context.	self assert: res keys size equals: 1.</body><body package="GraphQLBeta-Tests-Nodes" selector="testFailCollectFieldsComposed">testFailCollectFieldsComposed	| res argument |	argument := GQLArgumentNode new name: 'id'; value: '1'.	objectNode1 name: 'film'; arguments: (Array with: argument).	innerEscalar := Array with: (GQLFieldNode new name: 'name').	objectNode1 selectionSet: (GQLSelectionSetNode new selections: innerEscalar).		objectNode2 name: 'film'.	innerEscalar := Array with: (GQLFieldNode new name: 'rating').	objectNode2 selectionSet: (GQLSelectionSetNode new selections: innerEscalar).	selectionSet selections: (Array with: objectNode1 with: objectNode2).		self should: [ selectionSet collectFields: context ] raise: GQLException.</body><body package="GraphQLBeta-Tests-Nodes" selector="testFailCollectFieldsSimple">testFailCollectFieldsSimple	| argument |	argument := GQLArgumentNode new name: 'id'; value: '4'.	field1 name: 'hello';			arguments: (Array with: argument).	field2 name: 'hello'.	selectionSet selections: (Array with: field1 with: field2).		self should: [ selectionSet collectFields: context. ] raise: GQLException.</body><body package="GraphQLBeta-Tests-Nodes" selector="testFailSameShapeWithNonScalarFieldArguments">testFailSameShapeWithNonScalarFieldArguments	| argument |	argument := GQLArgumentNode new name: 'id'; value: '1'.	objectNode1 name: 'film'; arguments: (Array with: argument).	innerEscalar := Array with: (GQLFieldNode new name: 'name').	objectNode1 selectionSet: (GQLSelectionSetNode new selections: innerEscalar).		argument := GQLArgumentNode new name: 'id'; value: '2'.	objectNode2 name: 'film'; arguments: (Array with: argument).	innerEscalar := Array with: (GQLFieldNode new name: 'rating').	objectNode2 selectionSet: (GQLSelectionSetNode new selections: innerEscalar).		self deny: (selectionSet sameShape: objectNode1  with: objectNode2).</body><body package="GraphQLBeta-Tests-Nodes" selector="testFailSameShapeWithScalarFieldArguments">testFailSameShapeWithScalarFieldArguments	| argument |	argument := GQLArgumentNode new name: 'id'; value: '4'.	field1 name: 'hello';			arguments: (Array with: argument).	argument := GQLArgumentNode new name: 'id'; value: '2'.	field2 name: 'hello';			arguments: (Array with: argument).	selectionSet selections: (Array with: field1 with: field2).	self deny: (selectionSet sameShape: field1  with: field2).</body><body package="GraphQLBeta-Tests-Nodes" selector="testMergeSelectionSetWith">testMergeSelectionSetWith	objectNode1 name: 'film'.	innerEscalar := Array with: (GQLFieldNode new name: 'name').	objectNode1 selectionSet: (GQLSelectionSetNode new selections: innerEscalar).		objectNode2 name: 'film'.	innerEscalar := Array with: (GQLFieldNode new name: 'rating').	objectNode2 selectionSet: (GQLSelectionSetNode new selections: innerEscalar).		selectionSet mergeSelectionSet: objectNode1  with: objectNode2 .		self assert:  objectNode1 selectionSet selections size equals: 2.</body><body package="GraphQLBeta-Tests-Nodes" selector="testSameShapeWithNonScalarField">testSameShapeWithNonScalarField	objectNode1 name: 'film'.	innerEscalar := Array with: (GQLFieldNode new name: 'name').	objectNode1 selectionSet: (GQLSelectionSetNode new selections: innerEscalar).		objectNode2 name: 'film'.	innerEscalar := Array with: (GQLFieldNode new name: 'rating').	objectNode2 selectionSet: (GQLSelectionSetNode new selections: innerEscalar).		self assert: (selectionSet sameShape: objectNode1  with: objectNode2).</body><body package="GraphQLBeta-Tests-Nodes" selector="testSameShapeWithNonScalarFieldArguments">testSameShapeWithNonScalarFieldArguments	| argument |	argument := GQLArgumentNode new name: 'id'; value: '1'.	objectNode1 name: 'film'; arguments: (Array with: argument).	innerEscalar := Array with: (GQLFieldNode new name: 'name').	objectNode1 selectionSet: (GQLSelectionSetNode new selections: innerEscalar).		objectNode2 name: 'film'; arguments: (Array with: argument).	innerEscalar := Array with: (GQLFieldNode new name: 'rating').	objectNode2 selectionSet: (GQLSelectionSetNode new selections: innerEscalar).		self assert: (selectionSet sameShape: objectNode1  with: objectNode2).</body><body package="GraphQLBeta-Tests-Nodes" selector="testSameShapeWithScalarField">testSameShapeWithScalarField	field1 name: 'hello'.	field2 name: 'hello'.	selectionSet selections: (Array with: field1 with: field2).	self assert: (selectionSet sameShape: field1  with: field2).</body><body package="GraphQLBeta-Tests-Nodes" selector="testSameShapeWithScalarFieldArguments">testSameShapeWithScalarFieldArguments	| argument |	argument := GQLArgumentNode new name: 'id'; value: '4'.	field1 name: 'hello';			arguments: (Array with: argument).	field2 name: 'hello';			arguments: (Array with: argument).	selectionSet selections: (Array with: field1 with: field2).	self assert: (selectionSet sameShape: field1  with: field2).</body></methods><methods><class-id>GraphQLBeta.GQLSelectionSetNodeTest</class-id> <category>running</category><body package="GraphQLBeta-Tests-Nodes" selector="setUp">setUp	selectionSet := GQLSelectionSetNode new.	objectNode1 := GQLNonScalarFieldNode new.	objectNode2 := GQLNonScalarFieldNode new.	field1 := GQLScalarFieldNode new.	field2 := GQLScalarFieldNode new.	context := GQLContext new.</body></methods><methods><class-id>GraphQLBeta.GQLFieldNodeTest</class-id> <category>utils</category><body package="GraphQLBeta-Tests-Nodes" selector="doubleIncludeDirective:">doubleIncludeDirective: aValue	| directive |	directive := (self includeDirective: aValue) first.	^ Array with: directive with: directive</body><body package="GraphQLBeta-Tests-Nodes" selector="doubleSkipDirective:">doubleSkipDirective: aValue	| directive |	directive := (self skipDirective: aValue) first.	^ Array with: directive with: directive</body><body package="GraphQLBeta-Tests-Nodes" selector="includeDirective:">includeDirective: aValue	| directive |	directive := GQLIncludeDirectiveNode new.	directive arguments first value value: aValue asString.	^ Array with: directive</body><body package="GraphQLBeta-Tests-Nodes" selector="includeDirective:skipDirective:">includeDirective: firstValue skipDirective: secondValue	| directiveI directiveS |	directiveI := (self includeDirective: firstValue) first.	directiveS := (self skipDirective: secondValue) first.	^ Array with: directiveI with: directiveS</body><body package="GraphQLBeta-Tests-Nodes" selector="negatedIncludeDirectives">negatedIncludeDirectives	^ Array with: (self includeDirective: true) first with: (self includeDirective: false) first</body><body package="GraphQLBeta-Tests-Nodes" selector="negatedSkipDirectives">negatedSkipDirectives	^ Array with: (self skipDirective: false) first with: (self skipDirective: true) first</body><body package="GraphQLBeta-Tests-Nodes" selector="skipDirective:">skipDirective: aValue	| directive |	directive := GQLSkipDirectiveNode new.	directive arguments first value value: aValue asString.	^ Array with: directive</body><body package="GraphQLBeta-Tests-Nodes" selector="skipDirective:includeDirective:">skipDirective: secondValue includeDirective: firstValue	| directiveI directiveS |	directiveI := (self includeDirective: firstValue) first.	directiveS := (self skipDirective: secondValue) first.	^ Array with: directiveS with: directiveI</body></methods><methods><class-id>GraphQLBeta.GQLFieldNodeTest</class-id> <category>test-nonScalarFields</category><body package="GraphQLBeta-Tests-Nodes" selector="testNonScalarEvaluateDirectivesTrue">testNonScalarEvaluateDirectivesTrue	"Evaluate return true if:	- directives are empty	- include is true and skip is false"	self assert: (nonScalarField evaluateDirectives: schema using: context).	nonScalarField directives: (self includeDirective: true).	self assert: (nonScalarField evaluateDirectives: schema using: context).	nonScalarField directives: (self skipDirective: false).	self assert: (nonScalarField evaluateDirectives: schema using: context).	nonScalarField directives: (self includeDirective: true skipDirective: false).	self assert: (nonScalarField evaluateDirectives: schema using: context).	nonScalarField directives: (self skipDirective: false includeDirective: true).	self assert: (nonScalarField evaluateDirectives: schema using: context).</body><body package="GraphQLBeta-Tests-Nodes" selector="testNonScalarFieldsEvaluateDirectivesFalse">testNonScalarFieldsEvaluateDirectivesFalse	"Evaluate return false if:	- duplicated directives	- any directive is not defined by default directives on schema"	nonScalarField directives: (self doubleIncludeDirective: true).	self deny: (nonScalarField evaluateDirectives: schema using: context).	nonScalarField directives: (self doubleSkipDirective: false).	self deny: (nonScalarField evaluateDirectives: schema using: context).	nonScalarField directives: (self negatedIncludeDirectives).	self deny: (nonScalarField evaluateDirectives: schema using: context).	scalarField directives: (self negatedSkipDirectives).	self deny: (nonScalarField evaluateDirectives: schema using: context).	nonScalarField directives: (Array with: (GQLDirectiveNode new name: 'other')).	self deny: (nonScalarField evaluateDirectives: schema using: context).</body></methods><methods><class-id>GraphQLBeta.GQLFieldNodeTest</class-id> <category>tests-scalarFields</category><body package="GraphQLBeta-Tests-Nodes" selector="testScalarEvaluateDirectivesTrue">testScalarEvaluateDirectivesTrue	"Evaluate return true if:	- directives are empty	- include is true and skip is false"	self assert: (scalarField evaluateDirectives: schema using: context).	scalarField directives: (self includeDirective: true).	self assert: (scalarField evaluateDirectives: schema using: context).	scalarField directives: (self skipDirective: false).	self assert: (scalarField evaluateDirectives: schema using: context).	scalarField directives: (self includeDirective: true skipDirective: false).	self assert: (scalarField evaluateDirectives: schema using: context).	scalarField directives: (self skipDirective: false includeDirective: true).	self assert: (scalarField evaluateDirectives: schema using: context).</body><body package="GraphQLBeta-Tests-Nodes" selector="testScalarFieldsEvaluateDirectivesFalse">testScalarFieldsEvaluateDirectivesFalse	"Evaluate return false if:	- duplicated directives	- any directive is not defined by default directives on schema"	scalarField directives: (self doubleIncludeDirective: true).	self deny: (scalarField evaluateDirectives: schema using: context).	scalarField directives: (self doubleSkipDirective: false).	self deny: (scalarField evaluateDirectives: schema using: context).	scalarField directives: (self negatedIncludeDirectives).	self deny: (scalarField evaluateDirectives: schema using: context).	scalarField directives: (self negatedSkipDirectives).	self deny: (scalarField evaluateDirectives: schema using: context).	scalarField directives: (Array with: (GQLDirectiveNode new name: 'other')).	self deny: (scalarField evaluateDirectives: schema using: context).</body></methods><methods><class-id>GraphQLBeta.GQLFieldNodeTest</class-id> <category>running</category><body package="GraphQLBeta-Tests-Nodes" selector="setUp">setUp	schema := GQLSSchemaNode new.	scalarField := GQLScalarFieldNode new name: 'name'.	nonScalarField := GQLNonScalarFieldNode new name: 'allFilms'.	context := nil.	</body></methods><methods><class-id>GraphQLBeta.GQLSNode</class-id> <category>initialization</category><body package="GraphQLBeta-NodesSchema" selector="initialize">initialize"The default position is 0"	position := 0</body></methods><methods><class-id>GraphQLBeta.GQLSNode</class-id> <category>accessing</category><body package="GraphQLBeta-NodesSchema" selector="position">position"Return the position"	^ position</body><body package="GraphQLBeta-NodesSchema" selector="position:">position: aNumber	"Set the position"	position := aNumber</body></methods><methods><class-id>GraphQLBeta.GQLSTypeNode</class-id> <category>testing</category><body package="GraphQLBeta-NodesSchema" selector="isInputType">isInputType"Return if is a input type"	^ false</body><body package="GraphQLBeta-NodesSchema" selector="isInterfaceType">isInterfaceType"Return if is a interface type"	^ false</body><body package="GraphQLBeta-NodesSchema" selector="isObjectType">isObjectType"Return if is a object type"	^ false</body><body package="GraphQLBeta-NodesSchema" selector="isScalarType">isScalarType"Return if is a scalar type"	^ false</body><body package="GraphQLBeta-NodesSchema" selector="isUnionType">isUnionType"Return if is a union type"	^ false</body><body package="GraphQLBeta-NodesSchema" selector="isValidateClass">isValidateClass"Respondes if a type needs to be searched on the image of Pharo"	^ false</body><body package="GraphQLBeta-NodesSchema" selector="isWrappedType">isWrappedType"Return if is a wrapped type"	^ false</body></methods><methods><class-id>GraphQLBeta.GQLSWrapTypeNode</class-id> <category>testing</category><body package="GraphQLBeta-NodesSchema" selector="isInputType">isInputType"Return if the wrappedType is a inputType"	^ self wrappedType isInputType </body><body package="GraphQLBeta-NodesSchema" selector="isWrappedType">isWrappedType"Return if has a wrapped type"	^ true</body></methods><methods><class-id>GraphQLBeta.GQLSWrapTypeNode</class-id> <category>accessing</category><body package="GraphQLBeta-NodesSchema" selector="wrappedType">wrappedType"Return the wrappedType"	^ wrappedType </body><body package="GraphQLBeta-NodesSchema" selector="wrappedType:">wrappedType: aType"Set the wrappedType"	wrappedType := aType</body></methods><methods><class-id>GraphQLBeta.GQLSArgumentFieldNode</class-id> <category>accessing</category><body package="GraphQLBeta-NodesSchema" selector="name">name"Return the name"	^ name</body><body package="GraphQLBeta-NodesSchema" selector="name:">name: aName"Set the name"	name := aName</body><body package="GraphQLBeta-NodesSchema" selector="type">type"Return the type"	^ type </body><body package="GraphQLBeta-NodesSchema" selector="type:">type: aType"Set the type"	type := aType</body></methods><methods><class-id>GraphQLBeta.GQLSSchemaNode</class-id> <category>accessing</category><body package="GraphQLBeta-NodesSchema" selector="getDirective:">getDirective: aDirectiveName	"Return the directive corresponding to the given directive name"	(defaultDirectives includesKey: aDirectiveName asString)		ifTrue: [ ^ defaultDirectives at: aDirectiveName asString].	^ nil			</body><body package="GraphQLBeta-NodesSchema" selector="getInterface:">getInterface: anInterfaceName	"Return the interface corresponding to the given name"	((schemaTypes includesKey: anInterfaceName asString)		and: [ (schemaTypes at: anInterfaceName asString) isInterfaceType ])		ifTrue: [ ^ schemaTypes at: anInterfaceName asString].</body><body package="GraphQLBeta-NodesSchema" selector="getType:">getType: aTypeName	"Return the type corresponding to the given type name"	(schemaTypes includesKey: aTypeName asString)		ifTrue: [ ^ schemaTypes at: aTypeName asString].	^ scalarTypes at: aTypeName asString</body><body package="GraphQLBeta-NodesSchema" selector="types">types"Return the types"	^ schemaTypes </body><body package="GraphQLBeta-NodesSchema" selector="validatedTypes">validatedTypes"Return the object types or input objects"	^ schemaTypes select: #isValidateClass</body></methods><methods><class-id>GraphQLBeta.GQLSSchemaNode</class-id> <category>adding</category><body package="GraphQLBeta-NodesSchema" selector="addTypes:">addTypes: aCollection"Given a collection puts the values on a dictionary for improve the search"	aCollection do: [ :type | schemaTypes at: type name put: type ]</body></methods><methods><class-id>GraphQLBeta.GQLSSchemaNode</class-id> <category>initialization</category><body package="GraphQLBeta-NodesSchema" selector="initialize">initialize	super initialize.	self initializeScalarTypes.	self initializeDefaultDirectives.	schemaTypes := Dictionary new</body><body package="GraphQLBeta-NodesSchema" selector="initializeDefaultDirectives">initializeDefaultDirectives	defaultDirectives := Dictionary new.	defaultDirectives at: 'skip' put: GQLSkipDirectiveNode new.	defaultDirectives at: 'include' put: GQLIncludeDirectiveNode new.</body><body package="GraphQLBeta-NodesSchema" selector="initializeScalarTypes">initializeScalarTypes	"Creates a dictionary with the default scalar types"	scalarTypes := Dictionary new.	scalarTypes at: 'Int' put: GQLSIntTypeNode new.	scalarTypes at: 'String' put: GQLSStringTypeNode new.	scalarTypes at: 'ID' put: GQLSIDTypeNode new.	scalarTypes at: 'Boolean' put: GQLSBooleanTypeNode new.	scalarTypes at: 'Float' put: GQLSFloatTypeNode new</body></methods><methods><class-id>GraphQLBeta.GQLSSchemaNode</class-id> <category>development support</category><body package="GraphQLBeta-NodesSchema" selector="validate">validate	"Verify that all the input types and types exist on smalltalk, interfaces has uniqueness field names and all types implemented interfaces satisfy the object type validation."	| res validators |	validators := Array with: #validateWithImage 							with: #validateObjectTypes							with: #validateUnionTypes.	validators detect: [ :validator | res := self perform: validator.												res isKindOf: GQLValidationException ]				  ifFound: [ :validator | ^ res ]</body><body package="GraphQLBeta-NodesSchema" selector="validateObjectTypes">validateObjectTypes"Return self if all the object types that implemented interfaces are consistent, if not raise a GQLValidationException"		| objectTypes |	objectTypes := self types values select: #isObjectType.	objectTypes detect: [ :objectType | | fields |		fields := Set new.		objectType interfaces do: [ :nameInterface | 				fields addAll: (self getInterface: nameInterface) fields values ].		(objectType implementsFields: fields) not ]				ifFound: [ :objectType | 					^ GQLValidationException new node: objectType;													messageText: 'Missing fields on object type 													for implementing interface'; raise ].</body><body package="GraphQLBeta-NodesSchema" selector="validateUnionTypes">validateUnionTypes"Return self if all the union types has values as object types, if not raise a GQLValidationException"	| unions |	unions := self types select: #isUnionType.	unions detect: [ :union | (union namedTypes allSatisfy: 												[ :name | (self getType: name) isObjectType ]) not ]			ifFound: [ :union | ^ GQLValidationException new									node: union;									messageText: 'The values of union are not object type';									raise ].	^ self	</body><body package="GraphQLBeta-NodesSchema" selector="validateWithImage">validateWithImage"Return self if all the types exist on the smalltalk image and also the fields, if not raise a GQLValidationException"	| allClasses |	allClasses := Smalltalk globals allClasses.	self validatedTypes do: [ :assoc | 		| class fields nameAssoc |		nameAssoc := assoc name.		(nameAssoc endsWith: 'Input') 		ifTrue: [ nameAssoc := nameAssoc copyFrom: 1 to: nameAssoc size - 5].		class := allClasses 			detect: [ :c | c name = nameAssoc asSymbol ]			ifNone: [ ^ GQLValidationException new				node: assoc value;				messageClassText ].		fields := assoc value fields values.		fields do: [ :field | 			class allMethods				detect: [ :method | method selector = field fullName asSymbol ]				ifNone: [ ^ GQLValidationException new					node: field;					messageMethodText: assoc ] ] ].</body></methods><methods><class-id>GraphQLBeta.GQLSSchemaNode</class-id> <category>as yet unclassified</category><body package="GraphQLBeta-NodesSchema" selector="root:">root: anInstance"Set an instance as root and his class as the query"	root := anInstance.	query := self		getType: anInstance class name</body></methods><methods><class-id>GraphQLBeta.GQLException</class-id> <category>*GraphQLBeta</category><body package="GraphQLBeta" selector="node">node"Return the element that causes a exception"	^ node</body><body package="GraphQLBeta" selector="node:">node: aNode"Recive a node element that causes a exception"	node := aNode</body></methods><methods><class-id>GraphQLBeta.GQLException</class-id> <category>accessing</category><body package="GraphQLBeta" selector="defaultAction">defaultAction	"No one has handled this error, but now give them a chance to decide how to debug it.  If none handle this either then open debugger (see UnhandedError-defaultAction)"	^ self</body></methods><methods><class-id>GraphQLBeta.GQLValidationException</class-id> <category>message</category><body package="GraphQLBeta" selector="messageClassText">messageClassText"Message for class that doesn't exist on the image of Smalltalk"	| writer |	writer := WriteStream on: String new.	writer		nextPutAll: 'No exist the class ';		nextPutAll: node name.	self messageText: writer contents</body><body package="GraphQLBeta" selector="messageMethodText:">messageMethodText: aClass"Message for the method that doesn't exist on the Class"	| writer |	writer := WriteStream on: String new.	writer		nextPutAll: 'No exist the method ';		nextPutAll: node fullName;		nextPutAll: ' on the class ';		nextPutAll: aClass name.	self messageText: writer contents</body></methods><methods><class-id>GraphQLBeta.GQLEvaluationException</class-id> <category>message</category><body package="GraphQLBeta" selector="messageArgumentText:">messageArgumentText: aNode	"Message for argument that doesn't exist on the definition of schema"	| writer |	writer := WriteStream on: String new.	writer		nextPutAll: 'No exist the argument ';		nextPutAll: node argumentName;		nextPutAll: ' on the definition of the schema, on the node ';		nextPutAll: aNode fieldName.	self messageText: writer contents</body><body package="GraphQLBeta" selector="messageInputText">messageInputText	"Message for input that doesn't exist on the definition of schema"	| writer |	writer := WriteStream on: String new.	writer		nextPutAll: 'No valid input type: ';		nextPutAll: node inputType;		nextPutAll: ' on the definition of the schema'.	self messageText: writer contents</body><body package="GraphQLBeta" selector="messageObjectText">messageObjectText	"Message for object that doesn't exist on the definition of schema"	| writer |	writer := WriteStream on: String new.	writer		nextPutAll: 'No valid object type: ';		nextPutAll: node fieldName;		nextPutAll: ' on the definition of the schema'.	self messageText: writer contents</body><body package="GraphQLBeta" selector="messageScalarText">messageScalarText	"Message for scalar that doesn't exist on the definition of schema"	| writer |	writer := WriteStream on: String new.	writer		nextPutAll: 'No valid scalar: ';		nextPutAll: node fieldName;		nextPutAll: ' on the definition of the schema'.	self messageText: writer contents</body></methods><methods><class-id>GraphQLBeta.GQLNode</class-id> <category>initialization</category><body package="GraphQLBeta-Nodes" selector="initialize">initialize	position := 0.</body></methods><methods><class-id>GraphQLBeta.GQLNode</class-id> <category>accessing</category><body package="GraphQLBeta-Nodes" selector="position">position"Return the position"	^ position</body><body package="GraphQLBeta-Nodes" selector="position:">position: aPosition"Set the position"	position := aPosition</body></methods><methods><class-id>GraphQLBeta.GQLNode</class-id> <category>visiting</category><body package="GraphQLBeta-Nodes" selector="acceptVisitor:">acceptVisitor: aVisitor"This is responsability of the subclass"	self shouldBeImplemented</body></methods><methods><class-id>GraphQLBeta.GQLNode</class-id> <category>action</category><body package="GraphQLBeta-Nodes" selector="executeOn:with:using:">executeOn: resolver with: context using: schema"This is responsability of the subclass"	self shouldBeImplemented</body></methods><methods><class-id>GraphQLBeta.GQLSelectionNode</class-id> <category>accessing</category><body package="GraphQLBeta-Nodes" selector="directives">directives"Return the directives"	^ directives</body><body package="GraphQLBeta-Nodes" selector="directives:">directives: anObject"Set the directives"	directives := anObject</body><body package="GraphQLBeta-Nodes" selector="evaluateDirectives:using:">evaluateDirectives: schema using: context"Verify that directives follow the specification of the schema directives"	directives ifNil: [ ^ true ]. 	((directives select: #isSkip) size &lt;= 1) &amp; ((directives select: #isInclude) size &lt;= 1)		ifTrue: [ ^ directives allSatisfy: [ :directive | 					(directive evaluateOn: schema using: context) ] ]		ifFalse: [ ^ false ].</body></methods><methods><class-id>GraphQLBeta.GQLSelectionNode</class-id> <category>as yet unclassified</category><body package="GraphQLBeta-Nodes" selector="collectVariablesOn:with:">collectVariablesOn: context with: visitedFragments	^ self subclassResponsibility </body><body package="GraphQLBeta-Nodes" selector="collectVarSelectionSet:using:with:">collectVarSelectionSet: aSelectionSet using: context with: visitedFragments	| groupedVariables |	groupedVariables := Set new.	aSelectionSet selections do: [ :selection | 		groupedVariables addAll: (selection collectVariablesOn: context with: visitedFragments)	].	^ groupedVariables </body></methods><methods><class-id>GraphQLBeta.GQLSelectionNode</class-id> <category>action</category><body package="GraphQLBeta-Nodes" selector="executeDirectives:">executeDirectives: context"Execute the directives based on the variables declared on context or their arguments"	| executedDirectives response |	response := true.	directives ifNil: [ ^ response ].	executedDirectives := directives collect: [ :a | a execute: context ].	executedDirectives do: [ :exe |			response := response &amp; exe ].	^ response</body></methods><methods><class-id>GraphQLBeta.GQLSelectionNode</class-id> <category>testing</category><body package="GraphQLBeta-Nodes" selector="isSpread">isSpread	^ false</body></methods><methods><class-id>GraphQLBeta.GQLSelectionNode</class-id> <category>utils</category><body package="GraphQLBeta-Nodes" selector="ifField:ifFragment:ifInline:">ifField: aFieldBlock ifFragment: aFragmentBlock ifInline: aInlineBlock	^ self subclassResponsibility </body></methods><methods><class-id>GraphQLBeta.GQLFragmentSpreadNode</class-id> <category>accessing</category><body package="GraphQLBeta-Nodes" selector="name">name"Return the name"	^ name</body><body package="GraphQLBeta-Nodes" selector="name:">name: anObject"Set the name"	name := anObject</body><body package="GraphQLBeta-Nodes" selector="targetSpreads">targetSpreads"Return an array with self"	^ Array with: self.</body></methods><methods><class-id>GraphQLBeta.GQLFragmentSpreadNode</class-id> <category>comparing</category><body package="GraphQLBeta-Nodes" selector="=">= other		^ self name = other name</body><body package="GraphQLBeta-Nodes" selector="hash">hash	^ self name hash</body></methods><methods><class-id>GraphQLBeta.GQLFragmentSpreadNode</class-id> <category>as yet unclassified</category><body package="GraphQLBeta-Nodes" selector="collectVariablesOn:with:">collectVariablesOn: context with: visitedFragments	| groupedVariables |	groupedVariables := Set new.	(visitedFragments includes: name) 	ifFalse: [ 		visitedFragments add: name.		groupedVariables addAll: (		self collectVarSelectionSet: (context fragments at: name) selectionSet 		using: context with: visitedFragments).		 ].	^ groupedVariables</body></methods><methods><class-id>GraphQLBeta.GQLFragmentSpreadNode</class-id> <category>testing</category><body package="GraphQLBeta-Nodes" selector="isSpread">isSpread	^ true</body></methods><methods><class-id>GraphQLBeta.GQLFragmentSpreadNode</class-id> <category>utils</category><body package="GraphQLBeta-Nodes" selector="ifField:ifFragment:ifInline:">ifField: aFieldBlock ifFragment: aFragmentBlock ifInline: aInlineBlock	^ aFragmentBlock value</body></methods><methods><class-id>GraphQLBeta.GQLDefinitionNode</class-id> <category>testing</category><body package="GraphQLBeta-Nodes" selector="isOperation">isOperation	^ self subclassResponsibility </body></methods><methods><class-id>GraphQLBeta.GQLOperationDefinitionNode</class-id> <category>accessing</category><body package="GraphQLBeta-Nodes" selector="rootOperation:">rootOperation: root	^ (root isDictionary) ifTrue: [ root at: self type ] ifFalse: [ root ].</body><body package="GraphQLBeta-Nodes" selector="targetSpreads">targetSpreads	^ self subclassResponsibility</body><body package="GraphQLBeta-Nodes" selector="type">type	^ self subclassResponsibility </body></methods><methods><class-id>GraphQLBeta.GQLOperationDefinitionNode</class-id> <category>testing</category><body package="GraphQLBeta-Nodes" selector="isOperation">isOperation	^ true</body></methods><methods><class-id>GraphQLBeta.GQLVariableDefinitionNode</class-id> <category>accessing</category><body package="GraphQLBeta-Nodes" selector="currentValue">currentValue	value isNil 	ifTrue: [ ^ defaultValue ]	ifFalse: [ ^ value ]</body><body package="GraphQLBeta-Nodes" selector="defaultValue">defaultValue"Return the defaultValue"	^ defaultValue</body><body package="GraphQLBeta-Nodes" selector="defaultValue:">defaultValue: anObject"Set the default value"	defaultValue := anObject</body><body package="GraphQLBeta-Nodes" selector="name">name"Return the name"	^ GQLVariableNode new value: name</body><body package="GraphQLBeta-Nodes" selector="name:">name: anObject"Set the name"	name := anObject</body><body package="GraphQLBeta-Nodes" selector="type">type"Return the type"	^ type</body><body package="GraphQLBeta-Nodes" selector="type:">type: anObject"Set the type"	type := anObject</body><body package="GraphQLBeta-Nodes" selector="value">value	^ value</body><body package="GraphQLBeta-Nodes" selector="value:">value: anObject	value := anObject</body></methods><methods><class-id>GraphQLBeta.GQLSelectionSetNode</class-id> <category>accessing</category><body package="GraphQLBeta-Nodes" selector="selections">selections"Return the selections"	^ selections</body><body package="GraphQLBeta-Nodes" selector="selections:">selections: fields"Set the selections"	selections := fields</body><body package="GraphQLBeta-Nodes" selector="targetSpreads">targetSpreads"Return all the fragments spreads used on this node"	| spreads |	spreads := Set new.	selections do: [ :selection | spreads addAll: selection targetSpreads ].	^ spreads</body></methods><methods><class-id>GraphQLBeta.GQLSelectionSetNode</class-id> <category>action</category><body package="GraphQLBeta-Nodes" selector="collectField:with:">collectField: selection with: groupedFields"View on groupedFields if selection exist or if can merge"		| responseKey |	responseKey := selection key.	(groupedFields includesKey: responseKey)				ifTrue: [ 					(self sameShape: (groupedFields at: responseKey) with: selection)					ifTrue: [ selection isScalar 						ifFalse: [ 								self								mergeSelectionSet: (groupedFields at: responseKey)								with: selection ] ]					ifFalse: [ ^ GQLException new node: selection; 							messageText: 'Duplicated fields with different arguments, use alias';							raise ].							 ]				ifFalse:					[ groupedFields at: responseKey put: selection ].		^ groupedFields</body><body package="GraphQLBeta-Nodes" selector="collectFields:">collectFields: context	"Collect all the selections"	| groupedFields visitedFragments |	groupedFields := OrderedDictionary new.	visitedFragments := OrderedDictionary new.	selections select: [ :field | field executeDirectives: context ]		thenDo: [ :selection |			groupedFields := 				selection ifField: [ self collectField: selection with: groupedFields. ]						 ifFragment:  [ 							self collectFragment: selection 										with: visitedFragments using: groupedFields on: context ]						 ifInline: [ self collectInlineFragment: selection with: groupedFields on: context ].				 ].	^ groupedFields</body><body package="GraphQLBeta-Nodes" selector="collectFragment:with:using:on:">collectFragment: selection with: visitedFragments using: groupedFields on: context"View on visitedFragments if fragment exist, then add selectionSet based on groupedFieldsHERE IS IMPORTANT VERIFY THE TYPE"		| responseKey fragment fragmentFieldSet |	responseKey := selection name.	(visitedFragments includesKey: responseKey) ifFalse: [ 		visitedFragments at: responseKey put: selection.		context fragments 			at: responseKey			ifPresent: [ :v | fragment := v ]			ifAbsent: [ ^ GQLException new 					node: selection;					messageText: 'Undefined fragment';					raise ].		fragmentFieldSet := fragment selectionSet collectFields: context.		fragmentFieldSet valuesDo: [ :value |			self collectField: value with: groupedFields ]		].		^ groupedFields</body><body package="GraphQLBeta-Nodes" selector="collectInlineFragment:with:on:">collectInlineFragment: selection with: groupedFields on: context"Collect inline fragments based on their selection setHERE TYPE CHECK THE TYPE OF INLINE FRAGMENT"		| fragmentFieldSet |	fragmentFieldSet := selection selectionSet collectFields: context.	fragmentFieldSet valuesDo: [ :value |	self collectField: value with: groupedFields ].	^ groupedFields</body><body package="GraphQLBeta-Nodes" selector="executeOn:with:using:">executeOn: root with: context using: schema	"Execute the field nodes with the root, an enviroment and the schema"	| collectedFields response myRoot |	selections detect: [ :selection | (selection evaluateDirectives: schema using: context) not ]				ifFound: [ :selection | ^ GQLException new node: selection; 									messageText: 'Error on directives'; raise ].	collectedFields := self collectFields: context.	collectedFields class = GQLException ifTrue: [ ^ collectedFields ].	response := OrderedDictionary new.	myRoot := self rootOperation: root.	collectedFields		do: [ :f |			response				at: f key				put: (f executeOn: myRoot with: context using: schema). ].	^ response</body><body package="GraphQLBeta-Nodes" selector="mergeSelectionSet:with:">mergeSelectionSet: field1 with: field2"Merge two selection sets"	| newFieldNodes |	newFieldNodes := OrderedCollection new.	newFieldNodes addAll: (field2 selectionSet selections).	newFieldNodes addAll: (field1 selectionSet selections).	field1 selectionSet selections: newFieldNodes asArray</body><body package="GraphQLBeta-Nodes" selector="sameShape:with:">sameShape: field1 with: field2"Verify if two fields have the same name and value argumentsHERE IS IMPORTANT VERIFY THE TYPE"	^ (field1 name = field2 name) and: [ field1 arguments = field2 arguments ]</body><body package="GraphQLBeta-Nodes" selector="type">type	^ 'query'</body></methods><methods><class-id>GraphQLBeta.GQLSchemaGrammarTest</class-id> <category>test-grammar-field</category><body package="GraphQLBeta-Tests-Grammar" selector="testField">testField	self parse: 'someName1 	: Int' rule: #field.	self parse: 'someName2 	: [String ! ]!' rule: #field.	self parse: 'someName3 	: 	ID !' rule: #field.	self parse: 'someName4 	: 	SomeOtherType !' rule: #field.	self parse: 'withParam1 ( aParam: String): 	SomeOtherType !' rule: #field.	self parse: 'withParam2( aParam: String, bParam:Int): 	SomeOtherType !' rule: #field.	self		parse: 'withParam3( aParam: String, someOtherParam:Int): 	SomeOtherType !'		rule: #field.</body><body package="GraphQLBeta-Tests-Grammar" selector="testFieldIncorrect">testFieldIncorrect	self fail: '123:Int !' rule: #field.	self fail: 'someName : [ String' rule: #field.	self fail: 'some : !' rule: #field.	self fail: 'some() : Int' rule: #field.	self fail: 'some : 123' rule: #field.	self fail: 'some : [String !' rule: #field</body></methods><methods><class-id>GraphQLBeta.GQLSchemaGrammarTest</class-id> <category>test-grammar-parameter</category><body package="GraphQLBeta-Tests-Grammar" selector="testParameter">testParameter	self parse: 'p1:[Int!]!' rule: #parameter.	self parse: 'p1 : [String ! ]' rule: #parameter.	self parse: 'p2: String!' rule: #parameter.	self parse: 'p : Some' rule: #parameter.	self parse: 'p : Some!' rule: #parameter.	self parse: 'p : [ Some ] !' rule: #parameter.	self parse: 'p : [Some!] !' rule: #parameter.</body><body package="GraphQLBeta-Tests-Grammar" selector="testParameterIncorrect">testParameterIncorrect	self fail: 'Int !' rule: #parameter.	self fail: 'p1:' rule: #parameter.	self fail: 'p1: !' rule: #parameter.	self fail: 'p1 Int' rule: #parameter.	self fail: 'p1 !' rule: #parameter.</body></methods><methods><class-id>GraphQLBeta.GQLSchemaGrammarTest</class-id> <category>tests-grammar</category><body package="GraphQLBeta-Tests-Grammar" selector="parserClass">parserClass	^ GQLSchemaGrammar</body><body package="GraphQLBeta-Tests-Grammar" selector="testSchemaAll">testSchemaAll	| text |	text := 'enum DogCommand { SIT, DOWN, HEEL }				type Dog implements Pet {  					name: String!  					nickname: String  					barkVolume: Int  					doesKnowCommand(dogCommand: DogCommand!): Boolean!  					isHousetrained(atOtherHomes: Boolean): Boolean!  					owner: Human				}				interface Sentient {  					name: String!				}				interface Pet { 					 name: String!				}				type Alien implements Sentient {  					name: String!  					homePlanet: String				}				type Human implements Sentient {  					name: String!				}				enum CatCommand { JUMP }			type Cat implements Pet {  				name: String!  				nickname: String  				doesKnowCommand(catCommand: CatCommand!): Boolean!  				meowVolume: Int			}			union CatOrDog = Cat | Dog			union DogOrHuman = Dog | Human			union HumanOrAlien = Human | Alien			type QueryRoot {  				dog: Dog			}'.	self parse: text rule: #schema</body><body package="GraphQLBeta-Tests-Grammar" selector="testSchemaInputObjectType">testSchemaInputObjectType	| text |	text := 'input MessageInput {  				content: String 				author: String			}			type Message {  				id: ID!  				content: String  				author: String			}			type Query {  				getMessage(id: ID!): Message			}'.	self parse: text rule: #schema.	self parse: 'input SomeType {						someName : [Int]					}' rule: #schema.	self parse: 'input SomeOtherTypeName {						someName 	: [String ! ],						someName 	:String 					}' rule: #schema</body><body package="GraphQLBeta-Tests-Grammar" selector="testSchemaObjectType">testSchemaObjectType	| text |	text := 'type SomeType {					someName : [Int]				},				type SomeOtherTypeName {					someName 	: [String ! ]					someName 	:String 				}'.	self parse: text rule: #schema.	self parse: 'type SomeType {						someName : [Int]					}' rule: #schema.	self parse: 'type SomeOtherTypeName {						someName 	: [String ! ],						someName 	:String 					}' rule: #schema</body><body package="GraphQLBeta-Tests-Grammar" selector="testSchemaWithEnum">testSchemaWithEnum	| text |	text := 'enum DogCommand { SIT, DOWN, HEEL }				type SomeType {					someName : [Int]				},				type SomeOtherTypeName {					someName 	: [String ! ]					someName 	:String 				}'.	self parse: text rule: #schema.	self		parse:			'type SomeType {						someName : [Int]					}			enum DogCommand { SIT, DOWN, HEEL }'		rule: #schema.	self		parse:			'enum CatCommand { JUMP }			type SomeOtherTypeName {						someName 	: [String ! ],						someName 	:String 					}			enum DogCommand { SIT, DOWN, HEEL }'		rule: #schema</body><body package="GraphQLBeta-Tests-Grammar" selector="testSchemaWithInterface">testSchemaWithInterface	| text |	text := 'type SomeType {					someName : [Int]				},				interface SomeOtherTypeName {					someName 	: [String ! ]					someName 	:String 				}'.	self parse: text rule: #schema.	self		parse:			'interface SomeType {						someName : [Int]					}'		rule: #schema.</body><body package="GraphQLBeta-Tests-Grammar" selector="testSchemaWithUnion">testSchemaWithUnion	| text |	text := 'union DogOrHuman = Dog | Human				union HumanOrAlien = Human | Alien				type SomeType {					someName : [Int]				},				type SomeOtherTypeName {					someName 	: [String ! ]					someName 	:String 				}'.	self parse: text rule: #schema.	self		parse:			'type SomeType {						someName : [Int]					}			union HumanOrAlien = Human | Alien'		rule: #schema.	self		parse:			'union HumanOrAlien = Human | Alien			type SomeOtherTypeName {						someName 	: [String ! ],						someName 	:String 					}			union DogOrHuman = Dog | Human'		rule: #schema</body></methods><methods><class-id>GraphQLBeta.GQLSchemaGrammarTest</class-id> <category>test-grammar-inputTypes</category><body package="GraphQLBeta-Tests-Grammar" selector="testInputType">testInputType	self parse: '[Int ! ]!' rule: #inputType.	self parse: '[String ! ]' rule: #inputType.	self parse: '[ String ]!' rule: #inputType.	self parse: 'Int !' rule: #inputType.	self parse: 'String' rule: #inputType.	self parse: 'Some' rule: #inputType.</body><body package="GraphQLBeta-Tests-Grammar" selector="testInputTypeIncorrect">testInputTypeIncorrect	self fail: '[Int' rule: #inputType.	self fail: '[String !' rule: #inputType.	self fail: '[ ]!' rule: #inputType.	self fail: '!' rule: #inputType.	self fail: '[Some' rule: #inputType.</body></methods><methods><class-id>GraphQLBeta.GQLSchemaGrammarTest</class-id> <category>test-grammar-nonNullInputType</category><body package="GraphQLBeta-Tests-Grammar" selector="testNonNullInputType">testNonNullInputType	self parse: 'Int!' rule: #nonNullInputType.	self parse: 'SomeOtherType !' rule: #nonNullInputType.	self parse: '[ Int ]!' rule: #nonNullInputType.	self parse: '[ Int! ]!' rule: #nonNullInputType.	self parse: '[ SomeOtherType ]!' rule: #nonNullInputType.	self parse: '[ SomeOtherType! ]!' rule: #nonNullInputType</body><body package="GraphQLBeta-Tests-Grammar" selector="testNonNullInputTypeIncorrect">testNonNullInputTypeIncorrect	self fail: 'Int!!' rule: #nonNullInputType.	self fail: 'Int' rule: #nonNullInputType.	self fail: 'SomeOtherType' rule: #nonNullInputType.	self fail: '[ Int! ]' rule: #nonNullInputType.	self fail: '[ Int ]' rule: #nonNullInputType.	self fail: '[ SomeOtherType ]' rule: #nonNullInputType.	self fail: '[ SomeOtherType! ]' rule: #nonNullInputType</body></methods><methods><class-id>GraphQLBeta.GQLSchemaGrammarTest</class-id> <category>test-grammar-objectType</category><body package="GraphQLBeta-Tests-Grammar" selector="testFailObjectTypeIncomplete">testFailObjectTypeIncomplete	self fail: '{someName 	: 	ID !}' rule: #objectType.	self fail: 'type {someName 	: 	ID !}' rule: #objectType.	self fail: 'type {}' rule: #objectType.	self fail: 'type Some {}' rule: #objectType.	self fail: 'type implements' rule: #objectType.	self fail: 'type Some implements {}' rule: #objectType.	self fail: 'type Some implements {someName : ID}' rule: #objectType.	self fail: 'type Some Other { someName: ID}' rule: #objectType.</body><body package="GraphQLBeta-Tests-Grammar" selector="testFailObjectTypeOther">testFailObjectTypeOther	self fail: 'enum Flower { ROSE, LAVANDA}' rule: #objectType.	self fail: 'interface Sentiet { name : String}' rule: #objectType.	self fail: 'union CatOrDog = Cat | Dog' rule: #objectType</body><body package="GraphQLBeta-Tests-Grammar" selector="testObjectType">testObjectType	self parse: 'type SomeType {someName : [Int]}' rule: #objectType.	self		parse: 'type SomeOtherTypeName {someName 	: [String ! ], someName 	:String }'		rule: #objectType.	self parse: 'type Some {someObject : Some }' rule: #objectType.	self parse: 'type Some {someObject : Some ! }' rule: #objectType.	self parse: 'type Some {someObject : [ Some ] ! }' rule: #objectType.	self parse: 'type Some {someObject : [ Some ! ] }' rule: #objectType.	self parse: 'type Some {someObject : [ Some ! ] ! }' rule: #objectType.	self parse: 'type Some implements Other { some : Int }' rule: #objectType.	self		parse: 'type SomeOtherTypeName implements Other {someName 	: [String ! ], someName 	:String }'		rule: #objectType.	self parse: 'type Some implements Other {someObject : Some }' rule: #objectType.	self parse: 'type Some implements Other {someObject(a : String) : Some }' rule: #objectType.	self parse: 'type Some implements Other {someObject(a : String, p: Some) : Some }' rule: #objectType.	self parse: 'type Some implements Other {someObject : Some ! }' rule: #objectType.	self parse: 'type Some implements Other {someObject : [ Some ] ! }' rule: #objectType.	self parse: 'type Some implements Other {someObject : [ Some ! ] }' rule: #objectType.	self parse: 'type Some implements Other {someObject : [ Some ! ] ! }' rule: #objectType.</body></methods><methods><class-id>GraphQLBeta.GQLSchemaGrammarTest</class-id> <category>test-grammar-unionType</category><body package="GraphQLBeta-Tests-Grammar" selector="testFailUnionTypeOther">testFailUnionTypeOther	self fail: '{someName 	: 	ID !}' rule: #unionType.	self fail: 'type {someName 	: 	ID !}' rule: #unionType.	self fail: 'type {}' rule: #unionType.	self fail: 'type Some {}' rule: #unionType.	self fail: 'type implements' rule: #unionType.	self fail: 'type Some implements {}' rule: #unionType.	self fail: 'type Some implements {someName : ID}' rule: #unionType.	self fail: 'type Some Other { someName: ID}' rule: #unionType.	self fail: 'interface Sentiet { name : String}' rule: #unionType.	self fail: 'enum FLOWER { ROSE, LAVANDA }' rule: #unionType.</body><body package="GraphQLBeta-Tests-Grammar" selector="testUnionType">testUnionType	self parse: 'union CatOrDog = Cat | Dog' rule: #unionType.	self parse: 'union DogOrHuman = Dog | Human' rule: #unionType.	self parse: 'union DogOrCatOrBird = Dog | Cat | Bird' rule: #unionType.</body><body package="GraphQLBeta-Tests-Grammar" selector="testUnionTypeIncorrect">testUnionTypeIncorrect	self fail: 'union CatOrDog = Cat | ' rule: #unionType.	self fail: 'union = Cat | Dog' rule: #unionType.	self fail: 'union CatOrDog Cat | Dog' rule: #unionType.	self fail: 'union CatOrDog = Cat Dog' rule: #unionType.</body></methods><methods><class-id>GraphQLBeta.GQLSchemaGrammarTest</class-id> <category>test-grammar-inputObjectType</category><body package="GraphQLBeta-Tests-Grammar" selector="testFailInputObjectTypeIncomplete">testFailInputObjectTypeIncomplete	self fail: '{someName 	: 	ID !}' rule: #inputObjectType.	self fail: 'input {someName 	: 	ID !}' rule: #inputObjectType.	self fail: 'input {}' rule: #inputObjectType.	self fail: 'input Some {}' rule: #inputObjectType.	self fail: 'input Some {}' rule: #inputObjectType.	self fail: 'input Some {some : }' rule: #inputObjectType.	self fail: 'input Some Other { someName: ID}' rule: #inputObjectType.	self fail: 'input Some { someName(a : ) : ID}' rule: #inputObjectType.	self fail: 'input Some { someName(a : String, b ) : ID}' rule: #inputObjectType.</body><body package="GraphQLBeta-Tests-Grammar" selector="testFailInputObjectTypeOther">testFailInputObjectTypeOther	self fail: 'enum Flower { ROSE, LAVANDA}' rule: #inputObjectType.	self fail: 'interface Sentiet { name : String}' rule: #inputObjectType.	self fail: 'union CatOrDog = Cat | Dog' rule: #inputObjectType.	self fail: 'type SomeType {someName : [Int]}' rule: #inputObjectType.	self fail: 'type SomeType implements Some {someName : [Int]}' rule: #inputObjectType.</body><body package="GraphQLBeta-Tests-Grammar" selector="testInputObjectType">testInputObjectType	self parse: 'input SomeType {someName : [Int]}' rule: #inputObjectType.	self		parse: 'input SomeOtherTypeName {someName 	: [String ! ], someName 	:String }'		rule: #inputObjectType.	self parse: 'input Some {someObject : Some }' rule: #inputObjectType.	self parse: 'input Some {someObject : Some ! }' rule: #inputObjectType.	self parse: 'input Some {someObject : [ Some ] ! }' rule: #inputObjectType.	self parse: 'input Some {someObject : [ Some ! ] }' rule: #inputObjectType.	self parse: 'input Some {someObject : [ Some ! ] ! }' rule: #inputObjectType.	self parse: 'input Some { some : Int }' rule: #inputObjectType.	self parse: 'input Some { some(p : String) : Int }' rule: #inputObjectType.	self parse: 'input Some { some(p : Some) : Int }' rule: #inputObjectType.	self parse: 'input Some { some(p : String, a : Some) : Int }' rule: #inputObjectType.</body></methods><methods><class-id>GraphQLBeta.GQLSchemaGrammarTest</class-id> <category>test-grammar-enumType</category><body package="GraphQLBeta-Tests-Grammar" selector="testEnumType">testEnumType	self parse: 'enum DogCommand { SIT, DOWN, HEEL }' rule: #enumType.	self parse: 'enum CatCommand { JUMP }' rule: #enumType.</body><body package="GraphQLBeta-Tests-Grammar" selector="testFailEnumTypeIncomplete">testFailEnumTypeIncomplete	self fail: 'enum { ROSE, LAVANDA}' rule: #enumType.	self fail: 'enum ROSE, LAVANDA' rule: #enumType.	self fail: 'enum { }' rule: #enumType.	self fail: 'enum FLOWER' rule: #enumType.	self fail: 'enum true { ROSE, LAVANDA}' rule: #enumType.	self fail: 'enum false { ROSE, LAVANDA}' rule: #enumType.	self fail: 'enum null { ROSE, LAVANDA}' rule: #enumType.	self fail: 'FLOWER' rule: #enumType.	self fail: 'FLOWER { ROSE, LAVANDA}' rule: #enumType.</body><body package="GraphQLBeta-Tests-Grammar" selector="testFailEnumTypeOther">testFailEnumTypeOther	self fail: '{someName 	: 	ID !}' rule: #enumType.	self fail: 'type {someName 	: 	ID !}' rule: #enumType.	self fail: 'type {}' rule: #enumType.	self fail: 'type Some {}' rule: #enumType.	self fail: 'type implements' rule: #enumType.	self fail: 'type Some implements {}' rule: #enumType.	self fail: 'type Some implements {someName : ID}' rule: #enumType.	self fail: 'type Some Other { someName: ID}' rule: #enumType.	self fail: 'interface Sentiet { name : String}' rule: #enumType.	self fail: 'interface { name : String}' rule: #enumType.	self fail: 'union CatOrDog = Cat | Dog' rule: #enumType</body></methods><methods><class-id>GraphQLBeta.GQLSchemaGrammarTest</class-id> <category>test-grammar-interfaceType</category><body package="GraphQLBeta-Tests-Grammar" selector="testFailInterfaceTypeOther">testFailInterfaceTypeOther	self fail: '{someName 	: 	ID !}' rule: #interfaceType.	self fail: 'type {someName 	: 	ID !}' rule: #interfaceType.	self fail: 'type {}' rule: #interfaceType.	self fail: 'type Some {}' rule: #interfaceType.	self fail: 'type implements' rule: #interfaceType.	self fail: 'type Some implements {}' rule: #interfaceType.	self fail: 'type Some implements {someName : ID}' rule: #interfaceType.	self fail: 'type Some Other { someName: ID}' rule: #interfaceType.	self fail: 'union CatOrDog = Cat | Dog' rule: #interfaceType.	self fail: 'enum Some { someName: ID}' rule: #interfaceType.</body><body package="GraphQLBeta-Tests-Grammar" selector="testInterfaceType">testInterfaceType	self parse: 'interface DogCommand { some : Int}' rule: #interfaceType.	self parse:			'interface CatCommand { other : [ Int ]												  name : String !												  friends : [ Cat ]! }'		rule: #interfaceType.	self parse:			'interface CatCommand { other : [ Int ! ] !												  name(some : String) : String !												  friends : [ Cat ]! }'		rule: #interfaceType.</body><body package="GraphQLBeta-Tests-Grammar" selector="testInterfaceTypeIncorrect">testInterfaceTypeIncorrect	self fail: 'interface  { some : Int}' rule: #interfaceType.	self		fail:			'interface CatCommand { other : [ Int 												  name : String !												  friends : [ Cat ]! }'		rule: #interfaceType.	self		fail:			'interface CatCommand { other :												  name : String !												  friends : [ Cat ]! }'		rule: #interfaceType</body></methods><methods><class-id>GraphQLBeta.GQLSchemaGrammarTest</class-id> <category>test-grammar-listType</category><body package="GraphQLBeta-Tests-Grammar" selector="testListType">testListType	self parse: '[Int]' rule: #listType.	self parse: '[SomeObject ]' rule: #listType.	self parse: '[String! ]' rule: #listType.	self parse: '[SomeObject ! ] ' rule: #listType.</body><body package="GraphQLBeta-Tests-Grammar" selector="testListTypeIncorrect">testListTypeIncorrect	self fail: 'Int !' rule: #listType.	self fail: '[Int]!' rule: #listType.	self fail: '[Int ! ]!!' rule: #listType.	self fail: '[String ' rule: #listType.	self fail: '[Some !' rule: #listType</body></methods><methods><class-id>GraphQLBeta.GQLSchemaGrammarTest</class-id> <category>test-grammar-parameters</category><body package="GraphQLBeta-Tests-Grammar" selector="testParameters">testParameters	self parse: '(p1:[Int], p2:String)' rule: #parameters.	self parse: '(p1 : [String ! ])' rule: #parameters.	self parse: '( p1 :[Int ! ]!, p2: String!)' rule: #parameters.</body><body package="GraphQLBeta-Tests-Grammar" selector="testParametersIncorrect">testParametersIncorrect	self fail: '(Int !)' rule: #parameters.	self fail: '(p1, p2)' rule: #parameters.	self fail: '(p1 : Int' rule: #parameters.	self fail: '(p1 Int)' rule: #parameters.	self fail: '(p1 Int!)' rule: #parameters.	self fail: '(p1 : !)' rule: #parameters.	self fail: '(p1 : Int, p2)' rule: #parameters.	self fail: '(p1, p2 : Int)' rule: #parameters.</body></methods><methods><class-id>GraphQLBeta.GQLSchemaGrammarTest</class-id> <category>test-grammar-listInputType</category><body package="GraphQLBeta-Tests-Grammar" selector="testListInputType">testListInputType	"Inner types only input type"	self parse: '[Int]' rule: #listInputType.	self parse: '[String ! ]' rule: #listInputType.	self parse: '[Some!]' rule: #listInputType.	self parse: '[Some ! ] ' rule: #listInputType.	self parse: '[[Int]]' rule: #listInputType</body><body package="GraphQLBeta-Tests-Grammar" selector="testListInputTypeIncorrect">testListInputTypeIncorrect	self fail: 'Int !' rule: #listInputType.	self fail: '[Int ! ]!!' rule: #listInputType.	self fail: '[Int ! ]!' rule: #listInputType.	self fail: '[String ' rule: #listInputType.	self fail: '[Some ' rule: #listInputType.	self fail: '[Some! ' rule: #listInputType.	self fail: '[Some !!' rule: #listInputType.	self fail: '[ Some ] !' rule: #listInputType.</body></methods><methods><class-id>GraphQLBeta.GQLSchemaGrammarTest</class-id> <category>test-grammar-fieldSet</category><body package="GraphQLBeta-Tests-Grammar" selector="testFieldSet">testFieldSet	self parse: '{someName : [Int]}' rule: #fieldSet.	self parse: '{someName 	: [String ! ], someName 	:String }' rule: #fieldSet.	self parse: '{someName 	: [String ! ] someName 	:String }' rule: #fieldSet.	self parse: '{someName 	: String !, someName 	:String }' rule: #fieldSet.	self parse: '{someName 	: String ! someName 	:String }' rule: #fieldSet.	self parse: '{someName 	: [String !] ! someName 	:String }' rule: #fieldSet.</body><body package="GraphQLBeta-Tests-Grammar" selector="testFieldSetIncorrect">testFieldSetIncorrect	self fail: 'someName 	: 	ID !' rule: #fieldSet.	self fail: '{}' rule: #fieldSet.	self fail: '{ someName }' rule: #fieldSet.	self fail: '{ someName : }' rule: #fieldSet.	self fail: '{ someName : !}' rule: #fieldSet.	self fail: '{ someName ID}' rule: #fieldSet.	self fail: '{ someName ID!}' rule: #fieldSet.	self fail: '{ someName !}' rule: #fieldSet.</body></methods><methods><class-id>GraphQLBeta.GQLSchemaGrammarTest</class-id> <category>test-grammar-nonNullType</category><body package="GraphQLBeta-Tests-Grammar" selector="testNonNullType">testNonNullType	self parse: 'Int!' rule: #nonNullType.	self parse: 'SomeOtherType !' rule: #nonNullType.	self parse: '[ Int ]!' rule: #nonNullType.	self parse: '[ Int! ]!' rule: #nonNullType.	self parse: '[ SomeOtherType ]!' rule: #nonNullType.	self parse: '[ SomeOtherType! ]!' rule: #nonNullType.</body><body package="GraphQLBeta-Tests-Grammar" selector="testNonNullTypeIncorrect">testNonNullTypeIncorrect	self fail: 'Int!!' rule: #nonNullType.	self fail: 'Int' rule: #nonNullType.	self fail: 'SomeOtherType' rule: #nonNullType.	self fail: '[ Int! ]' rule: #nonNullType.	self fail: '[ Int ]' rule: #nonNullType.	self fail: '[ SomeOtherType ]' rule: #nonNullType.	self fail: '[ SomeOtherType! ]' rule: #nonNullType</body></methods><methods><class-id>GraphQLBeta.GQLObjectFieldNode</class-id> <category>accessing</category><body package="GraphQLBeta-Nodes" selector="name">name"Return the name"	^ name</body><body package="GraphQLBeta-Nodes" selector="name:">name: anObject"Set the name"	name := anObject</body><body package="GraphQLBeta-Nodes" selector="value">value"Return the value"	^ value</body><body package="GraphQLBeta-Nodes" selector="value:">value: anObject"Set the value"	value := anObject</body></methods><methods><class-id>GraphQLBeta.GQLObjectFieldNode</class-id> <category>action</category><body package="GraphQLBeta-Nodes" selector="executeOn:with:using:">executeOn: resolver with: context using: schema		^ value executeOn: resolver with: context using: schema </body></methods><methods><class-id>GraphQLBeta.GraphQLBetaDemoHTML class</class-id> <category>dependencies</category><body package="GraphQLBeta-Demo" selector="htmlPage">htmlPage	"DO NOT EDIT"	^ '&lt;!DOCTYPE html&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;GraphQL editor&lt;/title&gt;&lt;meta name="description" content="GraphQL Editor - write and run your GraphQL code inside this page."&gt;&lt;script&gt;  var protocol = ("https:" == document.location.protocol)? "https" : "http";  document.write(unescape("%3Cscript src=\""+ protocol + "://code.jquery.com/jquery-1.11.0.min.js\" type=\"text/javascript\"%3E%3C/script%3E"));  document.write(unescape("%3Cscript src=\""+ protocol + "://code.jquery.com/jquery-migrate-1.2.1.min.js\" type=\"text/javascript\"%3E%3C/script%3E"));&lt;/script&gt;&lt;link href="https://js.do/js/codemirror-5.32.1/lib/codemirror.css" rel="stylesheet"&gt;&lt;script src="https://js.do/js/codemirror-5.32.1/lib/codemirror.js"&gt;&lt;/script&gt;&lt;style&gt;body{  margin: 0;  font-family: "Helvetica Neue", Helvetica, Arial, sans-serif;  font-size: 14px;  line-height: 20px;  color: #333333;  background-color: #ffffff;}header {  background-color: black;  padding: 5px;}h1{  color: white;}#gql_operation, #gql_variables{  position: absolute;}#results_area, #gql_code{  position: absolute;  top: 120px;  bottom: 60px;}#results_area{  padding-left: 5px;  right: 1em;  left: 50%;}#gql_code, #gql_operation, #gql_variables{  padding-right: 5px;  right: 50%;  left: 1em;}.beauty-input {  -webkit-border-radius: 3px;     -moz-border-radius: 3px;          border-radius: 3px;  background-color: #ffffff;  border: 1px solid #cccccc;  -webkit-box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075);     -moz-box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075);          box-shadow: inset 0 1px 1px rgba(0, 0, 0, 0.075);  -webkit-transition: border linear 0.2s, box-shadow linear 0.2s;     -moz-transition: border linear 0.2s, box-shadow linear 0.2s;       -o-transition: border linear 0.2s, box-shadow linear 0.2s;          transition: border linear 0.2s, box-shadow linear 0.2s;}.label {  display: inline-block;  padding: 2px 4px;  font-size: 11.844px;  font-weight: bold;  line-height: 14px;  color: #ffffff;  text-shadow: 0 -1px 0 rgba(0, 0, 0, 0.25);  white-space: nowrap;  vertical-align: baseline;  background-color: #999999;  border-radius: 3px;}.top_label {  z-index: 10;  position: absolute;  top: 0px;  right: 10px;  opacity: 0.5;}#col_resize{  position: absolute;  left: 50%;  right: 50%;  top: 140px;  bottom: 60px;  width: 10px;  margin-left: -5px;  cursor: col-resize;  z-index: 3;  text-align: center;  vertical-align: middle;  line-height: 50;  color: #bbb;  text-shadow: 1px 0px #ddd;}footer{  position: absolute;  text-align: center;  bottom: 10px;  left: 1em;  right: 1em;}.buttons{  margin-top: 20px;  position: absolute;  top: 69px;  right: 1em;  left: 1em;}.btn{  display: inline-block;  padding: 4px 12px;  margin-bottom: 0;  font-size: 14px;  line-height: 20px;  color: #333333;  text-align: center;  text-shadow: 0 1px 1px rgba(255, 255, 255, 0.75);  vertical-align: middle;  cursor: pointer;  background-color: #f5f5f5;  background-image: -moz-linear-gradient(top, #ffffff, #e6e6e6);  background-image: -webkit-gradient(linear, 0 0, 0 100%, from(#ffffff), to(#e6e6e6));  background-image: -webkit-linear-gradient(top, #ffffff, #e6e6e6);  background-image: -o-linear-gradient(top, #ffffff, #e6e6e6);  background-image: linear-gradient(to bottom, #ffffff, #e6e6e6);  background-repeat: repeat-x;  border: 1px solid #bbbbbb;  border-color: #e6e6e6 #e6e6e6 #bfbfbf;  border-color: rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.1) rgba(0, 0, 0, 0.25);  border-bottom-color: #a2a2a2;  -webkit-border-radius: 4px;  -moz-border-radius: 4px;  border-radius: 4px;  filter: progid:DXImageTransform.Microsoft.gradient(startColorstr="#ffffffff", endColorstr="#ffe6e6e6", GradientType=0);  filter: progid:DXImageTransform.Microsoft.gradient(enabled=false);  -webkit-box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2), 0 1px 2px rgba(0, 0, 0, 0.05);  -moz-box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2), 0 1px 2px rgba(0, 0, 0, 0.05);  box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.2), 0 1px 2px rgba(0, 0, 0, 0.05);}.btn:hover {  color: #333333;  text-decoration: none;  background-color: #e6e6e6;  *background-color: #d9d9d9;  /* Buttons in IE7 don"t get borders, so darken on hover */  background-position: 0 -15px;  -webkit-transition: background-position 0.1s linear;     -moz-transition: background-position 0.1s linear;       -o-transition: background-position 0.1s linear;          transition: background-position 0.1s linear;}.btn:focus {  outline: thin dotted #333;  outline: 5px auto -webkit-focus-ring-color;  outline-offset: -2px;}.btn.active,.btn:active {  background-color: #e6e6e6;  background-color: #d9d9d9 \9;  background-image: none;  outline: 0;  -webkit-box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.15), 0 1px 2px rgba(0, 0, 0, 0.05);     -moz-box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.15), 0 1px 2px rgba(0, 0, 0, 0.05);          box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.15), 0 1px 2px rgba(0, 0, 0, 0.05);}a{  text-decoration: none;}.btn-small [class^="icon-"], .btn-small [class*=" icon-"] {    margin-top: 0;}.btn-small{  margin-top: 0;  font-size: 11.9px;  padding: 2px 10px;  font-size: 11.9px;  border-radius: 3px;}[class^="icon-"], [class*=" icon-"] {  display: inline-block;  width: 14px;  height: 14px;  margin-top: 1px;  line-height: 14px;  vertical-align: text-top;  background-image: url(https://js.do/bootstrap/img/glyphicons-halflings.png);  background-position: 14px 14px;  background-repeat: no-repeat;}.icon-play {  background-position: -264px -72px;}.icon-file {  background-position: -24px -24px;}.icon-options{  background-position: -264px 0;}.alert_message{  position: fixed;  top: 0px;  left: 0px;  width: 100%;  height: 100%;  background-color: black;  z-index: 19;  opacity: 0.85;  display: none;}.alert_message div{  z-index: 20;  top: 80px;  position: absolute;  background-color: white;  border: 1px solid black;  box-shadow: rgb(192, 192, 192) 0px 0px 10px;  padding: 2em; left: 0px;  right: 0px;  margin-left: auto;  margin-right: auto;  max-width: 700px;}&lt;/style&gt;&lt;/head&gt;&lt;body&gt;  &lt;header&gt;    &lt;h1&gt;ProtoGraphQL in Smalltalk&lt;/h1&gt;  &lt;/header&gt;  &lt;form method="get" id="gql_form"&gt;    &lt;input id="query" name="query" type= "hidden"&gt;    &lt;input id="operation" name="operation" type= "hidden"&gt;    &lt;input id="variables" name="variables" type= "hidden"&gt;    &lt;div class="buttons"&gt;      &lt;a href="javascript:;" class="btn xbtn-info btn-small" onclick="run_code(); return(false);"&gt;        &lt;i class="icon-play"&gt;&lt;/i&gt;        &amp;nbsp; Run&lt;/a&gt;      &lt;a href="javascript:;" class="btn xbtn-info btn-small" onclick="moreOptions(); return(false);"&gt;          &lt;i class="icon-options"&gt;&lt;/i&gt;          &amp;nbsp; Options&lt;/a&gt;      &lt;a href="javascript:;" class="btn xbtn-info btn-small" onclick="showExamples(); return(false);"&gt;        &lt;i class="icon-file"&gt;&lt;/i&gt;        &amp;nbsp; Examples&lt;/a&gt;    &lt;/div&gt;    &lt;div id="gql_code"&gt;      &lt;span class="label top_label"&gt;GraphQL&lt;/span&gt;    &lt;/div&gt;    &lt;div id="moreOptions"&gt;      &lt;div id="gql_operation"&gt;        &lt;span class="label top_label"&gt;Operation&lt;/span&gt;      &lt;/div&gt;      &lt;div id="gql_variables"&gt;        &lt;span class="label top_label"&gt;Variables&lt;/span&gt;      &lt;/div&gt;    &lt;/div&gt;  &lt;/form&gt;  &lt;div id="col_resize"&gt;||&lt;/div&gt;  &lt;div id="results_area" class="code_area_result"&gt;    &lt;span class="label top_label"&gt;Result&lt;/span&gt;  &lt;/div&gt;  &lt;div class="alert_message"&gt;    &lt;div&gt;      &lt;h3&gt;Examples:&lt;/h3&gt;      &lt;ul&gt;        &lt;li&gt;&lt;a href="javascript:;" onclick="example(&amp;#39;heros&amp;#39;); return false;"&gt;Heros&lt;/a&gt;&lt;/li&gt;        &lt;li&gt;&lt;a href="javascript:;" onclick="example(&amp;#39;films&amp;#39;); return false;"&gt;Films&lt;/a&gt;&lt;/li&gt;        &lt;li&gt;&lt;a href="javascript:;" onclick="example(&amp;#39;operation&amp;#39;); return false;"&gt;Operations&lt;/a&gt;&lt;/li&gt;      &lt;/ul&gt;    &lt;/div&gt;  &lt;/div&gt;  &lt;footer&gt;SemanTICs S.R.L.&amp; Object Profile&lt;/footer&gt;  &lt;script&gt;  var codeMirror, resultsMirror, operationMirror, variablesMirror;  var examples = [];  examples["heros"]="{\n  heroes{\n    name\n    planet\n  }\n}\n";  examples["films"] = "{\n	allFilms{\n		name	\n	}\n}";  examples["operation"] = [`query operation1($name : String, $person : PersonInput, $gender : FilmType){      film(name:$name){        name        rating      }      filmsOn(gender: $gender){        name        rating      }      filmsDirected(by:$person){        name      }   }   query operation2 {     hello   }`, "operation1", "{ \"name\":\"terminator\", \"person\":{name:\"George Lucas\"}, \"gender\":ACTION }"];  $(function(){    codeMirror = CodeMirror(document.getElementById("gql_code"),{      "lineNumbers": true,      "indentUnit": 0,      "theme": "default",      "smartIndent": false,      "enterMode": "flat",      "styleActiveLine": true,      "autofocus": true    });    resultsMirror = createMirror("results_area");    operationMirror = createMirror("gql_operation");    variablesMirror = createMirror("gql_variables");    codeMirror.setValue("####VAR####");    var string = "####VAR####";    operationMirror.setValue(string);    variablesMirror.setValue("####VAR####");    resultsMirror.setValue("####VAR####");    $(".CodeMirror").addClass("beauty-input");    $(".alert_message").click(function(){$(".alert_message").hide("fast");});    if(!string)      moreOptions();    window.onresize = function() {      recalculate_windows_size();    }    window.onload = function() {      recalculate_windows_size();      resultsMirror.refresh();    }  });  function createMirror(id){    return CodeMirror(document.getElementById(id),{      "lineNumbers": true,      "indentUnit": 0,      "theme": "default",      "smartIndent": false,      "enterMode": "flat",      "styleActiveLine": true,      "autofocus": false    });  }  $("#col_resize").on("mousedown mouseup mouseover", function(event) {    event.preventDefault();    if (event.type == "mousedown") {      var w = $(window).width();      $(document).on("mousemove", function(event2) {        var percent = (event2.pageX/w * 100);        if (percent&gt;95) {          if (percent&gt;97) { // if mouse out of browser, disable drag.            disable_drag();          }          percent=95;        } else if (percent &lt; 5) {          if (percent&lt;3) { // if mouse out of browser, disable drag.            disable_drag();          }          percent = 5;        }        $("#gql_code, #gql_operation, #gql_variables").css("right", (100-percent)+"%");        $("#col_resize").css("right", (100-percent)+"%").css("left", (percent)+"%");        $("#results_area").css("left", (percent)+"%");      });    } else if (event.type == "mouseup") {      disable_drag();    }    function disable_drag() {      $(document).off("mousemove");    }  });  function recalculate_windows_size() {    var h = document.getElementById("gql_code").clientHeight;    $(".CodeMirror").height(h);    var el = $("#moreOptions");    if(el.css("display") == "none") return;    $("#gql_code .CodeMirror").height(h * 0.59);    $("#gql_operation").css({top: 120 + h * 0.61 });    $("#gql_variables").css({top: 120 + h * 0.82 });    $("#gql_operation .CodeMirror, #gql_variables .CodeMirror").height(h*0.18);  }  function example(id){    var arr = examples[id], x, y, z;    if(typeof arr === "string"){      x = arr;      y = z = "";    }else{      if($("#moreOptions").css("display") == "none")        moreOptions();      x = arr[0];      y = arr[1];      z = arr[2];    }    codeMirror.setValue(x);    operationMirror.setValue(y);    variablesMirror.setValue(z);    codeMirror.markClean();    operationMirror.markClean();    variablesMirror.markClean();  }  function showExamples(){    $(".alert_message").show("fast");  }  function moreOptions(){    var el = $("#moreOptions");    if(el.css("display") !== "none")      el.hide();    else el.show();    recalculate_windows_size();  }  function run_code(){    $("#query").val(codeMirror.getValue());    $("#operation").val(operationMirror.getValue());    $("#variables").val(variablesMirror.getValue());    $("#gql_form").submit();  }  &lt;/script&gt;&lt;/html&gt;'</body></methods><methods><class-id>GraphQLBeta.GQLRequestGrammarTest</class-id> <category>initialization</category><body package="GraphQLBeta-Tests-Grammar" selector="parserClass">parserClass	^ GQLRequestGrammar</body></methods><methods><class-id>GraphQLBeta.GQLRequestGrammarTest</class-id> <category>tests-grammar</category><body package="GraphQLBeta-Tests-Grammar" selector="testAlias">testAlias	|text|	text := 'smallPic:'.	self parse: text rule: #alias.	text := 'smallPic :'.	self parse: text rule: #alias.		</body><body package="GraphQLBeta-Tests-Grammar" selector="testArgument">testArgument	|text|	text := 'id:4'.	self parse: text rule: #argument.</body><body package="GraphQLBeta-Tests-Grammar" selector="testArguments">testArguments	|text|	text := '(id: 4)'.	self parse: text rule: #arguments.	text := '(id: 4, pass: 1233, pass2: 12312)'.	self parse: text rule: #arguments.</body><body package="GraphQLBeta-Tests-Grammar" selector="testDirectives">testDirectives	self parse: '@skip' rule: #directives.	self parse: '@skip(if: true)' rule: #directives.	self parse: '@skip(if: false)' rule: #directives.	self fail: 'missing@(if: true)' rule: #directives.</body><body package="GraphQLBeta-Tests-Grammar" selector="testDocument">testDocument	| text |	text := 'fragment friendFields on User {  		id  		name 	 	profilePic(size: 50)	}'.	self parse: text rule: #document.		text := 'fragment friendFields on User { 	 	id  		name  		...standardProfilePic	}'.	self parse: text rule: #document.		text := '{	  likeStory {			story {  	  	  		likeCount  	 		} 	 	}	}'.	self parse: text rule: #document.	text := 'mutation fetchLikeStory($var:Int){	  likeStory(storyID: Int) {			story {  	  	  		likeCount  	 		} 	 	}	}'.	self parse: text rule: #document.		text := '{	  likeStory($storyID: Int=12) {			story {  	  	  		likeCount  	 		} 	 	}	}'.	self fail: text rule: #document.	</body><body package="GraphQLBeta-Tests-Grammar" selector="testEnumValue">testEnumValue	self parse: 'ENUM_VALUE' rule: #enumValue.	self parse: 'any_other_name_value_noSpaces' rule: #enumValue.	self fail: 'true' rule: #enumValue.	self fail: 'false' rule: #enumValue.	self fail: 'null' rule: #enumValue.</body><body package="GraphQLBeta-Tests-Grammar" selector="testField">testField	|text|	text := 'me'.	self parse: text rule: #field.		text := 'user(id: 4) {    name  }'.	self parse: text rule: #field.</body><body package="GraphQLBeta-Tests-Grammar" selector="testFragmentDefinition">testFragmentDefinition	|text|	text := 'fragment friendFields on User {  id  name  profilePic(size: 50)}'.	self parse: text rule: #fragmentDefinition.		text := 'fragment friendFields on User {  id  name  ...standardProfilePic}'.	self parse: text rule: #fragmentDefinition.	</body><body package="GraphQLBeta-Tests-Grammar" selector="testFragmentSpread">testFragmentSpread	|text|	text := '...friendFields'.	self parse: text rule: #fragmentSpread.</body><body package="GraphQLBeta-Tests-Grammar" selector="testInlineFragment">testInlineFragment	|text|	text := '... on User {      friends {        count      }    }'.	self parse: text rule: #inlineFragment.		text := '... @include(if: $expandedInfo) {      firstName      lastName      birthday    }'.	self parse: text rule: #inlineFragment.</body><body package="GraphQLBeta-Tests-Grammar" selector="testInlineFragments">testInlineFragments	|text|	text := '... on User {      friends {        count      }    }'.	self parse: text rule: #inlineFragment.		text := '... @include(if: $expandedInfo) {      firstName      lastName      birthday    }'.	self parse: text rule: #inlineFragment.</body><body package="GraphQLBeta-Tests-Grammar" selector="testListValue">testListValue	self parse: '[1, 2, 3]' rule: #listValue.	self parse: '["a"]' rule: #listValue.	self parse: '[]' rule: #listValue.	self parse: '[[], "a", 1]' rule: #listValue.	self fail: 'null' rule: #listValue.	self fail: '123.123e12' rule: #listValue.</body><body package="GraphQLBeta-Tests-Grammar" selector="testNamedType">testNamedType	self parse: 'NamedType' rule: #namedType.	self fail: 'NonNullType!' rule: #namedType.</body><body package="GraphQLBeta-Tests-Grammar" selector="testNonNullType">testNonNullType	self parse: 'NonNullType!' rule: #nonNullType.	self fail: 'NonNullType' rule: #nonNullType.</body><body package="GraphQLBeta-Tests-Grammar" selector="testNullValue">testNullValue	self parse: 'null' rule: #nullValue.	self fail: '123.123' rule: #nullValue.	self fail: 'asdf' rule: #nullValue.</body><body package="GraphQLBeta-Tests-Grammar" selector="testObjectField">testObjectField	|text|		text := '_4__ : null'.	self parse: text rule: #objectField.	text := 'age : 12'.	self parse: text rule: #objectField.	</body><body package="GraphQLBeta-Tests-Grammar" selector="testObjectValue">testObjectValue	|text|		text := '{ }'.	self parse: text rule: #objectValue.		text := '{name: "12.43", age: 53 }'.	self parse: text rule: #objectValue.	</body><body package="GraphQLBeta-Tests-Grammar" selector="testOperationDefinition">testOperationDefinition	|text|		text := '{	  likeStory {			story {  	  	  		likeCount  	 		} 	 	}	}'.	self parse: text rule: #operationDefinition.	text := 'mutation fetchLikeStory($var:Int){	  likeStory(storyID: Int) {			story {  	  	  		likeCount  	 		} 	 	}	}'.	self parse: text rule: #operationDefinition.		text := '{	  likeStory($storyID: Int=12) {			story {  	  	  		likeCount  	 		} 	 	}	}'.	self fail: text rule: #operationDefinition.</body><body package="GraphQLBeta-Tests-Grammar" selector="testSelectionSet">testSelectionSet	|text|		text := '{		films {			id #comment			name 			rating 		}	}'.	self parse: text rule: #selectionSet.	text := '{			parents { 				firstName			}  			firstName  			lastName			friends { 				nickname				lastname			}		}'.	self parse: text rule: #selectionSet.	text := '{  			friends(id:4) { 				nickname			}  			firstName  			lastName		}'.	self parse: text rule: #selectionSet.</body><body package="GraphQLBeta-Tests-Grammar" selector="testType">testType	self parse: 'NonNullType' rule: #type.	self parse: 'NonNullType!' rule: #type.	self parse: '[Named]' rule: #type.	self parse: '[Named!]' rule: #type.	self parse: '[Named]!' rule: #type.	self parse: '[Named!]!' rule: #type.	self parse: 'Boolean' rule: #type.	self parse: 'Int!' rule: #type.	self parse: '[Float]' rule: #type.	self parse: '[String!]' rule: #type.	self parse: '[ID]!' rule: #type.	self parse: '[Int!]!' rule: #type	</body><body package="GraphQLBeta-Tests-Grammar" selector="testTypeCondition">testTypeCondition	|text|	text := 'on User'.	self parse: text rule: #typeCondition.</body><body package="GraphQLBeta-Tests-Grammar" selector="testValue">testValue	"implement tests with test contained in intValue floatValue, StringValue,	BooleanValue, NullValue, EnumValue, ListValue, ObjectValue"		"int value"	self parse: '2312' rule: #value.	self parse: '-123' rule: #value.	self parse: '+444' rule: #value.	"float value"	self parse: '2312.12' rule: #value.	self parse: '-123.23e12' rule: #value.	self parse: '-123.23E12' rule: #value.	self parse: '12' rule: #value.	"boolean value"	self parse: 'true' rule: #value.	self parse: 'false' rule: #value.	"string value"	self parse: '""' rule: #value.	self parse: '"any other kind of text +_)(*&amp;^%$#@ |}{:?&gt;&lt;][/;.,"' rule: #value.	self parse: '"\u00f3 \\ \/ \b \f \n \r \t"' rule: #value.	"list value"	self parse: '[1, 2, 3]' rule: #value.	self parse: '["a"]' rule: #value.	self parse: '[]' rule: #value.	self parse: '[[], "a", 1]' rule: #value.	"null value"	self parse: 'null' rule: #value.		"enum value"		self parse: 'ENUM_VALUE' rule: #value.	self parse: 'any_other_name_value_noSpaces' rule: #value.	self parse: '{ }' rule: #value.	self parse: '{name: "12.43", age: 53 }' rule: #value.	</body><body package="GraphQLBeta-Tests-Grammar" selector="testVariable">testVariable	self parse: '$someVariableName' rule: #variable.	self fail: 'missing$atthebegining' rule: #variable.</body><body package="GraphQLBeta-Tests-Grammar" selector="testVariableDefinition">testVariableDefinition	self parse: '$devicePicSize: Int' rule: #variableDefinition.	self parse: '$devicePicSize: Int = 12' rule: #variableDefinition.</body><body package="GraphQLBeta-Tests-Grammar" selector="testVariableDefinitions">testVariableDefinitions	self parse: '($devicePicSize: Int)' rule: #variableDefinitions.	self parse: '($devicePicSize: Int = 12)' rule: #variableDefinitions.	self parse: '($devicePicSize: Int = 12, $devicePicSize: Int = 2)' rule: #variableDefinitions.	self fail: '($devicePicSize: Int = 12,)' rule: #variableDefinitions.	self fail: '$devicePicSize: Int = 12' rule: #variableDefinitions.</body></methods><methods><class-id>GraphQLBeta.GQLSFieldNode</class-id> <category>accessing</category><body package="GraphQLBeta-NodesSchema" selector="arguments">arguments"Return the arguments"	^ arguments</body><body package="GraphQLBeta-NodesSchema" selector="fullName">fullName	"Return the full name"	fullName		ifNil: [ | write |			write := WriteStream on: String new.			write nextPutAll: self name.			self arguments				ifNotEmpty: [ :ags | 					ags keys						doWithIndex: [ :na :i | 							i = 1								ifTrue: [ write										nextPutAll: na capitalized;										nextPut: $: ]								ifFalse: [ write										nextPutAll: na;										nextPut: $: ] ] ].			fullName := write contents ].	^ fullName</body><body package="GraphQLBeta-NodesSchema" selector="getArgument:">getArgument: aString	"Return a argument given his name"	(arguments includesKey: aString)		ifTrue: [ ^ arguments at: aString ].	^ nil</body><body package="GraphQLBeta-NodesSchema" selector="name">name"Return the name"	^ name</body><body package="GraphQLBeta-NodesSchema" selector="name:">name: aName"Set the name"	name := aName</body><body package="GraphQLBeta-NodesSchema" selector="type">type"Return the type"	^ type</body><body package="GraphQLBeta-NodesSchema" selector="type:">type: aType"Set the type"	type := aType</body></methods><methods><class-id>GraphQLBeta.GQLSFieldNode</class-id> <category>adding</category><body package="GraphQLBeta-NodesSchema" selector="addArguments:">addArguments: aArray"Given a collection puts the values on a dictionary for improve the search"	aArray		ifNotNil: [ :array | array do: [ :argument | arguments at: argument name put: argument ] ]</body></methods><methods><class-id>GraphQLBeta.GQLSFieldNode</class-id> <category>initialization</category><body package="GraphQLBeta-NodesSchema" selector="initialize">initialize	super initialize.	arguments := OrderedDictionary new</body></methods><methods><class-id>GraphQLBeta.GQLVariableGrammarEvaluator</class-id> <category>accessing</category><body package="GraphQLBeta-Parser" selector="booleanValue">booleanValue"Return the boolean value"	^ super booleanValue		performs: [ :tokens | 			| node |			node := GQLBooleanNode new.			node value: tokens inputValue.			node ]</body><body package="GraphQLBeta-Parser" selector="enumValue">enumValue"Return the enum value"	^ super enumValue		performs: [ :tokens | 			| node |			node := GQLEnumNode new.			node value: tokens inputValue.			node ]</body><body package="GraphQLBeta-Parser" selector="floatValue">floatValue"Return the variable"	^ super floatValue		performs: [ :tokens | 			| node |			node := GQLFloatNode new.			node value: tokens inputValue.			node ]</body><body package="GraphQLBeta-Parser" selector="intValue">intValue"Return the intValue"	^ super intValue		performs: [ :tokens | 			| node |			node := GQLIntNode new.			node value: tokens inputValue.			node ]</body><body package="GraphQLBeta-Parser" selector="listValue">listValue"Return the list value"	^ super listValue		performs: [ :tokens | 			| node |			node := GQLListNode new.			node value: (tokens at: 2).			node ]</body><body package="GraphQLBeta-Parser" selector="nullValue">nullValue"Return the nullValue"	^ super nullValue		performs: [ :tokens | 			| node |			node := GQLNullNode new.			node value: tokens inputValue.			node ]</body><body package="GraphQLBeta-Parser" selector="objectField">objectField"Return a GQLObjectFieldNode instance with the information from the request"	^ super objectField		performs: [ :tokens | 			| node |			node := GQLObjectFieldNode new.			node name: (tokens at: 1) inputValue.			node value: (tokens at: 3).			node ]</body><body package="GraphQLBeta-Parser" selector="objectValue">objectValue"Return the objectValue"	^ super objectValue		performs: [ :tokens | 			| node |			node := GQLObjectNode new.			node objectFields: (tokens at: 2).			node ]</body><body package="GraphQLBeta-Parser" selector="stringValue">stringValue"Return the string value"	^ super stringValue		performs: [ :tokens | 			| node |			node := GQLStringNode new.			node value: tokens inputValue.			node ]</body><body package="GraphQLBeta-Parser" selector="variableSet">variableSet"Return the variableValues parsed"	^ super variableSet		performs: [ :tokens | tokens at: 2 ]</body></methods><methods><class-id>GraphQLBeta.GQLVariableGrammarEvaluator</class-id> <category>grammar</category><body package="GraphQLBeta-Parser" selector="variableValue">variableValue"Return a instance of GQLVariableDefinitionNode with the information of the parser"	^ super variableValue		performs: [ :tokens | 			| node |			node := GQLVariableDefinitionNode new.			node name: ((tokens at: 1) executeOn: nil with: nil using: nil).			node value: (tokens at: 3).			node		]</body></methods><methods><class-id>GraphQLBeta.GQLDirectiveNode</class-id> <category>accessing</category><body package="GraphQLBeta-Nodes" selector="arguments">arguments"Return the arguments"	^ arguments</body><body package="GraphQLBeta-Nodes" selector="arguments:">arguments: anObject"Set the arguments"	arguments := anObject</body><body package="GraphQLBeta-Nodes" selector="isInclude">isInclude	^ false</body><body package="GraphQLBeta-Nodes" selector="isSkip">isSkip	^ false</body><body package="GraphQLBeta-Nodes" selector="name">name"Return the name"	^ name</body><body package="GraphQLBeta-Nodes" selector="name:">name: anObject"Set the name"	name := anObject</body></methods><methods><class-id>GraphQLBeta.GQLDirectiveNode</class-id> <category>running</category><body package="GraphQLBeta-Nodes" selector="execute:">execute: context	^ self subclassResponsibility </body></methods><methods><class-id>GraphQLBeta.GQLDirectiveNode</class-id> <category>comparing</category><body package="GraphQLBeta-Nodes" selector="partialEquals:using:">partialEquals: other using: context"Given other directive, verify if has the same name and arguments"	^ (self name = other name) &amp;	  (self arguments size = other arguments size) and: 		[ self arguments allSatisfy: 			[ :arg | other arguments anySatisfy: [ :o | arg partialEquals: o using: context] ]]</body></methods><methods><class-id>GraphQLBeta.GQLDirectiveNode</class-id> <category>execute</category><body package="GraphQLBeta-Nodes" selector="evaluateOn:using:">evaluateOn: schema using: context"Evaluate if the directive exist on schema, as it's defined"	| directive |	directive := schema getDirective: self name.	^ directive isNotNil and: [self partialEquals: directive using: context].		</body></methods><methods><class-id>GraphQLBeta.GQLDirectiveNode class</class-id> <category>instance creation</category><body package="GraphQLBeta-Nodes" selector="new:">new: aName	| inst |	self allSubclasses detect: [ :subclass | subclass directiveName = aName ]						ifFound: [ :subclass | inst := subclass new ]						ifNone: [ inst := self new ].							^ inst</body></methods><methods><class-id>GraphQLBeta.GraphQLPlatform</class-id> <category>accessing - classes</category><body package="GraphQLBeta" selector="classAt:">classAt: symbol	self subclassResponsibility </body><body package="GraphQLBeta" selector="jsonWriter">jsonWriter	self subclassResponsibility</body><body package="GraphQLBeta" selector="toJson:">toJson: object	self subclassResponsibility</body></methods><methods><class-id>GraphQLBeta.GraphQLPlatform</class-id> <category>server</category><body package="GraphQLBeta" selector="okResponse:">okResponse: string	self subclassResponsibility</body><body package="GraphQLBeta" selector="registerDemoServer:">registerDemoServer: demo	self subclassResponsibility</body><body package="GraphQLBeta" selector="request:at:">request: aRequest at: nameQuery	self subclassResponsibility</body><body package="GraphQLBeta" selector="serverStop">serverStop	self subclassResponsibility</body></methods><methods><class-id>GraphQLBeta.GraphQLPlatform class</class-id> <category>accessing</category><body package="GraphQLBeta" selector="current">current	^ instance ifNil: [ instance := (self subclasses select: [ :cls | cls isActive ]) first new ].</body></methods><methods><class-id>GraphQLBeta.GQLTestMutationType</class-id> <category>as yet unclassified</category><body package="GraphQLBeta-Test-Utils" selector="createPointX:y:">createPointX: x y: y	^ x @ y</body></methods><methods><class-id>GraphQLBeta.GraphQL</class-id> <category>accessing</category><body package="GraphQLBeta" selector="handleRequest:">handleRequest: aTextRequest	"Given a text request, this is parsed and validated with the schema defined, if everything is ok then execute the request"	^ self handleRequest: aTextRequest using: '' with: ''.</body><body package="GraphQLBeta" selector="handleRequest:using:with:">handleRequest: aTextRequest using: operation with: textVariables	"Given a text request, this is parsed and validated with the schema defined, if everything is ok then execute the request"	| document res variables operationName |	res := schema validate.	variables := nil.	operationName := nil.	(res isKindOf: GQLException) ifTrue: [ ^ res ].	document := GQLSingleAnonimousQueryEvaluator parse: aTextRequest.	(document isKindOf: PPFailure)		ifTrue: [ ^ GQLException new messageText: 'Fail parsing on request' ].	textVariables isEmpty 	ifFalse: [ variables := GQLVariableGrammarEvaluator parse: textVariables ].	operation isEmpty 	ifFalse: [ operationName:= operation ].	context reset.	context addFragments: document fragments;	operationName: operationName;	variables: variables.	document := document evaluate.	res := (document isKindOf: GQLException)		ifFalse: [ document executeOn: rootInstance with: context using: schema ]		ifTrue: [ document ].	^ res</body><body package="GraphQLBeta" selector="schema">schema"Return the schema"	^ schema</body><body package="GraphQLBeta" selector="schema:">schema: aGQLSchema"Set the schema"	schema := aGQLSchema</body></methods><methods><class-id>GraphQLBeta.GraphQL</class-id> <category>initialization</category><body package="GraphQLBeta" selector="createSchema:">createSchema: aTextSchema"Given a text schema, parses this text if everything is ok then evaluate this nodes and the schema is validated"	schema := GQLSchemaGrammarEvaluator		parse: aTextSchema.	(schema isKindOf: PPFailure)		ifTrue: [ ^ GQLEvaluationException new messageText: 'Fail parsing on schema'; raise. ]	</body><body package="GraphQLBeta" selector="initialize">initialize"Initialize the validator and the entry point with the default schema"	rootInstance := Dictionary new.	rootInstance at: 'query' put: Query new;					at: 'mutation' put: Mutation new.	self createSchema: Query schema.	context := GQLContext new.</body><body package="GraphQLBeta" selector="rootInstance:">rootInstance: aRoot"Set the root instance of graphql server"	rootInstance := aRoot</body></methods><methods><class-id>GraphQLBeta.GQLTestQueryType</class-id> <category>accessing</category><body package="GraphQLBeta-Test-Utils" selector="boxOffice">boxOffice	^ boxOffice</body><body package="GraphQLBeta-Test-Utils" selector="boxOffice:">boxOffice: anObject	boxOffice := anObject</body><body package="GraphQLBeta-Test-Utils" selector="description">description	^ description</body><body package="GraphQLBeta-Test-Utils" selector="description:">description: anObject	description := anObject</body><body package="GraphQLBeta-Test-Utils" selector="featuresFilm:">featuresFilm: aGQLFilm	^ aGQLFilm filmName</body><body package="GraphQLBeta-Test-Utils" selector="filmName:rating:">filmName: aName rating: aRating	^ self films detect: [ :film | ((film name = aName) &amp; (film rating = aRating))  ]</body><body package="GraphQLBeta-Test-Utils" selector="films">films	| data |	data := OrderedCollection new.	data add: (GQLTestFilm new: 1 name: 'harry potter y la piedra filosofal' rating: 9 gender: 'SCIENCE_FICTION'). 	data addLast: (GQLTestFilm new: 2 name: 'el seÃ±or de los anillos' rating: 8 gender: 'SCIENCE_FICTION'). 	data addLast: (GQLTestFilm new: 3 name: 'terminator' rating: 5 gender: 'SCIENCE_FICTION'). 	data addLast: (GQLTestFilm new: 4 name: 'rambo' rating: 5 gender: 'ACTION'). 	data addLast: (GQLTestFilm new: 5 name: 'robocop' rating: 5 gender: 'SCIENCE_FICTION'). 	data addLast: (GQLTestFilm new: 6 name: 'alien' rating: 7 gender: 'SCIENCE_FICTION'). 	data addLast: (GQLTestFilm new: 7 name: 'annie' rating: 6 gender: 'COMEDY'). 	^ data</body><body package="GraphQLBeta-Test-Utils" selector="filmsWithRating:">filmsWithRating: aRating	^ self films select: [ :film | film rating = aRating ]</body><body package="GraphQLBeta-Test-Utils" selector="gender">gender	^ gender</body><body package="GraphQLBeta-Test-Utils" selector="gender:">gender: anObject	gender := anObject</body><body package="GraphQLBeta-Test-Utils" selector="hello">hello	^ 'hello world'</body><body package="GraphQLBeta-Test-Utils" selector="helloToName:">helloToName: aName 	^ 'hello ' , aName</body><body package="GraphQLBeta-Test-Utils" selector="isBoxOffice">isBoxOffice	^ isBoxOffice</body><body package="GraphQLBeta-Test-Utils" selector="isBoxOffice:">isBoxOffice: anObject	isBoxOffice := anObject</body><body package="GraphQLBeta-Test-Utils" selector="rating">rating	^ rating</body><body package="GraphQLBeta-Test-Utils" selector="rating:">rating: anObject	rating := anObject</body><body package="GraphQLBeta-Test-Utils" selector="totalInformationFilm:">totalInformationFilm: aArrayGQLTestQueryType	^ aArrayGQLTestQueryType.</body></methods><methods><class-id>GraphQLBeta.GQLTestQueryType</class-id> <category>as yet unclassified</category><body package="GraphQLBeta-Test-Utils" selector="classificationGender:">classificationGender: aClassification	(self classifications includes: aClassification) 	ifTrue: [ ^ aClassification  ] 	ifFalse: [ ^ nil ]</body><body package="GraphQLBeta-Test-Utils" selector="classifications">classifications	^ #('COMEDY' 'SCIENCE_FICTION' 'ACTION')</body><body package="GraphQLBeta-Test-Utils" selector="detailedInformationFilm:">detailedInformationFilm: aGQLTestQueryType	^ GQLTestQueryType new: aGQLTestQueryType. </body><body package="GraphQLBeta-Test-Utils" selector="filmsOfGender:">filmsOfGender: aGender	^ self films select: [ :f | f gender = aGender ]</body><body package="GraphQLBeta-Test-Utils" selector="filmsOnGenders:">filmsOnGenders: listGender	^ self films select: [ :f | listGender includes: f gender ]</body><body package="GraphQLBeta-Test-Utils" selector="informationFilm:">informationFilm: aGQLTestFilm	self description: aGQLTestFilm description.	^ GQLTestFilm new: aGQLTestFilm id name: aGQLTestFilm description  rating: aGQLTestFilm rating gender: aGQLTestFilm gender. </body><body package="GraphQLBeta-Test-Utils" selector="informationInputFilm:">informationInputFilm: aGQLFilm	^ GQLTestQueryType new description: aGQLFilm filmName; 							gender: 'gender'. </body></methods><methods><class-id>GraphQLBeta.GQLTestQueryType class</class-id> <category>instance creation</category><body package="GraphQLBeta-Test-Utils" selector="new:">new: aGQLTestQueryType	| instance |	instance := GQLTestQueryType new.	instance rating: aGQLTestQueryType rating.	instance boxOffice: aGQLTestQueryType boxOffice.	instance gender: aGQLTestQueryType gender.	instance isBoxOffice: aGQLTestQueryType isBoxOffice.	instance description: aGQLTestQueryType description.	instance gender: aGQLTestQueryType gender.	^ instance		</body></methods><methods><class-id>GraphQLBeta.GQLTest</class-id> <category>converting</category><body package="GraphQLBeta-Tests-Nodes" selector="assert:class:">assert: anObject class: aClass	self assert: anObject class equals: aClass</body><body package="GraphQLBeta-Tests-Nodes" selector="assert:fullName:">assert: anObject fullName: aName	self assert: anObject fullName equals: aName</body><body package="GraphQLBeta-Tests-Nodes" selector="assert:name:">assert: anObject name: aName	self assert: anObject name equals: aName</body><body package="GraphQLBeta-Tests-Nodes" selector="assert:position:">assert: anObject position: aInt	self assert: anObject position equals: aInt</body><body package="GraphQLBeta-Tests-Nodes" selector="assert:type:">assert: anObject type: aType	self assert: anObject type equals: aType</body><body package="GraphQLBeta-Tests-Nodes" selector="assertList:class:">assertList: aList class: aClass	aList do: [ :element | self assert: element class: aClass. ].</body></methods><methods><class-id>GraphQLBeta.GQLTest</class-id> <category>parsing</category><body package="GraphQLBeta-Tests-Nodes" selector="assertArguments:ofClasses:">assertArguments: aField ofClasses: aCollection	| valuesClasses |	valuesClasses := (aField arguments collect: #value) collect: #class.		self assert: (valuesClasses collect: [ :cls | cls name asString ] ) equals: aCollection.	</body><body package="GraphQLBeta-Tests-Nodes" selector="assertArguments:withNames:">assertArguments: aField withNames: aCollection	self assert: (aField arguments collect: #name) equals: aCollection.	</body><body package="GraphQLBeta-Tests-Nodes" selector="assertArguments:withValues:">assertArguments: aField withValues: aCollection	| values |	values := (aField arguments collect: #value) collect: #value.	self assert: values equals: aCollection.	</body><body package="GraphQLBeta-Tests-Nodes" selector="assertList:withValues:">assertList: aList withValues: aCollection	self assert: (aList collect: #value) equals: aCollection </body><body package="GraphQLBeta-Tests-Nodes" selector="assertObjectField:withNames:">assertObjectField: anObject withNames: aCollection	self assert: (anObject objectFields collect: #name) equals: aCollection.	</body><body package="GraphQLBeta-Tests-Nodes" selector="assertObjectField:withValues:">assertObjectField: anObject withValues: aCollection	self assert: ((anObject objectFields collect: #value) collect: #value) equals: aCollection.</body><body package="GraphQLBeta-Tests-Nodes" selector="assertSelections:withNames:">assertSelections: aField withNames: aCollection	| values |	values := aField selectionSet selections collect: #name.	self assert: values equals: aCollection.	</body><body package="GraphQLBeta-Tests-Nodes" selector="attendRequest:">attendRequest: text	^ self attendRequest: text using: nil with: ''.</body><body package="GraphQLBeta-Tests-Nodes" selector="attendRequest:using:with:">attendRequest: text using: operationName with: textVariables	^ self attendRequest: text using: operationName  with: textVariables  root: rootInstance</body><body package="GraphQLBeta-Tests-Nodes" selector="attendRequest:using:with:root:">attendRequest: text using: operationName with: textVariables root: root	| document context variables |	document := self parseRequest: text.	textVariables isEmpty 	ifFalse:[ variables := self parseVariables: textVariables ]	ifTrue: [ variables := nil ].	context := GQLContext new addFragments: document fragments; 					operationName: operationName; 					variables: variables.	^ document executeOn: root with: context using: schema.</body><body package="GraphQLBeta-Tests-Nodes" selector="parseRequest:">parseRequest: text		^ self requestEvaluator parse: text.</body><body package="GraphQLBeta-Tests-Nodes" selector="parseSchema:">parseSchema: text		^ self schemaEvaluator parse: text.</body><body package="GraphQLBeta-Tests-Nodes" selector="parseVariables:">parseVariables: text		^ self variableEvaluator parse: text.</body><body package="GraphQLBeta-Tests-Nodes" selector="requestEvaluator">requestEvaluator	^ GQLRequestGrammarEvaluator</body><body package="GraphQLBeta-Tests-Nodes" selector="schemaEvaluator">schemaEvaluator	^ GQLSchemaGrammarEvaluator</body><body package="GraphQLBeta-Tests-Nodes" selector="variableEvaluator">variableEvaluator	^ GQLVariableGrammarEvaluator </body></methods><methods><class-id>GraphQLBeta.GraphQLBetaTest</class-id> <category>tests</category><body package="GraphQLBeta-Tests-Nodes" selector="testDocumentCycledFragments">testDocumentCycledFragments	| request |	request := '{		a{		   ...data		}	}	fragment data on GQLA{		hey		...other	}	fragment other on GQLA{		hey		...data	}	'.	self should: [ graphQL handleRequest: request] raise: GQLException </body><body package="GraphQLBeta-Tests-Nodes" selector="testDocumentUniqueFragments">testDocumentUniqueFragments	| request |	request := '{		a{		   ...data		}	}	fragment data on GQLA{		hey		...other	}	fragment data on GQLA{		hey	}	'.	self should: [ graphQL handleRequest: request] raise: GQLException </body><body package="GraphQLBeta-Tests-Nodes" selector="testDocumentUnusedFragments">testDocumentUnusedFragments	| request |	request := '{		a{		   ...data		}	}	fragment data on GQLA{		hey		heyID	}	fragment unused on GQLA{		hey	}	'.	self should: [ graphQL handleRequest: request] raise: GQLException </body><body package="GraphQLBeta-Tests-Nodes" selector="testQuerySimple">testQuerySimple	| request response |	request := '{		hello		a { hey }	}'.	response := graphQL handleRequest: request.	self assert: response class: OrderedDictionary.	self assert: (response at: 'hello') asString equals: 'helloWorld'.	self assert: (response at: 'hello') ~= 'hello World'.	self assert: (response at: 'a') class: OrderedDictionary.	self assert: ((response at: 'a') at: 'hey') asString equals: 'heyhey'</body><body package="GraphQLBeta-Tests-Nodes" selector="testQueryWithFragments">testQueryWithFragments	| request response subResponse |	request := '{		a{		   ...data		}	}	fragment data on GQLA{		hey		heyID	}'.	response := graphQL handleRequest: request.	self assert: response class: OrderedDictionary.	subResponse := response at: 'a'.	self assert: subResponse class: OrderedDictionary.	self assert: (subResponse at: 'hey') equals: #'heyhey'.	self assert: (subResponse at: 'heyID') equals: 'id:1'.</body><body package="GraphQLBeta-Tests-Nodes" selector="testQueryWithFragmentsDirectives">testQueryWithFragmentsDirectives	| request response subResponse |	request := '{		a{		   ...data		}	}	fragment data on GQLA{		hey		heyID @skip(if:true)	}'.	response := graphQL handleRequest: request.	self assert: response class: OrderedDictionary.	subResponse := response at: 'a'.	self assert: subResponse class: OrderedDictionary.	self assert: (subResponse at: 'hey') equals: #'heyhey'.	self deny: (subResponse includes: 'heyID')</body><body package="GraphQLBeta-Tests-Nodes" selector="testQueryWithIncompletelyDefinedVariable">testQueryWithIncompletelyDefinedVariable	| request nameOperation textVariables |	request := '	query operation1($name: String){	    hello(name:$name)       sum(nums:$nums)		 an(gqla:$gqla){		     id		 }		 a(id:$id){		    id		 }   }   query operation2{     hello   }'.   nameOperation := 'operation1'.   textVariables :=    '{"name":"Alex", "nums":[1, 3, 4, 5], "gqla":{id:1}, "id":2}'.	self should: [		graphQL handleRequest: request using: nameOperation with: textVariables	] raise: Exception.</body><body package="GraphQLBeta-Tests-Nodes" selector="testQueryWithInlineFragment">testQueryWithInlineFragment	| request response subResponse |	request := '{		a{		   ...{				hey				heyID			}		}	}'.	response := graphQL handleRequest: request.	self assert: response class: OrderedDictionary.	subResponse := response at: 'a'.	self assert: subResponse class: OrderedDictionary.	self assert: (subResponse at: 'hey') equals: #'heyhey'.	self assert: (subResponse at: 'heyID') equals: 'id:1'.</body><body package="GraphQLBeta-Tests-Nodes" selector="testQueryWithInlineFragmentDirectives">testQueryWithInlineFragmentDirectives	| request response subResponse |	request := '{		a{		   ... @include(if:false){				hey				heyID			}		}	}'.	response := graphQL handleRequest: request.	self assert: response class: OrderedDictionary.	subResponse := response at: 'a'.	self assert: subResponse isEmpty</body><body package="GraphQLBeta-Tests-Nodes" selector="testQueryWithInlineFragmentType">testQueryWithInlineFragmentType	| request response subResponse |	request := '{		a{		   ... on GQLA @include(if:false){				hey				heyID			}		}	}'.	response := graphQL handleRequest: request.	self assert: response class: OrderedDictionary.	subResponse := response at: 'a'.	self assert: subResponse isEmpty</body><body package="GraphQLBeta-Tests-Nodes" selector="testQueryWithParamameters">testQueryWithParamameters	| request response |	request := '{		hello(name:"Luke Skywalker")		sum(nums:[1,2,3,4])		a { hey }	}'.	response := graphQL handleRequest: request.	self assert: response class: OrderedDictionary.	self assert: (response at: 'hello') equals: 'helloLuke Skywalker'.	self assert: (response at: 'hello') ~= 'hello World'.	self assert: (response at: 'a') class: OrderedDictionary.	self assert: ((response at: 'a') at: 'hey') asString equals: 'heyhey'.	self assert: (response at: 'sum') equals: 10</body><body package="GraphQLBeta-Tests-Nodes" selector="testQueryWithParamametersOnObjects">testQueryWithParamametersOnObjects	| request response |	request := '{		hello(name:"Luke Skywalker")		sum(nums:[1,2,3,4])		a(id:"asdf1231asdf") { heyID }	}'.	response := graphQL handleRequest: request.	self assert: response class: OrderedDictionary.	self assert: (response at: 'hello') equals: 'helloLuke Skywalker'.	self assert: (response at: 'hello') ~= 'hello World'.	self assert: (response at: 'a') class: OrderedDictionary.	self assert: ((response at: 'a') at: 'heyID') asString		  equals: 'id:asdf1231asdf'.	self assert: (response at: 'sum') equals: 10</body><body package="GraphQLBeta-Tests-Nodes" selector="testQueryWithUndefinedVariable">testQueryWithUndefinedVariable	| request nameOperation textVariables |	request := '	query operation1{	    hello(name:$name)       sum(nums:$nums)		 an(gqla:$gqla){		     id		 }		 a(id:$id){		    id		 }   }   query operation2{     hello   }'.   nameOperation := 'operation1'.   textVariables :=    '{"name":"Alex", "nums":[1, 3, 4, 5], "gqla":{id:1}, "id":2}'.	self should: [		graphQL handleRequest: request using: nameOperation with: textVariables	] raise: Exception.</body><body package="GraphQLBeta-Tests-Nodes" selector="testQueryWithUnusedVariables">testQueryWithUnusedVariables	| request nameOperation textVariables |	request := '	query operation1($name:String, $nums:[Int], $gqla:GQLA !, $id:ID){	    hello(name:$name) @skip(if:true)       sum(nums:$nums)		 an(gqla:$gqla){		     id		 }   }   query operation2{     hello   }'.   nameOperation := 'operation1'.   textVariables :=    '{"name":"Alex", "nums":[1, 3, 4, 5], "gqla":{id:1}, "id":null}'.	self assert: (graphQL handleRequest: request using: nameOperation with: textVariables) class: GQLException.</body><body package="GraphQLBeta-Tests-Nodes" selector="testQueryWithVariables">testQueryWithVariables	| request response nameOperation textVariables |	request := '	query operation1($name:String, $nums:[Int], $gqla:GQLA !, $id:ID){	    hello(name:$name)       sum(nums:$nums)		 an(gqla:$gqla){		     id		 }		 a(id:$id){		    id		 }   }   query operation2{     hello   }'.   nameOperation := 'operation1'.   textVariables :=    '{"name":"Alex", "nums":[1, 3, 4, 5], "gqla":{id:1}, "id":null}'.	response := graphQL handleRequest: request using: nameOperation with: textVariables.	self assert: response class: OrderedDictionary.	response := response at: nameOperation.	self assert: response class: OrderedDictionary.	self assert: (response at:'hello') equals: 'helloAlex'.	self assert: (response at:'sum') equals: 13.	self assert: (response at: 'an') class: OrderedDictionary.	self assert: ((response at: 'an') at: 'id') equals: 1.	self assert: ((response at: 'a') at: 'id') equals: nil.</body><body package="GraphQLBeta-Tests-Nodes" selector="testRequestUnableToParse">testRequestUnableToParse	| text request |	text := 'type GQLIQueryType {					hello : String					a : GQLA				}				type GQLA {					hey : String				}'.	graphQL createSchema: text.	request := '{		hello		a {  }	}'.	self assert: (graphQL handleRequest: request) class: GQLException </body><body package="GraphQLBeta-Tests-Nodes" selector="testSchemaInvalid">testSchemaInvalid	| text |	text := 'type GQLIQueryType {					hello : String					a : GQLA				}				type A {					hey : String				}'.	graphQL createSchema: text.	self assert: (graphQL schema validate) class: GQLValidationException.</body><body package="GraphQLBeta-Tests-Nodes" selector="testSchemaProbeInterfaces">testSchemaProbeInterfaces	| request response |	request := '{		hello(name:"Luke Skywalker")		sum(nums:[1,2,3,4])		a { hey }	}'.	response := graphQL handleRequest: request.	self assert: response class: OrderedDictionary.	self assert: (response at: 'hello') equals: 'helloLuke Skywalker'.	self assert: (response at: 'hello') ~= 'hello World'.	self assert: (response at: 'a') class: OrderedDictionary.	self assert: ((response at: 'a') at: 'hey') asString equals: 'heyhey'.	self assert: (response at: 'sum') equals: 10</body><body package="GraphQLBeta-Tests-Nodes" selector="testSchemaProbeUnions">testSchemaProbeUnions	| request response |	request := '{		...fragmentQuery	}	fragment fragmentQuery on Queries{		hello(name:"Luke Skywalker")		sum(nums:[1,2,3,4])		a { hey }	}'.	response := graphQL handleRequest: request.	self assert: response class: OrderedDictionary.	self assert: (response at: 'hello') equals: 'helloLuke Skywalker'.	self assert: (response at: 'hello') ~= 'hello World'.	self assert: (response at: 'a') class: OrderedDictionary.	self assert: ((response at: 'a') at: 'hey') asString equals: 'heyhey'.	self assert: (response at: 'sum') equals: 10</body><body package="GraphQLBeta-Tests-Nodes" selector="testSchemaUnableToParse">testSchemaUnableToParse	| text |	text := 'type GQLIQueryType {					hello : String					a : 				}				type GQLA {					hey : String				}'.	self assert: (graphQL createSchema: text) class: GQLEvaluationException.</body></methods><methods><class-id>GraphQLBeta.GraphQLBetaTest</class-id> <category>running</category><body package="GraphQLBeta-Tests-Nodes" selector="setUp">setUp	| text |	text := 'union Queries = GQLIQueryType			interface GQLQuery{				hello : String			}			type GQLIQueryType implements GQLQuery{					hello(name:String) : String					hello : String					sum(nums:[Int]) : Int					a : GQLA					an(gqla: GQLA): GQLA					a(id:ID) : GQLA				}				type GQLA {					hey : String					heyID : String				}'.	graphQL := GraphQL new.	graphQL rootInstance: GQLIQueryType new.	graphQL createSchema: text.</body></methods><methods><class-id>GraphQLBeta.GraphQLHeroTest</class-id> <category>accessing</category><body package="GraphQLBeta-Test-Utils" selector="heroes">heroes	| c clazz |	c := OrderedCollection new.	clazz := GraphQLPlatform current classAt: #Hero.	c		add: (clazz new name: 'Superman'; planet: 'Krypton');		add: (clazz new name: 'Mars pathfinder'; planet: 'Mars');		add: (clazz new name: 'Curiosity'; planet: 'Mars');		add: (clazz new name: 'Philae'; planet: 'comet 67P/ChuryumovâGerasimenko').	^ c</body><body package="GraphQLBeta-Test-Utils" selector="schema">schema	^ 'type GraphQLHeroTest{		heroes: [ Hero ]	},	type Hero{		name : String		planet : String	}'</body></methods><methods><class-id>GraphQLBeta.GraphQLHeroTest</class-id> <category>tests</category><body package="GraphQLBeta-Test-Utils" selector="createHeroClass">createHeroClass	| c |	c := Object		subclass: 'Hero'		instanceVariableNames: 'name planet'		classVariableNames: ''		package: 'DummyPackage'.	c compile: 'name ^ name'.	c		compile:			'name: aString	name := aString'.	c compile: 'planet ^ planet'.	c		compile:			'planet: aString	planet := aString'.	^ c</body><body package="GraphQLBeta-Test-Utils" selector="testOnHero">testOnHero	| c g res pkg |	c := self createHeroClass.	g := GraphQL new.	g rootInstance: self.	g createSchema: self schema.	res := g		handleRequest:			'{	heroes{		name		planet		}}'.	self assert: (res at: 'heroes') class equals: OrderedCollection.	c removeFromSystem.	pkg := 'DummyPackage' asPackageIfAbsent: [  ].	pkg ifNotNil: [ pkg removeFromSystem ]</body></methods><methods><class-id>GraphQLBeta.GQLSSchemaNodeTest</class-id> <category>tests</category><body package="GraphQLBeta-Tests-Nodes" selector="testFailValidateObjectTypesInterface">testFailValidateObjectTypesInterface	schema := self parseSchema: '						interface GQLTest{							name : String							rating : Int						}						type GQLTestFilm implements GQLTest{             					id : String            					name : String         					}'.	self should: [ schema validateObjectTypes ] raise: GQLValidationException</body><body package="GraphQLBeta-Tests-Nodes" selector="testFailValidateObjectTypesInterfaceWithArguments">testFailValidateObjectTypesInterfaceWithArguments	schema := self parseSchema: '						interface GQLTest{							name(arg1 : Int, arg2 : String) : String						}						type GQLTestFilm implements GQLTest{             					id : String            					name(arg1 : Int) : String         					}'.	self should: [ schema validateObjectTypes ] raise: GQLValidationException</body><body package="GraphQLBeta-Tests-Nodes" selector="testFullName">testFullName	| objectType field|	schema := self parseSchema: 'type GQLTestFilm{             id : String            name : String         }'.	objectType := schema getType: 'GQLTestFilm'.	self assert: objectType name: 'GQLTestFilm'.	field := objectType getField: 'name'.	self assert: field fullName: 'name'.	field := objectType getField: 'id'.	self assert: field fullName: 'id'</body><body package="GraphQLBeta-Tests-Nodes" selector="testFullNameWithParameters">testFullNameWithParameters	|  objectType field |	schema := self parseSchema: 'type GQLIBType{             					some (name : String, parameters : String) : String         					}'.	objectType := schema getType: 'GQLIBType'.	self assert: objectType name: 'GQLIBType'.	field := objectType getField: 'some'.	self assert: field fullName: 'someName:parameters:'</body><body package="GraphQLBeta-Tests-Nodes" selector="testInvalidateSimpleClass">testInvalidateSimpleClass	schema := self parseSchema: 'type GQLTestFilm{             					actors : String         					}'.	self assert: schema validate class: GQLValidationException</body><body package="GraphQLBeta-Tests-Nodes" selector="testInvalidateSimpleClassWithParameters">testInvalidateSimpleClassWithParameters	schema := self parseSchema: 'type GQLIBType{             					some (name : String) : String         					}'.	self assert: schema validate class: GQLValidationException</body><body package="GraphQLBeta-Tests-Nodes" selector="testNodesParametersPosition">testNodesParametersPosition	| type field parameter |	schema := self parseSchema: 'type GQLTestFilm{             id : String            name (id : String) : String         }'.	type := schema getType: 'GQLTestFilm'.	field := type getField: 'id'.	self assert: type position: 6.	self assert: field position: 32.	field := type getField: 'name'.	self assert: field position: 56.	parameter := field getArgument: 'id'.	self assert: parameter position: 62</body><body package="GraphQLBeta-Tests-Nodes" selector="testNodesPosition">testNodesPosition	| type field |	schema := self parseSchema: 'type GQLTestFilm{             					id : String            					name : String         					}'.	type := schema getType: 'GQLTestFilm'.	field := type getField: 'name'.	self assert: type position: 6.	self assert: field position: 66.	field := type getField: 'id'.	self assert: field position: 37</body><body package="GraphQLBeta-Tests-Nodes" selector="testValidateInputObject">testValidateInputObject	schema := self parseSchema: 'input GQLTestQueryTypeInput{             					description : String            					gender : String!         					}'.	self assert: schema validate class: GQLSSchemaNode</body><body package="GraphQLBeta-Tests-Nodes" selector="testValidateInterface">testValidateInterface	schema := self parseSchema: '							interface MyObject{								name : String							}							type GQLTestFilm implements MyObject{             					id : String            					name : String         					}'.	self assert: schema validate class: GQLSSchemaNode</body><body package="GraphQLBeta-Tests-Nodes" selector="testValidateObjectTypesInterface">testValidateObjectTypesInterface	schema := self parseSchema: '						interface GQLTest{							name : String						}						type GQLTestFilm implements GQLTest{             					id : String            					name : String         					}'.	self assert: schema validateObjectTypes class: GQLSSchemaNode</body><body package="GraphQLBeta-Tests-Nodes" selector="testValidateSchemaWithListNamedType">testValidateSchemaWithListNamedType	schema := self parseSchema: '					type GQLTestQueryType { 						films : [ GQLTestfilm] !					 }					type GQLTestFilm{             				id : String            				name : String							film : GQLFilm         			}					type GQLFilm { 							id : String 					}						'.	self assert: schema validate class: GQLSSchemaNode</body><body package="GraphQLBeta-Tests-Nodes" selector="testValidateSimpleClass">testValidateSimpleClass	schema := self parseSchema: 'type GQLTestFilm{             					id : String            					name : String         					}'.	self assert: schema validate class: GQLSSchemaNode</body><body package="GraphQLBeta-Tests-Nodes" selector="testValidateSimpleClassWithInputObject">testValidateSimpleClassWithInputObject	schema := self parseSchema: '					type GQLTestQueryType { 						films : [ GQLTestfilm] !						information(film: GQLTestQueryTypeInput): GQLTestQueryType					 }					type GQLTestFilm{             				id : String            				name : String         			}					input GQLTestQueryTypeInput { 							description : String					}'.	self assert: schema validate class: GQLSSchemaNode</body><body package="GraphQLBeta-Tests-Nodes" selector="testValidateSimpleClassWithListInputObject">testValidateSimpleClassWithListInputObject	schema := self parseSchema: '					type GQLTestQueryType { 						films : [ GQLTestfilm ] !						totalInformation(film: [GQLInputFilm]): [GQLFilm]					 }					type GQLTestFilm{             				id : String            				name : String							film : GQLFilm         			}					type GQLFilm { 							id : String 					}						'.	self assert: schema validate class: GQLSSchemaNode</body><body package="GraphQLBeta-Tests-Nodes" selector="testValidateSimpleClassWithManyNamedType">testValidateSimpleClassWithManyNamedType	schema := self parseSchema: '					type GQLTestQueryType { 						films : [ GQLTestfilm ] !					 }					type GQLTestFilm{             				id : String            				name : String							film : GQLFilm         			}					type GQLFilm { 							id : String 					}						'.	self assert: schema validate class: GQLSSchemaNode</body><body package="GraphQLBeta-Tests-Nodes" selector="testValidateSimpleClassWithNamedType">testValidateSimpleClassWithNamedType	schema := self parseSchema: 'type A {					id: InternalCount					isB: BooleanType					size: Int					idA: ID_A					values: [ Int ! ]					params (name: StringName, prom: FloatingPoint, key: String): [Int]				}'.	self assert: (schema types at: 'A') class equals: GQLSObjectTypeNode;		assert: ((schema types at: 'A') getField: 'id') type class			equals: GQLSNamedTypeNode;		assert: ((schema types at: 'A') getField: 'id') type name			equals: 'InternalCount';		assert: ((schema types at: 'A') getField: 'isB') type class			equals: GQLSNamedTypeNode;		assert: ((schema types at: 'A') getField: 'isB') type name			equals: 'BooleanType';		assert: ((schema types at: 'A') getField: 'size') type class			equals: GQLSIntTypeNode;		assert: ((schema types at: 'A') getField: 'idA') type class			equals: GQLSNamedTypeNode;		assert: ((schema types at: 'A') getField: 'values') type class			equals: GQLSListTypeNode;		assert: ((schema types at: 'A') getField: 'values') type wrappedType class			equals: GQLSNonNullTypeNode;		assert: ((schema types at: 'A') getField: 'params') type class			equals: GQLSListTypeNode;		assert:			(((schema types at: 'A') getField: 'params') arguments at: 'name') type				class			equals: GQLSNamedTypeNode;		assert:			(((schema types at: 'A') getField: 'params') arguments at: 'prom') type				class			equals: GQLSNamedTypeNode;		assert:			(((schema types at: 'A') getField: 'params') arguments at: 'key') type				class			equals: GQLSStringTypeNode</body><body package="GraphQLBeta-Tests-Nodes" selector="testValidateSimpleClassWithParameters">testValidateSimpleClassWithParameters	schema := self parseSchema: 'type GQLIQueryType{             					sum (nums: [Int]) : Int         					}'.	self assert: schema validate class: GQLSSchemaNode</body><body package="GraphQLBeta-Tests-Nodes" selector="testValidateSimpleClassWithParametersAndInputObject">testValidateSimpleClassWithParametersAndInputObject	schema := self parseSchema: '					type GQLTestFilm{             				id : String            				name : String							film : GQLFilm         			}					type GQLFilm { 							id : String 					}						'.	self assert: schema validate class: GQLSSchemaNode</body><body package="GraphQLBeta-Tests-Nodes" selector="testValidateUnion">testValidateUnion	schema := self parseSchema: '							union Filmed = GQLTestFilm | Film							interface MyObject{								name : String							}							type GQLTestFilm implements MyObject{             					id : String            					name : String         					}							type Film implements MyObject{             					name : String								rating : Int         					}'.	self assert: schema validateUnionTypes class: GQLSSchemaNode</body></methods><methods><class-id>GraphQLBeta.GQLSSchemaNodeTest</class-id> <category>tests-visiting</category><body package="GraphQLBeta-Tests-Nodes" selector="testEvaluate">testEvaluate	| typeA argument |	schema := self parseSchema: 'type A {								b (id: Int): B								c (p1: [Int], p2:String): [Int]								d (param:String)	:String 							},							type B {								someName 	: [String ! ]								someName 	:String 							}'.	typeA := schema getType: 'A'.	argument := (typeA getField: 'd') getArgument: 'param'.	self assert: typeA class: GQLSObjectTypeNode.	self assert: argument class: GQLSArgumentFieldNode.	self assert: argument type class: GQLSStringTypeNode.	self assert: (typeA getField: 'b') type class: GQLSNamedTypeNode .		argument := (typeA getField: 'c') getArgument: 'p1'.	self assert: argument type class: GQLSListTypeNode</body></methods><methods><class-id>GraphQLBeta.GQLRequestGrammarEvaluatorTest</class-id> <category>test-grammar-fields</category><body package="GraphQLBeta-Tests-Grammar" selector="testFieldsAlias">testFieldsAlias	| document userField subField |	document := self parseRequest: '{  				user(id: 4) {    					name    					smallPic: profilePic(size: 64)    					bigPic: profilePic(size: 1024)  			}		}'.	self assert: document class: GQLDocumentNode.	userField := document operations first selections first.	self assert: userField class: GQLNonScalarFieldNode.	self assert: userField name: 'user'.	self assert: userField arguments first name: 'id'.	self assertSelections: userField withNames: #('name' 'profilePic' 'profilePic').	subField := userField selectionSet selections second.	self assert: subField alias equals: 'smallPic'.	self assertArguments: subField withValues: #('64').	subField := userField selectionSet selections third.	self assert: subField alias equals: 'bigPic'.	self assertArguments: subField withValues: #('1024').	</body><body package="GraphQLBeta-Tests-Grammar" selector="testFieldsIncomplete">testFieldsIncomplete	| document  |	document := self parseRequest: '{  				user(id: 4) {    					name    					bigPic: profilePic(size: 1024)  					}'.	self assert: document class: PPFailure.		document := self parseRequest: '{  				user(id: 4) {    					name    					bigPic: profilePic(size: )  				}		}'.	self assert: document class equals: PPFailure.		document := self parseRequest: 'query myQuery {  				experimentalField @skip(if: )			}'.	self assert: document class equals: PPFailure.</body><body package="GraphQLBeta-Tests-Grammar" selector="testFieldsWithArguments">testFieldsWithArguments	| document filmsField actorsField |	document := self parseRequest: '{				films(inYear: 2016){					rating				}				actors(inMovie : "Star wars", active : true){					name				}			}'.	self assert: document class: GQLDocumentNode.	self assertList: document operations first selections class: GQLNonScalarFieldNode.	filmsField := document operations first selections first.	self assert: filmsField name: 'films'.	self assert: filmsField arguments size equals: 1.	self assertArguments: filmsField withNames: #('inYear').	self assertArguments: filmsField ofClasses: #('GQLIntNode').	self assertArguments: filmsField withValues: #('2016').	self assertSelections: filmsField withNames: #('rating').		actorsField := document operations first selections second.	self assert: actorsField name: 'actors'.	self assert: actorsField arguments size equals: 2.	self assertArguments: actorsField withNames: #('inMovie' 'active'). 	self assertArguments: actorsField ofClasses: #('GQLStringNode' 'GQLBooleanNode'). 	self assertArguments: actorsField withValues: #('"Star wars"' 'true').</body><body package="GraphQLBeta-Tests-Grammar" selector="testFieldsWithDirectives">testFieldsWithDirectives	| document operation field variable directive |	document := self parseRequest: 'query myQuery($someTest: Boolean) {  				experimentalField @skip(if: $someTest)			}'.	self assert: document class: GQLDocumentNode.	operation := document operations first.	self assert: operation class: GQLOperationNode.	self assert: operation name: 'myQuery'.	self assert: operation type: 'query'.	variable := operation variableDefinitions first.	self assert: variable name class: GQLVariableNode.	self assert: variable name value equals: 'someTest'.	self assert: variable type class: GQLSBooleanTypeNode.	field := operation selectionSet selections first.	self assert: field class: GQLScalarFieldNode.	self assert: field name: 'experimentalField'.	directive := field directives first.	self assert: directive name equals: 'skip'.	self assert: directive arguments size equals: 1.	self assertArguments: directive withNames: #('if').	self assertArguments: directive ofClasses: #('GQLVariableNode').	self assertArguments: directive withValues: #('someTest').	</body><body package="GraphQLBeta-Tests-Grammar" selector="testSimpleFields">testSimpleFields	| text document principalSelection firstSubSelection secondSubSelection|	text := '{				allFilms{					name					actors{						name					}				}			}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: GQLDocumentNode.	principalSelection := document operations first.	self assert: principalSelection class equals: GQLSelectionSetNode.	self assert: principalSelection selections first class equals: GQLNonScalarFieldNode.	self assert: principalSelection selections first name equals: 'allFilms'.	firstSubSelection := principalSelection selections first selectionSet.	self assert: firstSubSelection class equals: GQLSelectionSetNode.	self assert: firstSubSelection selections first name equals: 'name'.	self assert: firstSubSelection selections second name equals: 'actors'.	secondSubSelection := firstSubSelection selections second selectionSet.	self assert: secondSubSelection selections first name equals: 'name'.	</body></methods><methods><class-id>GraphQLBeta.GQLRequestGrammarEvaluatorTest</class-id> <category>test-grammar-fragmentSpread</category><body package="GraphQLBeta-Tests-Grammar" selector="testFragmentSpread">testFragmentSpread	| document nestedFragments firstSubSelection secondFragment |	document := self parseRequest: 'query withNestedFragments {  				user(id: 4) {    					...familiarFields    					mutualFriends(first: 10) {      					...friendFields    					}  				}	}'.	self assert: document class: GQLDocumentNode.	nestedFragments := document operations first.	self assert: nestedFragments class: GQLOperationNode.	self assert: nestedFragments type: 'query'.	self assert: nestedFragments name: 'withNestedFragments'.		firstSubSelection := nestedFragments selectionSet selections first.	self assert: firstSubSelection class: GQLNonScalarFieldNode.	self assert: firstSubSelection name: 'user'.	self assertArguments: firstSubSelection withNames: #('id').	self assertArguments: firstSubSelection ofClasses: #('GQLIntNode').	self assertArguments: firstSubSelection withValues: #('4'). 	self assertSelections: firstSubSelection withNames: #('familiarFields' 'mutualFriends').		secondFragment := firstSubSelection selectionSet selections second.	self assertSelections: secondFragment withNames: #('friendFields').	</body><body package="GraphQLBeta-Tests-Grammar" selector="testFragmentSpreadIncorrect">testFragmentSpreadIncorrect	| text document |	document := self parseRequest: 'query withNestedFragments {  				user(id: 4) {    					...familiarFields @skip(if: $someTest){						user					}  				}	}'.	self assert: document class: PPFailure.		document := self parseRequest: 'query withNestedFragments {  				user(id: 4) {    					...familiarFields @skip(if: $someTest){					}  				}	}'.	self assert: document class: PPFailure.		document := self parseRequest: 'query withNestedFragments {  				user(id: 4) {    					...familiarFields{						name					}  				}	}'.	self assert: document class: PPFailure.</body></methods><methods><class-id>GraphQLBeta.GQLRequestGrammarEvaluatorTest</class-id> <category>test-grammar-values</category><body package="GraphQLBeta-Tests-Grammar" selector="testArgumentsCompositeObjectValue">testArgumentsCompositeObjectValue	| document field values objectField |	document := self parseRequest: '{  				nearestThing(countries: [{ name: "Bolivia" , continent: "America" } , 												{ name : "Chile" , continent: "America"}])	}'.	self assert: document class: GQLDocumentNode.	field := document operations first selections first.	self assert: field name: 'nearestThing'.	self assert: field arguments size equals: 1.	self assertArguments: field withNames: #('countries').	self assertArguments: field ofClasses: #('GQLListNode').	values := field arguments first value value.	self assertList: values class: GQLObjectNode.	objectField := values first.	self assertObjectField: objectField withNames: #('name' 'continent').	self assertObjectField: objectField withValues: #('"Bolivia"' '"America"').	objectField := values second.	self assertObjectField: objectField withNames: #('name' 'continent').	self assertObjectField: objectField withValues: #('"Chile"' '"America"').</body><body package="GraphQLBeta-Tests-Grammar" selector="testArgumentsEnumValue">testArgumentsEnumValue	| document filmsField |	document := self parseRequest:  '{				films(ofGender: FavoriteGender){					rating					name				}			}'.	self assert: document class: GQLDocumentNode.	filmsField := document operations first selections first.	self assert: filmsField name: 'films'.	self assert: filmsField arguments size equals: 1.	self assertArguments: filmsField withNames: #('ofGender').	self assertArguments: filmsField ofClasses: #('GQLEnumNode').	self assertArguments: filmsField withValues: #('FavoriteGender'). </body><body package="GraphQLBeta-Tests-Grammar" selector="testArgumentsListScalarValue">testArgumentsListScalarValue	| document filmsField argument valueArgument |	document := self parseRequest:  '{				films(inYears: [ 2016, 2012, 2000], withActors: [ "Adam Sandler", "Cris Rock" ]){					rating					name				}			}'.	self assert: document class: GQLDocumentNode.	filmsField := document operations first selections first.	self assert: filmsField name: 'films'.	self assert: filmsField arguments size equals: 2.	self assertArguments: filmsField withNames: #('inYears' 'withActors').	self assertArguments: filmsField ofClasses: #('GQLListNode' 'GQLListNode').	argument := filmsField arguments first.	valueArgument := argument value value.	self assertList: valueArgument class: GQLIntNode.	self assertList: valueArgument withValues: #('2016' '2012' '2000').	argument := filmsField arguments second.	valueArgument := argument value value.	self assertList: valueArgument class: GQLStringNode.	self assertList: valueArgument withValues: #('"Adam Sandler"' '"Cris Rock"').</body><body package="GraphQLBeta-Tests-Grammar" selector="testArgumentsNullValue">testArgumentsNullValue	| document filmsField |	document := self parseRequest: '{				films(inYear: 2016, visual: null){					rating					name				}			}'.	self assert: document class: GQLDocumentNode.	filmsField := document operations first selections first.	self assert: filmsField name: 'films'.	self assert: filmsField arguments size equals: 2.	self assertArguments: filmsField withNames: #('inYear' 'visual').	self assertArguments: filmsField ofClasses: #('GQLIntNode' 'GQLNullNode').	self assertArguments: filmsField withValues: #('2016' 'null').	self assertSelections: filmsField withNames: #('rating' 'name').</body><body package="GraphQLBeta-Tests-Grammar" selector="testArgumentsObjectValue">testArgumentsObjectValue	| document field objectValue |	document := self parseRequest:  '{  				nearestThing(location: { lon: 12.43, lat: -53.211 })	}'.	self assert: document class: GQLDocumentNode.	field := document operations first selections first.	self assert: field name: 'nearestThing'.	self assert: field arguments size equals: 1.	self assert: field arguments first name: 'location'.	objectValue := field arguments first value.	self assert: objectValue class: GQLObjectNode.	self assertList: objectValue objectFields class: GQLObjectFieldNode.	self assertObjectField: objectValue withNames: #('lon' 'lat').	self assertObjectField: objectValue withValues: #('12.43' '-53.211').</body><body package="GraphQLBeta-Tests-Grammar" selector="testArgumentsSimpleScalarValue">testArgumentsSimpleScalarValue	| document filmsField actorsField|	document := self parseRequest:  '{				films(inYear: 2016, minorRating: 5.5){					rating				}				actors(inMovie : "Star wars", active : true){					name				}			}'.	self assert: document class: GQLDocumentNode.	filmsField := document operations first selections first.	self assert: filmsField name: 'films'.	self assert: filmsField arguments size equals: 2.	self assertArguments: filmsField withNames: #('inYear' 'minorRating').	self assertArguments: filmsField ofClasses: #('GQLIntNode' 'GQLFloatNode').	self assertArguments: filmsField withValues: #('2016' '5.5').	actorsField := document operations first selections second.	self assert: actorsField name: 'actors'.	self assert: actorsField arguments size equals: 2.	self assertArguments: actorsField withNames: #('inMovie' 'active').	self assertArguments: actorsField ofClasses: #('GQLStringNode' 'GQLBooleanNode').	self assertArguments: actorsField withValues: #('"Star wars"' 'true').</body><body package="GraphQLBeta-Tests-Grammar" selector="testArgumentsVariableValue">testArgumentsVariableValue	| document filmsField |	document := self parseRequest:  '{				films(inYears: $years withActors: $actors){					rating					name				}			}'.	self assert: document class: GQLDocumentNode.	filmsField := document operations first selections first.	self assert: filmsField name: 'films'.	self assert: filmsField arguments size equals: 2.	self assertArguments: filmsField withNames: #('inYears' 'withActors').	self assertArguments: filmsField ofClasses: #('GQLVariableNode' 'GQLVariableNode').	self assertArguments: filmsField withValues: #('years' 'actors').</body></methods><methods><class-id>GraphQLBeta.GQLRequestGrammarEvaluatorTest</class-id> <category>test-grammar-operation</category><body package="GraphQLBeta-Tests-Grammar" selector="testOperationFail">testOperationFail	| text document |	text := 'mutation { 				likeStory(storyID: 12345) { 			 	story {    				}  			}		}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: PPFailure.		text := 'mutation { 				likeStory(storyID: .12345) {  			}		}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: PPFailure.		text := '{ 				likeStor(storyID: 12345) {  			}		}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: PPFailure.</body><body package="GraphQLBeta-Tests-Grammar" selector="testOperationMutation">testOperationMutation	| text document operation firstField subField |	text := 'mutation { 				likeStory(storyID: 12345) { 			 	story {      				likeCount    				}  			}		}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: GQLDocumentNode.	operation := document operations first.	self assert: operation class equals: GQLOperationNode.	self assert: operation type equals: 'mutation'.	firstField := operation selectionSet selections first.	self assert: firstField class equals: GQLNonScalarFieldNode.	self assert: firstField name equals: 'likeStory'.	self assert: firstField arguments first name equals: 'storyID'.	self assert: firstField arguments first value class equals: GQLIntNode.	self assert: firstField arguments first value value equals: '12345'.	subField := firstField selectionSet selections first.	self assert: subField name equals: 'story'.	self assert: subField selectionSet selections first name equals: 'likeCount'.	</body></methods><methods><class-id>GraphQLBeta.GQLRequestGrammarEvaluatorTest</class-id> <category>tests</category><body package="GraphQLBeta-Tests-Grammar" selector="testFragmentSpreadWithDirectives">testFragmentSpreadWithDirectives	| document nestedFragments firstSubSelection firstFragment directive |	document := self parseRequest: 'query withNestedFragments {  				user(id: 4) {    					...familiarFields @skip(if: $someTest)  				}	}'.	self assert: document class: GQLDocumentNode.	nestedFragments := document operations first.	self assert: nestedFragments class: GQLOperationNode.	self assert: nestedFragments type: 'query'.	self assert: nestedFragments name: 'withNestedFragments'.		firstSubSelection := nestedFragments selectionSet selections first.	self assert: firstSubSelection class: GQLNonScalarFieldNode.	self assert: firstSubSelection name: 'user'.	self assertArguments: firstSubSelection withNames: #('id').	self assertArguments: firstSubSelection ofClasses: #('GQLIntNode').	self assertArguments: firstSubSelection withValues: #('4').		firstFragment := firstSubSelection selectionSet selections first.	self assert: firstFragment name: 'familiarFields'.	directive := firstFragment directives first.	self assert: directive name: 'skip'.	self assertArguments: directive withNames: #('if').	self assertArguments: directive withValues: #('someTest').</body><body package="GraphQLBeta-Tests-Grammar" selector="testInlineFragmentWithDirectives">testInlineFragmentWithDirectives	| text document inlineFragmentTyping firstSubSelection firstFragment  |	text := 'query inlineFragmentNoType($expandedInfo: Boolean) {  				user(handle: "zuck") {    					id    					... @include(if: $expandedInfo) {      					firstName    					}  				}	}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: GQLDocumentNode.	inlineFragmentTyping := document operations first.	self assert: inlineFragmentTyping class equals: GQLOperationNode.	self assert: inlineFragmentTyping type equals: 'query'.	self assert: inlineFragmentTyping name equals: 'inlineFragmentNoType'.	self assert: inlineFragmentTyping variableDefinitions first type class equals: GQLSBooleanTypeNode.	self assert: inlineFragmentTyping variableDefinitions first name value equals: 'expandedInfo'.		firstSubSelection := inlineFragmentTyping selectionSet selections first.	self assert: firstSubSelection class equals: GQLNonScalarFieldNode.	self assert: firstSubSelection name equals: 'user'.	self assert: firstSubSelection arguments first name equals: 'handle'.	self assert: firstSubSelection arguments first value class equals: GQLStringNode.	self assert: firstSubSelection arguments first value value equals: '"zuck"'. 		firstFragment := firstSubSelection selectionSet selections second.	self assert: firstFragment directives first name equals: 'include'.	self assert: firstFragment directives first arguments first name equals: 'if'.	self assert: firstFragment directives first arguments first value class equals: GQLVariableNode.	self assert: firstFragment directives first arguments first value value equals: 'expandedInfo'.	self assert: firstFragment selectionSet selections first name equals: 'firstName'.	</body><body package="GraphQLBeta-Tests-Grammar" selector="testOperationWithDirective">testOperationWithDirective	| text document operation firstField |	text := 'query @skip(if: $foo) { 				 field			}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: GQLDocumentNode.	operation := document operations first.	self assert: operation class equals: GQLOperationNode.	self assert: operation type equals: 'query'.	self assert: operation directives first name equals: 'skip'.	self assert: operation directives first arguments first name equals: 'if'.	self assert: operation directives first arguments first value class equals: GQLVariableNode.	self assert: operation directives first arguments first value value equals: 'foo'.	firstField := operation selectionSet selections first.	self assert: firstField class equals: GQLScalarFieldNode.	self assert: firstField name equals: 'field'.</body><body package="GraphQLBeta-Tests-Grammar" selector="testOperationWithVariableDefaultValue">testOperationWithVariableDefaultValue	| text document operation field |	text := 'query myQuery($atOtherHomes: Boolean = true) {  				isHousetrained(atOtherHomes: $atOtherHomes)				}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: GQLDocumentNode.	operation := document operations first.	self assert: operation class equals: GQLOperationNode.	self assert: operation name equals: 'myQuery'.	self assert: operation type equals: 'query'.	self assert: operation variableDefinitions first name class equals: GQLVariableNode.	self assert: operation variableDefinitions first name value equals: 'atOtherHomes'.	self assert: operation variableDefinitions first type class equals: GQLSBooleanTypeNode.	self assert: operation variableDefinitions first defaultValue class equals: GQLBooleanNode.	field := operation selectionSet selections first.	self assert: field class equals: GQLScalarFieldNode.	self assert: field name equals: 'isHousetrained'.	self assert: field arguments first name equals: 'atOtherHomes'.	self assert: field arguments first value class equals: GQLVariableNode.	self assert: field arguments first value value equals: 'atOtherHomes'.	</body><body package="GraphQLBeta-Tests-Grammar" selector="testOperationWithVariableDefinitions">testOperationWithVariableDefinitions	| text document operation field |	text := 'query myQuery($someTest: Boolean) {  				experimentalField @include(if: $someTest)				}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: GQLDocumentNode.	operation := document operations first.	self assert: operation class equals: GQLOperationNode.	self assert: operation name equals: 'myQuery'.	self assert: operation type equals: 'query'.	self assert: operation variableDefinitions first name class equals: GQLVariableNode.	self assert: operation variableDefinitions first name value equals: 'someTest'.	self assert: operation variableDefinitions first type class equals: GQLSBooleanTypeNode.	field := operation selectionSet selections first.	self assert: field class equals: GQLScalarFieldNode.	self assert: field name equals: 'experimentalField'.	self assert: field directives first name equals: 'include'.	self assert: field directives first arguments size equals: 1.	self assert: field directives first arguments first name equals: 'if'.	self assert: field directives first arguments first value class equals: GQLVariableNode.	self assert: field directives first arguments first value value equals: 'someTest'.	</body><body package="GraphQLBeta-Tests-Grammar" selector="testVariableListType">testVariableListType	| text document operation field |	text := 'query myQuery($someTest: [ Boolean ]) {  				experimentalField				}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: GQLDocumentNode.	operation := document operations first.	self assert: operation class equals: GQLOperationNode.	self assert: operation name equals: 'myQuery'.	self assert: operation type equals: 'query'.	self assert: operation variableDefinitions first name class equals: GQLVariableNode.	self assert: operation variableDefinitions first name value equals: 'someTest'.	self assert: operation variableDefinitions first type class equals: GQLSListTypeNode.	self assert: operation variableDefinitions first type wrappedType class equals: GQLSBooleanTypeNode.	field := operation selectionSet selections first.	self assert: field class equals: GQLScalarFieldNode.	self assert: field name equals: 'experimentalField'.</body><body package="GraphQLBeta-Tests-Grammar" selector="testVariableListTypeNamed">testVariableListTypeNamed	| text document operation field |	text := 'query myQuery($someTest: [ Some ]) {  				experimentalField				}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: GQLDocumentNode.	operation := document operations first.	self assert: operation class equals: GQLOperationNode.	self assert: operation name equals: 'myQuery'.	self assert: operation type equals: 'query'.	self assert: operation variableDefinitions first name class equals: GQLVariableNode.	self assert: operation variableDefinitions first name value equals: 'someTest'.	self assert: operation variableDefinitions first type class equals: GQLSListTypeNode.	self assert: operation variableDefinitions first type wrappedType class equals: GQLSNamedTypeNode.	self assert: operation variableDefinitions first type wrappedType name equals: 'Some'.	field := operation selectionSet selections first.	self assert: field class equals: GQLScalarFieldNode.	self assert: field name equals: 'experimentalField'.</body><body package="GraphQLBeta-Tests-Grammar" selector="testVariableListTypeNonNull">testVariableListTypeNonNull	| text document operation field |	text := 'query myQuery($someTest: [ Int! ]) {  				experimentalField				}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: GQLDocumentNode.	operation := document operations first.	self assert: operation class equals: GQLOperationNode.	self assert: operation name equals: 'myQuery'.	self assert: operation type equals: 'query'.	self assert: operation variableDefinitions first name class equals: GQLVariableNode.	self assert: operation variableDefinitions first name value equals: 'someTest'.	self assert: operation variableDefinitions first type class equals: GQLSListTypeNode.	self assert: operation variableDefinitions first type wrappedType class equals: GQLSNonNullTypeNode.	self assert: operation variableDefinitions first type wrappedType wrappedType class equals: GQLSIntTypeNode.	field := operation selectionSet selections first.	self assert: field class equals: GQLScalarFieldNode.	self assert: field name equals: 'experimentalField'.</body><body package="GraphQLBeta-Tests-Grammar" selector="testVariableListTypeNonNullNamed">testVariableListTypeNonNullNamed	| text document operation field |	text := 'query myQuery($someTest: [ Some! ]) {  				experimentalField				}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: GQLDocumentNode.	operation := document operations first.	self assert: operation class equals: GQLOperationNode.	self assert: operation name equals: 'myQuery'.	self assert: operation type equals: 'query'.	self assert: operation variableDefinitions first name class equals: GQLVariableNode.	self assert: operation variableDefinitions first name value equals: 'someTest'.	self assert: operation variableDefinitions first type class equals: GQLSListTypeNode.	self assert: operation variableDefinitions first type wrappedType class equals: GQLSNonNullTypeNode.	self assert: operation variableDefinitions first type wrappedType wrappedType class equals: GQLSNamedTypeNode.	self assert: operation variableDefinitions first type wrappedType wrappedType name equals: 'Some'.	field := operation selectionSet selections first.	self assert: field class equals: GQLScalarFieldNode.	self assert: field name equals: 'experimentalField'.</body><body package="GraphQLBeta-Tests-Grammar" selector="testVariableNamedType">testVariableNamedType	| text document operation field |	text := 'query myQuery($someTest: Some) {  				experimentalField				}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: GQLDocumentNode.	operation := document operations first.	self assert: operation class equals: GQLOperationNode.	self assert: operation name equals: 'myQuery'.	self assert: operation type equals: 'query'.	self assert: operation variableDefinitions first name class equals: GQLVariableNode.	self assert: operation variableDefinitions first name value equals: 'someTest'.	self assert: operation variableDefinitions first type class equals: GQLSNamedTypeNode.	self assert: operation variableDefinitions first type name equals: 'Some'.	field := operation selectionSet selections first.	self assert: field class equals: GQLScalarFieldNode.	self assert: field name equals: 'experimentalField'.</body><body package="GraphQLBeta-Tests-Grammar" selector="testVariableNonNullListType">testVariableNonNullListType	| text document operation field |	text := 'query myQuery($someTest: [ Float ]!) {  				experimentalField				}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: GQLDocumentNode.	operation := document operations first.	self assert: operation class equals: GQLOperationNode.	self assert: operation name equals: 'myQuery'.	self assert: operation type equals: 'query'.	self assert: operation variableDefinitions first name class equals: GQLVariableNode.	self assert: operation variableDefinitions first name value equals: 'someTest'.	self assert: operation variableDefinitions first type class equals: GQLSNonNullTypeNode.	self assert: operation variableDefinitions first type wrappedType class equals: GQLSListTypeNode.	self assert: operation variableDefinitions first type wrappedType wrappedType class equals: GQLSFloatTypeNode.	field := operation selectionSet selections first.	self assert: field class equals: GQLScalarFieldNode.	self assert: field name equals: 'experimentalField'.</body><body package="GraphQLBeta-Tests-Grammar" selector="testVariableNonNullListTypeNamed">testVariableNonNullListTypeNamed	| text document operation field |	text := 'query myQuery($someTest: [ Some ]!) {  				experimentalField				}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: GQLDocumentNode.	operation := document operations first.	self assert: operation class equals: GQLOperationNode.	self assert: operation name equals: 'myQuery'.	self assert: operation type equals: 'query'.	self assert: operation variableDefinitions first name class equals: GQLVariableNode.	self assert: operation variableDefinitions first name value equals: 'someTest'.	self assert: operation variableDefinitions first type class equals: GQLSNonNullTypeNode.	self assert: operation variableDefinitions first type wrappedType class equals: GQLSListTypeNode.	self assert: operation variableDefinitions first type wrappedType wrappedType class equals: GQLSNamedTypeNode.	self assert: operation variableDefinitions first type wrappedType wrappedType name equals: 'Some'.	field := operation selectionSet selections first.	self assert: field class equals: GQLScalarFieldNode.	self assert: field name equals: 'experimentalField'.</body><body package="GraphQLBeta-Tests-Grammar" selector="testVariableNonNullListTypeNonNull">testVariableNonNullListTypeNonNull	| text document operation field |	text := 'query myQuery($someTest: [ Boolean! ]!) {  				experimentalField				}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: GQLDocumentNode.	operation := document operations first.	self assert: operation class equals: GQLOperationNode.	self assert: operation name equals: 'myQuery'.	self assert: operation type equals: 'query'.	self assert: operation variableDefinitions first name class equals: GQLVariableNode.	self assert: operation variableDefinitions first name value equals: 'someTest'.	self assert: operation variableDefinitions first type class equals: GQLSNonNullTypeNode.	self assert: operation variableDefinitions first type wrappedType class equals: GQLSListTypeNode.	self assert: operation variableDefinitions first type wrappedType wrappedType class equals: GQLSNonNullTypeNode.	self assert: operation variableDefinitions first type wrappedType wrappedType wrappedType class equals: GQLSBooleanTypeNode.	field := operation selectionSet selections first.	self assert: field class equals: GQLScalarFieldNode.	self assert: field name equals: 'experimentalField'.</body><body package="GraphQLBeta-Tests-Grammar" selector="testVariableNonNullListTypeNonNullNamed">testVariableNonNullListTypeNonNullNamed	| text document operation field |	text := 'query myQuery($someTest: [ Some! ]!) {  				experimentalField				}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: GQLDocumentNode.	operation := document operations first.	self assert: operation class equals: GQLOperationNode.	self assert: operation name equals: 'myQuery'.	self assert: operation type equals: 'query'.	self assert: operation variableDefinitions first name class equals: GQLVariableNode.	self assert: operation variableDefinitions first name value equals: 'someTest'.	self assert: operation variableDefinitions first type class equals: GQLSNonNullTypeNode.	self assert: operation variableDefinitions first type wrappedType class equals: GQLSListTypeNode.	self assert: operation variableDefinitions first type wrappedType wrappedType class equals: GQLSNonNullTypeNode.	self assert: operation variableDefinitions first type wrappedType wrappedType wrappedType class equals: GQLSNamedTypeNode.	self assert: operation variableDefinitions first type wrappedType wrappedType wrappedType name equals: 'Some'.	field := operation selectionSet selections first.	self assert: field class equals: GQLScalarFieldNode.	self assert: field name equals: 'experimentalField'.</body><body package="GraphQLBeta-Tests-Grammar" selector="testVariableNonNullNamedType">testVariableNonNullNamedType	| text document operation field |	text := 'query myQuery($someTest: Some!) {  				experimentalField				}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: GQLDocumentNode.	operation := document operations first.	self assert: operation class equals: GQLOperationNode.	self assert: operation name equals: 'myQuery'.	self assert: operation type equals: 'query'.	self assert: operation variableDefinitions first name class equals: GQLVariableNode.	self assert: operation variableDefinitions first name value equals: 'someTest'.	self assert: operation variableDefinitions first type class equals: GQLSNonNullTypeNode.	self assert: operation variableDefinitions first type wrappedType class equals: GQLSNamedTypeNode.	self assert: operation variableDefinitions first type wrappedType name equals: 'Some'.	field := operation selectionSet selections first.	self assert: field class equals: GQLScalarFieldNode.	self assert: field name equals: 'experimentalField'.</body><body package="GraphQLBeta-Tests-Grammar" selector="testVariableNonNullScalarType">testVariableNonNullScalarType	| text document operation field |	text := 'query myQuery($someTest: ID!) {  				experimentalField				}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: GQLDocumentNode.	operation := document operations first.	self assert: operation class equals: GQLOperationNode.	self assert: operation name equals: 'myQuery'.	self assert: operation type equals: 'query'.	self assert: operation variableDefinitions first name class equals: GQLVariableNode.	self assert: operation variableDefinitions first name value equals: 'someTest'.	self assert: operation variableDefinitions first type class equals: GQLSNonNullTypeNode.	self assert: operation variableDefinitions first type wrappedType class equals: GQLSIDTypeNode.	field := operation selectionSet selections first.	self assert: field class equals: GQLScalarFieldNode.	self assert: field name equals: 'experimentalField'.</body><body package="GraphQLBeta-Tests-Grammar" selector="testVariableScalarType">testVariableScalarType	| text document operation field |	text := 'query myQuery($someTest: String) {  				experimentalField				}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: GQLDocumentNode.	operation := document operations first.	self assert: operation class equals: GQLOperationNode.	self assert: operation name equals: 'myQuery'.	self assert: operation type equals: 'query'.	self assert: operation variableDefinitions first name class equals: GQLVariableNode.	self assert: operation variableDefinitions first name value equals: 'someTest'.	self assert: operation variableDefinitions first type class equals: GQLSStringTypeNode.	field := operation selectionSet selections first.	self assert: field class equals: GQLScalarFieldNode.	self assert: field name equals: 'experimentalField'.</body></methods><methods><class-id>GraphQLBeta.GQLRequestGrammarEvaluatorTest</class-id> <category>test-grammar-fragment</category><body package="GraphQLBeta-Tests-Grammar" selector="testFragment">testFragment	| document withFragment fragment fieldSpread field |	document := self parseRequest: 'query withFragment {      			...friendFields			}			fragment friendFields on User { 				name 				profilePic(size: 50)	}'.		self assert: document class: GQLDocumentNode.	withFragment := document operations first.	self assert: withFragment class: GQLOperationNode.	self assert: withFragment type: 'query'.	self assert: withFragment name: 'withFragment'.	fieldSpread := withFragment selectionSet selections first.	self assert: fieldSpread class: GQLFragmentSpreadNode.	self assert: fieldSpread name: 'friendFields'.		fragment := document fragments first.	self assert: fragment class: GQLFragmentNode.	self assert: fragment name: 'friendFields'.	self assert: fragment typeCondition class: GQLSNamedTypeNode.	self assert: fragment typeCondition name: 'User'.	self assertSelections: fragment withNames: #('name' 'profilePic').		field := fragment selectionSet selections second.	self assertArguments: field withNames: #('size').	self assertArguments: field ofClasses: #('GQLIntNode').	self assertArguments: field withValues: #('50').	</body><body package="GraphQLBeta-Tests-Grammar" selector="testFragmentIncorrect">testFragmentIncorrect	| document |	document := self parseRequest: 'query withFragment {      			...friendFields			}			fragment on User { 				name 				profilePic(size: 50)	}'.	self assert: document class: PPFailure.		document := self parseRequest: 'query withFragment {      			...friendFields			}			fragment friendFields { 				name 				profilePic(size: 50)	}'.	self assert: document class: PPFailure.		document := self parseRequest: 'query withFragment {      			...friendFields			}			fragment friendFields on User {	}'.		self assert: document class: PPFailure.	</body><body package="GraphQLBeta-Tests-Grammar" selector="testFragmentWithDirectives">testFragmentWithDirectives	| text document withFragment fragment |	text := 'query withFragment {      			...friends			}			fragment friends on User @directiveBehavior { 				id	}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: GQLDocumentNode.	withFragment := document operations first.	self assert: withFragment class equals: GQLOperationNode.	self assert: withFragment type equals: 'query'.	self assert: withFragment name equals: 'withFragment'.	self assert: withFragment selectionSet selections first class equals: GQLFragmentSpreadNode.	self assert: withFragment selectionSet selections first name equals: 'friends'.		fragment := document fragments first.	self assert: fragment class equals: GQLFragmentNode.	self assert: fragment name equals: 'friends'.	self assert: fragment typeCondition class equals: GQLSNamedTypeNode.	self assert: fragment typeCondition name equals: 'User'.	self assert: fragment directives first name equals: 'directiveBehavior'.	self assert: fragment selectionSet selections first name equals: 'id'.	</body></methods><methods><class-id>GraphQLBeta.GQLRequestGrammarEvaluatorTest</class-id> <category>test-grammar-inlineFragment</category><body package="GraphQLBeta-Tests-Grammar" selector="testInlineFragmentIncomplete">testInlineFragmentIncomplete	| text document |	text := 'query inlineFragmentNoType($expandedInfo: Boolean) {    					... @include(if: ) {      					firstName      					birthday    					}	}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: PPFailure.		text := 'query inlineFragmentNoType($expandedInfo: Boolean) {    					.. on User {      					firstName      					birthday    					}	}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: PPFailure.</body><body package="GraphQLBeta-Tests-Grammar" selector="testInlineFragmentWithTypeCondition">testInlineFragmentWithTypeCondition	| text document inlineFragmentTyping firstSubSelection firstFragment secondFragment |	text := 'query inlineFragmentTyping {  				profiles(handles: ["zuck", "cocacola"]) {   					handle    					... on User {      					friends {        						count      					}    					}    					... on Page {      					likers {        						count      					}    					}  				}			}'.	document := GQLRequestGrammarEvaluator parse: text.	self assert: document class equals: GQLDocumentNode.	inlineFragmentTyping := document operations first.	self assert: inlineFragmentTyping class equals: GQLOperationNode.	self assert: inlineFragmentTyping type equals: 'query'.	self assert: inlineFragmentTyping name equals: 'inlineFragmentTyping'.		firstSubSelection := inlineFragmentTyping selectionSet selections first selectionSet.	self assert: firstSubSelection class equals: GQLSelectionSetNode.	self assert: firstSubSelection selections first name equals: 'handle'.		firstFragment := firstSubSelection selections second.	self assert: firstFragment typeCondition class equals: GQLSNamedTypeNode.	self assert: firstFragment typeCondition name equals: 'User'.	self assert: firstFragment selectionSet selections first name equals: 'friends'.	self assert: firstFragment selectionSet selections first selectionSet selections first name equals: 'count'.		secondFragment := firstSubSelection selections third.	self assert: secondFragment typeCondition class equals: GQLSNamedTypeNode.	self assert: secondFragment typeCondition name equals: 'Page'.	self assert: secondFragment selectionSet selections first name equals: 'likers'.	self assert: secondFragment selectionSet selections first selectionSet selections first name equals: 'count'.	</body></methods><methods><class-id>GraphQLBeta.GQLRequestGrammarEvaluatorTest</class-id> <category>as yet unclassified</category><body package="GraphQLBeta-Tests-Grammar" selector="requestEvaluator">requestEvaluator	^ GQLRequestGrammarEvaluator</body></methods><methods><class-id>GraphQLBeta.GQLDocumentNodeTest</class-id> <category>test-composeRequest</category><body package="GraphQLBeta-Tests-Nodes" selector="testComposedRequestInlineFragment">testComposedRequestInlineFragment	| response subResponse |	response := self attendRequest: '{		filmsWith(rating:5){			... {				name				rating			}		}	}'.		self assert: response class: OrderedDictionary.	subResponse := (response at:'filmsWith').	self assert: subResponse size equals: 3.	self assert: subResponse first size equals: 2.</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposedRequestInlineFragmentDirectives">testComposedRequestInlineFragmentDirectives	| response subResponse |	response := self attendRequest: '{		filmsWith(rating:5){			... @skip(if: true){				name				rating			}		}	}'.		self assert: response class: OrderedDictionary.	subResponse := (response at:'filmsWith').	subResponse do: [ :sub | self assert: sub isEmpty ]</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposedRequestInlineFragmentType">testComposedRequestInlineFragmentType	| response subResponse |	response := self attendRequest: '{		filmsWith(rating:5){			... on Film{				name				rating			}		}	}'.		self assert: response class: OrderedDictionary.	subResponse := (response at:'filmsWith').	self assert: subResponse size equals: 3.	self assert: subResponse first size equals: 2.</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposedRequestInterpret">testComposedRequestInterpret	| response subResponse |	response := self attendRequest: '{		hello		hello		films { 			rating			name		}	}'.		self assert: response class: OrderedDictionary.	subResponse := (response at:'hello').	self assert: subResponse equals: 'hello world'.	subResponse := (response at:'films').	self assert: subResponse class: OrderedCollection.	self assert: (subResponse first at: 'rating') equals: 9.	self assert: (subResponse first at: 'name') equals: 'harry potter y la piedra filosofal'</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposedRequestInterpretSpreadFragments">testComposedRequestInterpretSpreadFragments	| response subResponse |	response := self attendRequest: '{		films { 			...filmsData		}		filmsWith(rating:5){			...filmsData		}	}	fragment filmsData on GQLFilm{		name		rating	}	'.		self assert: response class: OrderedDictionary.	subResponse := (response at:'films').	self assert: (subResponse first at: 'rating') equals: 9.	self assert: (subResponse first at: 'name') equals: 'harry potter y la piedra filosofal'.	subResponse := (response at:'filmsWith').	self assert: subResponse size equals: 3.</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposedRequestInterpretUnknowFragments">testComposedRequestInterpretUnknowFragments	| text |	text:=  '{		films { 			...filmsData		}		filmsWith(rating:5){			...filmsData		}	}	fragment filmsDota on GQLFilm{		name		rating	}	'.		self should: [self attendRequest: text] raise: GQLException.</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposedRequestSpreadFragmentsWithDirectives">testComposedRequestSpreadFragmentsWithDirectives	| response subResponse |	response := self attendRequest: '{		films { 			...filmsData @skip(if : true)		}		filmsWith(rating:5){			...filmsData		}	}	fragment filmsData on GQLFilm{		name		rating @include(if : false)	}	'.		self assert: response class: OrderedDictionary.	subResponse := (response at: 'films').	subResponse do: [ :res |	self assert: res isEmpty.].	subResponse := (response at:'filmsWith').	self assert: subResponse size equals: 3.	self assert: subResponse first size equals: 1.</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposedRequestWhitAliasInterpret">testComposedRequestWhitAliasInterpret	| response subResponse |	response := self attendRequest: '{		hello		hello		myFilms : films { 			rating			name		}	}'.		self assert: response class: OrderedDictionary.	subResponse := (response at:'hello').	self assert: subResponse equals: 'hello world'.	subResponse := (response at:'myFilms').	self assert: subResponse class: OrderedCollection.	self assert: (subResponse first at: 'rating') equals: 9.	self assert: (subResponse first at: 'name') equals: 'harry potter y la piedra filosofal'</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposedRequestWithArgumentsAndAliasInterpret">testComposedRequestWithArgumentsAndAliasInterpret	| response subResponse |	response := self attendRequest: '{		hello		helloWorld: hello		myFilms : films { 			rating			name		}		aliasHello: helloTo(name:"terminator") 		}'.		self assert: response class: OrderedDictionary.	subResponse := (response at:'hello').	self assert: subResponse equals: 'hello world'.	subResponse := (response at:'helloWorld').	self assert: subResponse equals: 'hello world'.	subResponse := (response at:'myFilms').	self assert: subResponse class: OrderedCollection.	self assert: (subResponse first at: 'rating') equals: 9.	self assert: (subResponse first at: 'name') equals: 'harry potter y la piedra filosofal'.	self assert: (response at: 'aliasHello') equals: 'hello terminator'.</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposeRequestArgumentsExcludeWithTwoDirective">testComposeRequestArgumentsExcludeWithTwoDirective	| response |	response := self attendRequest: '{		filmsWith(rating: 5) @skip(if : true) @include(if : true){			name		}	}'.		self assert: response isEmpty.		response := self attendRequest: '{		filmsWith(rating: 5) @skip(if : true) @include(if : false){			name		}	}'.		self assert: response isEmpty.		response := self attendRequest: '{		filmsWith(rating: 5) @include(if : false) @skip(if : true){			name		}	}'.		self assert: response isEmpty.		response := self attendRequest: '{		filmsWith(rating: 5) @skip(if : false) @include(if : false){			name		}	}'.		self assert: response isEmpty.	</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposeRequestArgumentsIncludeWithTwoDirective">testComposeRequestArgumentsIncludeWithTwoDirective	| response |	response := self attendRequest: '{		filmsWith(rating: 5) @skip(if : false) @include(if : true){			name		}	}'.		self assert: response class: OrderedDictionary.		response := self attendRequest: '{		filmsWith(rating: 5) @include(if : true) @skip(if : false){			name		}	}'.		self assert: response class: OrderedDictionary.	</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposeRequestArgumentsWithDirectiveExclude">testComposeRequestArgumentsWithDirectiveExclude	| response |	response := self attendRequest: '{		filmsWith(rating: 5) @skip(if : true){			name		}	}'.		self assert: response isEmpty.		response := self attendRequest: '{		filmsWith(rating: 5) @include(if : false){			name		}	}'.		self assert: response isEmpty.</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposeRequestArgumentsWithDirectiveInclude">testComposeRequestArgumentsWithDirectiveInclude	| response expectedValues |	response := self attendRequest: '{		filmsWith(rating: 5) @skip(if : false){			name		}	}'.		self assert: response class: OrderedDictionary.	expectedValues := (response at: 'filmsWith') collect: [ :res | res at: 'name' ].	self assert: expectedValues asArray equals: #('terminator' 'rambo' 'robocop').		response := self attendRequest: '{		filmsWith(rating: 5) @include(if : true){			name		}	}'.		self assert: response class: OrderedDictionary.	expectedValues := (response at: 'filmsWith') collect: [ :res | res at: 'name' ].	self assert: expectedValues asArray equals: #('terminator' 'rambo' 'robocop').</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposeRequestArgumentsWithDuplicateDirective">testComposeRequestArgumentsWithDuplicateDirective	| text |	text := '{		filmsWith(rating: 5) @skip(if : false) @skip(if : true){			name		}	}'.		self should: [ self attendRequest: text ] raise: GQLException.		text := '{		filmsWith(rating: 5) @include(if : true) @include(if : false){			name		}	}'.		self should: [ self attendRequest: text ] raise: GQLException.</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposeRequestArgumentsWithEnumType">testComposeRequestArgumentsWithEnumType	| response |	response := self attendRequest: '{		filmsOf(gender: ACTION){			name			rating		}	}'.		self assert: response class: OrderedDictionary.	response := response at: 'filmsOf'.	self assert: response class: OrderedCollection .	self assert: response size equals: 1.	self assert: (response first at: 'name') equals: 'rambo'.	self assert: (response first at: 'rating') equals: 5.</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposeRequestArgumentsWithEnumTypeAndAlias">testComposeRequestArgumentsWithEnumTypeAndAlias	| response |	response := self attendRequest: '{		filmsOfAction: filmsOf(gender: ACTION){			name			rating		}	}'.		self assert: response class: OrderedDictionary.	response := response at: 'filmsOfAction'.	self assert: response class: OrderedCollection .	self assert: response size equals: 1.	self assert: (response first at: 'name') equals: 'rambo'.	self assert: (response first at: 'rating') equals: 5.</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposeRequestArgumentsWithEnumTypeAndDirectivesExclude">testComposeRequestArgumentsWithEnumTypeAndDirectivesExclude	| response |	response := self attendRequest: '{		filmsOf(gender: ACTION) @skip(if: true){			name			rating		}	}'.		self assert: response isEmpty.		response := self attendRequest: '{		filmsOf(gender: ACTION) @include(if: false){			name			rating		}	}'.		self assert: response isEmpty.</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposeRequestArgumentsWithEnumTypeAndDirectivesInclude">testComposeRequestArgumentsWithEnumTypeAndDirectivesInclude	| response |	response := self attendRequest: '{		filmsOf(gender: ACTION) @skip(if: false){			name			rating		}	}'.		self assert: response class: OrderedDictionary.	response := response at: 'filmsOf'.	self assert: response class: OrderedCollection .	self assert: response size equals: 1.	self assert: (response first at: 'name') equals: 'rambo'.	self assert: (response first at: 'rating') equals: 5.		response := self attendRequest: '{		filmsOf(gender: ACTION) @include(if: true){			name			rating		}	}'.		self assert: response class: OrderedDictionary.	response := response at: 'filmsOf'.	self assert: response class: OrderedCollection .	self assert: response size equals: 1.	self assert: (response first at: 'name') equals: 'rambo'.	self assert: (response first at: 'rating') equals: 5.</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposeRequestArgumentsWithListEnumType">testComposeRequestArgumentsWithListEnumType	| response |	response := self attendRequest: '{		filmsOn(genders: [ACTION, SCIENCE_FICTION]){			name			rating		}	}'.		self assert: response class: OrderedDictionary.	response := response at: 'filmsOn'.	self assert: response class: OrderedCollection .	self assert: response size equals: 6.	self assert: (response first at: 'name') equals: 'harry potter y la piedra filosofal'.	self assert: (response second at: 'name') equals: 'el seÃ±or de los anillos'.	self assert: (response third at: 'name') equals: 'terminator'.	self assert: (response fourth at: 'name') equals: 'rambo'.	self assert: (response fifth at: 'name') equals: 'robocop'.	self assert: (response sixth at: 'name') equals: 'alien'.</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposeRequestArgumentsWithManyVariable">testComposeRequestArgumentsWithManyVariable	| response text textVariables |	text := '	query operationVariables($name: String, $gender: MovieType, $rating: Int, 							$film: GQLFilmInput, $genders: [ MovieType ]){		features(film: $film)		helloTo(name: $name)		classification(gender: $gender)		filmsWith(rating: $rating){			name		}		filmsOn(genders: $genders){			name			rating		}	}	'.	textVariables := '{"name":"Alex", "gender": ACTION, "rating": 8, 							"film": {filmName : "harry potter y la piedra filosofal"}, 							"genders": [COMEDY, ACTION]}'.	response := self attendRequest: text using: 'operationVariables' with: textVariables.		self assert: response class: OrderedDictionary.	response := response at: 'operationVariables'.	self assert: response class: OrderedDictionary.	self assert: (response at: 'features') equals: 'harry potter y la piedra filosofal'.	self assert: (response at:'helloTo') equals: 'hello Alex'.	self assert: (response at: 'classification') equals: 'ACTION'.	self assert: (response at: 'filmsWith') class: OrderedCollection.	self assert: ((response at: 'filmsWith') first at: 'name') equals: 'el seÃ±or de los anillos'.	self assert: ((response at: 'filmsOn') first at: 'name') equals: 'rambo'.	self assert: ((response at: 'filmsOn') first at: 'rating') equals: 5.	self assert: ((response at: 'filmsOn') second at: 'name') equals: 'annie'.	self assert: ((response at: 'filmsOn') second at: 'rating') equals: 6.</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposeRequestArgumentsWithVariableAndDirectiveExclude">testComposeRequestArgumentsWithVariableAndDirectiveExclude	| text textVariables nameOperation response |	text := '	query operationVariables($name: String, $gender: MovieType,							$film: GQLFilm, $genders: [ MovieType ]){		features(film: $film) @skip(if: true)		helloTo(name: $name) @skip(if: true)		classification(gender: $gender) @skip(if: true)		filmsOn(genders: $genders) @skip(if: true){			name			rating		}	}	'.	nameOperation := 'operationVariables'.	textVariables := '{"name":"Alex", "gender": ACTION, 							"film": {filmName : "harry potter y la piedra filosofal"}, 							"genders": [COMEDY, ACTION]}'.	response := self attendRequest: text using: nameOperation with: textVariables.	self assert: (response at: nameOperation) isEmpty.		text := '	query operationVariables($name: String, $gender: MovieType,							$film: GQLFilm, $genders: [ MovieType ]){		features(film: $film) @include(if: false)		helloTo(name: $name) @include(if: false)		classification(gender: $gender) @include(if: false)		filmsOn(genders: $genders) @include(if: false){			name			rating		}	}	'.	response := self attendRequest: text using: nameOperation with: textVariables.	self assert: (response at: nameOperation) isEmpty.	   </body><body package="GraphQLBeta-Tests-Nodes" selector="testComposeRequestArgumentsWithVariableAndDirectiveInclude">testComposeRequestArgumentsWithVariableAndDirectiveInclude	| response text textVariables |	text := '	query operationVariables($name: String, $gender: MovieType, $rating: Int, 							$film: GQLFilm, $genders: [ MovieType ]){		features(film: $film) @skip(if:false)		helloTo(name: $name)  @skip(if:false)		classification(gender: $gender)  @skip(if:false)		filmsWith(rating: $rating)  @skip(if:false){			name		}		filmsOn(genders: $genders)  @skip(if:false){			name			rating		}	}	'.	textVariables := '{"name":"Alex", "gender": ACTION, "rating": 8, 							"film": {filmName : "harry potter y la piedra filosofal"}, 							"genders": [COMEDY, ACTION]}'.	response := self attendRequest: text using: 'operationVariables' with: textVariables.		self assert: response class: OrderedDictionary.	response := response at: 'operationVariables'.	self assert: response class: OrderedDictionary.	self assert: (response at: 'features') equals: 'harry potter y la piedra filosofal'.	self assert: (response at:'helloTo') equals: 'hello Alex'.	self assert: (response at: 'classification') equals: 'ACTION'.	self assert: (response at: 'filmsWith') class: OrderedCollection.	self assert: ((response at: 'filmsWith') first at: 'name') equals: 'el seÃ±or de los anillos'.	self assert: ((response at: 'filmsOn') first at: 'name') equals: 'rambo'.	self assert: ((response at: 'filmsOn') first at: 'rating') equals: 5.	self assert: ((response at: 'filmsOn') second at: 'name') equals: 'annie'.	self assert: ((response at: 'filmsOn') second at: 'rating') equals: 6.		text := '	query operationVariables($name: String, $gender: MovieType, $rating: Int, 							$film: GQLFilm, $genders: [ MovieType ]){		features(film: $film) @include(if:true)		helloTo(name: $name)  @include(if:true)		classification(gender: $gender)  @include(if:true)		filmsWith(rating: $rating)  @include(if:true){			name		}		filmsOn(genders: $genders)  @include(if:true){			name			rating		}	}	'.	response := self attendRequest: text using: 'operationVariables' with: textVariables.		self assert: response class: OrderedDictionary.	response := response at: 'operationVariables'.	self assert: response class: OrderedDictionary.	self assert: (response at: 'features') equals: 'harry potter y la piedra filosofal'.	self assert: (response at:'helloTo') equals: 'hello Alex'.	self assert: (response at: 'classification') equals: 'ACTION'.	self assert: (response at: 'filmsWith') class: OrderedCollection.	self assert: ((response at: 'filmsWith') first at: 'name') equals: 'el seÃ±or de los anillos'.	self assert: ((response at: 'filmsOn') first at: 'name') equals: 'rambo'.	self assert: ((response at: 'filmsOn') first at: 'rating') equals: 5.	self assert: ((response at: 'filmsOn') second at: 'name') equals: 'annie'.	self assert: ((response at: 'filmsOn') second at: 'rating') equals: 6.	   </body><body package="GraphQLBeta-Tests-Nodes" selector="testComposeRequestExcludeWithTwoDirective">testComposeRequestExcludeWithTwoDirective	| response |	response := self attendRequest: '{		films @skip(if : true) @include(if : true){			name		}	}'.		self assert: response isEmpty.		response := self attendRequest: '{		films @skip(if : true) @include(if : false){			name		}	}'.		self assert: response isEmpty.		response := self attendRequest: '{		films @include(if : false) @skip(if : true){			name		}	}'.		self assert: response isEmpty.		response := self attendRequest: '{		films @skip(if : false) @include(if : false){			name		}	}'.		self assert: response isEmpty.	</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposeRequestIncludeWithTwoDirective">testComposeRequestIncludeWithTwoDirective	| response |	response := self attendRequest: '{		films @skip(if : false) @include(if : true){			name		}	}'.		self assert: response class: OrderedDictionary.		response := self attendRequest: '{		films @include(if : true) @skip(if : false){			name		}	}'.		self assert: response class: OrderedDictionary.	</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposeRequestInterpretWithInputObject">testComposeRequestInterpretWithInputObject	| response  |	response := self attendRequest: '{		hello		information(film: {			description : "Fiction science movie",			gender : "Fiction science"		}) { 				description		 }	}'.		self assert: response class: OrderedDictionary.	self assert: (response at: 'hello') equals: 'hello world'.	self assert: (response at:'information') class: OrderedDictionary.	self assert: ((response at:'information') at: 'description') equals: 'Fiction science movie'</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposeRequestInterpretWithInputObjectAndAlias">testComposeRequestInterpretWithInputObjectAndAlias	| response  |	response := self attendRequest: '{		hello		aliasInformation: information(film: {			description : "Fiction science movie",			gender : "Fiction science"		}) { 				description		 }	}'.		self assert: response class: OrderedDictionary.	self assert: (response at: 'hello') equals: 'hello world'.	self assert: (response at:'aliasInformation') class: OrderedDictionary.	self assert: ((response at:'aliasInformation') at: 'description') equals: 'Fiction science movie'</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposeRequestInterpretWithInputObjectOfDifferentTypeFieldsAndArguments">testComposeRequestInterpretWithInputObjectOfDifferentTypeFieldsAndArguments	| response  |	response := self attendRequest: '{		helloTo(name: "Alex")		detailedInformation(film: {			rating : 9,			boxOffice: 12345523.34,			gender : "Fiction science",			isBoxOffice : true		}) { 				gender				boxOffice				rating				isBoxOffice		 }	}'.		self assert: response class: OrderedDictionary.	self assert: (response at: 'helloTo') equals: 'hello Alex'.	response := response at: 'detailedInformation'.	self assert: response class: OrderedDictionary.	self assert: response size equals: 4.	self assert: (response at: 'gender') equals: 'Fiction science'.	self assert: (response at: 'boxOffice') equals: 12345523.34.	self assert: (response at: 'rating') equals: 9.	self assert: (response at: 'isBoxOffice') equals: true.</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposeRequestInterpretWithInputObjectOfDifferentTypeFieldsAndDirectiveExclude">testComposeRequestInterpretWithInputObjectOfDifferentTypeFieldsAndDirectiveExclude	| response  |	response := self attendRequest: '{		detailedInformation(film: {			rating : 9,			boxOffice: 12345523.34,			gender : "Fiction science",			isBoxOffice : true		}) @skip(if: true) { 				gender				boxOffice				rating				isBoxOffice		 }	}'.		self assert: response isEmpty.		response := self attendRequest: '{		detailedInformation(film: {			rating : 9,			boxOffice: 12345523.34,			gender : "Fiction science",			isBoxOffice : true		}) @include(if: false) { 				gender				boxOffice				rating				isBoxOffice		 }	}'.	self assert: response isEmpty.</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposeRequestInterpretWithInputObjectOfDifferentTypeFieldsAndDirectiveInclude">testComposeRequestInterpretWithInputObjectOfDifferentTypeFieldsAndDirectiveInclude	| response  |	response := self attendRequest: '{		detailedInformation(film: {			rating : 9,			boxOffice: 12345523.34,			gender : "Fiction science",			isBoxOffice : true		}) @skip(if: false) { 				gender				boxOffice				rating				isBoxOffice		 }	}'.		self assert: response class: OrderedDictionary.	response := response at: 'detailedInformation'.	self assert: response class: OrderedDictionary.	self assert: response size equals: 4.	self assert: (response at: 'gender') equals: 'Fiction science'.	self assert: (response at: 'boxOffice') equals: 12345523.34.	self assert: (response at: 'rating') equals: 9.	self assert: (response at: 'isBoxOffice') equals: true.		response := self attendRequest: '{		detailedInformation(film: {			rating : 9,			boxOffice: 12345523.34,			gender : "Fiction science",			isBoxOffice : true		}) @include(if: true) { 				gender				boxOffice				rating				isBoxOffice		 }	}'.		self assert: response class: OrderedDictionary.	response := response at: 'detailedInformation'.	self assert: response class: OrderedDictionary.	self assert: response size equals: 4.	self assert: (response at: 'gender') equals: 'Fiction science'.	self assert: (response at: 'boxOffice') equals: 12345523.34.	self assert: (response at: 'rating') equals: 9.	self assert: (response at: 'isBoxOffice') equals: true.</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposeRequestInterpretWithListInputObject">testComposeRequestInterpretWithListInputObject	| response  |	response := self attendRequest: '{		hello		films { 			rating			name		}		totalInformation(film: [ 				{description : "Fiction science movie",				gender : "Fiction science"}, 				{description : "Animated cartoon movie"}, 				{gender : "Animated cartoon"}				])	}'.		self assert: response class: OrderedDictionary.	self assert: (response at: 'hello') equals: 'hello world'.	self assert: (response at: 'films') class: OrderedCollection.	self assert: ((response at: 'films') first at: 'rating') equals: 9.	self assert: ((response at: 'films') first at: 'name') equals: 'harry potter y la piedra filosofal'.	response:= response at: 'totalInformation'.	self assert: response class: Array.	self assert: response size equals: 3.	self assert: response first class: GQLTestQueryType.	self assert: (response first description) equals:'Fiction science movie'.	self assert: (response first gender) equals: 'Fiction science'.	self assert: (response second description) equals: 'Animated cartoon movie'.	self assert: (response third gender) equals: 'Animated cartoon'.</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposeRequestWithDirectiveExclude">testComposeRequestWithDirectiveExclude	| response |	response := self attendRequest: '{		films @skip(if : true){			name		}	}'.		self assert: response class: OrderedDictionary.	self assert: response isEmpty.		response := self attendRequest: '{		films @include(if : false){			name		}	}'.		self assert: response class: OrderedDictionary.	self assert: response isEmpty.</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposeRequestWithDirectiveInclude">testComposeRequestWithDirectiveInclude	| response expectedValues |	response := self attendRequest: '{		films @skip(if : false){			name		}	}'.		self assert: response class: OrderedDictionary.	self assert: (response at: 'films') class: OrderedCollection.	expectedValues := (response at: 'films') collect: [ :res | res at: 'name' ].	self assert: expectedValues asArray equals: #('harry potter y la piedra filosofal' 'el seÃ±or de los anillos' 'terminator' 'rambo' 'robocop' 'alien' 'annie').		response := self attendRequest: '{		films @include(if : true){			name		}	}'.		self assert: response class: OrderedDictionary.	self assert: (response at: 'films') class: OrderedCollection.	expectedValues := (response at: 'films') collect: [ :res | res at: 'name' ].	self assert: expectedValues asArray equals: #('harry potter y la piedra filosofal' 'el seÃ±or de los anillos' 'terminator' 'rambo' 'robocop' 'alien' 'annie').</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposeRequestWithDuplicateDirective">testComposeRequestWithDuplicateDirective	| text |	text := '{		films @skip(if : false) @skip(if : true){			name		}	}'.		self should: [ self attendRequest: text ] raise: GQLException.		text := '{		films @include(if : true) @include(if : false){			name		}	}'.		self should: [ self attendRequest: text ] raise: GQLException.</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposeRequestWithManyOperationMutation">testComposeRequestWithManyOperationMutation	| response rectangle text |	text := '	mutation pointCreation {		createPoint(x: 1, y: 2){		x y	}}	query operationFilmsWith {		filmsWith(rating: 5) {			name		}	}'.	response := self attendRequest: text using: 'pointCreation' with: '' root: GQLTestMutationType new.		self assert: response class: OrderedDictionary.	rectangle := response at: 'pointCreation'.	self assert: rectangle class: OrderedDictionary.	self assert: (rectangle at: 'createPoint') class: OrderedDictionary.	self assert: ((rectangle at: 'createPoint') at: 'x') equals: 1</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposeRequestWithManyOperationMutationAndWithoutOperationName">testComposeRequestWithManyOperationMutationAndWithoutOperationName	| text |	text := '	mutation pointCreation {		createPoint(x: 1, y: 2){		x y	}}	query operationFilmsWith {		filmsWith(rating: 5) {			name		}	}'.		self should: [ self attendRequest: text using: nil with: ''] raise: GQLException.</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposeRequestWithManyOperationQuery">testComposeRequestWithManyOperationQuery	| response operFilms text |	text := '	query operationFilms {		films {			name		}	}	query operationFilmsWith {		filmsWith(rating: 5) {			name		}	}'.	response := self attendRequest: text using: 'operationFilms' with: ''.		self assert: response class: OrderedDictionary.	operFilms := response at: 'operationFilms'.	self assert: operFilms class: OrderedDictionary.	self assert: (operFilms at: 'films') class: OrderedCollection.	self assert: ((operFilms at:'films') first at: 'name') equals: 'harry potter y la piedra filosofal'.</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposeRequestWithManyOperationQueryAndUnknownOperationName">testComposeRequestWithManyOperationQueryAndUnknownOperationName	| text |	text := '	query operationFilms {		films {			name		}	}	query operationFilmsWith {		filmsWith(rating: 5) {			name		}	}'.		self should: [ self attendRequest: text using: 'operationUnknown' with: '' ] raise: GQLException.</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposeRequestWithManyOperationQueryAndWithoutOperationName">testComposeRequestWithManyOperationQueryAndWithoutOperationName	| text |	text := '	query operationFilms {		films {			name		}	}	query operationFilmsWith {		filmsWith(rating: 5) {			name		}	}'.		self should: [ self attendRequest: text using: nil with: ''] raise: GQLException.</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposeRequestWithManyOperationQueryWithDirectiveExclude">testComposeRequestWithManyOperationQueryWithDirectiveExclude	| text response operFilms |	text := '	query operationFilms {		films @skip(if:true) {			name		}	}	query operationFilmsWith {		filmsWith(rating: 5) @skip(if: true) {			name		}	}'.	response := self attendRequest: text using: 'operationFilms' with: ''.		self assert: response class: OrderedDictionary.	operFilms := response at: 'operationFilms'.	self assert: operFilms isEmpty.		text := '	query operationFilms {		films @include(if: false) {			name		}	}	query operationFilmsWith {		filmsWith(rating: 5) @include(if: false) {			name		}	}'.	response := self attendRequest: text using: 'operationFilms' with: ''.		self assert: response class: OrderedDictionary.	operFilms := response at: 'operationFilms'.	self assert: operFilms isEmpty.</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposeRequestWithManyOperationQueryWithDirectiveInclude">testComposeRequestWithManyOperationQueryWithDirectiveInclude	| response operation text |	text := '	query operationFilms {		films @skip(if: false) {			name		}	}	query operationFilmsWith {		filmsWith(rating: 5) @skip(if: false) {			name		}	}'.	response := self attendRequest: text using: 'operationFilms' with: ''.		self assert: response class: OrderedDictionary.	operation := response at: 'operationFilms'.	self assert: (operation at: 'films') class: OrderedCollection.	self assert: (operation at: 'films') size equals: 7.	self assert: ((operation at:'films') first at: 'name') equals: 'harry potter y la piedra filosofal'.		text := '	query operationFilms {		films @include(if: true) {			name		}	}	query operationFilmsWith {		filmsWith(rating: 5) @include(if: true) {			name		}	}'.	response := self attendRequest: text using: 'operationFilmsWith' with: ''.		self assert: response class: OrderedDictionary.	operation := response at: 'operationFilmsWith'.	self assert: operation class: OrderedDictionary.	self assert: (operation at:'filmsWith') class: OrderedCollection.	self assert: (operation at:'filmsWith') size equals: 3.	self assert: ((operation at:'filmsWith') first at: 'name') equals: 'terminator'.</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposeRequestWithNamedTypeOfOneLevel">testComposeRequestWithNamedTypeOfOneLevel	| response |	response := self attendRequest: '{		hello		films { 			id		 }	}'.		self assert: response class: OrderedDictionary.	self assert: (response at:'hello') equals: 'hello world'.	response := response at: 'films'.	self assert: response class: OrderedCollection.	self assert: (response first at: 'id') equals: 1.	self assert: (response last at: 'id') equals: 7.</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposeRequestWithNamedTypeOfTwoLevelAndFirstDirectiveExclude">testComposeRequestWithNamedTypeOfTwoLevelAndFirstDirectiveExclude	| response |	response := self attendRequest: '{		films @skip(if: true){ 			id			name			film { 				film(name: "harry potter y la piedra filosofal")				id			}		 }	}'.		self assert: response isEmpty .		response := self attendRequest: '{		films @include(if: false){ 			id			name			film { 				film(name: "harry potter y la piedra filosofal")				id			}		 }	}'.		self assert: response isEmpty .</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposeRequestWithNamedTypeOfTwoLevelAndFirstDirectiveInclude">testComposeRequestWithNamedTypeOfTwoLevelAndFirstDirectiveInclude	| response |	response := self attendRequest: '{		films @skip(if: false){ 			id			film { 				get(filmName: "harry potter y la piedra filosofal")				id			}		 }	}'.		self assert: response class: OrderedDictionary .	response := response at: 'films'.	self assert: (response first at: 'id') equals: 1.	response := response first at: 'film'.	self assert: response class: OrderedDictionary.	self assert: (response at: 'get') equals: 'harry potter y la piedra filosofal'.	self assert: (response at: 'id') equals: 1.</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposeRequestWithNamedTypeOfTwoLevelAndParameters">testComposeRequestWithNamedTypeOfTwoLevelAndParameters	| response |	response := self attendRequest: '{		helloTo(name : "Alex")		films { 			film { 				get(filmName: "harry potter y la piedra filosofal")				id			}		 }	}'.		self assert: response class: OrderedDictionary.	self assert: (response at:'helloTo') equals: 'hello Alex'.	response := (response at: 'films') first at: 'film'.	self assert: response class: OrderedDictionary.	self assert: (response at: 'get') equals: 'harry potter y la piedra filosofal'.	self assert: (response at: 'id') equals: 1.</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposeRequestWithNamedTypeOfTwoLevelAndSecondDirectiveExclude">testComposeRequestWithNamedTypeOfTwoLevelAndSecondDirectiveExclude	| response |	response := self attendRequest: '{		films { 			id			film @skip(if: true){ 				film(name: "harry potter y la piedra filosofal")				id			}		 }	}'.		self assert: response class: OrderedDictionary.	response := response at: 'films'.	self assert: response class: OrderedCollection.	self assert: (response first includesKey: 'id').	self assert: (response first at: 'id') equals: 1.	self deny: (response first includesKey: 'film').			response := self attendRequest: '{		films { 			id			film @include(if: false){ 				film(name: "harry potter y la piedra filosofal")				id			}		 }	}'.	self assert: response class: OrderedDictionary.	response := response at: 'films'.	self assert: response class: OrderedCollection.	self assert: (response first includesKey: 'id').	self assert: (response first at: 'id') equals: 1.	self deny: (response first includesKey: 'film').</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposeRequestWithNamedTypeOfTwoLevelAndSecondDirectiveInclude">testComposeRequestWithNamedTypeOfTwoLevelAndSecondDirectiveInclude	| response |	response := self attendRequest: '{		films {			film @skip(if: false){ 				id			}		 }	}'.		self assert: response class: OrderedDictionary .	response := (response at: 'films') first at: 'film'.	self assert: response class: OrderedDictionary.	self assert: (response at: 'id') equals: 1.			response := self attendRequest: '{		films {			film @include(if: true){ 				id			}		 }	}'.		self assert: response class: OrderedDictionary .	response := (response at: 'films') first at: 'film'.	self assert: response class: OrderedDictionary.	self assert: (response at: 'id') equals: 1.</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposeRequestWithOneOperationMutation">testComposeRequestWithOneOperationMutation	| response text rectangle |	text := '	mutation pointCreation {		createPoint(x: 1, y: 2){			x y		}	}'.	response := self attendRequest: text using: 'pointCreation' with: '' root: GQLTestMutationType new.		self assert: response class: OrderedDictionary.	rectangle := response at: 'pointCreation'.	self assert: rectangle class: OrderedDictionary.	self assert: (rectangle at: 'createPoint') class: OrderedDictionary.	self assert: ((rectangle at: 'createPoint') at: 'x') equals: 1</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposeRequestWithOneOperationMutationAndWithoutOperationName">testComposeRequestWithOneOperationMutationAndWithoutOperationName	| response text rectangle |	text := '	mutation pointCreation {		createPoint(x: 1, y: 2){			x y		}	}'.	response := self attendRequest: text using: nil with: '' root: GQLTestMutationType new.		self assert: response class: OrderedDictionary.	rectangle := response at: 'pointCreation'.	self assert: rectangle class: OrderedDictionary.	self assert: (rectangle at: 'createPoint') class: OrderedDictionary.	self assert: ((rectangle at: 'createPoint') at: 'x') equals: 1</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposeRequestWithOneOperationQuery">testComposeRequestWithOneOperationQuery	| response text |	text := '	query operationFilms {		films {			name		}	}'.	response := self attendRequest: text using: 'operationFilms' with: ''.		self assert: response class: OrderedDictionary.	response := response at: 'operationFilms'.	self assert: response class: OrderedDictionary.	self assert: (response at:'films') class: OrderedCollection.	self assert: ((response at:'films') first at: 'name') equals: 'harry potter y la piedra filosofal'.</body><body package="GraphQLBeta-Tests-Nodes" selector="testComposeRequestWithOneOperationQueryAndWithoutOperationName">testComposeRequestWithOneOperationQueryAndWithoutOperationName	| response text |	text := '	query operationFilms {		films {			name		}	}'.	response := self attendRequest: text using: nil with: ''.		self assert: response class: OrderedDictionary.	response := response at: 'operationFilms'.	self assert: response class: OrderedDictionary.	self assert: (response at:'films') class: OrderedCollection.	self assert: (response at:'films') size equals: 7.	self assert: ((response at:'films') first at: 'name') equals: 'harry potter y la piedra filosofal'.</body></methods><methods><class-id>GraphQLBeta.GQLDocumentNodeTest</class-id> <category>test-simpleRequest</category><body package="GraphQLBeta-Tests-Nodes" selector="testMutationArgumentsWithOneVariable">testMutationArgumentsWithOneVariable	| response text textVariables rectangle |	text := '	mutation pointCreation($x : Int) {		createPoint(x: $x, y: 2){			x y		}	}	'.	textVariables := '{"x":1}'.	response := self attendRequest: text using: 'pointCreation' with: textVariables root: GQLTestMutationType new.		self assert: response class: OrderedDictionary.	rectangle := response at: 'pointCreation'.	self assert: rectangle class: OrderedDictionary.	self assert: (rectangle at: 'createPoint') class: OrderedDictionary.	self assert: ((rectangle at: 'createPoint') at: 'x') equals: 1</body><body package="GraphQLBeta-Tests-Nodes" selector="testMutationArgumentsWithOneVariableAndManyAssignment">testMutationArgumentsWithOneVariableAndManyAssignment	| response text textVariables rectangle |	text := '	mutation pointCreation($x : Int) {		createPoint(x: $x, y: 2){			x y		}	}	'.	textVariables := '{"x":5, "x":4, "x":1}'.	response := self attendRequest: text using: 'pointCreation' with: textVariables root: GQLTestMutationType new.		self assert: response class: OrderedDictionary.	rectangle := response at: 'pointCreation'.	self assert: rectangle class: OrderedDictionary.	self assert: (rectangle at: 'createPoint') class: OrderedDictionary.	self assert: ((rectangle at: 'createPoint') at: 'x') equals: 1</body><body package="GraphQLBeta-Tests-Nodes" selector="testMutationArgumentsWithVariableAndDefaultValue">testMutationArgumentsWithVariableAndDefaultValue	| response text textVariables rectangle |	text := '	mutation pointCreation($x : Int = 1) {		createPoint(x: $x, y: 2){			x y		}	}	'.	textVariables := ''.	response := self attendRequest: text using: 'pointCreation' with: textVariables root: GQLTestMutationType new.		self assert: response class: OrderedDictionary.	rectangle := response at: 'pointCreation'.	self assert: rectangle class: OrderedDictionary.	self assert: (rectangle at: 'createPoint') class: OrderedDictionary.	self assert: ((rectangle at: 'createPoint') at: 'x') equals: 1</body><body package="GraphQLBeta-Tests-Nodes" selector="testMutationArgumentsWithVariableAndFragment">testMutationArgumentsWithVariableAndFragment	| response text textVariables rectangle |	text := '	mutation pointCreation($x : Int) {		createPoint(x: $x, y: 2){			...data		}	}		fragment data on Point{	   x y	}	'.	textVariables := '{"x":1}'.	response := self attendRequest: text using: 'pointCreation' with: textVariables root: GQLTestMutationType new.		self assert: response class: OrderedDictionary.	rectangle := response at: 'pointCreation'.	self assert: rectangle class: OrderedDictionary.	self assert: (rectangle at: 'createPoint') class: OrderedDictionary.	self assert: ((rectangle at: 'createPoint') at: 'x') equals: 1</body><body package="GraphQLBeta-Tests-Nodes" selector="testSimpleRequestArgumentsExcludeWithTwoDirective">testSimpleRequestArgumentsExcludeWithTwoDirective	| response |	response := self attendRequest: '{		helloTo(name: "Alex") @skip(if : true) @include(if : true)	}'.		self assert: response isEmpty.		response := self attendRequest: '{		helloTo(name: "Alex") @skip(if : true) @include(if : false)	}'.		self assert: response isEmpty.		response := self attendRequest: '{		helloTo(name: "Alex") @include(if : false) @skip(if : true)	}'.		self assert: response isEmpty.		response := self attendRequest: '{		helloTo(name: "Alex") @skip(if : false) @include(if : false)	}'.		self assert: response isEmpty.	</body><body package="GraphQLBeta-Tests-Nodes" selector="testSimpleRequestArgumentsIncludeWithTwoDirective">testSimpleRequestArgumentsIncludeWithTwoDirective	| response |	response := self attendRequest: '{		helloTo(name: "Alex") @skip(if : false) @include(if : true)	}'.		self assert: response class: OrderedDictionary.		response := self attendRequest: '{		helloTo(name: "Alex") @include(if : true) @skip(if : false)	}'.		self assert: response class: OrderedDictionary.	</body><body package="GraphQLBeta-Tests-Nodes" selector="testSimpleRequestArgumentsWithDirectiveExclude">testSimpleRequestArgumentsWithDirectiveExclude	| response |	response := self attendRequest: '{		helloTo(name : "Alex") @skip(if : true)	}'.		self assert: response class: OrderedDictionary.	self assert: response isEmpty.		response := self attendRequest: '{		helloTo(name : "Alex") @include(if : false)	}'.	self assert: response class: OrderedDictionary.	self assert: response isEmpty.</body><body package="GraphQLBeta-Tests-Nodes" selector="testSimpleRequestArgumentsWithDirectiveInclude">testSimpleRequestArgumentsWithDirectiveInclude	| response |	response := self attendRequest: '{		helloTo(name : "Alex") @skip(if : false)	}'.		self assert: response class: OrderedDictionary.	self assert: (response at: 'helloTo') equals: 'hello Alex'.		response := self attendRequest: '{		helloTo(name : "Alex") @include(if : true)	}'.	self assert: response class: OrderedDictionary.	self assert: (response at: 'helloTo') equals: 'hello Alex'.</body><body package="GraphQLBeta-Tests-Nodes" selector="testSimpleRequestArgumentsWithDuplicateDirective">testSimpleRequestArgumentsWithDuplicateDirective	| text |	text := '{		helloTo(name:"Alex") @skip(if : true) @skip(if : false)	}'.		self should: [ self attendRequest: text ] raise: GQLException.		text  := '{		helloTo(name:"Alex") @include(if : true) @include(if : false)	}'.		self should: [ self attendRequest: text ] raise: GQLException.</body><body package="GraphQLBeta-Tests-Nodes" selector="testSimpleRequestArgumentsWithEnumType">testSimpleRequestArgumentsWithEnumType	| response |	response := self attendRequest: '{		classification(gender: ACTION)	}'.		self assert: response class: OrderedDictionary.	self assert: (response at: 'classification') equals: 'ACTION'.</body><body package="GraphQLBeta-Tests-Nodes" selector="testSimpleRequestArgumentsWithOneVariable">testSimpleRequestArgumentsWithOneVariable	| response text textVariables |	text := '	query operationHello($name: String){		helloTo(name: $name)	}	'.	textVariables := '{"name":"Alex"}'.	response := self attendRequest: text using: 'operationHello' with: textVariables.		self assert: response class: OrderedDictionary.	response := response at: 'operationHello'.	self assert: response class: OrderedDictionary.	self assert: (response at:'helloTo') equals: 'hello Alex'.	</body><body package="GraphQLBeta-Tests-Nodes" selector="testSimpleRequestArgumentsWithOneVariableAndManyAssignment">testSimpleRequestArgumentsWithOneVariableAndManyAssignment	| response text textVariables |	text := '	query operationHello($name: String){		helloTo(name: $name)	}	'.	textVariables := '{"name":"Alex", "name":"Mary", "name":"Juan"}'.	response := self attendRequest: text using: 'operationHello' with: textVariables.		self assert: response class: OrderedDictionary.	response := response at: 'operationHello'.	self assert: response class: OrderedDictionary.	self assert: (response at:'helloTo') equals: 'hello Juan'.	</body><body package="GraphQLBeta-Tests-Nodes" selector="testSimpleRequestArgumentsWithVariableAndDefaultValue">testSimpleRequestArgumentsWithVariableAndDefaultValue	| response text textVariables |	text := '	query operationHello($name: String="Alex"){		helloTo(name: $name)	}	'.	textVariables := ''.	response := self attendRequest: text using: 'operationHello' with: textVariables.		self assert: response class: OrderedDictionary.	response := response at: 'operationHello'.	self assert: response class: OrderedDictionary.	self assert: (response at:'helloTo') equals: 'hello Alex'.</body><body package="GraphQLBeta-Tests-Nodes" selector="testSimpleRequestArgumentsWithVariableAndDirectiveExclude">testSimpleRequestArgumentsWithVariableAndDirectiveExclude	| text textVariables response |	text := '	query operationClassification($gender: MovieType){		classification(gender: $gender) @skip(if: true)	}	'.	textVariables := '{"gender":ACTION}'.	response := self attendRequest: text using: 'operationClassification' with: textVariables.		self assert: response class: OrderedDictionary.	self assert: (response at: 'operationClassification') isEmpty.		text := '	query operationClassification($gender: MovieType){		classification(gender: $gender) @include(if: false)	}	'.	textVariables := '{"gender":ACTION}'.	response := self attendRequest: text using: 'operationClassification' with: textVariables.		self assert: response class: OrderedDictionary.	self assert: (response at: 'operationClassification') isEmpty.</body><body package="GraphQLBeta-Tests-Nodes" selector="testSimpleRequestArgumentsWithVariableAndDirectiveInclude">testSimpleRequestArgumentsWithVariableAndDirectiveInclude	| response text textVariables |	text := '	query operationClassification($gender: MovieType){		classification(gender: $gender) @skip(if: false)	}	'.	textVariables := '{"gender":ACTION}'.	response := self attendRequest: text using: 'operationClassification' with: textVariables.		self assert: response class: OrderedDictionary.	response := response at: 'operationClassification'.	self assert: response class: OrderedDictionary.	self assert: (response at:'classification') equals: 'ACTION'.	   text := '	query operationClassification($gender: MovieType){		classification(gender: $gender) @include(if: true)	}	'.	textVariables := '{"gender":ACTION}'.	response := self attendRequest: text using: 'operationClassification' with: textVariables.		self assert: response class: OrderedDictionary.	response := response at: 'operationClassification'.	self assert: response class: OrderedDictionary.	self assert: (response at:'classification') equals: 'ACTION'.	</body><body package="GraphQLBeta-Tests-Nodes" selector="testSimpleRequestArgumentsWithVariableAndFragment">testSimpleRequestArgumentsWithVariableAndFragment	| response text textVariables |	text := '	query operationHello($name: String){		...fragmentHello	}		fragment fragmentHello on GQLTestQueryType{	   helloTo(name: $name)	}	'.	textVariables := '{"name":"Alex"}'.	response := self attendRequest: text using: 'operationHello' with: textVariables.		self assert: response class: OrderedDictionary.	response := response at: 'operationHello'.	self assert: response class: OrderedDictionary.	self assert: (response at:'helloTo') equals: 'hello Alex'.</body><body package="GraphQLBeta-Tests-Nodes" selector="testSimpleRequestArgumentsWithVariableAssignedAndDefaultValue">testSimpleRequestArgumentsWithVariableAssignedAndDefaultValue	| response text textVariables |	text := '	query operationHello($name: String="Alex"){		helloTo(name: $name)	}	'.	textVariables := '{"name":"Mary"}'.	response := self attendRequest: text using: 'operationHello' with: textVariables.		self assert: response class: OrderedDictionary.	response := response at: 'operationHello'.	self assert: response class: OrderedDictionary.	self assert: (response at:'helloTo') equals: 'hello Mary'.</body><body package="GraphQLBeta-Tests-Nodes" selector="testSimpleRequestExcludeWithTwoDirective">testSimpleRequestExcludeWithTwoDirective	| response |	response := self attendRequest: '{		hello @skip(if : true) @include(if : true)	}'.		self assert: response isEmpty.		response := self attendRequest: '{		hello @skip(if : true) @include(if : false)	}'.		self assert: response isEmpty.		response := self attendRequest: '{		hello @include(if : false) @skip(if : true)	}'.		self assert: response isEmpty.		response := self attendRequest: '{		hello @skip(if : false) @include(if : false)	}'.		self assert: response isEmpty.	</body><body package="GraphQLBeta-Tests-Nodes" selector="testSimpleRequestIncludeWithTwoDirective">testSimpleRequestIncludeWithTwoDirective	| response |	response := self attendRequest: '{		hello @skip(if : false) @include(if : true)	}'.		self deny: response isEmpty.		response := self attendRequest: '{		hello @include(if : true) @skip(if : false)	}'.		self deny: response isEmpty.</body><body package="GraphQLBeta-Tests-Nodes" selector="testSimpleRequestInterpret">testSimpleRequestInterpret	| response  |	response := self attendRequest: '{		hello	}'.		self assert: response class: OrderedDictionary.	self assert: (response at:'hello') equals: 'hello world'.</body><body package="GraphQLBeta-Tests-Nodes" selector="testSimpleRequestInterpretInlineFragments">testSimpleRequestInterpretInlineFragments	| response  |	response := self attendRequest: '{		...{			hello		}	}'.		self assert: response class: OrderedDictionary.	self assert: (response at:'hello') equals: 'hello world'.	self assert: response size equals: 1.</body><body package="GraphQLBeta-Tests-Nodes" selector="testSimpleRequestInterpretInlineFragmentsDirectives">testSimpleRequestInterpretInlineFragmentsDirectives	| response  |	response := self attendRequest: '{		... on Query @include(if:true){			hello		}	}'.		self assert: response class: OrderedDictionary.	self assert: (response at:'hello') equals: 'hello world'.	self assert: response size equals: 1.</body><body package="GraphQLBeta-Tests-Nodes" selector="testSimpleRequestInterpretInlineFragmentsType">testSimpleRequestInterpretInlineFragmentsType	| response  |	response := self attendRequest: '{		... on Query{			hello		}	}'.		self assert: response class: OrderedDictionary.	self assert: (response at:'hello') equals: 'hello world'.	self assert: response size equals: 1.</body><body package="GraphQLBeta-Tests-Nodes" selector="testSimpleRequestInterpretSpreadFragments">testSimpleRequestInterpretSpreadFragments	| response  |	response := self attendRequest: '{		hello		...helloFragment	}	fragment helloFragment on GQLTestQueryType{		hello	}	'.		self assert: response class: OrderedDictionary.	self assert: (response at:'hello') equals: 'hello world'.	self assert: response size equals: 1.</body><body package="GraphQLBeta-Tests-Nodes" selector="testSimpleRequestInterpretWithAlias">testSimpleRequestInterpretWithAlias	| response  |	response := self attendRequest: '{		myMessage : hello	}'.		self assert: response class: OrderedDictionary.	self assert: (response at:'myMessage') equals: 'hello world'.</body><body package="GraphQLBeta-Tests-Nodes" selector="testSimpleRequestInterpretWithInputObject">testSimpleRequestInterpretWithInputObject	| response  |	response := self attendRequest: '{		information(film: {			description : "Fiction science movie",			gender : "Fiction science"		}) { 				description		 }	}'.		self assert: response class: OrderedDictionary.	self assert: (response at:'information') class: OrderedDictionary.	self assert: ((response at:'information') at: 'description') equals: 'Fiction science movie'</body><body package="GraphQLBeta-Tests-Nodes" selector="testSimpleRequestInterpretWithInputObjectModified">testSimpleRequestInterpretWithInputObjectModified	| response  |	response := self attendRequest: '{		informationInput(film: {			filmName : "Fiction science movie"		}) { 				description		 }	}'.		self assert: response class: OrderedDictionary.	self assert: (response at:'informationInput') class: OrderedDictionary.	self assert: ((response at:'informationInput') at: 'description') equals: 'Fiction science movie'</body><body package="GraphQLBeta-Tests-Nodes" selector="testSimpleRequestInterpretWithInputObjectOfDifferentTypeFields">testSimpleRequestInterpretWithInputObjectOfDifferentTypeFields	| response  |	response := self attendRequest: '{		detailedInformation(film: {			rating : 9,			boxOffice: 12345523.34,			gender : "Fiction science",			isBoxOffice : true		}) { 				gender				boxOffice				rating				isBoxOffice		 }	}'.		self assert: response class: OrderedDictionary.	response := response at: 'detailedInformation'.	self assert: response class: OrderedDictionary.	self assert: response size equals: 4.	self assert: (response at: 'gender') equals: 'Fiction science'.	self assert: (response at: 'boxOffice') equals: 12345523.34.	self assert: (response at: 'rating') equals: 9.	self assert: (response at: 'isBoxOffice') equals: true.</body><body package="GraphQLBeta-Tests-Nodes" selector="testSimpleRequestInterpretWithInputObjectOfScalarType">testSimpleRequestInterpretWithInputObjectOfScalarType	| response  |	response := self attendRequest: '{		features(film: {filmName: "Pirates of the Caribbean"})	}'.	self assert: response class: OrderedDictionary.	self assert: (response at:'features') equals: 'Pirates of the Caribbean'</body><body package="GraphQLBeta-Tests-Nodes" selector="testSimpleRequestInterpretWithListInputObject">testSimpleRequestInterpretWithListInputObject	| response  |	response := self attendRequest: '{		totalInformation(film: [ 				{description : "Fiction science movie",				gender : "Fiction science"}, 				{description : "Animated cartoon movie"}, 				{gender : "Animated cartoon"}		]){			description			gender		}	}'.		self assert: response class: OrderedDictionary.	response := response at: 'totalInformation'.	self assert: response class: OrderedCollection.	self assert: response size equals: 3.	self assert: response first class: OrderedDictionary.	self assert: (response first at: 'description') equals: 'Fiction science movie'.	self assert: (response first at: 'gender') equals: 'Fiction science'.	self assert: (response second at: 'description') equals: 'Animated cartoon movie'.	self assert: (response second at: 'gender') isNil.	self assert: (response third at: 'description') isNil.	self assert: (response third at: 'gender') equals: 'Animated cartoon'.</body><body package="GraphQLBeta-Tests-Nodes" selector="testSimpleRequestSameFieldAlias">testSimpleRequestSameFieldAlias	| response  |	response := self attendRequest: '{		hello		myMessage : hello	}'.		self assert: response class: OrderedDictionary.	self assert: (response at:'hello') equals: 'hello world'.	self assert: (response at:'myMessage') equals: 'hello world'.</body><body package="GraphQLBeta-Tests-Nodes" selector="testSimpleRequestSpreadFragmentsWithDirectives">testSimpleRequestSpreadFragmentsWithDirectives	| response  |	response := self attendRequest: '{		films{			name		}		...helloFragment @skip(if : true)	}	fragment helloFragment on GQLTestQueryType{		hello	}'.		self assert: response class: OrderedDictionary.	self deny: (response keys includes: 'hello').	self assert: (response keys includes: 'films').</body><body package="GraphQLBeta-Tests-Nodes" selector="testSimpleRequestUnknowSpreadFragments">testSimpleRequestUnknowSpreadFragments	| text  |	text := '{		hello		...helloFragment	}	fragment fragmentHello on GQLTestQueryType{		hello	}	'.		self should: [self attendRequest: text] raise: GQLException.</body><body package="GraphQLBeta-Tests-Nodes" selector="testSimpleRequestWithDirectiveExclude">testSimpleRequestWithDirectiveExclude	| response  |	response := self attendRequest: '{		hello @skip(if : true)	}'.		self assert: response class: OrderedDictionary.	self assert: response isEmpty.		response := self attendRequest: '{		hello @include(if : false)	}'.		self assert: response class: OrderedDictionary.	self assert: response isEmpty.</body><body package="GraphQLBeta-Tests-Nodes" selector="testSimpleRequestWithDirectiveInclude">testSimpleRequestWithDirectiveInclude	| response  |	response := self attendRequest: '{		hello @skip(if : false)	}'.		self assert: response class: OrderedDictionary.	self assert: (response at: 'hello') equals: 'hello world'.		response := self attendRequest: '{		hello @include(if : true)	}'.		self assert: response class: OrderedDictionary.	self assert: (response at: 'hello') equals: 'hello world'.</body><body package="GraphQLBeta-Tests-Nodes" selector="testSimpleRequestWithDuplicateDirective">testSimpleRequestWithDuplicateDirective	| text |	text := '{		hello @skip(if : true) @skip(if : false)	}'.		self should: [ self attendRequest: text ] raise: GQLException.		text := '{		hello @include(if : true) @include(if : false)	}'.		self should: [ self attendRequest: text ] raise: GQLException.</body><body package="GraphQLBeta-Tests-Nodes" selector="testSimpleRequestWithManyOperationQuery">testSimpleRequestWithManyOperationQuery	| response operHello text |	text := 'query operationHello {		hello	}	query operationHelloTo {		helloTo(name: "Alex")	}'.	response := self attendRequest: text using: 'operationHello' with: ''.		self assert: response class: OrderedDictionary.	operHello := response at: 'operationHello'.	self assert: operHello class: OrderedDictionary.	self assert: (operHello at:'hello') equals: 'hello world'.</body><body package="GraphQLBeta-Tests-Nodes" selector="testSimpleRequestWithManyOperationQueryAndUnknownOperationName">testSimpleRequestWithManyOperationQueryAndUnknownOperationName	| text |	text := '	query operationHello {		hello	}	query operationHelloTo {		helloTo(name: "Alex")	}'.		self should: [ self attendRequest: text using: 'operationUnknown' with: '' ] raise: GQLException.</body><body package="GraphQLBeta-Tests-Nodes" selector="testSimpleRequestWithManyOperationQueryAndWithoutOperationName">testSimpleRequestWithManyOperationQueryAndWithoutOperationName	| text |	text := '	query operationHello {		hello	}	query operationHelloTo {		helloTo(name: "Alex")	}'.		self should: [ self attendRequest: text using: nil with: '' ] raise: GQLException.</body><body package="GraphQLBeta-Tests-Nodes" selector="testSimpleRequestWithManyOperationQueryWithDirectiveExclude">testSimpleRequestWithManyOperationQueryWithDirectiveExclude	| response operHello text |	text := 'query operationHello {		hello @skip(if: true)	}	query operationHelloTo {		helloTo(name: "Alex") @skip(if: true)	}'.	response := self attendRequest: text using: 'operationHello' with: ''.		self assert: response class: OrderedDictionary.	operHello := response at: 'operationHello'.	self assert: operHello isEmpty.		text := '	query operationHello {		hello @include(if: false)	}	query operationHelloTo {		helloTo(name: "Alex") @include(if: false)	}'.	response := self attendRequest: text using: 'operationHello' with: ''.		self assert: response class: OrderedDictionary.	operHello := response at: 'operationHello'.	self assert: operHello isEmpty.</body><body package="GraphQLBeta-Tests-Nodes" selector="testSimpleRequestWithManyOperationQueryWithDirectiveInclude">testSimpleRequestWithManyOperationQueryWithDirectiveInclude	| response operHelloTo text |	text := '	query operationHello {		hello @skip(if: false)	}	query operationHelloTo {		helloTo(name: "Alex") @skip(if: false)	}'.	response := self attendRequest: text using: 'operationHelloTo' with: ''.		self assert: response class: OrderedDictionary.	operHelloTo := response at: 'operationHelloTo'.	self assert: operHelloTo class: OrderedDictionary.	self assert: (operHelloTo at:'helloTo') equals: 'hello Alex'.		text := '	query operationHello {		hello @include(if: true)	}	query operationHelloTo {		helloTo(name: "Alex") @include(if: true)	}'.	response :=  self attendRequest: text using: 'operationHelloTo' with: ''.		self assert: response class: OrderedDictionary.	operHelloTo := response at: 'operationHelloTo'.	self assert: operHelloTo class: OrderedDictionary.	self assert: (operHelloTo at:'helloTo') equals: 'hello Alex'.</body><body package="GraphQLBeta-Tests-Nodes" selector="testSimpleRequestWithOneOperationQuery">testSimpleRequestWithOneOperationQuery	| response text |	text := '	query operationHello {		hello	}'.	response := self attendRequest: text using: 'operationHello' with: ''.		self assert: response class: OrderedDictionary.	response := response at: 'operationHello'.	self assert: response class: OrderedDictionary.	self assert: (response at:'hello') equals: 'hello world'.</body><body package="GraphQLBeta-Tests-Nodes" selector="testSimpleRequestWithOneOperationQueryAndWithoutOperationName">testSimpleRequestWithOneOperationQueryAndWithoutOperationName	| response text |	text := '	query operationHello {		hello	}'.	response := self attendRequest: text using: nil with: ''.		self assert: response class: OrderedDictionary.	response := response at: 'operationHello'.	self assert: response class: OrderedDictionary.	self assert: (response at:'hello') equals: 'hello world'.</body><body package="GraphQLBeta-Tests-Nodes" selector="testSimpleRequestWithUnknownDirective">testSimpleRequestWithUnknownDirective	| text |	text := '{		hello @unknownDirective	}'.		self should: [ self attendRequest: text ] raise: GQLException.		text := '{		hello @unknownDirective(if : false)	}'.		self should: [ self attendRequest: text ] raise: GQLException.	</body></methods><methods><class-id>GraphQLBeta.GQLDocumentNodeTest</class-id> <category>test-variables</category><body package="GraphQLBeta-Tests-Nodes" selector="testDefaultValueVariable">testDefaultValueVariable	| text response |	text := '	query operation1($name: String="Alex"){		helloTo(name: $name)	}	'.	response := self attendRequest: text using: 'operation1' with: ''.	response := response at: 'operation1'.	self assert: (response at: 'helloTo') equals: 'hello Alex'.		text := '	query operation1($name: String!="Alex"){		helloTo(name: $name)	}	'.	self should: [ self attendRequest: text using: 'operation1' with: '' ] raise: GQLException.</body><body package="GraphQLBeta-Tests-Nodes" selector="testDefinedUseVariable">testDefinedUseVariable	| text textVariables |	text := '	query operation1{		...fragHello	}	fragment fragHello on GQLTestQueryType{		helloTo(name:$name)	}	'.	textVariables := '{"name":"Alex"}'.	self should: [ self attendRequest: text using: 'operation1' with: textVariables ] raise: GQLException.</body><body package="GraphQLBeta-Tests-Nodes" selector="testDirectiveVariable">testDirectiveVariable	| text response textVariables |	text := '	query operation1($name:String, $bool:Boolean){		helloTo(name:$name) @skip(if:$bool)	}	'.	textVariables := '{"name":"Alex", "bool":false}'.	response := self attendRequest: text using: 'operation1' with: textVariables.	response := response at: 'operation1'.	self assert: (response at: 'helloTo') equals: 'hello Alex'.		text := 'query operation1($name : String, $gender : FilmType, $lala : Boolean, $rating:Int){      film(name:$name, rating:$rating){        name        rating @skip(if:$lala)      }      filmsOf(gender: $gender){        name        rating      }   }'.		textVariables := '{    "name":"terminator", "rating":5, "gender":ACTION, "lala":true    }'.	response := self attendRequest: text using: 'operation1' with: textVariables.	response := response at: 'operation1'.	self assert: ((response at: 'film') at: 'name') equals: 'terminator'.	self assert: ((response at: 'filmsOf') first at: 'name') equals: 'rambo'.	self assert: ((response at: 'filmsOf') first at: 'rating') equals: 5.</body><body package="GraphQLBeta-Tests-Nodes" selector="testInputTypeVariable">testInputTypeVariable	| text response textVariables |	text := '	query operation1($gqlFilm: GQLFilmInput){		informationInput(film: $gqlFilm){			description			rating		}	}	'.	textVariables := '{"gqlFilm":{filmName:"rambo"}}'.	response := self attendRequest: text using: 'operation1' with: textVariables.	response := response at: 'operation1'.	self assert: ((response at: 'informationInput') at:'description') equals: 'rambo'.	self assert: ((response at: 'informationInput') at:'rating') equals: nil.</body><body package="GraphQLBeta-Tests-Nodes" selector="testUniquenessVariableInvalid">testUniquenessVariableInvalid	| text textVariables |	text := '	query operation1($name: String, $name: String){		helloTo(name: $name)	}	'.	textVariables := '{"name":"Alex"}'.	self should: [ self attendRequest: text using: 'operation1' with: textVariables ] raise: GQLException.</body><body package="GraphQLBeta-Tests-Nodes" selector="testUniquenessVariableValid">testUniquenessVariableValid	| response text textVariables |	text := '	query operation1($name: String){		...fragHello	}	query operation2($name: String){		...fragHello	}	fragment fragHello on GQLTestQueryType{		helloTo(name: $name)	}	'.	textVariables := '{"name":"Alex"}'.	response := self attendRequest: text using: 'operation1' with: textVariables.		self assert: response class: OrderedDictionary.	response := response at: 'operation1'.	self assert: response class: OrderedDictionary.	self assert: (response at:'helloTo') equals: 'hello Alex'.</body><body package="GraphQLBeta-Tests-Nodes" selector="testUsedVariable">testUsedVariable	| text textVariables response |	text := '	query operation1($name:String){		...fragHello	}	fragment fragHello on GQLTestQueryType{		hello	}	'.	textVariables := '{"name":"Alex"}'.	self should: [ self attendRequest: text using: 'operation1' with: textVariables ] raise: GQLException.		text := '	query operation1($name:String){		...fragHello	}	fragment fragHello on GQLTestQueryType{		helloTo(name:$name)	}	'.	response := self attendRequest: text using: 'operation1' with: textVariables.	response := response at: 'operation1'.	self assert: (response at: 'helloTo') equals: 'hello Alex'.</body><body package="GraphQLBeta-Tests-Nodes" selector="testValidationVariablesDocument">testValidationVariablesDocument	| text response textVariables |	text := '	query operation1($name:String, $bool:Boolean){		helloTo(name:$name) @skip(if:$bool)	}	query operation2{		hello	}	'.	textVariables := '{"name":"Alex", "bool":false}'.	response := self attendRequest: text using: 'operation2' with: textVariables.	response := response at: 'operation2'.	self assert: (response at: 'hello') equals: 'hello world'.</body></methods><methods><class-id>GraphQLBeta.GQLDocumentNodeTest</class-id> <category>initialization</category><body package="GraphQLBeta-Tests-Nodes" selector="setUp">setUp	| text |	text := 'type GQLTestMutationType{					createPoint(x:Int, y:Int) : Point				}				type Point{				 x : Int				 y : Int				}								type GQLTestQueryType{					hello : String					helloTo(name:String) : String					films : [ GQLTestFilm ]					filmsWith(rating : Int) : [ GQLTestFilm ]					information(film: GQLTestFilmInput) : GQLTestFilm					detailedInformation(film: GQLTestQueryTypeInput): GQLTestQueryType					totalInformation(film: [GQLTestQueryTypeInput]): [ GQLTestQueryType]					informationInput(film: GQLFilmInput): GQLTestQueryType					features(film: GQLFilmInput): String					classification(gender: MovieType): String					filmsOf(gender: MovieType): [ GQLTestFilm ]					filmsOn(genders: [MovieType]): [ GQLTestFilm ]					film(name:String, rating: Int): GQLFilm				},				type GQLFilm{					filmName : String					id : Int					get(filmName: String): String				},				type GQLTestFilm{					id : String					name : String					rating : Int				},				input GQLFilmInput {					description : String					gender : String				}				enum MovieType{COMEDY, SCIENCE_FICTION, DRAMA}'.		schema := self parseSchema: text.	schema validate.		rootInstance := GQLTestQueryType new.	schema root: rootInstance.		</body></methods><methods><class-id>GraphQLBeta.GQLDocumentNodeTest</class-id> <category>test-fragment</category><body package="GraphQLBeta-Tests-Nodes" selector="testCyclesFragment">testCyclesFragment	| document |	document := self parseRequest: '{		filmsWith(rating: 5) @skip(if : false) @include(if : true){			...named		}	}	fragment named on Film{		name		...other	}	fragment other on Film{		id	   ...named	}'.		self should: [ document evaluate ] raise: GQLException.</body><body package="GraphQLBeta-Tests-Nodes" selector="testNoCyclesFragment">testNoCyclesFragment	| document |	document := self parseRequest: '{		filmsWith(rating: 5) @skip(if : false) @include(if : true){			...named		}	}	fragment named on Film{		name		...other	}	fragment other on Film{		id	}'.		self assert: document evaluate class: GQLDocumentNode</body><body package="GraphQLBeta-Tests-Nodes" selector="testUniquenessFragment">testUniquenessFragment	| document |	document := self parseRequest: '{		filmsWith(rating: 5) @skip(if : false) @include(if : true){			...named		}	}	fragment named on Film{		name	}	fragment named on Film{	   name	}'.		self should: [ document evaluate ] raise: GQLException.</body><body package="GraphQLBeta-Tests-Nodes" selector="testUsedFragments">testUsedFragments	| document  |	document := self parseRequest: '{		hello	}	fragment fragmentHello on GQLTestQueryType{		hello	}'.		self should: [document evaluate] raise: GQLException.</body><body package="GraphQLBeta-Tests-Nodes" selector="testUsedInlineFragments">testUsedInlineFragments	| document  |	document := self parseRequest: '{		...fragmentHello	}	fragment fragmentHello on GQLTestQueryType{		hello		... { 			...fragmentOther		 }	}	fragment fragmentOther on GQLTestQueryType{		hello	}'.		self assert: document evaluate class: GQLDocumentNode.</body></methods><methods><class-id>GraphQLBeta.GQLDocumentNodeTest</class-id> <category>parsing</category><body package="GraphQLBeta-Tests-Nodes" selector="requestEvaluator">requestEvaluator	^ GQLSingleAnonimousQueryEvaluator</body></methods><methods><class-id>GraphQLBeta.GQLSchemaGrammar</class-id> <category>grammar</category><body package="GraphQLBeta-Parser" selector="baseType">baseType"Return a parser accepting object filed base types"	^ scalarType / namedType		"enumTypeName / objectTypeName / interfaceTypeName / unionTypeName "</body><body package="GraphQLBeta-Parser" selector="enumType">enumType	"Return a parser accepting:enum enumTypeName enumValueList"	^ 'enum' asParser , (enumTypeName trim: ignored) , enumValueList</body><body package="GraphQLBeta-Parser" selector="enumTypeName">enumTypeName	"Return a token name that is not a true, false or null"	^ (booleanValue not , nullValue not , tokenName) flatten token</body><body package="GraphQLBeta-Parser" selector="enumValueList">enumValueList	"Return a parser accepting:{ tokenName+ }"	^ ${ asParser , (tokenName trim: ignored) plus , $} asParser</body><body package="GraphQLBeta-Parser" selector="field">field"Return a parser accepting:fieldName parametersOptional : fieldType"	^ fieldName , (parameters trim: ignored) optional , ($: asParser trim: ignored)		, fieldType</body><body package="GraphQLBeta-Parser" selector="fieldInputObject">fieldInputObject	"Return a parser accepting:fieldName parametersOptional : fieldInputObjectType"	^ fieldName , (parameters trim: ignored) optional , ($: asParser trim: ignored) , inputType </body><body package="GraphQLBeta-Parser" selector="fieldInputObjectSet">fieldInputObjectSet	"Return a parser accepting:{ fieldInputObject+ }"	^ ${ asParser , (fieldInputObject trim: ignored) plus , $} asParser</body><body package="GraphQLBeta-Parser" selector="fieldName">fieldName	^ tokenName </body><body package="GraphQLBeta-Parser" selector="fieldSet">fieldSet"Return a parser accepting:{ field+ }"	^ ${ asParser , (field trim: ignored) plus , $} asParser</body><body package="GraphQLBeta-Parser" selector="fieldType">fieldType"Return a parser accepting baseType or wrappedType"	^ nonNullType / baseType / listType </body><body package="GraphQLBeta-Parser" selector="ignoredSpaces">ignoredSpaces	"Return the parsers accepting the list of things we want to ignore"	^ comment / lineTerminator / unicodeBOM		/ whiteSpace</body><body package="GraphQLBeta-Parser" selector="inputObjectType">inputObjectType	"Return a parser accepting:input inputObjectTypeName fieldSet"	^ 'input' asParser , (inputObjectTypeName trim: ignored) , fieldInputObjectSet</body><body package="GraphQLBeta-Parser" selector="inputObjectTypeName">inputObjectTypeName"Return a token name"	^ tokenName	</body><body package="GraphQLBeta-Parser" selector="inputType">inputType	^ nonNullInputType / namedInputType / listInputType</body><body package="GraphQLBeta-Parser" selector="interfaceList">interfaceList	^ ('implements' asParser trim: ignored), ((interfaceTypeName trim: ignoredSpaces) separatedBy: ($, asParser trim: ignoredSpaces))</body><body package="GraphQLBeta-Parser" selector="interfaceType">interfaceType	"Return a parser accepting:interface interfaceTypeName fieldSet"	^ 'interface' asParser , (interfaceTypeName trim: ignored) , fieldSet</body><body package="GraphQLBeta-Parser" selector="interfaceTypeName">interfaceTypeName	"Return a token name"	^ tokenName</body><body package="GraphQLBeta-Parser" selector="listInputType">listInputType"Return a parser accepting:[ inputType ] "	^ $[ asParser , (inputType trim: ignored) , ($] asParser trimRight: ignored)</body><body package="GraphQLBeta-Parser" selector="listType">listType	"Return a parser accepting: [ fieldType ]"	^ $[ asParser , (fieldType trim: ignored) , ($] asParser trimRight: ignored)</body><body package="GraphQLBeta-Parser" selector="namedInputType">namedInputType	"Return a token name"	^ scalarType / namedType</body><body package="GraphQLBeta-Parser" selector="namedType">namedType"Return a token name"	^ tokenName</body><body package="GraphQLBeta-Parser" selector="nonNull">nonNull"Return a parser accepting !"	^ $! asParser</body><body package="GraphQLBeta-Parser" selector="nonNullBaseType">nonNullBaseType	"Return a parser accepting: type nonNull"	^ (baseType trim: ignored) , nonNull </body><body package="GraphQLBeta-Parser" selector="nonNullInputType">nonNullInputType	"Return a parser accepting: namedType nonNull"	^ nonNullNamedType / nonNullListInputType</body><body package="GraphQLBeta-Parser" selector="nonNullListInputType">nonNullListInputType	"Return a parser accepting: listInputType!"	^ listInputType, nonNull</body><body package="GraphQLBeta-Parser" selector="nonNullListType">nonNullListType	"Return a parser accepting: listType!"	^ listType, nonNull</body><body package="GraphQLBeta-Parser" selector="nonNullNamedType">nonNullNamedType	"Return a parser accepting: nametype nonNull"	^ (namedType trim: ignored) , nonNull </body><body package="GraphQLBeta-Parser" selector="nonNullType">nonNullType	"Return a parser accepting: type nonNull"	^ nonNullBaseType / nonNullListType</body><body package="GraphQLBeta-Parser" selector="objectType">objectType	"Return a parser accepting:type objectTypeName implementsOptional fieldSet"	^ 'type' asParser , (objectTypeName trim: ignored), interfaceList optional , fieldSet</body><body package="GraphQLBeta-Parser" selector="objectTypeName">objectTypeName"Return a token name"	^ tokenName</body><body package="GraphQLBeta-Parser" selector="parameter">parameter"Return a parser accepting: parameterName : inputType"	^ parameterName , ($: asParser trim: ignored) , inputType</body><body package="GraphQLBeta-Parser" selector="parameterName">parameterName"Return a token name"	^ tokenName</body><body package="GraphQLBeta-Parser" selector="parameters">parameters"Return a parser accepting:  ( parameter+ )"	^ ($( asParser trimRight: ignored) , (parameter trimRight: ignored) plus , $) asParser</body><body package="GraphQLBeta-Parser" selector="schema">schema"Return a parser accepting one or more type"	^ (schemaType trim: ignored) plus</body><body package="GraphQLBeta-Parser" selector="schemaType">schemaType	"Return a parser accepting:- objectType- enumType- interfaceType- unionType- inputObjectType"	^ objectType / enumType / interfaceType / unionType / inputObjectType</body><body package="GraphQLBeta-Parser" selector="start">start"Return a parser accepting a schema and then the end of the input"	^ schema end</body><body package="GraphQLBeta-Parser" selector="type">type"Return a parser accepting:- scalarType- objectTypeName- enumTypeName- interfaceTypeName- unionTypeName"	^ scalarType / objectTypeName / enumTypeName / interfaceTypeName / unionTypeName </body><body package="GraphQLBeta-Parser" selector="unionType">unionType	"Return a parser accepting:union unionTypeName = unionValuesList"	^ 'union' asParser , (unionTypeName trim: ignored) , ($= asParser trim: ignored), unionValuesList </body><body package="GraphQLBeta-Parser" selector="unionTypeName">unionTypeName	"Return a token name"	^ tokenName</body><body package="GraphQLBeta-Parser" selector="unionValuesList">unionValuesList	"Return a parser accepting:  objectTypeName | unionValue "	^ (objectTypeName trimRight: ignored) separatedBy: ($| asParser trim: ignored)</body></methods><methods><class-id>GraphQLBeta.GQLRequestGrammarEvaluator</class-id> <category>grammar</category><body package="GraphQLBeta-Parser" selector="alias">alias"Return the alias"	^ super alias		performs: [ :tokens | (tokens at: 1) inputValue ]</body><body package="GraphQLBeta-Parser" selector="argument">argument"Return a GQLArgumentNode instance with the information parsed of the request"	^ super argument		performs: [ :tokens | 			|node|			node := GQLArgumentNode new.			node name: (tokens at: 1) inputValue.			node value: (tokens at: 3).			node ]</body><body package="GraphQLBeta-Parser" selector="arguments">arguments"Return the arguments"	^ super arguments		performs: [ :tokens | tokens at: 2 ]</body><body package="GraphQLBeta-Parser" selector="booleanType">booleanType	"Return a GQLSBooleanType instance"	^ super booleanType		performs: [ :tokens | 			| node |			node := GQLSBooleanTypeNode new.			node ]</body><body package="GraphQLBeta-Parser" selector="booleanValue">booleanValue"Return the boolean value"	^ super booleanValue		performs: [ :tokens | 			| node |			node := GQLBooleanNode new.			node value: tokens inputValue.			node ]</body><body package="GraphQLBeta-Parser" selector="defaultValue">defaultValue"Return the default value"	^ super defaultValue		performs: [ :tokens | (tokens at: 2) ]</body><body package="GraphQLBeta-Parser" selector="directive">directive"Return a GQLDirectiveNode instance with the information of the request"	^ super directive		performs: [ :tokens | 			|node|			node := GQLDirectiveNode new.			node name: (tokens at: 2) inputValue.			node arguments: (tokens at: 3).			node ]</body><body package="GraphQLBeta-Parser" selector="document">document	"Return a instance of GQLDocumentNode with the information of the parser"	^ super document		performs: [ :tokens | 			| node |			node := GQLDocumentNode new.			node definitions: tokens ]</body><body package="GraphQLBeta-Parser" selector="enumValue">enumValue"Return the enum value"	^ super enumValue		performs: [ :tokens | 			| node |			node := GQLEnumNode new.			node value: tokens inputValue.			node ]</body><body package="GraphQLBeta-Parser" selector="floatType">floatType	"Return a GQLSFloatTypeNode instance"	^ super floatType		performs: [ :tokens | 			| node |			node := GQLSFloatTypeNode new.			node ]</body><body package="GraphQLBeta-Parser" selector="floatValue">floatValue"Return the variable"	^ super floatValue		performs: [ :tokens | 			| node |			node := GQLFloatNode new.			node value: tokens inputValue.			node ]</body><body package="GraphQLBeta-Parser" selector="fragmentDefinition">fragmentDefinition	"Return a instance of GQLFragmentNode with the information of the request"	^ super fragmentDefinition		performs: [ :tokens | 			| node |			node := GQLFragmentNode new.			node name: (tokens at: 3).			node typeCondition: (tokens at: 4).			node directives: (tokens at: 5).			node selectionSet: (tokens at: 6).			node]</body><body package="GraphQLBeta-Parser" selector="fragmentName">fragmentName"Return the fragmentName"	^ super fragmentName		performs: [ :tokens | (tokens at: 2) inputValue ]</body><body package="GraphQLBeta-Parser" selector="fragmentSpread">fragmentSpread	"Return a instance of GQLFragmentSpreadNode with the information of the request"	^ super fragmentSpread		performs: [ :tokens | 			| node |			node := GQLFragmentSpreadNode new.			node name: (tokens at: 2).			node directives: (tokens at: 3).			node]</body><body package="GraphQLBeta-Parser" selector="idType">idType	"Return a GQLSIDType instance"	^ super idType		performs: [ :tokens | 			| node |			node := GQLSIDTypeNode new.			node ]</body><body package="GraphQLBeta-Parser" selector="inlineFragment">inlineFragment	"Return a instance of GQLInlineFragmentNode with the information of the request"	^ super inlineFragment		performs: [ :tokens | 			| node |			node := GQLInlineFragmentNode new.			node typeCondition: (tokens at: 2).			node directives: (tokens at: 3).			node selectionSet: (tokens at: 4)]</body><body package="GraphQLBeta-Parser" selector="intType">intType	"Return a GQLSIntTypeNode instance"	^ super intType		performs: [ :tokens | 			| node |			node := GQLSIntTypeNode new.			node position: tokens start.			node ]</body><body package="GraphQLBeta-Parser" selector="intValue">intValue"Return the intValue"	^ super intValue		performs: [ :tokens | 			| node |			node := GQLIntNode new.			node value: tokens inputValue.			node ]</body><body package="GraphQLBeta-Parser" selector="listType">listType"Return a list type"	^ super listType		performs: [ :tokens | 			| node |			node := GQLSListTypeNode new.			node wrappedType: (tokens at: 2).			node position: (tokens at: 2) position.			node ]</body><body package="GraphQLBeta-Parser" selector="listValue">listValue"Return the list value"	^ super listValue		performs: [ :tokens | 			| node |			node := GQLListNode new.			node value: (tokens at: 2).			node ]</body><body package="GraphQLBeta-Parser" selector="named">named	"Return a GQLSNamedTypeNode instance with his name and the position on the request"	^ super named		performs: [ :tokens | 			| node |			node := GQLSNamedTypeNode new.			node name: tokens inputValue.			node position: tokens start.			node ]</body><body package="GraphQLBeta-Parser" selector="nonNullType">nonNullType"Return the non null type"	^ super nonNullType		performs: [ :tokens | 			| node |			node := GQLSNonNullTypeNode new.			node wrappedType: (tokens at: 1).			node position: (tokens at: 1) position.			node ]</body><body package="GraphQLBeta-Parser" selector="nonScalarField">nonScalarField"Return a GQLNonScalarNode instance with the information of the request parsed"	^ super nonScalarField		performs: [ :tokens | 			| node |			node := GQLNonScalarFieldNode new.			node alias: (tokens at: 1).			node name: (tokens at: 2) inputValue.			node arguments: (tokens at: 3).			node selectionSet: (tokens at: 5).			node position: (tokens at: 2) start.			node ]</body><body package="GraphQLBeta-Parser" selector="nullValue">nullValue"Return the nullValue"	^ super nullValue		performs: [ :tokens | 			| node |			node := GQLNullNode new.			node value: tokens inputValue.			node ]</body><body package="GraphQLBeta-Parser" selector="objectField">objectField"Return a GQLObjectFieldNode instance with the information from the request"	^ super objectField		performs: [ :tokens | 			| node |			node := GQLObjectFieldNode new.			node name: (tokens at: 1) inputValue.			node value: (tokens at: 3).			node ]</body><body package="GraphQLBeta-Parser" selector="objectValue">objectValue"Return the objectValue"	^ super objectValue		performs: [ :tokens | 			| node |			node := GQLObjectNode new.			node objectFields: (tokens at: 2).			node ]</body><body package="GraphQLBeta-Parser" selector="operation">operation	"Return a instance of GQLOperationNode with the information of the parser"	^ super operation		performs: [ :tokens | 			| node |			node := GQLOperationNode new.			node type: (tokens at: 1).			node name: (tokens at: 3).			node variableDefinitions: (tokens at: 4).			node directives: (tokens at: 5).			node selectionSet: (tokens at: 6)]</body><body package="GraphQLBeta-Parser" selector="scalarField">scalarField"Return a GQLScalarFieldNode instance with the information from the request"	^ super scalarField		performs: [ :tokens | 			|node|			node := GQLScalarFieldNode new.			node alias: (tokens at: 1).			node name: (tokens at: 2) inputValue.			node arguments: (tokens at: 3).			node directives: (tokens at: 4).			node ]</body><body package="GraphQLBeta-Parser" selector="selectionSet">selectionSet"Return a set of selections"	^ super selectionSet		performs: [ :tokens | 			|node|			node := GQLSelectionSetNode new.			node selections: (tokens at: 2).			node ]</body><body package="GraphQLBeta-Parser" selector="stringType">stringType	"Return a GQLSStringType instance"	^ super stringType		performs: [ :tokens | 			| node |			node := GQLSStringTypeNode new.			node ]</body><body package="GraphQLBeta-Parser" selector="stringValue">stringValue"Return the string value"	^ super stringValue		performs: [ :tokens | 			| node |			node := GQLStringNode new.			node value: tokens inputValue.			node ]</body><body package="GraphQLBeta-Parser" selector="typeCondition">typeCondition"Return the type condition"	^ super typeCondition		performs: [ :tokens | (tokens at: 3) ]</body><body package="GraphQLBeta-Parser" selector="variable">variable"Return a GQLVariableNode instance with the value assigned"	^ super variable		performs: [ :tokens | 			| node |			node := GQLVariableNode new.			node value: (tokens inputValue copyWithout: $$).			node ]</body><body package="GraphQLBeta-Parser" selector="variableDefinition">variableDefinition"Return a GQLVariableDefinitionNode instance with the name, type and the default value of the variable"	^ super variableDefinition		performs: [ :tokens |			| node |			node := GQLVariableDefinitionNode new.			node name: ((tokens at: 1) value).			node type: (tokens at: 3).			node defaultValue: (tokens at: 4).			node ]</body><body package="GraphQLBeta-Parser" selector="variableDefinitions">variableDefinitions"Return the variable definitions"	^ super variableDefinitions		performs: [ :tokens | tokens at: 2 ]</body></methods><methods><class-id>GraphQLBeta.GQLOperationNode</class-id> <category>accessing</category><body package="GraphQLBeta-Nodes" selector="directives">directives"Return the directives"	^ directives</body><body package="GraphQLBeta-Nodes" selector="directives:">directives: anObject"Set the directives"	directives := anObject</body><body package="GraphQLBeta-Nodes" selector="name">name"Return the name"	^ name</body><body package="GraphQLBeta-Nodes" selector="name:">name: aName"Set the name"	aName ifNotNil: [ name := aName inputValue ]</body><body package="GraphQLBeta-Nodes" selector="selectionSet">selectionSet"Return the selection set"	^ selectionSet</body><body package="GraphQLBeta-Nodes" selector="selectionSet:">selectionSet: anObject"Set the selection set"	selectionSet := anObject</body><body package="GraphQLBeta-Nodes" selector="targetSpreads">targetSpreads"Return the names of fragment spreads used"	^ selectionSet targetSpreads</body><body package="GraphQLBeta-Nodes" selector="type">type"Return the type"	^ type</body><body package="GraphQLBeta-Nodes" selector="type:">type: anObject"Set the type"	type := anObject</body><body package="GraphQLBeta-Nodes" selector="variableDefinitions">variableDefinitions"Return the variable definitions"	^ variableDefinitions</body><body package="GraphQLBeta-Nodes" selector="variableDefinitions:">variableDefinitions: anObject"Set the variable definitions"	variableDefinitions := anObject</body></methods><methods><class-id>GraphQLBeta.GQLOperationNode</class-id> <category>as yet unclassified</category><body package="GraphQLBeta-Nodes" selector="validVariables">validVariables	| variables |	variables := OrderedCollection new.	variableDefinitions isNotNil	ifTrue: [				variables := variableDefinitions reject: [:var | var isCharacter].		(self unrepeatedVariables: variables) 		ifFalse: [ variables := OrderedCollection new ]	].	^ variables.</body></methods><methods><class-id>GraphQLBeta.GQLOperationNode</class-id> <category>action</category><body package="GraphQLBeta-Nodes" selector="collectVariables:">collectVariables: context	"Collect all variables"	| groupedVariables visitedFragments selections |	groupedVariables := Set new.	visitedFragments := Set new.	selections := self selectionSet selections.	selections do: [ :selection | groupedVariables addAll: (selection collectVariablesOn: context with: visitedFragments) ].	^ groupedVariables</body><body package="GraphQLBeta-Nodes" selector="executeOn:with:using:">executeOn: root with: context using: schema		"Execute the operation with the root, an enviroment and the schema"	| response |	response := OrderedDictionary new.	response at: self name 	put: (self selectionSet executeOn: (self rootOperation: root) with: context using: schema).	^ response</body><body package="GraphQLBeta-Nodes" selector="unrepeatedVariables:">unrepeatedVariables: aCollection	^ (aCollection collect: [ :var | var name value ]) asSet size = aCollection size.</body></methods><methods><class-id>GraphQLBeta.GQLA</class-id> <category>accessing</category><body package="GraphQLBeta-Test-Trash" selector="hey">hey"Return heyhey"	^ #heyhey</body><body package="GraphQLBeta-Test-Trash" selector="heyID">heyID"Return id and his value"	^ #id: , id asString</body><body package="GraphQLBeta-Test-Trash" selector="id">id	^ id</body><body package="GraphQLBeta-Test-Trash" selector="id:">id: aID"Set the id"	id := aID</body></methods><methods><class-id>GraphQLBeta.GQLSingleAnonimousQueryEvaluatorTest</class-id> <category>tests-fieldsFeatures</category><body package="GraphQLBeta-Tests-Grammar" selector="testDocumentPosition">testDocumentPosition	| request document fields |	request := '{		hello		films	}'.	document := GQLSingleAnonimousQueryEvaluator parse: request.	fields := document operations first selections.		self assert: fields first position equals: 5.	self assert: fields second position equals: 13.</body><body package="GraphQLBeta-Tests-Grammar" selector="testDocumentWithArgumentsPosition">testDocumentWithArgumentsPosition	| request document fields arguments |	request := '{		hello (name : "Luke")	}'.	document := GQLSingleAnonimousQueryEvaluator parse: request.	fields := document operations first selections.	arguments := fields first arguments.		self assert: fields first position equals: 5.	self assert: arguments first position equals: 12.</body><body package="GraphQLBeta-Tests-Grammar" selector="testFieldsAlias">testFieldsAlias	| document userField subField |	document := self parseRequest: '{  				user(id: 4) {    					name    					smallPic: profilePic(size: 64)    					bigPic: profilePic(size: 1024)  			}		}'.	self assert: document class: GQLDocumentNode.	userField := document operations first selections first.	self assert: userField class: GQLNonScalarFieldNode.	self assert: userField name: 'user'.	self assert: userField arguments first name: 'id'.	self assertSelections: userField withNames: #('name' 'profilePic' 'profilePic').	subField := userField selectionSet selections second.	self assert: subField alias equals: 'smallPic'.	self assertArguments: subField withValues: #('64').	subField := userField selectionSet selections third.	self assert: subField alias equals: 'bigPic'.	self assertArguments: subField withValues: #('1024').	</body></methods><methods><class-id>GraphQLBeta.GQLSingleAnonimousQueryEvaluatorTest</class-id> <category>tests-fieldsNonScalar</category><body package="GraphQLBeta-Tests-Grammar" selector="testDocumentComposedWithArguments">testDocumentComposedWithArguments	| request document selectionSet |	request := '{		hello(name: "Luke")		films { 			name (capitalize:true, prefix: "Film ")			rating		}	}'.	document := GQLSingleAnonimousQueryEvaluator parse: request.	selectionSet := document operations first.	self assert: document class equals: GQLDocumentNode.	self assert: selectionSet class equals: GQLSelectionSetNode.	self assert: (selectionSet selections at: 1) class equals: GQLScalarFieldNode.	self assert: (selectionSet selections at: 1) name equals: 'hello'.		self assert: (selectionSet selections at: 2) class equals: GQLNonScalarFieldNode.	self assert: (selectionSet selections at: 2) name equals: 'films'.		"arguments"	self assert: ((selectionSet selections at: 1) arguments at: 1) class 	     equals: GQLArgumentNode.	self assert: ((selectionSet selections at: 1) arguments at: 1) name 	     equals: 'name'.	self assert: ((selectionSet selections at: 1) arguments at: 1) value class 	     equals: GQLStringNode.		"object inner fields"		self assert: ((selectionSet selections at: 2) selectionSet selections at:1) class equals: GQLScalarFieldNode .	self assert: ((selectionSet selections at: 2) selectionSet selections at:1) name equals: 'name'.	self assert: ((selectionSet selections at: 2) selectionSet selections at:2) class equals: GQLScalarFieldNode.	self assert: ((selectionSet selections at: 2) selectionSet selections at:2) name equals: 'rating'.	"arguments"	self assert: (((selectionSet selections at: 2) selectionSet selections at:1) arguments at: 1) class 		  equals: GQLArgumentNode.	self assert: (((selectionSet selections at: 2) selectionSet selections at:1) arguments at: 1) name 		  equals: 'capitalize'.	self assert: (((selectionSet selections at: 2) selectionSet selections at:1) arguments at: 2) name 		  equals: 'prefix'.	</body><body package="GraphQLBeta-Tests-Grammar" selector="testDocumentComposePosition">testDocumentComposePosition	| request document fields selectionSet |	request := '{		hello		films { 			name			rating		}	}'.	document := GQLSingleAnonimousQueryEvaluator parse: request.	fields := document operations first selections.	selectionSet := fields second selectionSet selections.		self assert: fields first position equals: 5.	self assert: fields second position equals: 13.	self assert: selectionSet first position equals: 25.	self assert: selectionSet second position equals: 33.</body></methods><methods><class-id>GraphQLBeta.GQLSingleAnonimousQueryEvaluatorTest</class-id> <category>tests-fragmentSpread</category><body package="GraphQLBeta-Tests-Grammar" selector="testDocumentSimpleComposedFragmentSpread">testDocumentSimpleComposedFragmentSpread| request document fragmentSpread |	request := '{		...named		hello	}	fragment named on Person{		...other @skip(if : true)		hello(arg : 1) 	}	fragment other on Droid{		name	}	'.	document := GQLSingleAnonimousQueryEvaluator parse: request.	fragmentSpread := document operations first selections first.	self assert: document class equals: GQLDocumentNode.	self assert: fragmentSpread class equals: GQLFragmentSpreadNode.	self assert: fragmentSpread name: 'named'.	fragmentSpread := document fragments first selectionSet selections first.	self assert: fragmentSpread class equals: GQLFragmentSpreadNode.	self assert: fragmentSpread name: 'other'.	self assert: fragmentSpread directives first class: GQLSkipDirectiveNode.</body><body package="GraphQLBeta-Tests-Grammar" selector="testDocumentSimpleFragmentSpread">testDocumentSimpleFragmentSpread| request document fragmentSpread |	request := '{		...named		...other @skip(if : true)		hello	}	fragment named on Person{		name @skip(if : false)		hello(arg : 1) 	}	fragment other on Droid{		name	}	'.	document := GQLSingleAnonimousQueryEvaluator parse: request.	fragmentSpread := document operations first selections first.	self assert: document class equals: GQLDocumentNode.	self assert: fragmentSpread class equals: GQLFragmentSpreadNode.	self assert: fragmentSpread name: 'named'.	fragmentSpread := document operations first selections second.	self assert: fragmentSpread class equals: GQLFragmentSpreadNode.	self assert: fragmentSpread name: 'other'.	self assert: fragmentSpread directives first class: GQLSkipDirectiveNode.</body></methods><methods><class-id>GraphQLBeta.GQLSingleAnonimousQueryEvaluatorTest</class-id> <category>tests-fieldsScalar</category><body package="GraphQLBeta-Tests-Grammar" selector="testDocumentSimpleWithArguments">testDocumentSimpleWithArguments	| request document selectionSet |	request := '{		hello (name: "Luke")	}'.	document := GQLSingleAnonimousQueryEvaluator parse: request.	selectionSet := document operations first.	self assert: document class equals: GQLDocumentNode.	self assert: selectionSet class equals: GQLSelectionSetNode.	self assert: selectionSet selections first class equals: GQLScalarFieldNode.	self assert: selectionSet selections first name equals: 'hello'.		self assert: ((selectionSet selections at: 1) arguments at: 1) class equals: GQLArgumentNode.	self assert: ((selectionSet selections at: 1) arguments at: 1) name equals: 'name'.	self assert: ((selectionSet selections at: 1) arguments at: 1) value class equals: GQLStringNode.	</body><body package="GraphQLBeta-Tests-Grammar" selector="testDocumentSimpleWithArgumentsAndDirective">testDocumentSimpleWithArgumentsAndDirective	| request document selectionSet |	request := '{		hello (name: "Luke") @include(if : true)	}'.	document := GQLSingleAnonimousQueryEvaluator parse: request.	selectionSet := document operations first.	self assert: document class equals: GQLDocumentNode.	self assert: selectionSet class equals: GQLSelectionSetNode.	self assert: selectionSet selections first class equals: GQLScalarFieldNode.	self assert: selectionSet selections first name equals: 'hello'.		self assert: ((selectionSet selections at: 1) arguments at: 1) class equals: GQLArgumentNode.	self assert: ((selectionSet selections at: 1) arguments at: 1) name equals: 'name'.	self assert: ((selectionSet selections at: 1) arguments at: 1) value class equals: GQLStringNode.	self assert: (selectionSet selections at: 1) directives size equals: 1.	self assert: (selectionSet selections at: 1) directives first class: GQLIncludeDirectiveNode.	self assertArguments: (selectionSet selections at: 1) directives first 				withNames: #('if').	self assertArguments: (selectionSet selections at: 1) directives first 				withValues: #('true').</body><body package="GraphQLBeta-Tests-Grammar" selector="testDocumentSimpleWithArgumentsAndDirectives">testDocumentSimpleWithArgumentsAndDirectives	| request document selectionSet |	request := '{		hello (name: "Luke") @include(if : true) @skip(if : false)	}'.	document := GQLSingleAnonimousQueryEvaluator parse: request.	selectionSet := document operations first.	self assert: document class equals: GQLDocumentNode.	self assert: selectionSet class equals: GQLSelectionSetNode.	self assert: selectionSet selections first class equals: GQLScalarFieldNode.	self assert: selectionSet selections first name equals: 'hello'.		self assert: ((selectionSet selections at: 1) arguments at: 1) class equals: GQLArgumentNode.	self assert: ((selectionSet selections at: 1) arguments at: 1) name equals: 'name'.	self assert: ((selectionSet selections at: 1) arguments at: 1) value class equals: GQLStringNode.	self assert: (selectionSet selections at: 1) directives size equals: 2.	self assert: (selectionSet selections at: 1) directives first class: GQLIncludeDirectiveNode.	self assertArguments: (selectionSet selections at: 1) directives first 				withNames: #('if').	self assertArguments: (selectionSet selections at: 1) directives first 				withValues: #('true').	self assert: (selectionSet selections at: 1) directives second class: GQLSkipDirectiveNode.	self assertArguments: (selectionSet selections at: 1) directives second 				withNames: #('if').	self assertArguments: (selectionSet selections at: 1) directives second 				withValues: #('false').</body></methods><methods><class-id>GraphQLBeta.GQLSingleAnonimousQueryEvaluatorTest</class-id> <category>tests-accessing</category><body package="GraphQLBeta-Tests-Grammar" selector="requestEvaluator">requestEvaluator	^ GQLSingleAnonimousQueryEvaluator</body><body package="GraphQLBeta-Tests-Grammar" selector="testDocument">testDocument	| request document |	request := '{		hello	}'.	document := GQLSingleAnonimousQueryEvaluator parse: request.		self assert: document class equals: GQLDocumentNode.	self assert: document operations first class equals: GQLSelectionSetNode.	self assert: document operations first selections first class equals: GQLScalarFieldNode.	self assert: document operations first selections first name equals: 'hello'.	request := '{		hello		films { 			name			rating		}	}'.	document := GQLSingleAnonimousQueryEvaluator parse: request.	self assert: document class equals: GQLDocumentNode.	self assert: document operations first class equals: GQLSelectionSetNode.	self assert: document operations first selections first class equals: GQLScalarFieldNode.	self assert: document operations first selections second class equals: GQLNonScalarFieldNode.	self assert: document operations first selections first name equals: 'hello'.	self assert: document operations first selections second name equals: 'films'.		"object inner fields"		self assert: ((document operations first selections second) selectionSet selections at:1) class equals: GQLScalarFieldNode.	self assert: ((document operations first selections second) selectionSet selections at:1) name equals: 'name'.	self assert: ((document operations first selections second) selectionSet selections at:2) class equals: GQLScalarFieldNode.	self assert: ((document operations first selections second) selectionSet selections at:2) name equals: 'rating'.	</body></methods><methods><class-id>GraphQLBeta.GQLSingleAnonimousQueryEvaluatorTest</class-id> <category>tests-inlineFragment</category><body package="GraphQLBeta-Tests-Grammar" selector="testDocumentSimpleComposedInlineFragment">testDocumentSimpleComposedInlineFragment| request document inline |	request := '{		...{		 name		 ...{			hello(arg : 1) 		 }		}	}'.	document := GQLSingleAnonimousQueryEvaluator parse: request.	inline := document operations first selections first.	self assert: document class equals: GQLDocumentNode.	self assert: inline class equals: GQLInlineFragmentNode.	self assert: inline typeCondition equals: nil.	self assert: inline directives equals: nil.	self assert: inline selectionSet selections first name equals:'name'.	inline := inline selectionSet selections second.	self assert: inline class equals: GQLInlineFragmentNode.	self assert: inline selectionSet selections first name equals:'hello'.</body><body package="GraphQLBeta-Tests-Grammar" selector="testDocumentSimpleInlineFragment">testDocumentSimpleInlineFragment| request document inline |	request := '{		...{		name @skip(if : false)		hello(arg : 1) 		}	}'.	document := GQLSingleAnonimousQueryEvaluator parse: request.	inline := document operations first selections first.	self assert: document class equals: GQLDocumentNode.	self assert: inline class equals: GQLInlineFragmentNode.	self assert: inline typeCondition equals: nil.	self assert: inline directives equals: nil.	self assert: inline selectionSet selections first name equals:'name'.	self assert: inline selectionSet selections second name equals:'hello'.</body><body package="GraphQLBeta-Tests-Grammar" selector="testDocumentSimpleInlineFragmentDirectives">testDocumentSimpleInlineFragmentDirectives| request document inline |	request := '{	   hello		... on Film @skip(if:true){		name @skip(if : false)		hello(arg : 1) 		}	}'.	document := GQLSingleAnonimousQueryEvaluator parse: request.	inline := document operations first selections second.	self assert: document class equals: GQLDocumentNode.	self assert: inline class equals: GQLInlineFragmentNode.	self assert: inline typeCondition class equals: GQLSNamedTypeNode.	self assert: inline typeCondition name equals: 'Film'.	self assert: inline directives first class equals: GQLSkipDirectiveNode.	self assert: inline selectionSet selections first name equals:'name'.	self assert: inline selectionSet selections second name equals:'hello'.</body><body package="GraphQLBeta-Tests-Grammar" selector="testDocumentSimpleInlineFragmentType">testDocumentSimpleInlineFragmentType| request document inline |	request := '{		... on Film{		name @skip(if : false)		hello(arg : 1) 		}	}'.	document := GQLSingleAnonimousQueryEvaluator parse: request.	inline := document operations first selections first.	self assert: document class equals: GQLDocumentNode.	self assert: inline class equals: GQLInlineFragmentNode.	self assert: inline typeCondition class equals: GQLSNamedTypeNode.	self assert: inline typeCondition name equals: 'Film'.	self assert: inline directives equals: nil.	self assert: inline selectionSet selections first name equals:'name'.	self assert: inline selectionSet selections second name equals:'hello'.</body></methods><methods><class-id>GraphQLBeta.GQLSingleAnonimousQueryEvaluatorTest</class-id> <category>tests-fragment</category><body package="GraphQLBeta-Tests-Grammar" selector="testDocumentSimpleFragmentDefinition">testDocumentSimpleFragmentDefinition| request document fragment |	request := '{		hello (name: "Luke")	}	fragment named on Person{		name @skip(if : false)		hello(arg : 1) 	}	fragment other on Droid{		name	}	'.	document := GQLSingleAnonimousQueryEvaluator parse: request.	fragment := document fragments first.	self assert: document class equals: GQLDocumentNode.	self assert: fragment class equals: GQLFragmentNode.	self assert: fragment name: 'named'.	self assert: fragment typeCondition class: GQLSNamedTypeNode.	self assert: fragment typeCondition name: 'Person'.	self assert: fragment selectionSet selections size equals: 2.	self assert: fragment selectionSet selections first name: 'name'.	self assert: fragment selectionSet selections second name: 'hello'.	fragment := document fragments second.	self assert: fragment class equals: GQLFragmentNode.	self assert: fragment name: 'other'.	self assert: fragment typeCondition class: GQLSNamedTypeNode.	self assert: fragment typeCondition name: 'Droid'.	self assert: fragment selectionSet selections size equals: 1.	self assert: fragment selectionSet selections first name: 'name'.</body></methods><methods><class-id>GraphQLBeta.GQLFragmentNode</class-id> <category>accessing</category><body package="GraphQLBeta-Nodes" selector="directives">directives"Return the directives"	^ directives</body><body package="GraphQLBeta-Nodes" selector="directives:">directives: anObject"Set the directives"	directives := anObject</body><body package="GraphQLBeta-Nodes" selector="name">name"Return the name"	^ name</body><body package="GraphQLBeta-Nodes" selector="name:">name: anObject"Set the name"	name := anObject</body><body package="GraphQLBeta-Nodes" selector="selectionSet">selectionSet"Return the selection set"	^ selectionSet</body><body package="GraphQLBeta-Nodes" selector="selectionSet:">selectionSet: anObject"Set the selection set"	selectionSet := anObject</body><body package="GraphQLBeta-Nodes" selector="targetSpreads">targetSpreads"Return the fragment spreads of this node"	^ selectionSet targetSpreads</body><body package="GraphQLBeta-Nodes" selector="typeCondition">typeCondition"Return the type condition"	^ typeCondition</body><body package="GraphQLBeta-Nodes" selector="typeCondition:">typeCondition: anObject"Set the type condition"	typeCondition := anObject</body></methods><methods><class-id>GraphQLBeta.GQLFragmentNode</class-id> <category>testing</category><body package="GraphQLBeta-Nodes" selector="isOperation">isOperation	^ false</body></methods><methods><class-id>GraphQLBeta.Mutation</class-id> <category>as yet unclassified</category><body package="GraphQLBeta" selector="createPointX:y:">createPointX: x y: y	^ x @ y</body><body package="GraphQLBeta" selector="createRectangleLeft:right:top:bottom:">createRectangleLeft: left right: right top: top bottom: bottom	^ Rectangle left: left right: right top: top bottom: bottom</body></methods><methods><class-id>GraphQLBeta.GQLContext</class-id> <category>accessing</category><body package="GraphQLBeta" selector="addFragments:">addFragments: aCollection"Given a collection, recollect on a dictionary each fragment name and the fragment"	fragments := Dictionary new.	aCollection do: [ :fr | fragments at: fr name put: fr ].</body><body package="GraphQLBeta" selector="fragments">fragments	^ fragments</body><body package="GraphQLBeta" selector="fragments:">fragments: anObject	fragments := anObject</body><body package="GraphQLBeta" selector="operationName">operationName	^ operationName</body><body package="GraphQLBeta" selector="operationName:">operationName: anObject	operationName := anObject</body><body package="GraphQLBeta" selector="variables">variables	^ variables</body><body package="GraphQLBeta" selector="variables:">variables: aCollection	aCollection isNotNil 	ifTrue: [ 		| nameVar |		aCollection do: [ :var | 			nameVar := var name value.			variables 				at: nameVar 				ifPresent: [ :v |					var type isNotNil 						ifTrue: [ (variables at: nameVar) type: var type ].					var defaultValue isNotNil 						ifTrue: [ (variables at: nameVar) defaultValue: var defaultValue ].					var value isNotNil						ifTrue: [ (variables at: nameVar) value: var value ] . 				] ifAbsent: [ variables at: nameVar put: var ] 		]	].</body></methods><methods><class-id>GraphQLBeta.GQLContext</class-id> <category>initialization</category><body package="GraphQLBeta" selector="initialize">initialize		fragments := Dictionary new.		variables := Dictionary new.</body></methods><methods><class-id>GraphQLBeta.GQLContext</class-id> <category>action</category><body package="GraphQLBeta" selector="reset">reset	fragments removeAll.	variables removeAll.	operationName := nil.</body></methods><methods><class-id>GraphQLBeta.GQLContext</class-id> <category>testing</category><body package="GraphQLBeta" selector="isValid">isValid"Verify if all the variables are defined in operation"	variables values detect: [ :var | var type isNil ]							ifFound: [ :var | ^ GQLException new node: self; 					messageText: 'All variables must be defined on operation'; raise ]</body></methods><methods><class-id>GraphQLBeta.GQLTestFilm</class-id> <category>accessing</category><body package="GraphQLBeta-Test-Utils" selector="description">description	^ description</body><body package="GraphQLBeta-Test-Utils" selector="description:">description: anObject	description := anObject</body><body package="GraphQLBeta-Test-Utils" selector="film">film	^film		</body><body package="GraphQLBeta-Test-Utils" selector="gender">gender	^ gender</body><body package="GraphQLBeta-Test-Utils" selector="gender:">gender: anObject	gender := anObject</body><body package="GraphQLBeta-Test-Utils" selector="id">id	^ id		</body><body package="GraphQLBeta-Test-Utils" selector="name">name	^ filmName 	</body><body package="GraphQLBeta-Test-Utils" selector="rating">rating	^ rating		</body><body package="GraphQLBeta-Test-Utils" selector="toDictionary">toDictionary	^ Dictionary new 		at: #id put: id;		at: #name put: filmName;		at: #rating put: rating	</body></methods><methods><class-id>GraphQLBeta.GQLTestFilm</class-id> <category>initialization</category><body package="GraphQLBeta-Test-Utils" selector="initialize:name:rating:gender:">initialize: anId name: aString rating: aNumber gender: aGender	id := anId.	filmName := aString.	rating := aNumber.	description := aString.	gender := aGender.	film := GQLFilm new initialize: aString id: anId .	</body></methods><methods><class-id>GraphQLBeta.GQLTestFilm class</class-id> <category>instance creation</category><body package="GraphQLBeta-Test-Utils" selector="new:name:rating:gender:">new: id name: filmName rating: rating gender: gender	| inst |	inst := self new.	inst initialize: id name: filmName rating: rating gender: gender.	^ inst.	</body></methods><methods><class-id>GraphQLBeta.GQLArgumentNode</class-id> <category>accessing</category><body package="GraphQLBeta-Nodes" selector="name">name"Return the name"	^ name</body><body package="GraphQLBeta-Nodes" selector="name:">name: anObject"Set the name"	name := anObject</body><body package="GraphQLBeta-Nodes" selector="resolver:using:">resolver: aType using: schema	| symbol |	symbol := (self value name: aType name using: schema) asSymbol.	Smalltalk globals allClasses do: [ :cls | cls name = symbol		ifTrue: [ ^ cls new ] ].</body><body package="GraphQLBeta-Nodes" selector="resolverArg:with:ofType:">resolverArg: resolver with: field ofType: aType	| resolverArg |	aType isScalarType 	ifTrue: [ ^ resolver ] 	ifFalse: [ aType isWrappedType 		ifTrue: [ resolverArg := (self resolverArg: resolver with: field ofType: aType wrappedType) ]		ifFalse: [ | nameResolver allClasses class |			nameResolver := (aType nameUsing: self value) asSymbol .			allClasses := Smalltalk allClasses.			class := allClasses 				detect: [ :c | c name = nameResolver ] 				ifNone: [ self error: 'not valid' ].			resolverArg := class new.			]		 ].	^ resolverArg</body><body package="GraphQLBeta-Nodes" selector="resolverArg:with:ofType:using:">resolverArg: resolver with: field ofType: aType using: schema	aType isScalarType 	ifTrue: [ ^ resolver ] 	ifFalse: [ 		aType isWrappedType 		ifTrue: [ ^ self resolverArg: resolver with: field ofType: aType  wrappedType using: schema ]		ifFalse: [ ^ self resolver: aType using: schema ].	].</body><body package="GraphQLBeta-Nodes" selector="value">value"Return the value"	^ value</body><body package="GraphQLBeta-Nodes" selector="value:">value: anObject"Set the value"	value := anObject</body></methods><methods><class-id>GraphQLBeta.GQLArgumentNode</class-id> <category>action</category><body package="GraphQLBeta-Nodes" selector="executeOn:with:using:">executeOn: resolver with: context using: schema"Pass to execute the argument value"	^ value		executeOn: resolver		with: context		using: schema</body></methods><methods><class-id>GraphQLBeta.GQLArgumentNode</class-id> <category>comparing</category><body package="GraphQLBeta-Nodes" selector="partialEquals:using:">partialEquals: other using: context"Given other argument, verify if have the same name and return the same type of value"	^ (self name = other name) and: [		self value class = other value class or: [			(context variables at: self value value ) type name = other value nodeName		]	]</body></methods><methods><class-id>GraphQLBeta.GQLValueNode</class-id> <category>as yet unclassified</category><body package="GraphQLBeta-Nodes" selector="valueVariables">valueVariables	^ Dictionary new.</body></methods><methods><class-id>GraphQLBeta.GQLValueNode</class-id> <category>testing</category><body package="GraphQLBeta-Nodes" selector="isObjectNode">isObjectNode	^ false</body><body package="GraphQLBeta-Nodes" selector="isVariableNode">isVariableNode	^ false</body></methods><methods><class-id>GraphQLBeta.GQLValueNode</class-id> <category>comparing</category><body package="GraphQLBeta-Nodes" selector="=">= other	^ self value = other value</body></methods><methods><class-id>GraphQLBeta.GQLValueNode</class-id> <category>accessing</category><body package="GraphQLBeta-Nodes" selector="name:using:">name: aName using: schema	self subclassResponsibility </body><body package="GraphQLBeta-Nodes" selector="nodeName">nodeName	self subclassResponsibility </body><body package="GraphQLBeta-Nodes" selector="value">value"Return the value"	^ value</body><body package="GraphQLBeta-Nodes" selector="value:">value: anObject"Set the value"	value := anObject</body><body package="GraphQLBeta-Nodes" selector="valueWith:">valueWith: context"Set the value"	^ value</body></methods><methods><class-id>GraphQLBeta.GQLValueNode</class-id> <category>action</category><body package="GraphQLBeta-Nodes" selector="executeOn:with:using:">executeOn: resolver with: context using: schema	self subclassResponsibility </body></methods><methods><class-id>GraphQLBeta.GQLVariableNode</class-id> <category>as yet unclassified</category><body package="GraphQLBeta-Nodes" selector="valueVariables">valueVariables 	^ Dictionary new at: value put: self; yourself</body></methods><methods><class-id>GraphQLBeta.GQLVariableNode</class-id> <category>testing</category><body package="GraphQLBeta-Nodes" selector="isVariableNode">isVariableNode	^ true</body></methods><methods><class-id>GraphQLBeta.GQLVariableNode</class-id> <category>action</category><body package="GraphQLBeta-Nodes" selector="executeOn:with:using:">executeOn: resolver with: context using: schema	context variables isNil 	ifTrue: [ ^ GQLException new node: self; messageText: 'Error on variables'; raise ]	ifFalse: [ context variables detect: 	[ :var | var name value = self value ]	ifFound: [ :var | ^ self value: var executeOn: resolver with: context  using: schema ]	ifNone: [ ^ GQLException new node: self; 					messageText: 'Error on variables'; raise ]. 	]</body></methods><methods><class-id>GraphQLBeta.GQLVariableNode</class-id> <category>accessing</category><body package="GraphQLBeta-Nodes" selector="name:using:">name: aName using: schema	(schema types includesKey: aName)	ifTrue: [ ^ (schema types at: aName) nameOfClass: aName]	ifFalse: [ ^ aName ]</body><body package="GraphQLBeta-Nodes" selector="value:executeOn:with:using:">value: aVarDefinition executeOn: resolver with: context using: schema	| varValue |	varValue := aVarDefinition currentValue.	varValue isObjectNode 		ifTrue: [ varValue objectFields do:			[ :objField | resolver perform: (objField name, ':') asSymbol 									with: (objField value executeOn: resolver with: context using: schema)]			].		^ varValue executeOn: resolver with: context using: schema</body><body package="GraphQLBeta-Nodes" selector="valueWith:">valueWith: context	^ context variables at: value		ifPresent: [ :var | var currentValue value ] 		ifAbsent: [ value ]</body></methods><methods><class-id>GraphQLBeta.GQLIntNode</class-id> <category>action</category><body package="GraphQLBeta-Nodes" selector="executeOn:with:using:">executeOn: resolver with: context using: schema"Execute the input value according to the resolver, the enviroment and the schema"	^ value asInteger</body></methods><methods><class-id>GraphQLBeta.GQLBooleanNode</class-id> <category>action</category><body package="GraphQLBeta-Nodes" selector="executeOn:with:using:">executeOn: resolver with: context using: schema"Execute the input value according to the resolver, the enviroment and the schema"	^ value = 'true'</body></methods><methods><class-id>GraphQLBeta.GQLBooleanNode</class-id> <category>accessing</category><body package="GraphQLBeta-Nodes" selector="nodeName">nodeName	^ 'Boolean'</body></methods><methods><class-id>GraphQLBeta.GQLListNode</class-id> <category>action</category><body package="GraphQLBeta-Nodes" selector="executeOn:with:using:">executeOn: resolver with: context using: schema"Execute the input value according to the resolver, the enviroment and the schema"	^ value collect: [ :e | 					e						executeOn: resolver						with: context						using: schema ]</body></methods><methods><class-id>GraphQLBeta.GQLListNode</class-id> <category>accessing</category><body package="GraphQLBeta-Nodes" selector="name:using:">name: aName using: schema	value isEmpty	ifTrue: [ ^ aName ]	ifFalse: [ ^ value first name: aName using: schema ]</body></methods><methods><class-id>GraphQLBeta.GQLNullNode</class-id> <category>action</category><body package="GraphQLBeta-Nodes" selector="executeOn:with:using:">executeOn: resolver with: context using: schema"Execute the input value according to the resolver, the enviroment and the schema"	^ nil</body></methods><methods><class-id>GraphQLBeta.GQLInlineFragmentNode</class-id> <category>accessing</category><body package="GraphQLBeta-Nodes" selector="selectionSet">selectionSet"Return the selection set"	^ selectionSet</body><body package="GraphQLBeta-Nodes" selector="selectionSet:">selectionSet: anObject"Set the selection set"	selectionSet := anObject</body><body package="GraphQLBeta-Nodes" selector="targetSpreads">targetSpreads"Return the fragment spreads used on the selection set"	^ selectionSet targetSpreads</body><body package="GraphQLBeta-Nodes" selector="typeCondition">typeCondition"Return the type condition"	^ typeCondition</body><body package="GraphQLBeta-Nodes" selector="typeCondition:">typeCondition: anObject"Set the type condition"	typeCondition := anObject</body></methods><methods><class-id>GraphQLBeta.GQLInlineFragmentNode</class-id> <category>as yet unclassified</category><body package="GraphQLBeta-Nodes" selector="collectVariablesOn:with:">collectVariablesOn: context with: visitedFragments	"Collect variables of inline fragments based on their selection set"	^ self collectVarSelectionSet: selectionSet using: context with: visitedFragments.	</body></methods><methods><class-id>GraphQLBeta.GQLInlineFragmentNode</class-id> <category>utils</category><body package="GraphQLBeta-Nodes" selector="ifField:ifFragment:ifInline:">ifField: aFieldBlock ifFragment: aFragmentBlock ifInline: aInlineBlock	^ aInlineBlock value</body></methods><methods><class-id>GraphQLBeta.GQLObjectNode</class-id> <category>accessing</category><body package="GraphQLBeta-Nodes" selector="name:using:">name: aName using: schema	(aName endsWith: 'Input') 	ifTrue: [ ^ aName copyFrom: 1 to: aName size - 5 ]	ifFalse: [ ^ aName ].</body><body package="GraphQLBeta-Nodes" selector="objectFields">objectFields"Return the object fields"	^ objectFields</body><body package="GraphQLBeta-Nodes" selector="objectFields:">objectFields: anObject"Set the object fields"	objectFields := anObject.	objectFields isEmpty ifTrue: [ ^ GQLException new messageText: 'objectFields empty'; raise] 								ifFalse: [ self position: objectFields first position ]</body></methods><methods><class-id>GraphQLBeta.GQLObjectNode</class-id> <category>as yet unclassified</category><body package="GraphQLBeta-Nodes" selector="valueVariables">valueVariables	| valueVariables |	valueVariables := Dictionary new.	self objectFields select: [ :objField | objField value isVariableNode ] 	thenDo: [ :objField | valueVariables at: objField value value put: objField value ].	^ valueVariables</body></methods><methods><class-id>GraphQLBeta.GQLObjectNode</class-id> <category>testing</category><body package="GraphQLBeta-Nodes" selector="isObjectNode">isObjectNode	^ true</body></methods><methods><class-id>GraphQLBeta.GQLObjectNode</class-id> <category>action</category><body package="GraphQLBeta-Nodes" selector="executeOn:with:using:">executeOn: resolver with: context using: schema"Return the object with its respective fields"	| objectResult |	objectResult := resolver class new.	objectFields do: [ :objField | 		objectResult := objectResult perform: (objField name, ':') asSymbol 											with: (objField executeOn: resolver with: context using: schema)].	^ objectResult </body></methods><methods><class-id>GraphQLBeta.GQLStringNode</class-id> <category>action</category><body package="GraphQLBeta-Nodes" selector="executeOn:with:using:">executeOn: resolver with: context using: schema"Execute the input value according to the resolver, the enviroment and the schema"	 ^ value				copyFrom: 2				to: value size - 1</body></methods><methods><class-id>GraphQLBeta.GQLDefaultDirectiveNode</class-id> <category>accessing</category><body package="GraphQLBeta-Nodes" selector="condition">condition	^ self subclassResponsibility</body></methods><methods><class-id>GraphQLBeta.GQLDefaultDirectiveNode</class-id> <category>initialization</category><body package="GraphQLBeta-Nodes" selector="initialize">initialize	super initialize.	arguments := Array with: (GQLArgumentNode new name: 'if'; 											   value: GQLBooleanNode new).</body></methods><methods><class-id>GraphQLBeta.GQLDefaultDirectiveNode</class-id> <category>execute</category><body package="GraphQLBeta-Nodes" selector="execute:">execute: context		| node |	node := self arguments first value.	^ node value = self condition or: [(node valueWith: context) = self condition]</body></methods><methods><class-id>GraphQLBeta.GQLDefaultDirectiveNode class</class-id> <category>as yet unclassified</category><body package="GraphQLBeta-Nodes" selector="directiveName">directiveName	^ ''</body></methods><methods><class-id>GraphQLBeta.GQLIncludeDirectiveNode</class-id> <category>accessing</category><body package="GraphQLBeta-Nodes" selector="condition">condition"Return the condition that must have to able the field"	^ 'true'.</body><body package="GraphQLBeta-Nodes" selector="isInclude">isInclude	^ true</body></methods><methods><class-id>GraphQLBeta.GQLIncludeDirectiveNode</class-id> <category>initialization</category><body package="GraphQLBeta-Nodes" selector="initialize">initialize	super initialize.	name := 'include'.</body></methods><methods><class-id>GraphQLBeta.GQLIncludeDirectiveNode class</class-id> <category>as yet unclassified</category><body package="GraphQLBeta-Nodes" selector="directiveName">directiveName	^ 'include'</body></methods><methods><class-id>GraphQLBeta.GQLSkipDirectiveNode</class-id> <category>accessing</category><body package="GraphQLBeta-Nodes" selector="condition">condition"Return the condition that must have to able the field"	^ 'false'.</body><body package="GraphQLBeta-Nodes" selector="isSkip">isSkip	^ true</body></methods><methods><class-id>GraphQLBeta.GQLSkipDirectiveNode</class-id> <category>initialization</category><body package="GraphQLBeta-Nodes" selector="initialize">initialize	super initialize.	name := 'skip'.</body></methods><methods><class-id>GraphQLBeta.GQLSkipDirectiveNode class</class-id> <category>as yet unclassified</category><body package="GraphQLBeta-Nodes" selector="directiveName">directiveName	^ 'skip'</body></methods><methods><class-id>GraphQLBeta.Query</class-id> <category>accessing</category><body package="GraphQLBeta" selector="allClasses">allClasses	^ Smalltalk allClasses.</body><body package="GraphQLBeta" selector="allClassesStartingWith:">allClassesStartingWith: aName	^ self allClasses select: [ :c | c name beginsWith: aName ]</body><body package="GraphQLBeta" selector="allFilms">allFilms	^ OrderedCollection new 		add: (Film			name: 'terminator'			rating: 5			director: (Person name: 'James Cameron' age: 35)			gender: 'ACTION');		add: (Film			name: 'Star wars: New Hope'			rating: 9			director: (Person name: 'George Lucas' age: 35)			gender: 'SCIENCE_FICTION');		add: (Film			name: 'Star wars: The Clone Wars'			rating: 6			director: (Person name: 'George Lucas' age: 35)			gender: 'SCIENCE_FICTION');		add: (Film			name: 'Star wars: The Empire Strikes Back'			rating: 8			director: (Person name: 'Irvin Kershner' age: 35)			gender: 'SCIENCE_FICTION');		add: (Film			name: 'Star wars: Return of Jedi'			rating: 7			director: (Person name: 'Richard Marquand' age: 35)			gender: 'SCIENCE_FICTION');		add: (Film			name: 'Star wars: The Phantom Menace'			rating: 6			director: (Person name: 'George Lucas' age: 35)			gender: 'SCIENCE_FICTION');		add: (Film			name: 'Star wars: Attack of the Clones'			rating: 6			director: (Person name: 'George Lucas' age: 35)			gender: 'SCIENCE_FICTION');		yourself</body><body package="GraphQLBeta" selector="allRectangles">allRectangles	^ Rectangle allInstances.</body><body package="GraphQLBeta" selector="filmName:">filmName: aName	^ self allFilms detect: [ :f | f name = aName ]					  ifNone: [ nil ]</body><body package="GraphQLBeta" selector="filmsDirectedBy:">filmsDirectedBy: aPerson	^ self allFilms select: [ :f | f director name = aPerson name ]</body><body package="GraphQLBeta" selector="filmsDirectorsIncluded:">filmsDirectorsIncluded: aCollection	| names |	names := aCollection collect: #name.	^ self allFilms select: [ :f | names includes: (f director name) ]</body><body package="GraphQLBeta" selector="filmsOnGender:">filmsOnGender: aGender	^ self allFilms select: [ :f | f gender = aGender ]</body><body package="GraphQLBeta" selector="firstShapesOfType:">firstShapesOfType: aType	aType = 'RECTANGLE'	ifTrue: [ ^ self allRectangles copyFrom: 1 to: 100  ]	ifFalse: [ aType = 'POINT' 		ifTrue: [ ^ Point allInstances copyFrom: 1 to: 100 ]		ifFalse: [^ #() ]	]</body><body package="GraphQLBeta" selector="hello">hello	^ 'hello'</body><body package="GraphQLBeta" selector="helloMessageTo:">helloMessageTo: aPerson	^ 'hello ', aPerson name</body><body package="GraphQLBeta" selector="shapeOfType:">shapeOfType: aType	aType = 'RECTANGLE'	ifTrue: [ ^ self allRectangles  ]	ifFalse: [ aType = 'POINT' 		ifTrue: [ ^ Point allInstances]		ifFalse: [^ #() ]	]</body></methods><methods><class-id>GraphQLBeta.Query class</class-id> <category>accessing</category><body package="GraphQLBeta" selector="schema">schema"The text of the schema"	^ 'union Queries = Query	union Shape = Rectangle | Point	enum FilmType { ACTION, COMEDY, DRAMA }	enum ShapeType { RECTANGLE, POINT, ROMBUS, TRAPEZOID }		type Mutation{		createRectangle(left: Int, right: Int, top: Int, bottom: Int) : Rectangle		createPoint(x:Int, y: Int) : Point	}		type Query{			allClasses : [ Class ]			allClassesStarting(with: String) : [ Class ]			allRectangles : [ Rectangle ]			allFilms: [ Film ]			film(name:String):Film			filmsDirected(by:PersonInput):[Film]			filmsDirectors(included:[PersonInput]):[Film]			filmsOn(gender: FilmType) : [ Film ]			helloMessage(to:PersonInput):String			shapeOf(type: ShapeType): [ Shape ]			firstShapesOf(type: ShapeType): [ Shape ]	   },			interface namedItem{			name : String		}		input PersonInput{			name : String		}		type Film implements namedItem{			name : String			rating : Int			director : Person			gender : FilmType		},		type Person implements namedItem{			name : String			age : Int		}	   type Class implements namedItem{			name : String			methods : [ CompiledMethod ]		},		type CompiledMethod{			selector : String		},		type Rectangle{			origin : Point			corner : Point		},		type Point{			x : Float			y : Float		}'</body></methods><methods><class-id>GraphQLBeta.GQLSNamedTypeNode</class-id> <category>accessing</category><body package="GraphQLBeta-NodesSchema" selector="name">name"Return the name"	^ name</body><body package="GraphQLBeta-NodesSchema" selector="name:">name: aName"Set the name"	name := aName	</body><body package="GraphQLBeta-NodesSchema" selector="nameOfClass:">nameOfClass: aName	self subclassResponsibility </body></methods><methods><class-id>GraphQLBeta.GQLSInterfaceTypeNode</class-id> <category>testing</category><body package="GraphQLBeta-NodesSchema" selector="isInterfaceType">isInterfaceType"Return if is a interface type"	^ true</body></methods><methods><class-id>GraphQLBeta.GQLSInterfaceTypeNode</class-id> <category>initialization</category><body package="GraphQLBeta-NodesSchema" selector="initialize">initialize	super initialize.	fields := Dictionary new</body></methods><methods><class-id>GraphQLBeta.GQLSInterfaceTypeNode</class-id> <category>accessing</category><body package="GraphQLBeta-NodesSchema" selector="fields">fields"Return the fields"	^ fields</body><body package="GraphQLBeta-NodesSchema" selector="getField:">getField: aFieldName	"Return the field given his name"	| res |	res := (fields includesKey: aFieldName)		ifTrue: [ fields at: aFieldName ]		ifFalse: [ nil ].	^ res</body></methods><methods><class-id>GraphQLBeta.GQLSInterfaceTypeNode</class-id> <category>adding</category><body package="GraphQLBeta-NodesSchema" selector="addFields:">addFields: aArray"Puts the fields of the array on a dictionary"	aArray do: [ :field | fields at: field name put: field ]</body></methods><methods><class-id>GraphQLBeta.GQLSEnumTypeNode</class-id> <category>adding</category><body package="GraphQLBeta-NodesSchema" selector="addValues:">addValues: values"Set the string of values "	stringValues := values</body></methods><methods><class-id>GraphQLBeta.GQLSEnumTypeNode</class-id> <category>accessing</category><body package="GraphQLBeta-NodesSchema" selector="nameOfClass:">nameOfClass: aName	^ self class name</body><body package="GraphQLBeta-NodesSchema" selector="values">values"Return the string values"	^ stringValues</body></methods><methods><class-id>GraphQLBeta.GQLSEnumTypeNode</class-id> <category>testing</category><body package="GraphQLBeta-NodesSchema" selector="isInputType">isInputType"Return if is input type"	^ true</body></methods><methods><class-id>GraphQLBeta.GQLSInputObjectTypeNode</class-id> <category>initialization</category><body package="GraphQLBeta-NodesSchema" selector="initialize">initialize	super initialize.	fieldSet := Dictionary new</body></methods><methods><class-id>GraphQLBeta.GQLSInputObjectTypeNode</class-id> <category>accessing</category><body package="GraphQLBeta-NodesSchema" selector="fields">fields	^ fieldSet </body><body package="GraphQLBeta-NodesSchema" selector="getField:">getField: aFieldName	"Return the field given his name"	| res |	res := (fieldSet includesKey: aFieldName)		ifTrue: [ fieldSet at: aFieldName ]		ifFalse: [ nil ].	^ res</body><body package="GraphQLBeta-NodesSchema" selector="nameOfClass:">nameOfClass: aName	(aName endsWith: 'Input') 	ifTrue: [ ^ aName copyFrom: 1 to: aName size - 5 ]	ifFalse: [ ^ GQLException new node: self; 					messageText: 'Error with variables'; raise ].</body></methods><methods><class-id>GraphQLBeta.GQLSInputObjectTypeNode</class-id> <category>testing</category><body package="GraphQLBeta-NodesSchema" selector="isInputType">isInputType"Return if if a input type"	^ true</body><body package="GraphQLBeta-NodesSchema" selector="isValidateClass">isValidateClass"Respondes if a type needs to be searched on the image of Pharo"	^ true</body></methods><methods><class-id>GraphQLBeta.GQLSInputObjectTypeNode</class-id> <category>adding</category><body package="GraphQLBeta-NodesSchema" selector="addFields:">addFields: aArray"Given a collection puts the values on a dictionary for improve the search"	aArray do: [ :field | fieldSet at: field name put: field ]</body></methods><methods><class-id>GraphQLBeta.GQLSObjectTypeNode</class-id> <category>accessing</category><body package="GraphQLBeta-NodesSchema" selector="fields">fields"Return the fields"	^ fieldSet</body><body package="GraphQLBeta-NodesSchema" selector="getField:">getField: aFieldName	"Return the field given his name"	| res |	res := (fieldSet includesKey: aFieldName)		ifTrue: [ fieldSet at: aFieldName ]		ifFalse: [ nil ].	^ res</body><body package="GraphQLBeta-NodesSchema" selector="getFieldType:">getFieldType: aFieldName	"Return the type of a field"	| res |	res := (fieldSet includesKey: aFieldName)		ifTrue: [ (fieldSet at: aFieldName) type ]		ifFalse: [ nil ].	^ res</body><body package="GraphQLBeta-NodesSchema" selector="implements:">implements: aArray"Set the interfaces that implements"	aArray ifNotNil: [ interfaces := aArray ]</body><body package="GraphQLBeta-NodesSchema" selector="interfaces">interfaces"Return the interfaces"	^ interfaces</body><body package="GraphQLBeta-NodesSchema" selector="nameOfClass:">nameOfClass: aName	^ aName</body></methods><methods><class-id>GraphQLBeta.GQLSObjectTypeNode</class-id> <category>initialization</category><body package="GraphQLBeta-NodesSchema" selector="initialize">initialize	super initialize.	fieldSet := Dictionary new.	interfaces := OrderedCollection new. </body></methods><methods><class-id>GraphQLBeta.GQLSObjectTypeNode</class-id> <category>testing</category><body package="GraphQLBeta-NodesSchema" selector="implementsFields:">implementsFields: aCollection"Check if has all the fields on interface with the same argumentsHERE MUST CHECK THE TYPE OF FIELD AND ARGUMENT ACCORD: 3.1.2.3 SPEC GRAPHQL"	^ aCollection allSatisfy: 	[ :field | (self fields includesKey: field name) 				and: [ (self getField: field name) arguments = field arguments ] ]</body><body package="GraphQLBeta-NodesSchema" selector="isObjectType">isObjectType"Return if is a object type"	^ true</body><body package="GraphQLBeta-NodesSchema" selector="isValidateClass">isValidateClass"Respondes if a type needs to be searched on the image of Pharo"	^ true</body></methods><methods><class-id>GraphQLBeta.GQLSObjectTypeNode</class-id> <category>adding</category><body package="GraphQLBeta-NodesSchema" selector="addFields:">addFields: aArray"Given a collection puts the values on a dictionary for improve the search"	aArray do: [ :field | fieldSet at: field name put: field ]</body></methods><methods><class-id>GraphQLBeta.GQLSScalarTypeNode</class-id> <category>testing</category><body package="GraphQLBeta-NodesSchema" selector="isInputType">isInputType"Return if is a input type"	^ true</body><body package="GraphQLBeta-NodesSchema" selector="isScalarType">isScalarType"Return if is a scalar type"	^ true</body></methods><methods><class-id>GraphQLBeta.GQLSFloatTypeNode</class-id> <category>initialization</category><body package="GraphQLBeta-NodesSchema" selector="initialize">initialize	super initialize.	name := 'Float'</body></methods><methods><class-id>GraphQLBeta.GQLSStringTypeNode</class-id> <category>initialization</category><body package="GraphQLBeta-NodesSchema" selector="initialize">initialize	super initialize.	name := 'String'</body></methods><methods><class-id>GraphQLBeta.GQLSIntTypeNode</class-id> <category>initialization</category><body package="GraphQLBeta-NodesSchema" selector="initialize">initialize	super initialize.	name := 'Int'</body></methods><methods><class-id>GraphQLBeta.GQLSBooleanTypeNode</class-id> <category>initialization</category><body package="GraphQLBeta-NodesSchema" selector="initialize">initialize	super initialize.	name := 'Boolean'</body></methods><methods><class-id>GraphQLBeta.GQLSUnionTypeNode</class-id> <category>adding</category><body package="GraphQLBeta-NodesSchema" selector="addTypes:">addTypes: types"Given a collection puts the values on a dictionary for improve the search"	namedTypes := types</body></methods><methods><class-id>GraphQLBeta.GQLSUnionTypeNode</class-id> <category>accessing</category><body package="GraphQLBeta-NodesSchema" selector="namedTypes">namedTypes"Return the named types"	^ namedTypes</body></methods><methods><class-id>GraphQLBeta.GQLSUnionTypeNode</class-id> <category>testing</category><body package="GraphQLBeta-NodesSchema" selector="isUnionType">isUnionType"Return if is a union type"	^ true</body></methods><methods><class-id>GraphQLBeta.GQLSchemaGrammarEvaluatorTest</class-id> <category>tests-schemaObjectTypes</category><body package="GraphQLBeta-Tests-Grammar" selector="testIncompleteSchemaObjectType">testIncompleteSchemaObjectType	| text schema |	text := 'type Query{              name :             }'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: PPFailure.	text := 'type Query{              name : String            }				{}'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: PPFailure.	text := 'type Query{              name : String            }				type Class{ 				  name :				}'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: PPFailure</body><body package="GraphQLBeta-Tests-Grammar" selector="testIncompleteSchemaObjectTypeParameters">testIncompleteSchemaObjectTypeParameters	| text schema |	text := 'type Query{              name (id: Int : String            }'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: PPFailure.	text := 'type Query{              name (id: Int, ) : String            }				{}'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: PPFailure.	text := 'type Query{              name (id:Int) : String            }				type Class{ 				  name :				}'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: PPFailure</body><body package="GraphQLBeta-Tests-Grammar" selector="testSchemaObjectType">testSchemaObjectType	| text schema someType someOtherType var |	text := 'type SomeType {					someName : [Int]					otherVariable 	:String				},				type SomeOtherTypeName {					someName 	: [String ! ]				}'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: GQLSSchemaNode.	someType := schema types at: 'SomeType'.	someOtherType := schema types at: 'SomeOtherTypeName'.	self assert: someType class equals: GQLSObjectTypeNode.	self assert: someType name equals: 'SomeType'.	var := someType fields at: 'someName'.	self assert: var class equals: GQLSFieldNode.	self assert: var name equals: 'someName'.	self assert: var type class equals: GQLSListTypeNode.		self assert: someOtherType fields values first type class equals: GQLSListTypeNode.	self assert: var type wrappedType name equals: 'Int'.	var := someType fields at: 'otherVariable'.	self assert: var name equals: 'otherVariable'.	self assert: var type name equals: 'String'</body><body package="GraphQLBeta-Tests-Grammar" selector="testSchemaObjectTypeAndEnumType">testSchemaObjectTypeAndEnumType	| text schema someType enumType var |	text := 'type SomeType {					someName(arg: EnumArg): String					otherVariable 	:String				},				enum EnumArg{				   ARG_1				   ARG_2					ARG_3				}'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: GQLSSchemaNode.	someType := schema types at: 'SomeType'.	self assert: someType class equals: GQLSObjectTypeNode.	self assert: someType name equals: 'SomeType'.	var := someType fields at: 'someName'.	self assert: var class equals: GQLSFieldNode.	self assert: var name equals: 'someName'.	self assert: var arguments size equals: 1.	self assert: (var arguments at: 'arg') type class equals: GQLSNamedTypeNode.		enumType := schema types at: 'EnumArg'.	self assert: enumType class equals: GQLSEnumTypeNode.	self assert: enumType values size equals: 3.	self assert: (enumType values at: 1) equals: 'ARG_1'.	self assert: (enumType values at: 2) equals: 'ARG_2'.	self assert: (enumType values at: 3) equals: 'ARG_3'.</body><body package="GraphQLBeta-Tests-Grammar" selector="testSchemaObjectTypeParameters">testSchemaObjectTypeParameters	| text schema someType var |	text := 'type SomeType {					field(id: Int) : [Int]					otherVariable(param: String, param2: [Int]!):String 					a (param: [Int]!):Int				},				type SomeOtherTypeName {					someName (a:String!): [String ! ]					someName2 :String 				}'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: GQLSSchemaNode.	someType := schema types at: 'SomeType'.	self assert: someType class equals: GQLSObjectTypeNode.	self assert: someType name equals: 'SomeType'.	self assert: someType fields values third name equals: 'otherVariable'.	var := someType fields at: 'a'.	self		assert: var arguments values first class		equals: GQLSArgumentFieldNode.	self		assert: var arguments values first class		equals: GQLSArgumentFieldNode.	self		assert: var arguments values first type class		equals: GQLSNonNullTypeNode.	self		assert: var arguments values first type wrappedType class		equals: GQLSListTypeNode</body><body package="GraphQLBeta-Tests-Grammar" selector="testSchemaObjectTypeWithInterface">testSchemaObjectTypeWithInterface	| text schema someType someOtherType |	text := 'type SomeType implements Type{					someName : [Int]				},				type SomeOtherTypeName implements Type, Other {					someName 	: String !				}'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: GQLSSchemaNode.	someType := schema types at: 'SomeType'.	someOtherType := schema types at: 'SomeOtherTypeName'.	self assert: someType class equals: GQLSObjectTypeNode.	self assert: someType name equals: 'SomeType'.	self assert: someType interfaces size equals: 1.	self assert: someType interfaces first equals: 'Type'.	self assert: someOtherType class equals: GQLSObjectTypeNode.	self assert: someOtherType name equals: 'SomeOtherTypeName'.	self assert: someOtherType interfaces size equals: 2.	self assert: someOtherType interfaces first equals: 'Type'.	self assert: someOtherType interfaces second equals: 'Other'.</body></methods><methods><class-id>GraphQLBeta.GQLSchemaGrammarEvaluatorTest</class-id> <category>test-schemaInputObjectType</category><body package="GraphQLBeta-Tests-Grammar" selector="testIncompleteSchemaInputObjectType">testIncompleteSchemaInputObjectType	| text schema |	text := 'input ExampleInputObject { 			 	a: String  				b: !				c: OtherInputObject			}'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: PPFailure.	text := 'input ExampleInputObject { 			 	a: String  				b: Int!				c: OtherInputObject			'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: PPFailure.	text := 'input ExampleInputObject { 			 	a: String  				b: Int!				c: OtherInputObject!!			}'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: PPFailure</body><body package="GraphQLBeta-Tests-Grammar" selector="testSchemaInputObjectType">testSchemaInputObjectType	| text schema inputObject |	text := 'input ExampleInputObject { 			 	a: String  				b: Int!				c: OtherInputObject			}'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: GQLSSchemaNode.	inputObject := schema getType: 'ExampleInputObject'.	self assert: inputObject class equals: GQLSInputObjectTypeNode.	self assert: inputObject name equals: 'ExampleInputObject'.	self assert: (inputObject getField: 'a') class equals: GQLSInputObjectFieldNode.	self assert: (inputObject getField: 'a') type class equals: GQLSStringTypeNode.	self assert: (inputObject getField: 'b') type wrappedType class equals: GQLSIntTypeNode.	self assert: (inputObject getField: 'c') type class equals: GQLSNamedTypeNode.</body></methods><methods><class-id>GraphQLBeta.GQLSchemaGrammarEvaluatorTest</class-id> <category>test-schemaUnionType</category><body package="GraphQLBeta-Tests-Grammar" selector="testIncompleteSchemaUnionType">testIncompleteSchemaUnionType	| text schema |	text := 'union CatOrDog = Cat |'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: PPFailure.	text := 'union CatOrDog  Cat | Dog'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: PPFailure.	text := 'union CatOrDog = Cat | |'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: PPFailure</body><body package="GraphQLBeta-Tests-Grammar" selector="testSchemaUnionType">testSchemaUnionType	| text schema dog cat |	text := 'union CatOrDog = Cat | Dog				union DogOrHuman = Dog | Human | Alien'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: GQLSSchemaNode.	cat := schema getType: 'CatOrDog'.	dog := schema getType: 'DogOrHuman'.	self assert: dog class equals: GQLSUnionTypeNode.	self assert: cat class equals: GQLSUnionTypeNode.	self assert: dog namedTypes size equals: 3.	self assert: cat namedTypes size equals: 2.	self assert: dog namedTypes first equals: 'Dog'.	self assert: dog namedTypes second equals: 'Human'.	self assert: dog namedTypes third equals: 'Alien'.	self assert: cat namedTypes first equals: 'Cat'.	self assert: cat namedTypes second equals: 'Dog'.</body></methods><methods><class-id>GraphQLBeta.GQLSchemaGrammarEvaluatorTest</class-id> <category>test-schemaInterfaceType</category><body package="GraphQLBeta-Tests-Grammar" selector="testIncompleteSchemaInterfaceType">testIncompleteSchemaInterfaceType	| text schema |	text := 'interface NamedEntity {				  name: String			  '.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: PPFailure.	text := 'interface NamedEntity {				  name: 			  }'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: PPFailure.	text := 'interface NamedEntity {				  name: String : Int			  }'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: PPFailure</body><body package="GraphQLBeta-Tests-Grammar" selector="testSchemaInterfaceType">testSchemaInterfaceType	| text schema interface |	text := 'interface NamedEntity {				  field(id: Int) : [Int]				  otherVariable(param: String, param2: [Int]!) : String 				  a (param: [Int]!) : A			  }'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: GQLSSchemaNode.	interface := schema getType: 'NamedEntity'.	self assert: interface class equals: GQLSInterfaceTypeNode.	self assert: interface name equals: 'NamedEntity'.	self assert: (interface getField: 'field') class equals: GQLSFieldNode.	self assert: (interface getField: 'field') type class equals: GQLSListTypeNode.	self assert: (interface getField: 'field') type wrappedType class equals: GQLSIntTypeNode.	self assert: (interface getField: 'otherVariable') type class equals: GQLSStringTypeNode.	self assert: ((interface getField: 'otherVariable') getArgument: 'param2') type class equals: GQLSNonNullTypeNode.	self assert: (interface getField: 'a') type class equals: GQLSNamedTypeNode.</body></methods><methods><class-id>GraphQLBeta.GQLSchemaGrammarEvaluatorTest</class-id> <category>test-schemaEnumType</category><body package="GraphQLBeta-Tests-Grammar" selector="testIncompleteSchemaEnumType">testIncompleteSchemaEnumType	| text schema |	text := 'enum CatCommand {}'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: PPFailure.	text := 'enum { JUMP }'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: PPFailure.	text := 'enum CatCommand { JUMP'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: PPFailure</body><body package="GraphQLBeta-Tests-Grammar" selector="testSchemaEnumType">testSchemaEnumType	| text schema dog cat |	text := 'enum DogCommand { SIT, DOWN, HEEL }			  enum CatCommand { JUMP }'.	schema := GQLSchemaGrammarEvaluator parse: text.	self assert: schema class equals: GQLSSchemaNode.	dog := schema getType: 'DogCommand'.	cat := schema getType: 'CatCommand'.	self assert: dog class equals: GQLSEnumTypeNode.	self assert: cat class equals: GQLSEnumTypeNode.	self assert: dog values size equals: 3.	self assert: cat values size equals: 1.	self assert: dog values first equals: 'SIT'.	self assert: dog values second equals: 'DOWN'.	self assert: dog values third equals: 'HEEL'.	self assert: cat values first equals: 'JUMP'.</body></methods><methods><class-id>GraphQLBeta.GQLFieldNode</class-id> <category>accessing</category><body package="GraphQLBeta-Nodes" selector="alias">alias"Return the alias"	^ alias</body><body package="GraphQLBeta-Nodes" selector="alias:">alias: anObject"Set the alias"	alias := anObject</body><body package="GraphQLBeta-Nodes" selector="arguments">arguments"Return the arguments"	^ arguments</body><body package="GraphQLBeta-Nodes" selector="arguments:">arguments: anObject"If anObject is nil set the arguments to a new array, otherwise set the arguments"	anObject ifNil: [ arguments := Array new ]				ifNotNil: [ arguments := anObject ] </body><body package="GraphQLBeta-Nodes" selector="fullName">fullName	"Return the full name"	fullName		ifNil: [ | write |			write := WriteStream on: String new.			write nextPutAll: self name.			self arguments				ifNotEmpty: [ :ags | 					ags doWithIndex: [ :ag :i | 							i = 1								ifTrue: [ write										nextPutAll: ag name capitalized;										nextPut: $: ]								ifFalse: [ write										nextPutAll: ag name;										nextPut: $: ] ] ].			fullName := write contents ].	^ fullName</body><body package="GraphQLBeta-Nodes" selector="key">key"The key on the dictionary of the response"	^ alias ifNil: [ name ] ifNotNil: [ alias ]</body><body package="GraphQLBeta-Nodes" selector="name">name"Return the name"	^ name</body><body package="GraphQLBeta-Nodes" selector="name:">name: anObject"Set the name"	name := anObject</body><body package="GraphQLBeta-Nodes" selector="paramsOn:with:using:ofClass:">paramsOn: resolver with: context using: schema ofClass: className	| params field |	field := (schema getType: className) getField: self name.	params := arguments		collect: [ :arg | 			| resolverArg |			resolverArg := field arguments isEmpty				ifTrue: [ resolver ]				ifFalse: [ arg						resolverArg: resolver						with: field						ofType: (field arguments at: arg name) type						using: schema ].			arg executeOn: resolverArg with: context using: schema ].	^ params</body><body package="GraphQLBeta-Nodes" selector="targetSpreads">targetSpreads	^ self subclassResponsibility</body></methods><methods><class-id>GraphQLBeta.GQLFieldNode</class-id> <category>as yet unclassified</category><body package="GraphQLBeta-Nodes" selector="collectAllArguments">collectAllArguments	| args |	args := OrderedCollection new.	directives isNotNil 	ifTrue: [ 		| argDirectives |		argDirectives := directives collect: [ :dir | dir arguments ].		args addAll: argDirectives first.	].	args addAll: arguments.	^ args</body><body package="GraphQLBeta-Nodes" selector="collectVariables:using:">collectVariables: args using: context	| groupedVariables |	groupedVariables := Set new.	args collect: [ :arg | arg value valueVariables ]	thenDo: [ :dictVariables | 		dictVariables keys do: [ :keyVariable | 			context variables at: keyVariable			ifAbsent: [ context variables at: keyVariable put: (GQLVariableDefinitionNode new name: (dictVariables at: keyVariable))].			groupedVariables add: keyVariable		].	].	^ groupedVariables </body><body package="GraphQLBeta-Nodes" selector="collectVariablesOn:with:">collectVariablesOn: context with: visitedFragments	| args groupedVariables |	groupedVariables := Set new.	args := self collectAllArguments.	groupedVariables := self collectVariables: args using: context.	^ groupedVariables </body></methods><methods><class-id>GraphQLBeta.GQLFieldNode</class-id> <category>testing</category><body package="GraphQLBeta-Nodes" selector="isScalar">isScalar"To verify if a field is scalar"	self shouldBeImplemented</body></methods><methods><class-id>GraphQLBeta.GQLFieldNode</class-id> <category>action</category><body package="GraphQLBeta-Nodes" selector="executeOn:with:using:">executeOn: resolver with: context using: schema	self subclassResponsibility </body></methods><methods><class-id>GraphQLBeta.GQLFieldNode</class-id> <category>utils</category><body package="GraphQLBeta-Nodes" selector="ifField:ifFragment:ifInline:">ifField: aFieldBlock ifFragment: aFragmentBlock ifInline: aInlineBlock	^ aFieldBlock value</body></methods><methods><class-id>GraphQLBeta.GQLScalarFieldNode</class-id> <category>testing</category><body package="GraphQLBeta-Nodes" selector="isScalar">isScalar"Answer true for be a scalar field"	^ true</body></methods><methods><class-id>GraphQLBeta.GQLScalarFieldNode</class-id> <category>action</category><body package="GraphQLBeta-Nodes" selector="executeOn:with:using:">executeOn: resolver with: context using: schema"Given a resolver, an enviroment and the schema, execute the scalar node"	| result params className |	className := resolver isClass		ifTrue: [ #Class ]		ifFalse: [ resolver class name ].	params := self paramsOn: resolver with: context using: schema ofClass: className.	result := resolver		perform: self fullName asSymbol		withArguments: params asArray.	^ result</body></methods><methods><class-id>GraphQLBeta.GQLScalarFieldNode</class-id> <category>accessing</category><body package="GraphQLBeta-Nodes" selector="targetSpreads">targetSpreads"Return empty beacuse cant have fragment spreads"	^ #()</body></methods><methods><class-id>GraphQLBeta.GQLEnumNode</class-id> <category>action</category><body package="GraphQLBeta-Nodes" selector="executeOn:with:using:">executeOn: aGQLEnumNode with: aGQLContext using: aGQLSSchemaNode 	^ value</body></methods><methods><class-id>GraphQLBeta.GQLEnumNode</class-id> <category>accessing</category><body package="GraphQLBeta-Nodes" selector="name:using:">name: aName using: schema	^ self class name</body></methods><methods><class-id>GraphQLBeta.GQLNodeVisitor</class-id> <category>initialize</category><body package="GraphQLBeta-Visitors" selector="initialize">initialize"Initialize the stack "	schemaContextStack := Stack new</body><body package="GraphQLBeta-Visitors" selector="schema:">schema: aSchema"Set the schema"	schema := aSchema</body></methods><methods><class-id>GraphQLBeta.GQLNodeVisitor</class-id> <category>visiting</category><body package="GraphQLBeta-Visitors" selector="visitArgumentNode:">visitArgumentNode: aGQLArgumentNode"Given a argument node validate if is correct to the respective type then continue the validation"	| param |	param := schemaContextStack top		getArgument: aGQLArgumentNode argumentName.	param ifNil: [ ^ self ].	schemaContextStack push: param inputType.	aGQLArgumentNode inputValue		acceptVisitor: self.	schemaContextStack pop</body><body package="GraphQLBeta-Visitors" selector="visitDocumentNode:">visitDocumentNode: documentNode"Given a document node validate if the selection set is correct"	"query only, TODO: mutation"	schemaContextStack push: schema query.	documentNode selectionSet		acceptVisitor: self</body><body package="GraphQLBeta-Visitors" selector="visitInputValueNode:">visitInputValueNode: aGQLInputValueNode</body><body package="GraphQLBeta-Visitors" selector="visitObjectNode:">visitObjectNode: objectNode	"Given a object node see if is correct then continue the validation"	| field |	field := schemaContextStack top		getField: objectNode fieldName.	field ifNil: [ ^ self ].	"visit arguments"	schemaContextStack push: field.	objectNode arguments		do: [ :a | a acceptVisitor: self ].	schemaContextStack pop.	"visit inner types"	field type class = GQLListNode 		ifTrue: [ "visit List's inner type if"			schemaContextStack				push: field type wrappedType ]		ifFalse: [ schemaContextStack push: field type ].	objectNode selectionSet		acceptVisitor: self.	schemaContextStack pop</body><body package="GraphQLBeta-Visitors" selector="visitScalarNode:">visitScalarNode: scalarNode	"Given a scalar node see if is correct and then continue the validation"	| field |	field := schemaContextStack top		getField: scalarNode fieldName.	field ifNil: [ ^ self ].	"visit arguments"	schemaContextStack push: field.	scalarNode arguments		do: [ :a | a acceptVisitor: self ].	schemaContextStack pop</body><body package="GraphQLBeta-Visitors" selector="visitSelectionSetNode:">visitSelectionSetNode: selectionSetNode	"Given a selection set node validate each field node"	^ selectionSetNode fields		collect:			[ :fieldNode | fieldNode acceptVisitor: self ]</body></methods><methods><class-id>GraphQLBeta.Person</class-id> <category>accessing</category><body package="GraphQLBeta-Demo" selector="age">age	^ age</body><body package="GraphQLBeta-Demo" selector="age:">age: anObject	age := anObject</body><body package="GraphQLBeta-Demo" selector="name">name	^ name</body><body package="GraphQLBeta-Demo" selector="name:">name: anObject	name := anObject</body></methods><methods><class-id>GraphQLBeta.Person class</class-id> <category>instance creation</category><body package="GraphQLBeta-Demo" selector="name:age:">name: aName age: aAge	| inst |	inst := self new.	inst name: aName;		age: aAge.	^ inst</body></methods><methods><class-id>GraphQLBeta.GQLSIDTypeNode</class-id> <category>initialization</category><body package="GraphQLBeta-NodesSchema" selector="initialize">initialize	super initialize.	name := 'ID'</body></methods><methods><class-id>GraphQLBeta.GQLSchemaGrammarEvaluator</class-id> <category>accessing</category><body package="GraphQLBeta-Parser" selector="booleanType">booleanType	"Return a GQLSBooleanType instance"	^ super booleanType		performs: [ :tokens | 			| node |			node := GQLSBooleanTypeNode new.			node ]</body><body package="GraphQLBeta-Parser" selector="enumType">enumType	"Return a GQLSEnumTypeNode instance with the enumTypeName, the values and the position on the text schema"	^ super enumType		performs: [ :tokens | 			| node |			node := GQLSEnumTypeNode new.			node name: (tokens at: 2) inputValue.			node addValues: (tokens at: 3).			node position: (tokens at: 2) start ]</body><body package="GraphQLBeta-Parser" selector="enumValueList">enumValueList	"Return an array"	^ super enumValueList		performs: [ :tokens | 			(tokens at: 2) collect: #inputValue ]</body><body package="GraphQLBeta-Parser" selector="field">field	"Return a GQLSFieldNode instance with the name, arguments, type and position on the text schema"	^ super field		performs: [ :tokens | 			| node |			node := GQLSFieldNode new.			node name: (tokens at: 1) inputValue.			node addArguments: (tokens at: 2).			node type: (tokens at: 4).			node position: (tokens at: 1) start.			node fullName.			node ]</body><body package="GraphQLBeta-Parser" selector="fieldInputObject">fieldInputObject	"Return a GQLSFieldInputObjectFieldNode instance with the name, arguments, type and position on the text schema"	^ super field		performs: [ :tokens | 			| node |			node := GQLSInputObjectFieldNode new.			node name: (tokens at: 1) inputValue.			node addArguments: (tokens at: 2).			node type: (tokens at: 4).			node position: (tokens at: 1) start.			node fullName.			node ]</body><body package="GraphQLBeta-Parser" selector="fieldInputObjectSet">fieldInputObjectSet"Return the fields"	^ super fieldInputObjectSet		performs: [ :tokens | tokens at: 2 ]</body><body package="GraphQLBeta-Parser" selector="fieldSet">fieldSet"Return the fields"	^ super fieldSet		performs: [ :tokens | tokens at: 2 ]</body><body package="GraphQLBeta-Parser" selector="floatType">floatType	"Return a GQLSFloatType instance"	^ super floatType		performs: [ :tokens | 			| node |			node := GQLSFloatTypeNode new.			node ]</body><body package="GraphQLBeta-Parser" selector="idType">idType	"Return a GQLSIDType instance"	^ super idType		performs: [ :tokens | 			| node |			node := GQLSIDTypeNode new.			node ]</body><body package="GraphQLBeta-Parser" selector="inputObjectType">inputObjectType	"Return a GQLSInputObjectTypeNode instance with the input object name, the fields and the position on the text schema"	^ super inputObjectType		performs: [ :tokens | 			| node |			node := GQLSInputObjectTypeNode new.			node name: (tokens at: 2) inputValue.			node addFields: (tokens at: 3).			node position: (tokens at: 2) start ]</body><body package="GraphQLBeta-Parser" selector="inputType">inputType"Return the tokens"	^ super inputType performs: [ :tokens | tokens ]</body><body package="GraphQLBeta-Parser" selector="interfaceList">interfaceList	"Return an array"	^ super interfaceList		performs: [ :tokens | 			(tokens at: 2) reject: #isCharacter thenCollect: #inputValue ]</body><body package="GraphQLBeta-Parser" selector="interfaceType">interfaceType	"Return a GQLSInterfaceTypeNode instance with the enumTypeName, the values and the position on the text schema"	^ super interfaceType		performs: [ :tokens | 			| node |			node := GQLSInterfaceTypeNode new.			node name: (tokens at: 2) inputValue.			node addFields: (tokens at: 3).			node position: (tokens at: 2) start ]</body><body package="GraphQLBeta-Parser" selector="intType">intType	"Return a GQLSIntType instance"	^ super intType		performs: [ :tokens | 			| node |			node := GQLSIntTypeNode new.			node position: tokens start.			node ]</body><body package="GraphQLBeta-Parser" selector="listInputType">listInputType	"Return a GQLSListTypeNode instance with the innerInputType and if is null"	^ super listInputType		performs: [ :tokens | 			| node |			node := GQLSListTypeNode new.			node wrappedType: (tokens at: 2).			node position: (tokens at: 2) position.			node ]</body><body package="GraphQLBeta-Parser" selector="listType">listType	"Return a GQLSListTypeNode instance with the innerTypeNode"	^ super listType		performs: [ :tokens | 			| node |			node := GQLSListTypeNode new.			node wrappedType: (tokens at: 2).			node position: (tokens at: 2) position.			node ]</body><body package="GraphQLBeta-Parser" selector="namedType">namedType	"Return a GQLSNamedTypeNode instance with the wrapped type"	^ super namedType		performs: [ :tokens | 			| node |			node := GQLSNamedTypeNode new.			node name: tokens inputValue.			node position: tokens start.			node ]</body><body package="GraphQLBeta-Parser" selector="nonNullInputType">nonNullInputType	"Return a GQLSNonNullInputTypeNode instance with the wrapped type"	^ super nonNullInputType		performs: [ :tokens | 			| node |			node := GQLSNonNullTypeNode new.			node wrappedType: (tokens at: 1).			node position: (tokens at: 1) position.			node ]</body><body package="GraphQLBeta-Parser" selector="nonNullType">nonNullType	"Return a GQLSNonNullTypeNode instance with the wrapped type"	^ super nonNullType		performs: [ :tokens | 			| node |			node := GQLSNonNullTypeNode new.			node wrappedType: (tokens at: 1).			node position: (tokens at: 1) position.			node ]</body><body package="GraphQLBeta-Parser" selector="objectType">objectType	"Return a GQLSObjectTypeNode instance with the objectTypeName, the fields and the position on the text schema"	^ super objectType		performs: [ :tokens | 			| node |			node := GQLSObjectTypeNode new.			node name: (tokens at: 2) inputValue.			node addFields: (tokens at: 4).			node implements: (tokens at: 3).			node position: (tokens at: 2) start ]</body><body package="GraphQLBeta-Parser" selector="parameter">parameter	"Return a GQLSParameterNode instance with the parameterName, inputType and the position on the text schema"	^ super parameter		performs: [ :tokens | 			| node |			node := GQLSArgumentFieldNode new.			node name: (tokens at: 1) inputValue.			node type: (tokens at: 3).			node position: (tokens at: 1) start.			node ]</body><body package="GraphQLBeta-Parser" selector="parameters">parameters"Return the list of parameter"	^ super parameters		performs: [ :tokens | tokens at: 2 ]</body><body package="GraphQLBeta-Parser" selector="schema">schema	"Return a GQLSchemaNode instance with the types defined on the text schema"	^ super schema		performs: [ :types | 			| node |			node := GQLSSchemaNode new.			node addTypes: types ]</body><body package="GraphQLBeta-Parser" selector="start">start	"Return a parser accepting schema and then the input ends"	^ schema end</body><body package="GraphQLBeta-Parser" selector="stringType">stringType	"Return a GQLSStringType instance"	^ super stringType		performs: [ :tokens | 			| node |			node := GQLSStringTypeNode new.			node ]</body><body package="GraphQLBeta-Parser" selector="unionType">unionType	"Return a GQLSUnionTypeNode instance with the union name, the values and the position on the text schema"	^ super unionType		performs: [ :tokens | 			| node |			node := GQLSUnionTypeNode new.			node name: (tokens at: 2) inputValue.			node addTypes: (tokens at: 4).			node position: (tokens at: 2) start ]</body><body package="GraphQLBeta-Parser" selector="unionValuesList">unionValuesList	"Return an array"	^ super unionValuesList		performs: [ :tokens |			tokens reject: #isCharacter thenCollect: #inputValue. ]</body></methods><methods><class-id>GraphQLBeta.GQLTypeValidator</class-id> <category>visiting</category><body package="GraphQLBeta-Visitors" selector="visitArgumentNode:">visitArgumentNode: aGQLArgumentNode	"Given an argument node see if the argument belongs to the corresponding top of the stack, if not raise a GQLEvaluationException"	| param |	param := schemaContextStack top getArgument: aGQLArgumentNode argumentName.	param		ifNil: [ GQLEvaluationException new				node: aGQLArgumentNode;				messageArgumentText: schemaContextStack top;				raise ].	super visitArgumentNode: aGQLArgumentNode</body><body package="GraphQLBeta-Visitors" selector="visitInputValueNode:">visitInputValueNode: aGQLInputValueNode	"Given a input value node see if corresponds to the type of the stack if not raise a exception"	| schemaType |	schemaType := schemaContextStack top.	(schemaType		isAValidType: aGQLInputValueNode)		ifFalse: [ GQLEvaluationException new				node: aGQLInputValueNode;				messageInputText;				raise ]</body><body package="GraphQLBeta-Visitors" selector="visitObjectNode:">visitObjectNode: objectNode	"Given a object node validate if exist at the schema if not raise a exception"	| field |	field := schemaContextStack top		getField: objectNode fieldName.	field		ifNil: [ GQLEvaluationException new				node: objectNode;				messageObjectText;				raise ].	super visitObjectNode: objectNode</body><body package="GraphQLBeta-Visitors" selector="visitScalarNode:">visitScalarNode: scalarNode"Given a scalar node see if this exist at the schema if not raise a exception"	| field |	field := schemaContextStack top		getField: scalarNode fieldName.	field isNil		ifTrue: [ GQLEvaluationException new				node: scalarNode;				messageScalarText;				raise ].	super visitScalarNode: scalarNode</body></methods><methods><class-id>GraphQLBeta.GQLTypeValidator</class-id> <category>validation</category><body package="GraphQLBeta-Visitors" selector="validate:withSchema:">validate: document withSchema: aGQLschema	"Given a document(request) and the schema start to validate at the document"	| res |	schema := aGQLschema.	[ document acceptVisitor: self.	res := document ]		on: GQLException		do: [ :e | res := e ].	^ res</body></methods><methods><class-id>GraphQLBeta.GraphQLBetaDemoSite</class-id> <category>server</category><body package="GraphQLBeta-Demo" selector="answerTo:">answerTo: aRequest	| ans query operation variables |	query :=''.	operation := ''.	variables := ''.	ans := ''.	(aRequest urlString beginsWith: '/?query') ifTrue: [ 		query := self request: aRequest at: 'query'.		operation := self request: aRequest at: 'operation'.		variables := self request: aRequest at: 'variables'.		[ ans := GraphQLPlatform current 			toJson: (graphql handleRequest: query using: operation with: variables).		] on: Error do: [ :ex | ans := self printError: ex  ].	].	^ self buildResponseWith: ans from: query using: operation with: variables.</body><body package="GraphQLBeta-Demo" selector="buildResponseWith:from:using:with:">buildResponseWith: result from: query using: operation with: variables	| strings stream input |		strings := GraphQLBetaDemoHTML htmlPage splitOn: '####VAR####'.	stream := String new writeStream.	input := Array with: query with: operation with: variables with: result.	self validInput: input.	strings doWithIndex: [ :str :index |		stream nextPutAll: str.		index &lt;= input size ifTrue: [ 			stream nextPutAll: (input at: index) ].		 ].		^ GraphQLPlatform current okResponse: stream contents.</body><body package="GraphQLBeta-Demo" selector="configure">configure	graphql := GraphQL new.	graphql createSchema: Query schema.</body><body package="GraphQLBeta-Demo" selector="printError:">printError: ex	| s |	s := String new writeStream.	[s 		nextPutAll: ex description; cr;		nextPutAll: (String streamContents: [:stream | 			ex signalerContext ifNotNil: [ :context |				context debugStackOn: stream ] ] ) ] ensure: [ s close ].	^ s contents</body><body package="GraphQLBeta-Demo" selector="request:at:">request: aRequest at: nameQuery	^ GraphQLPlatform current request: aRequest at: nameQuery.</body><body package="GraphQLBeta-Demo" selector="validInput:">validInput: input	input doWithIndex: [ :str :index | | s lines |		s := String new writeStream.		lines := str lines.		lines doWithIndex: [ :line :i |			s nextPutAll: (line copyReplaceAll: '"' with: '\"').			i = lines size ifFalse: [ s nextPutAll: '\n'].			 ].		input at: index put: s contents.		 ].</body></methods><methods><class-id>GraphQLBeta.GQLSingleAnonimousQueryEvaluator</class-id> <category>accessing</category><body package="GraphQLBeta-Parser" selector="alias">alias"Return the alias"	^ super alias performs: [ :tokens | (tokens at: 1) inputValue ]</body><body package="GraphQLBeta-Parser" selector="argument">argument	"Return an instance of GQLArgumentNode with  information about the query"	^ super argument		performs: [ :tokens | 			| node |			node := GQLArgumentNode new.			node name: (tokens at: 1) inputValue.			node value: (tokens at: 3).			node position: (tokens at: 1) start.			node ]</body><body package="GraphQLBeta-Parser" selector="arguments">arguments	"Return the arguments parsed"	^ super arguments		performs: [ :tokens | tokens at: 2 ]</body><body package="GraphQLBeta-Parser" selector="booleanType">booleanType	"Return a GQLSBooleanType instance"	^ super booleanType		performs: [ :tokens | 			| node |			node := GQLSBooleanTypeNode new.			node ]</body><body package="GraphQLBeta-Parser" selector="booleanValue">booleanValue"Return GQLBooleanNode instances with the information of the query"	^ super booleanValue		performs: [ :tokens | 			| node |			node := GQLBooleanNode new.			node value: tokens inputValue.			node position: tokens start. ]</body><body package="GraphQLBeta-Parser" selector="defaultValue">defaultValue"Return the default value"	^ super defaultValue		performs: [ :tokens | (tokens at: 2) ]</body><body package="GraphQLBeta-Parser" selector="directive">directive"Return the directive"	^ super directive performs: [ :tokens | 		| node |		node := GQLDirectiveNode new: (tokens at: 2) inputValue.		node name: (tokens at: 2) inputValue.		node arguments: (tokens at: 3).		node position: (tokens at: 2) start.		]</body><body package="GraphQLBeta-Parser" selector="document">document	"Return a instance of GQLDocumentNode with the information of the parser"	^ super document		performs: [ :tokens | 			| node |			node := GQLDocumentNode new.			node definitions: tokens ]</body><body package="GraphQLBeta-Parser" selector="enumValue">enumValue	"Return GQLEnumNode instance with the information of the request parsed"	^ super enumValue		performs: [ :tokens | 			| node |			node := GQLEnumNode new.			node				value: tokens inputValue.			node position: tokens start. ]</body><body package="GraphQLBeta-Parser" selector="floatType">floatType	"Return a GQLSFloatTypeNode instance"	^ super floatType		performs: [ :tokens | 			| node |			node := GQLSFloatTypeNode new.			node ]</body><body package="GraphQLBeta-Parser" selector="floatValue">floatValue	"Return GQLFloatNode instance of input type float with the information of the request parsed"	^ super floatValue		performs: [ :tokens | 			| node |			node := GQLFloatNode new.			node value: tokens inputValue.			node position: tokens start. ]</body><body package="GraphQLBeta-Parser" selector="fragmentDefinition">fragmentDefinition	"Return a instance of GQLFragmentNode with the information of the request"	^ super fragmentDefinition		performs: [ :tokens | 			| node |			node := GQLFragmentNode new.			node name: (tokens at: 3).			node typeCondition: (tokens at: 4).			node directives: (tokens at: 5).			node selectionSet: (tokens at: 6).			node]</body><body package="GraphQLBeta-Parser" selector="fragmentName">fragmentName"Return the fragmentName"	^ super fragmentName		performs: [ :tokens | (tokens at: 2) inputValue ]</body><body package="GraphQLBeta-Parser" selector="fragmentSpread">fragmentSpread	"Return a instance of GQLFragmentSpreadNode with the information of the request"	^ super fragmentSpread		performs: [ :tokens | 			| node |			node := GQLFragmentSpreadNode new.			node name: (tokens at: 2).			node directives: (tokens at: 3).			node]</body><body package="GraphQLBeta-Parser" selector="idType">idType	"Return a GQLSIDType instance"	^ super idType		performs: [ :tokens | 			| node |			node := GQLSIDTypeNode new.			node ]</body><body package="GraphQLBeta-Parser" selector="inlineFragment">inlineFragment	"Return a instance of GQLInlineFragmentNode with the information of the request"	^ super inlineFragment		performs: [ :tokens | 			| node |			node := GQLInlineFragmentNode new.			node typeCondition: (tokens at: 2).			node directives: (tokens at: 3).			node selectionSet: (tokens at: 4)]</body><body package="GraphQLBeta-Parser" selector="intType">intType	"Return a GQLSIntTypeNode instance"	^ super intType		performs: [ :tokens | 			| node |			node := GQLSIntTypeNode new.			node position: tokens start.			node ]</body><body package="GraphQLBeta-Parser" selector="intValue">intValue"Return GQLIntNode instance of input type Int with the information of the request parsed"	^ super intValue		performs: [ :tokens | 			| node |			node := GQLIntNode new.			node value: tokens inputValue.			node position: tokens start. ]</body><body package="GraphQLBeta-Parser" selector="listValue">listValue"Return GQLListNode instance of input type List with the information of the request parsed"	^ super listValue		performs: [ :tokens | 			| node |			node := GQLListNode new.			node value: (tokens at: 2).			node ]</body><body package="GraphQLBeta-Parser" selector="named">named	"Return a GQLSNamedTypeNode instance with his name and the position on the request"	^ super named		performs: [ :tokens | 			| node |			node := GQLSNamedTypeNode new.			node name: tokens inputValue.			node position: tokens start.			node ]</body><body package="GraphQLBeta-Parser" selector="nonScalarField">nonScalarField"Return a GQLNonScalarNode instance with the information of the request parsed"	^ super nonScalarField		performs: [ :tokens | 			| node |			node := GQLNonScalarFieldNode new.			node alias: (tokens at: 1).			node name: (tokens at: 2) inputValue.			node arguments: (tokens at: 3).			node directives: (tokens at: 4).			node selectionSet: (tokens at: 5).			node position: (tokens at: 2) start.			node ]</body><body package="GraphQLBeta-Parser" selector="nullValue">nullValue"Return GQLNullNode instance of input type null with the information of the request parsed"	^ super nullValue		performs: [ :tokens | 			| node |			node := GQLNullNode new.			node value: tokens inputValue.			node position: tokens start.]</body><body package="GraphQLBeta-Parser" selector="objectField">objectField	"Return GQLObjectFieldNode instance with the information of the request parsed"	^ super objectField		performs: [ :tokens | 			| node |			node := GQLObjectFieldNode new.			node name: (tokens at: 1) inputValue.			node position: (tokens at: 1) start.			node value: (tokens at: 3) ]</body><body package="GraphQLBeta-Parser" selector="objectValue">objectValue	"Return GQLObjectNode instance of input type Object with the information of the request parsed"	^ super objectValue		performs: [ :tokens | 			| node |			node := GQLObjectNode new.			node objectFields: (tokens at: 2).			node ]</body><body package="GraphQLBeta-Parser" selector="operation">operation	"Return a instance of GQLOperationNode"	^ super operation		performs: [ :tokens | 			| node |			node := GQLOperationNode new.			node type: (tokens at: 1).			node name: (tokens at: 3).			node variableDefinitions: (tokens at: 4).			node directives: (tokens at: 5).			node selectionSet: (tokens at: 6)]</body><body package="GraphQLBeta-Parser" selector="scalarField">scalarField"Return a GQLScalarFieldNode instance with the information of the request parsed"	^ super scalarField		performs: [ :tokens | 			| node |			node := GQLScalarFieldNode new.			node alias: (tokens at: 1).			node name: (tokens at: 2) inputValue.			node arguments: (tokens at: 3).			node directives: (tokens at: 4).			node position: (tokens at: 2) start.			node ]</body><body package="GraphQLBeta-Parser" selector="selection">selection"Return the tokens parsed"	^ super selection performs: [ :tokens | tokens ]</body><body package="GraphQLBeta-Parser" selector="selectionSet">selectionSet"Return a instance of GQLSelectionSetNode with the information of the parser"	^ super selectionSet		performs: [ :tokens | 			| node val |			val := tokens at: 2.			node := GQLSelectionSetNode new.			node selections: val ]</body><body package="GraphQLBeta-Parser" selector="stringType">stringType	"Return a GQLSStringType instance"	^ super stringType		performs: [ :tokens | 			| node |			node := GQLSStringTypeNode new.			node ]</body><body package="GraphQLBeta-Parser" selector="stringValue">stringValue"Return GQLStringNode instance of input type String with the information of the request parsed"	^ super stringValue		performs: [ :tokens | 			| node |			node := GQLStringNode new.			node value: tokens inputValue.			node position: tokens start. ]</body><body package="GraphQLBeta-Parser" selector="typeCondition">typeCondition"Return the type condition"	^ super typeCondition		performs: [ :tokens | (tokens at: 3) ]</body><body package="GraphQLBeta-Parser" selector="variableDefinitions">variableDefinitions"Return the variable definitions"	^ super variableDefinitions		performs: [ :tokens | tokens at: 2 ]</body></methods><methods><class-id>GraphQLBeta.GQLSingleAnonimousQueryEvaluator</class-id> <category>grammar</category><body package="GraphQLBeta-Parser" selector="nonNullType">nonNullType"Return the non null type"	^ super nonNullType		performs: [ :tokens | 			| node |			node := GQLSNonNullTypeNode new.			node wrappedType: (tokens at: 1).			node position: (tokens at: 1) position.			node ]</body><body package="GraphQLBeta-Parser" selector="variable">variable"Return GQLVariableNode instance of input type variable with the information of the request parsed"	^ super variable		performs: [ :tokens | 			| node |			node := GQLVariableNode new.			node value: (tokens inputValue copyWithout: $$).			"node name: #Variable "]</body><body package="GraphQLBeta-Parser" selector="variableDefinition">variableDefinition"Return a GQLVariableDefinitionNode instance with the name, type and the default value of the variable"	^ super variableDefinition		performs: [ :tokens |			| node |			node := GQLVariableDefinitionNode new.			node name: (tokens at: 1) value.			node type: (tokens at: 3).			node defaultValue: (tokens at: 4).			node ]</body></methods><methods><class-id>GraphQLBeta.Film</class-id> <category>accessing</category><body package="GraphQLBeta-Demo" selector="director">director	^ director</body><body package="GraphQLBeta-Demo" selector="director:">director: aPerson	director := aPerson</body><body package="GraphQLBeta-Demo" selector="gender">gender	^ gender</body><body package="GraphQLBeta-Demo" selector="gender:">gender: aGender	gender := aGender</body><body package="GraphQLBeta-Demo" selector="name">name	^ name</body><body package="GraphQLBeta-Demo" selector="name:">name: aString	name := aString</body><body package="GraphQLBeta-Demo" selector="rating">rating	^ rating</body><body package="GraphQLBeta-Demo" selector="rating:">rating: aInt	rating := aInt</body></methods><methods><class-id>GraphQLBeta.Film class</class-id> <category>instance creation</category><body package="GraphQLBeta-Demo" selector="name:rating:director:gender:">name: aName rating: aRating director: aDirector gender: aGender	| inst |	inst := self new.	inst name: aName;		rating: aRating;		director: aDirector;		gender: aGender.	^ inst</body></methods><methods><class-id>GraphQLBeta.GQLFloatNode</class-id> <category>action</category><body package="GraphQLBeta-Nodes" selector="executeOn:with:using:">executeOn: resolver with: context using: schema"Execute the input value according to the resolver, the enviroment and the schema"	^ value asNumber</body></methods><methods><class-id>GraphQLBeta.GQLNonScalarFieldNode</class-id> <category>accessing</category><body package="GraphQLBeta-Nodes" selector="selectionSet">selectionSet"Return the selection set"	^ selectionSet</body><body package="GraphQLBeta-Nodes" selector="selectionSet:">selectionSet: anObject"Set the selection set"	selectionSet := anObject</body><body package="GraphQLBeta-Nodes" selector="targetSpreads">targetSpreads"Return the fragments spreads used on the selectionSet"	^ selectionSet targetSpreads</body></methods><methods><class-id>GraphQLBeta.GQLNonScalarFieldNode</class-id> <category>testing</category><body package="GraphQLBeta-Nodes" selector="isScalar">isScalar"Answer false because is not scalar"	^ false</body></methods><methods><class-id>GraphQLBeta.GQLNonScalarFieldNode</class-id> <category>action</category><body package="GraphQLBeta-Nodes" selector="executeOn:with:using:">executeOn: resolver with: context using: schema"Given a resolver, an contextiroment and the schema, execute the request"	| objectValue type result params className |	className := resolver isClass		ifTrue: [ #Class ]		ifFalse: [ resolver class name ].	params := self paramsOn: resolver with: context using: schema ofClass: className.	objectValue := resolver		perform: self fullName asSymbol		withArguments: params asArray.	type := (schema getType: className)		getFieldType: self name.	type class = GQLSListTypeNode		ifTrue: [ result := OrderedCollection new.			objectValue				do: [ :el | 					result add: (self selectionSet executeOn: el with: context using: schema) ] ]		ifFalse: [ result := self selectionSet executeOn: objectValue with: context using: schema ].	^ result</body></methods><methods><class-id>GraphQLBeta.GQLNonScalarFieldNode</class-id> <category>utils</category><body package="GraphQLBeta-Nodes" selector="collectVariablesOn:with:">collectVariablesOn: context with: visitedFragments	| groupVariables args |	groupVariables := Set new.	args := self collectAllArguments.	groupVariables addAll: (self collectVariables: args using: context).	groupVariables addAll: (self collectVarSelectionSet: selectionSet using: context with: visitedFragments).	^ groupVariables.</body></methods><methods><class-id>GraphQLBeta.GQLDocumentNode</class-id> <category>action</category><body package="GraphQLBeta-Nodes" selector="executeOn:with:using:">executeOn: root with: context using: schema"Given a root, a context and the schema, execute this document"	context operationName isNil 	ifTrue: [ ^ self executeShorthandOn: root with: context using: schema ]	ifFalse: [ | validVariables | 		validVariables := self validVariablesDocument: context.		(validVariables isMemberOf: GQLException) 		ifTrue: [ ^ validVariables ]		ifFalse: [  ^ self executeOperationOn: root with: context using: schema ]	]</body><body package="GraphQLBeta-Nodes" selector="executeOperationOn:with:using:">executeOperationOn: root with: context using: schema"Execute the operation of name defined on the context, if there isnt an operation with the name raise an exception"	operations detect: [ :op | op name = context operationName ] 		ifFound: [ :op | ^ op executeOn: root with: context using: schema ] 		ifNone: [ ^ GQLException new messageText: 'Operation with name ', 						context operationName, ' not defined'; 											raise ] </body><body package="GraphQLBeta-Nodes" selector="executeShorthandOn:with:using:">executeShorthandOn: root with: context using: schema"Execute the shorthand operation only if is the only one, if not raise an exception that must be require operationName"	operations size = 1 		ifTrue: [ ^ operations first executeOn: root with: context using: schema ]		ifFalse: [ ^ GQLException new messageText: 'Query error, require operationName'; 											raise ]</body><body package="GraphQLBeta-Nodes" selector="validVariablesDocument:">validVariablesDocument: context	| variables |	variables := self variablesOn: context.	(variables isMemberOf: GQLException) 	ifTrue: [ ^ variables ]	ifFalse: [ context variables: variables.		context variables values 			detect: [ :var | var type isNil or: 				[(var type class = GQLSNonNullTypeNode) and: [ var defaultValue isNotNil ] ] ]			ifFound: [ ^ GQLException new node: self; 					messageText: 'All variables must be defined on operations'; raise] 		].</body><body package="GraphQLBeta-Nodes" selector="variablesOn:">variablesOn: context	| collectedVariables |	collectedVariables := OrderedCollection new.	operations do: [ :op | 		| varDefinitions colVar |		colVar := op collectVariables: context.		(colVar isMemberOf: GQLException) 		ifTrue: [ ^ colVar ]		ifFalse: [ 			varDefinitions := op validVariables.			colVar asSet = (varDefinitions  collect: [ :var | var name value ]) asSet			ifTrue: [ collectedVariables addAll: varDefinitions ]			ifFalse: [ ^ GQLException new node: self; 					messageText: 'Error with variables'; raise ]		]	].	^ collectedVariables</body></methods><methods><class-id>GraphQLBeta.GQLDocumentNode</class-id> <category>public access</category><body package="GraphQLBeta-Nodes" selector="evaluate">evaluate"Validate the fragments"	| fragmentsNames spreads |	fragmentsNames := fragments collect: #name.	spreads := self spreads.		fragmentsNames size = fragmentsNames asSet size 		ifFalse: [ ^ GQLException new messageText: 'Duplicated name fragment'; 											raise ].														fragments detect: [ :fragment | self hasCycle: fragment with: Set new ]				ifFound: [ :fragment | ^ GQLException new node: fragment;											messageText: 'Cycles on fragment'; raise ].					fragments size = spreads size ifFalse: [ ^ GQLException new											messageText: 'Unused fragments'; raise ].											spreads detect: [ :spread | (fragmentsNames includes: spread name) not ]		ifFound: [ :spread | ^ GQLException new node: spread; 													messageText: 'Undefined fragment'; raise ]</body><body package="GraphQLBeta-Nodes" selector="getFragment:">getFragment: aName"Return the fragment with aName"	fragments detect: [ :fragment | fragment name = aName ]				ifFound: [ :fragment | ^ fragment ].</body><body package="GraphQLBeta-Nodes" selector="hasCycle:with:">hasCycle: aFragment with: visited"Return if aFragment has a cycle on their definition"	| spreads hasCycle index |	spreads := aFragment targetSpreads asArray.	hasCycle := false.	index := 1.	[ hasCycle not and: [ index &lt;= spreads size ] ] 		whileTrue: [ | spread |			spread := spreads at: index. 			(visited includes: spread) 			ifTrue: [ hasCycle := true ]			ifFalse: [ index := index + 1.						visited add: spread.						  hasCycle := self hasCycle: (self getFragment: spread name) with: visited ]	].	^ hasCycle</body></methods><methods><class-id>GraphQLBeta.GQLDocumentNode</class-id> <category>initialization</category><body package="GraphQLBeta-Nodes" selector="initialize">initialize	super initialize.	fragments := OrderedCollection new.	operations := OrderedCollection new.</body></methods><methods><class-id>GraphQLBeta.GQLDocumentNode</class-id> <category>accessing</category><body package="GraphQLBeta-Nodes" selector="definitions:">definitions: aList"Set operations or fragments"		operations := aList select: [ :def | def isOperation ].	fragments := aList reject: [ :def | def isOperation ].</body><body package="GraphQLBeta-Nodes" selector="fragments">fragments"Return the fragments"		^ fragments</body><body package="GraphQLBeta-Nodes" selector="fragments:">fragments: aArray"Set the fragments"	fragments := aArray</body><body package="GraphQLBeta-Nodes" selector="operations">operations"Return the operations"		^ operations</body><body package="GraphQLBeta-Nodes" selector="operations:">operations: aArray"Set the operations"	operations := aArray</body><body package="GraphQLBeta-Nodes" selector="spreads">spreads"Return all the fragment spreads on the operations and the fragments"	| spreads |	spreads := Set new.	operations do: [ :operation | 		spreads addAll: (operation targetSpreads) ].	fragments do: [ :fragment | 		spreads addAll: (fragment targetSpreads) ].	^ spreads</body></methods><methods><class-id>Core.Metaclass</class-id> <category>*GraphQLBeta</category><body package="GraphQLBeta" selector="visualworksName">visualworksName	^ self baseClass visualworksName , ' class'.</body></methods><methods><class-id>PetitParser.PPParser</class-id> <category>*GraphQLBeta</category><body package="GraphQLBeta" selector="performs:">performs: aBlock	^ PPActionParser on: self block: aBlock</body></methods><methods><class-id>Core.Dictionary</class-id> <category>*GraphQLBeta</category><body package="GraphQLBeta" selector="qlcollect:">qlcollect: aBlock	^ self collect: aBlock</body></methods><methods><class-id>SUnit.TestResource class</class-id> <category>*GraphQLBeta</category><body package="GraphQLBeta" selector="visualworksName">visualworksName	^ self == TestResource ifTrue: ['Smalltalk.SUnit.TestResource'] ifFalse: [self name]</body></methods><methods><class-id>GraphQLBeta.GraphQLBenchmark class</class-id> <category>benchmarking</category><body package="GraphQLBeta-Test-Benchmark" selector="benchmark01">benchmark01	&lt;script: 'self benchmark01'&gt;	"This benchmark print resutl for the excel document	 Variable or expression expected -&gt;https://goo.gl/kSdX2S"	Transcript 		show: Smalltalk version; cr;		show: (Smalltalk vm wordSize = 4 ifTrue: [ 32 ] ifFalse: [ 64 ] ); show: ' bits'.			#('{queryPoints}'		'{queryPoints { x y } }' 		'{queryPoints { x } }'		'{queryPoints { y } }' ) do: [ :query |		"Transcript cr; cr; show: 'Query: '; show: query."		#(5000000 4000000 200000 100000) do: [ :s | 			"Transcript cr; show: 'Points size: '; show: s."			self benchmarkTimePoints: s query: query ]		 displayingProgress: [:s | 'Processing bench01 for: ', s asString, ' points '].	] displayingProgress: [ :q | 'Processing for: ', q].</body><body package="GraphQLBeta-Test-Benchmark" selector="benchmark02">benchmark02	&lt;script: 'self benchmark02'&gt;	Transcript 		show: Smalltalk version; cr;		show: (Smalltalk vm wordSize = 4 ifTrue: [ 32 ] ifFalse: [ 64 ] ); show: ' bits'.	#('{queryRectangles}'	 	'{queryRectangles { origin corner } }' 	 	'{queryRectangles { origin } }'	 	'{queryRectangles { corner } }'	 	'{queryRectangles { origin { x y } } } ' ) do: [ :query |		"Transcript cr; show: 'Query: '; show: query."				#(1000000 800000 600000) do: [ :s | 			"Transcript cr; cr; show: 'Rectangles size: ', s asString."			self benchmarkTimeRectangles: s query: query ]		 displayingProgress: [:s | 'Processing bench02 for: ', s asString, ' rectangles'].	] displayingProgress: [ :q | 'Processing for: ', q ].</body></methods><methods><class-id>GraphQLBeta.GraphQLBenchmark class</class-id> <category>initialization</category><body package="GraphQLBeta-Test-Benchmark" selector="cleanMemory">cleanMemory	&lt;script: 'self cleanMemory'&gt;	3 timesRepeat:[ Smalltalk garbageCollect].	Object new; new; new.	3 timesRepeat: [Smalltalk garbageCollect].</body><body package="GraphQLBeta-Test-Benchmark" selector="initializePoints:">initializePoints: size	&lt;script: 'self initializePoints: 10'&gt;	objects := OrderedCollection new: size.	1 to: size do: [ :i | 		objects add: i asPoint].	lastSize := size</body><body package="GraphQLBeta-Test-Benchmark" selector="initializeRectangles:">initializeRectangles: size	&lt;script: 'self initializeRectangles: 10'&gt;	objects := OrderedCollection new: size.		1 to: size do: [ :i | 		objects add: (Rectangle origin: i asPoint corner: i asPoint negated) ].	lastSize := size</body><body package="GraphQLBeta-Test-Benchmark" selector="reset">reset	&lt;script: 'self reset'&gt;	objects := nil.	lastSize := nil.</body></methods><methods><class-id>GraphQLBeta.GraphQLBetaDemoHTML class</class-id> <category>html sources</category><body package="GraphQLBeta-Demo" selector="exportHTMLFile:">exportHTMLFile: fileName	"Export the html content to the file name, in order to edit it"	&lt;script: 'self exportHTMLFile: ''foo.html'' '&gt;	| file s |	file := fileName asFileReference.	file exists		ifTrue: [ file delete ].	s := file writeStream.	[ s nextPutAll: (self htmlPage copyReplaceAll: String cr with: String crlf) ]		ensure: [ s close ].	self inform: 'exported!!!'</body><body package="GraphQLBeta-Demo" selector="importHTMLFile:">importHTMLFile: fileName	"Import the html from a file document, in order to save it in the smalltalk image"	&lt;script: 'self importHTMLFile: ''foo.html'' '&gt;	| content code |	content := ((fileName asFileReference readStream contents copyReplaceAll: '''' with: '"')		copyReplaceAll: String cr		with: '') copyReplaceAll: String lf with: String cr.	code := 'htmlPage	"DO NOT EDIT"	^ ''' , content , ''''.	self class compile: code classified: 'dependencies'.	self inform: 'Imported html!!!'</body></methods><methods><class-id>GraphQLBeta.GraphQLBetaDemoSite class</class-id> <category>demo</category><body package="GraphQLBeta-Demo" selector="demoStart">demoStart	&lt;script: 'self demoStart'&gt;	| inst |	inst := self new.		GraphQLPlatform current registerDemoServer: inst.	inst configure.</body><body package="GraphQLBeta-Demo" selector="demoStop">demoStop	&lt;script: 'self demoStop'&gt;	GraphQLPlatform current serverStop.</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Metaclass</name><environment>Core</environment><super>Core.ClassDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>thisClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>Dictionary</name><environment>Core</environment><super>Core.Set</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>TestCase</name><environment>SUnit</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>testSelector </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>SUnit</category><attributes><package>SUnitToo</package></attributes></class><class><name>PPParser</name><environment>PetitParser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>properties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Parsers</category><attributes><package>PetitParser</package></attributes></class><class><name>PPCompositeParser</name><environment>PetitParser</environment><super>PetitParser.PPDelegateParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dependencies </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Tools</category><attributes><package>PetitParser</package></attributes></class><class><name>Exception</name><environment>Core</environment><super>Core.GenericException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>PPCompositeParserTest</name><environment>PetitTests</environment><super>PetitTests.PPAbstractParserTest</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parser result debugResult </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitTests-Core</category><attributes><package>PetitTests</package></attributes></class></st-source>