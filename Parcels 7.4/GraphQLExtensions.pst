<?xml version="1.0"?><st-source><!-- Name: GraphQLExtensionsBundleName: GraphQLExtensionsBundleStructure: a Store.BundleForParcelParcel: #('GraphQLExtensions')ParcelName: GraphQLExtensionsDate: 5:41:53 pm July 27, 2018 --><time-stamp>From VisualWorksÂ®, 7.4 of December 5, 2005 on July 27, 2018 at 5:41:53 pm</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>Stack</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>list </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLExtensions</category><attributes><package>GraphQLExtensions</package></attributes></class><class><name>OrderedDictionary</name><environment>Smalltalk</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary orderedKeys </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLExtensions</category><attributes><package>GraphQLExtensions</package></attributes></class><methods><class-id>Stack</class-id> <category>initialize</category><body package="GraphQLExtensions" selector="initialize">initialize	list := LinkedList new.</body></methods><methods><class-id>Stack</class-id> <category>accessing</category><body package="GraphQLExtensions" selector="list">list	^ list</body><body package="GraphQLExtensions" selector="pop">pop 	^ self list removeFirst value</body><body package="GraphQLExtensions" selector="push:">push: anObject 	"Adds a new object of any kind on top of the stack."	self list addFirst: (LinkValue value: anObject).	^ anObject.</body><body package="GraphQLExtensions" selector="top">top	^ self list first value.</body></methods><methods><class-id>Stack class</class-id> <category>initialize</category><body package="GraphQLExtensions" selector="new">new	^ super new initialize</body></methods><methods><class-id>OrderedDictionary</class-id> <category>initialize-release</category><body package="GraphQLExtensions" selector="initialize">initialize	dictionary := Dictionary new: 10.	orderedKeys := Array new: 10.</body></methods><methods><class-id>OrderedDictionary</class-id> <category>accessing</category><body package="GraphQLExtensions" selector="associationAt:">associationAt: aKey	^ dictionary associationAt: aKey</body><body package="GraphQLExtensions" selector="associations">associations	| associations i |	associations := Array new: self size.	i := 1.	self associationsDo: [:each |		associations at: i put: each.		i := i + 1].	^ associations.</body><body package="GraphQLExtensions" selector="associationsDo:">associationsDo: aBlock	self keysDo: [:each | aBlock value: (self associationAt: each)]</body><body package="GraphQLExtensions" selector="at:">at: aKey	^ dictionary at: aKey</body><body package="GraphQLExtensions" selector="at:put:">at: aKey put: aValue	| oldSize |	oldSize := dictionary size.	dictionary at: aKey put: aValue.	dictionary size &gt; oldSize		ifTrue: [			orderedKeys size &gt; oldSize				ifFalse: [self growOrderedKeys].			orderedKeys at: oldSize + 1 put: aKey].	^ aValue.</body><body package="GraphQLExtensions" selector="do:">do: aBlock	self valuesDo: aBlock</body><body package="GraphQLExtensions" selector="encodeAsJSONDataUsing:">encodeAsJSONDataUsing: aJSONEncoder	| index |	aJSONEncoder beginObject.	index := 0.	(orderedKeys reject: #isNil) do: [ :k | | value |		index := index + 1.		value := dictionary at: k.		index &gt; 1 ifTrue: [aJSONEncoder emitComma].		aJSONEncoder encodeKey: k value: value	].	aJSONEncoder endObject.</body><body package="GraphQLExtensions" selector="growOrderedKeys">growOrderedKeys	orderedKeys :=		(Array new: ((orderedKeys size * 1.5) asInteger max: 10))			replaceFrom: 1			to: orderedKeys size			with: orderedKeys			startingAt: 1.</body><body package="GraphQLExtensions" selector="includesKey:">includesKey: aKey	^ dictionary includesKey: aKey</body><body package="GraphQLExtensions" selector="keys">keys	^ orderedKeys copyFrom: 1 to: self size</body><body package="GraphQLExtensions" selector="keysDo:">keysDo: aBlock	1 to: self size do: [:i | aBlock value: (orderedKeys at: i)]</body><body package="GraphQLExtensions" selector="size">size	^ dictionary size</body><body package="GraphQLExtensions" selector="values">values	^ self associations collect: [:each | each value]</body><body package="GraphQLExtensions" selector="valuesDo:">valuesDo: aBlock	self keysDo: [:each | aBlock value: (self at: each)]</body></methods><methods><class-id>OrderedDictionary</class-id> <category>testing</category><body package="GraphQLExtensions" selector="isDictionary">isDictionary	^true</body></methods><methods><class-id>OrderedDictionary</class-id> <category>comparing</category><body package="GraphQLExtensions" selector="=">= anObject	self == anObject		ifTrue: [^ true].	(self species == anObject species		and: [self size = anObject size])		ifFalse: [^ false].	dictionary associationsDo: [:each |		(anObject at: each key ifAbsent: [^ false]) = each value			ifFalse: [^ false]].	^ true.</body><body package="GraphQLExtensions" selector="hash">hash	^ dictionary hash</body></methods><methods><class-id>OrderedDictionary class</class-id> <category>instance creation</category><body package="GraphQLExtensions" selector="new">new	^super new initialize</body></methods><methods><class-id>Core.Object</class-id> <category>As yet unclassified</category><body package="GraphQLExtensions" selector="as:">as: aSimilarClass	"Create an object of class aSimilarClass that has similar contents to the receiver."	^ aSimilarClass newFrom: self</body></methods><methods><class-id>Core.Object</class-id> <category>initialize-release</category><body package="GraphQLExtensions" selector="initialize">initialize</body></methods><methods><class-id>Core.Object</class-id> <category>As yet unclassified</category><body package="GraphQLExtensions" selector="isClass">isClass	^ false</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="GraphQLExtensions" selector="isDictionary">isDictionary	^false</body><body package="GraphQLExtensions" selector="isNotNil">isNotNil	"Coerces nil to false and everything else to true."	^true</body></methods><methods><class-id>Core.Object</class-id> <category>splitjoin</category><body package="GraphQLExtensions" selector="split:">split: aSequenceableCollection	"optimized version for single delimiters:	Example:		$/ split: '/foo/bar'"			| result |		result := OrderedCollection new: (aSequenceableCollection size / 2) asInteger.	self split: aSequenceableCollection do: [ :item |		result add: item ].	^ result</body><body package="GraphQLExtensions" selector="split:do:">split: aSequenceableCollection do: aBlock	"optimized version for single delimiters:	Example:		$/ split: '/foo/bar' indicesDo: [ :item | ]"	self split: aSequenceableCollection indicesDo: [ :start :end | 		aBlock value: (aSequenceableCollection copyFrom: start to: end) ]</body><body package="GraphQLExtensions" selector="split:indicesDo:">split: aSequenceableCollection indicesDo: aBlock	"optimized version for single delimiters:	Example:		$/ split: '/foo/bar' indicesDo: [ :start :end | ]"			|  position oldPosition |		position := 1.	oldPosition := position.		position := aSequenceableCollection indexOf: self startingAt: position.	[ position &gt; 0 ] whileTrue: [		aBlock value: oldPosition value: position - 1.		position := position + 1.		oldPosition := position.		position := aSequenceableCollection indexOf: self startingAt: position.	].	aBlock value: oldPosition value: aSequenceableCollection size.</body></methods><methods><class-id>Core.String class</class-id> <category>defaults</category><body package="GraphQLExtensions" selector="cr">cr	"Answer a string containing a single carriage return character."	^ self with: Character cr</body></methods><methods><class-id>Core.String</class-id> <category>converting</category><body package="GraphQLExtensions" selector="asPackageIfAbsent:">asPackageIfAbsent: a	^ nil </body></methods><methods><class-id>Core.String</class-id> <category>accessing</category><body package="GraphQLExtensions" selector="capitalized">capitalized	"Return a copy with the first letter capitalized"	| cap |	self isEmpty ifTrue: [ ^self copy ].	cap := self copy.	cap at: 1 put: (cap at: 1) asUppercase.	^ cap</body><body package="GraphQLExtensions" selector="lineIndicesDo:">lineIndicesDo: aBlock	"execute aBlock with 3 arguments for each line:	- start index of line	- end index of line without line delimiter	- end index of line including line delimiter(s) CR, LF or CRLF"		| cr lf start sz nextLF nextCR |	start := 1.	sz := self size.	cr := Character cr.	nextCR := self indexOf: cr startingAt: 1.	lf := Character lf.	nextLF := self indexOf: lf startingAt: 1.	[ start &lt;= sz ] whileTrue: [		(nextLF = 0 and: [ nextCR = 0 ])			ifTrue: [ "No more CR, nor LF, the string is over"					aBlock value: start value: sz value: sz.					^self ].		(nextCR = 0 or: [ 0 &lt; nextLF and: [ nextLF &lt; nextCR ] ])			ifTrue: [ "Found a LF"					aBlock value: start value: nextLF - 1 value: nextLF.					start := 1 + nextLF.					nextLF := self indexOf: lf startingAt: start ]			ifFalse: [ 1 + nextCR = nextLF				ifTrue: [ "Found a CR-LF pair"					aBlock value: start value: nextCR - 1 value: nextLF.					start := 1 + nextLF.					nextCR := self indexOf: cr startingAt: start.					nextLF := self indexOf: lf startingAt: start ]				ifFalse: [ "Found a CR"					aBlock value: start value: nextCR - 1 value: nextCR.					start := 1 + nextCR.					nextCR := self indexOf: cr startingAt: start ]]]</body><body package="GraphQLExtensions" selector="lines">lines    "Answer an array of lines composing this receiver without the line ending delimiters"    ^Array new: (self size // 60 max: 16)            streamContents: [:lines | self linesDo: [:aLine | lines nextPut: aLine]]</body><body package="GraphQLExtensions" selector="linesDo:">linesDo: aBlock	"Execute aBlock with each line in this string. The terminating line delimiters CR, LF or CRLF pairs are not included in what is passed to aBlock"	self lineIndicesDo: [:start :endWithoutDelimiters :end |		aBlock value: (self copyFrom: start to: endWithoutDelimiters)]</body><body package="GraphQLExtensions" selector="trimBoth">trimBoth	"Trim separators from both sides of the receiving string."		^ self trimBoth: [ :char | char isSeparator ]</body><body package="GraphQLExtensions" selector="trimBoth:">trimBoth: aBlock	"Trim characters satisfying the condition given in aBlock from both sides of the receiving string."	^ self trimLeft: aBlock right: aBlock</body><body package="GraphQLExtensions" selector="trimLeft:right:">trimLeft: aLeftBlock right: aRightBlock	"Trim characters satisfying the condition given in aLeftBlock from the left side and aRightBlock from the right sides of the receiving string."	| left right |	left := 1.	right := self size.		[ left &lt;= right and: [ aLeftBlock value: (self at: left) ] ]		whileTrue: [ left := left + 1 ].			[ left &lt;= right and: [ aRightBlock value: (self at: right) ] ]		whileTrue: [ right := right - 1 ].			^ self copyFrom: left to: right</body></methods><methods><class-id>Core.Collection</class-id> <category>converting</category><body package="GraphQLExtensions" selector="asDictionary">asDictionary	^ self as: Dictionary.</body><body package="GraphQLExtensions" selector="associationsDo:">associationsDo: aBlock	"Evaluate aBlock for each of the receiver's elements (key/value 	associations).  If any non-association is within, the error is not caught now,	but later, when a key or value message is sent to it."	self do: aBlock</body></methods><methods><class-id>Core.Collection</class-id> <category>enumerating</category><body package="GraphQLExtensions" selector="collect:thenDo:">collect: collectBlock thenDo: doBlock 	"Utility method to improve readability."		^ self do: [ :each|		doBlock value: (collectBlock value: each)]</body><body package="GraphQLExtensions" selector="detect:ifFound:">detect: aBlock ifFound: foundBlock	"Evaluate aBlock with each of the receiver's elements as the argument.  	If some element evaluates aBlock to true, then cull this element into 	foundBlock. 	If no element matches the criteria then do nothing.	Always returns self to avoid misuse and a potential isNil check on the sender."	self		detect: aBlock		ifFound: foundBlock		ifNone: [ 			"Do nothing on purpose"			 ]</body><body package="GraphQLExtensions" selector="detect:ifFound:ifNone:">detect: aBlock ifFound: foundBlock ifNone: exceptionBlock	"Evaluate aBlock with each of the receiver's elements as the argument.  	If some element evaluates aBlock to true, then cull this element into 	foundBlock and answer the result of this evaluation. 	If none evaluate to true, then evaluate exceptionBlock."	self		do: [ :each | 			(aBlock value: each)				ifTrue: [ ^ foundBlock cull: each ] ].	^ exceptionBlock value	</body><body package="GraphQLExtensions" selector="doWithIndex:">doWithIndex: t1 	"	***This is decompiled code.*** 	The source was unavailable because the source pointer appears to point to 	an incorrect position in the file. The file may have been modified after this 	method was updated."	| t2 |	t2 := 0.	self do: [:t3 | t1 value: t3 value: (t2 := t2 + 1)].	^self</body><body package="GraphQLExtensions" selector="reject:thenCollect:">reject: t1 thenCollect: t2 	"	***This is decompiled code.*** 	The source was unavailable because the source pointer appears to point to 	an incorrect position in the file. The file may have been modified after this 	method was updated."	^(self reject: t1)		collect: t2</body></methods><methods><class-id>Core.Collection</class-id> <category>removing</category><body package="GraphQLExtensions" selector="removeAll">removeAll	"Remove each element from the receiver and leave it empty.	ArrayedCollections cannot respond to this message.	There are two good reasons why a subclass should override this message:	1) the subclass does not support being modified while being iterated	2) the subclass provides a much faster way than iterating through each element"	self do: [:each | self remove: each].</body></methods><methods><class-id>Core.Collection</class-id> <category>enumerating</category><body package="GraphQLExtensions" selector="select:thenDo:">select: selectBlock thenDo: doBlock    "Utility method to improve readability.	Do not create the intermediate collection."    self do: [: each |        ( selectBlock value: each ) 			ifTrue: [ doBlock value: each ]    ].</body></methods><methods><class-id>Core.Metaclass</class-id> <category>accessing</category><body package="GraphQLExtensions" selector="isClass">isClass	^ true</body></methods><methods><class-id>Core.Class</class-id> <category>accessing</category><body package="GraphQLExtensions" selector="allMethods">allMethods	| methods |	methods := OrderedCollection new.	self withAllSuperclasses do: [:each | methods addAll: each methodDictionary values ].	^ methods</body><body package="GraphQLExtensions" selector="encodeAsJSONDataUsing:">encodeAsJSONDataUsing: aJSONEncoder	aJSONEncoder encode: self toDictionary </body><body package="GraphQLExtensions" selector="gqlMethods">gqlMethods	| methods |	methods := OrderedCollection new.	methods addAll: self methodDictionary values.	^ methods</body><body package="GraphQLExtensions" selector="isClass">isClass	^ true</body></methods><methods><class-id>Core.Class</class-id> <category>As yet unclassified</category><body package="GraphQLExtensions" selector="subclass:instanceVariableNames:classVariableNames:package:">subclass: aSubclassSymbol instanceVariableNames: instVarNames classVariableNames: classVarNames package: aPackageSymbol	"Added to allow for a simplified subclass creation experience. "	^ self		subclass: aSubclassSymbol		instanceVariableNames: instVarNames		classVariableNames: classVarNames		poolDictionaries: ''		category: aPackageSymbol</body></methods><methods><class-id>Core.Class</class-id> <category>accessing</category><body package="GraphQLExtensions" selector="toDictionary">toDictionary	^ Dictionary new 		at: #name put: name;		at: #gqlMethods put: self gqlMethods;		yourself</body></methods><methods><class-id>GraphQLBeta.GraphQLObject class</class-id> <category>instance creation</category><body package="GraphQLExtensions" selector="new">new	^ super new initialize</body></methods><methods><class-id>Core.SequenceableCollection class</class-id> <category>instance creation</category><body package="GraphQLExtensions" selector="new:streamContents:">new: newSize streamContents: blockWithArg	| stream |	stream := WriteStream on: (self new: newSize).	blockWithArg value: stream.	^ stream contents</body><body package="GraphQLExtensions" selector="streamContents:">streamContents: blockWithArg	^ self new: 100 streamContents: blockWithArg</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>testing</category><body package="GraphQLExtensions" selector="beginsWith:">beginsWith: aSequenceableCollection	"Answer true if the receiver starts with the argument collection"	(aSequenceableCollection isEmpty or: [self size &lt; aSequenceableCollection size]) ifTrue: [^false].	aSequenceableCollection withIndexDo: [:each :index | (self at: index) ~= each ifTrue: [^false]].	^true</body><body package="GraphQLExtensions" selector="hasEqualElements:">hasEqualElements: otherCollection	"Answer whether the receiver's size is the same as otherCollection's	size, and each of the receiver's elements equal the corresponding 	element of otherCollection.	This should probably replace the current definition of #= ."	| size |	(otherCollection isKindOf: SequenceableCollection) ifFalse: [^ false].	(size := self size) = otherCollection size ifFalse: [^ false].	1 to: size do:		[:index |		(self at: index) = (otherCollection at: index) ifFalse: [^ false]].	^ true</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>accessing</category><body package="GraphQLExtensions" selector="indexOf:startingAt:">indexOf: anElement startingAt: start       "Answer the index of the first occurence of anElement after start within the receiver. If the receiver does not contain anElement, answer 0."	^self indexOf: anElement startingAt: start ifAbsent: 0</body><body package="GraphQLExtensions" selector="indexOf:startingAt:ifAbsent:">indexOf: anElement startingAt: start ifAbsent: exceptionBlock	"Answer the index of the first occurence of anElement after start	within the receiver. If the receiver does not contain anElement, 	answer the 	result of evaluating the argument, exceptionBlock."	start to: self size do:		[:index |		(self at: index) = anElement ifTrue: [^ index]].	^ exceptionBlock value</body><body package="GraphQLExtensions" selector="reduce:">reduce: aBlock	"Fold the result of the receiver into aBlock. The argument aBlock must take two or more arguments. It applies the argument, binaryBlock cumulatively to the elements of the receiver. For sequenceable collections the elements will be used in order, for unordered collections the order is unspecified."		"#(1 2 3) reduce: [ :a :b | a + b ]		--&gt; 1 + 2 + 3 = 6	#(1 2 3 4 5) reduce: [ :a :b :c | a + b + c ]		--&gt; 1 + 2 + 3 + 4 + 5 = 15"			^ self reduceLeft: aBlock</body><body package="GraphQLExtensions" selector="reduceLeft:">reduceLeft: aBlock	"Fold the result of the receiver from left to right into aBlock. The argument aBlock must take two or more arguments."	"#(1 2 3) reduceLeft: [ :a :b | a - b ].		--&gt; ((1 - 2) - 3) = -4	#(1 + 3 - 5) reduceLeft: [ :a :op :b | a perform: op with: b ].		--&gt; ((1 + 3) - 5) = -1"	| arguments |	self emptyCheck.	arguments := Array new: aBlock argumentCount.	(arguments size = 0 or: [ (self size + 1) \\ (arguments size - 1) &gt; 0 ])		ifTrue: [ self error: 'Collection size and block argument count do not match.' ].	arguments at: 1 put: self first.	2 to: self size by: arguments size - 1 do: [ :index |		arguments			replaceFrom: 2 to: arguments size with: self startingAt: index;			at: 1 put: (aBlock valueWithArguments: arguments) ].	^ arguments first</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>enumerating</category><body package="GraphQLExtensions" selector="select:thenDo:">select: selectBock thenDo: aBlock	"Refer to the comment in Collection&gt;&gt;#select:thenDo:"		| each |	1 to: self size do: [ :index |		(selectBock value: (each := self at: index))			ifTrue: [ aBlock value: each ]].</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>splitjoin</category><body package="GraphQLExtensions" selector="split:indicesDo:">split: aSequenceableCollection indicesDo: aBlock		"Split a collection by myself as a delimitier.	see Object &gt;&gt; split: for optimized version for single delimiters.	Example:		'||' split: 'foo||bar||2'"		| position oldPosition |		position := 1.	oldPosition := position.	position := aSequenceableCollection indexOfSubCollection: self startingAt: position.		[ position &gt; 0 ] whileTrue: [		aBlock value: oldPosition value: position - 1.		position := position + self size.		oldPosition := position.		position := aSequenceableCollection indexOfSubCollection: self startingAt: position.	].	aBlock value: oldPosition value: aSequenceableCollection size.</body><body package="GraphQLExtensions" selector="splitOn:">splitOn: splitter 	"splitter - can be a subsequence, a Block or a Regex (String receiver only).	Any other object used as a splitter is treated as an Array containing that object."	^ splitter split: self</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>enumerating</category><body package="GraphQLExtensions" selector="withIndexDo:">withIndexDo: elementAndIndexBlock 	"Just like with:do: except that the iteration index supplies the second argument to the block. 	#(11 22 13) withWithDo: [ :each :i | Transcript show: (each * each + i) ;cr ].	prints: 		122		486		172"			1 to: self size do:		[:index |		elementAndIndexBlock			value: (self at: index)			value: index]</body></methods><methods><class-id>Core.Dictionary class</class-id> <category>As yet unclassified</category><body package="GraphQLExtensions" selector="newFrom:">newFrom: aDict 	"Answer an instance of me containing the same associations as aDict.	 Error if any key appears twice."	| newDictionary |	newDictionary := self new: aDict size.		aDict associationsDo:		[:x |		(newDictionary includesKey: x key)			ifTrue: [self error: 'Duplicate key: ', x key printString]			ifFalse: [newDictionary add: x]].	^ newDictionary"	NewDictionary newFrom: {1-&gt;#a. 2-&gt;#b. 3-&gt;#c}	{1-&gt;#a. 2-&gt;#b. 3-&gt;#c} as: NewDictionary	NewDictionary newFrom: {1-&gt;#a. 2-&gt;#b. 1-&gt;#c}	{1-&gt;#a. 2-&gt;#b. 1-&gt;#c} as: NewDictionary"</body></methods><methods><class-id>Core.Dictionary</class-id> <category>comparing</category><body package="GraphQLExtensions" selector="=">= aDictionary	"Determine whether aDictionary has equal values at the same keys as the receiver, and that the key set is the same between both."		self == aDictionary ifTrue: [^true].	self species == aDictionary species ifFalse: [^false].	self size = aDictionary size ifFalse: [^false].	self		keysAndValuesDo:			[:key :value | 			| otherValue |			otherValue := aDictionary				at: key				ifAbsent: [^false].			otherValue = value ifFalse: [^false]].	^true</body><body package="GraphQLExtensions" selector="hash">hash	"Answer an integer hash value for the receiver such that,	  -- the hash value of an unchanged object is constant over time, and	  -- two equal objects have equal hash values"	| hash |	hash := self species hash.	self size &lt;= 10 ifTrue:		[self do: [:elem | hash := hash bitXor: elem hash]].	^hash bitXor: self size hash</body></methods><methods><class-id>Core.Dictionary</class-id> <category>testing</category><body package="GraphQLExtensions" selector="isDictionary">isDictionary	^true</body></methods><methods><class-id>Core.Dictionary</class-id> <category>removing</category><body package="GraphQLExtensions" selector="removeAll">removeAll	self keys do: [:k | self removeKey: k ].</body></methods><methods><class-id>Core.Set</class-id> <category>testing</category><body package="GraphQLExtensions" selector="=">= aSet	self == aSet ifTrue: [^ true].	"stop recursion"	(aSet isKindOf: Set) ifFalse: [^ false].	self size = aSet size ifFalse: [^ false].	self do: [:each | (aSet includes: each) ifFalse: [^ false]].	^ true</body></methods><methods><class-id>Core.Point</class-id> <category>accessing</category><body package="GraphQLExtensions" selector="encodeAsJSONDataUsing:">encodeAsJSONDataUsing: aJSONEncoder	aJSONEncoder encode: self toDictionary</body><body package="GraphQLExtensions" selector="toDictionary">toDictionary	^ Dictionary new 		at: #x put: x;		at: #y put: y;		yourself</body></methods><methods><class-id>Core.Behavior</class-id> <category>accessing</category><body package="GraphQLExtensions" selector="methodDict">methodDict	^ self methodDictionary</body></methods><methods><class-id>Core.UndefinedObject</class-id> <category>testing</category><body package="GraphQLExtensions" selector="isNotNil">isNotNil 	"Refer to the comment in Object|isNotNil."	^false</body></methods><methods><class-id>Core.Exception</class-id> <category>accessing</category><body package="GraphQLExtensions" selector="signalerContext">signalerContext	^ initialContext</body></methods><methods><class-id>Kernel.BlockClosure</class-id> <category>As yet unclassified</category><body package="GraphQLExtensions" selector="argumentCount">argumentCount	"Answer the number of arguments that must be used to evaluate this block"	^ self numArgs	</body></methods><methods><class-id>Kernel.BlockClosure</class-id> <category>evaluating</category><body package="GraphQLExtensions" selector="cull:">cull: anObject	"If the receiver can handle an argument, evaluate with the argument, otherwise drop the last argument and evaluate as a no arg block."	^self numArgs = 0		ifTrue: [self value]		ifFalse: [self value: anObject]</body></methods><methods><class-id>Graphics.Rectangle</class-id> <category>accessing</category><body package="GraphQLExtensions" selector="encodeAsJSONDataUsing:">encodeAsJSONDataUsing: aJSONEncoder	aJSONEncoder encode: self toDictionary</body><body package="GraphQLExtensions" selector="toDictionary">toDictionary	^ Dictionary new	   at: #origin put: origin;	   at: #corner put: corner;	   yourself</body></methods><methods><class-id>Kernel.NameSpace</class-id> <category>accessing</category><body package="GraphQLExtensions" selector="globals">globals	^ self</body></methods><methods><class-id>Kernel.MethodContext</class-id> <category>accessing</category><body package="GraphQLExtensions" selector="debugStackOn:">debugStackOn: stream	self printSenderStackOn: stream max: 1000</body></methods><methods><class-id>Kernel.CompiledMethod</class-id> <category>accessing</category><body package="GraphQLExtensions" selector="encodeAsJSONDataUsing:">encodeAsJSONDataUsing: aJSONEncoder	aJSONEncoder encode: self toDictionary</body><body package="GraphQLExtensions" selector="toDictionary">toDictionary	^ Dictionary new	   at: #selector put: self selector;	   yourself</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Rectangle</name><environment>Graphics</environment><super>Graphics.Geometric</super><private>false</private><indexed-type>none</indexed-type><inst-vars>origin corner </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Geometry</category><attributes><package>Graphics-Geometry</package></attributes></class><class><name>UndefinedObject</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>BlockClosure</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method outerContext copiedValues </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>Collection</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>NameSpace</name><environment>Kernel</environment><super>Kernel.GeneralNameSpace</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parent name </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>System-Name Spaces</category><attributes><package>System-Name Spaces</package></attributes></class><class><name>Set</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>tally </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>SequenceableCollection</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>Dictionary</name><environment>Core</environment><super>Core.Set</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>Behavior</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>superclass methodDict format subclasses </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>Class</name><environment>Core</environment><super>Core.ClassDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name classPool environment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>Metaclass</name><environment>Core</environment><super>Core.ClassDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>thisClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>Point</name><environment>Core</environment><super>Core.ArithmeticValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars>x y </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Geometry</category><attributes><package>Graphics-Geometry</package></attributes></class><class><name>String</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>MethodContext</name><environment>Kernel</environment><super>Kernel.Context</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>Exception</name><environment>Core</environment><super>Core.GenericException</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Exception Handling</category><attributes><package>Kernel-Exception Handling</package></attributes></class><class><name>CompiledMethod</name><environment>Kernel</environment><super>Kernel.CompiledMainBlock</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>mclass sourceCode </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class></st-source>