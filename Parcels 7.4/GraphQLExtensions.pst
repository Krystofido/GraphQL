<?xml version="1.0"?><st-source><!-- Name: GraphQLExtensionsBundleName: GraphQLExtensionsBundleStructure: a Store.BundleForParcelParcel: #('GraphQLExtensions')ParcelName: GraphQLExtensionsDate: 11:45:26 am July 18, 2018 --><time-stamp>From VisualWorksÂ®, 7.4 of December 5, 2005 on July 18, 2018 at 11:45:26 am</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><class><name>OrderedDictionary</name><environment>Smalltalk</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dictionary orderedKeys </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLExtensions</category><attributes><package>GraphQLExtensions</package></attributes></class><class><name>Stack</name><environment>Smalltalk</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>list </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>GraphQLExtensions</category><attributes><package>GraphQLExtensions</package></attributes></class><methods><class-id>OrderedDictionary</class-id> <category>initialize-release</category><body package="GraphQLExtensions" selector="initialize">initialize	dictionary := Dictionary new: 10.	orderedKeys := Array new: 10.</body></methods><methods><class-id>OrderedDictionary</class-id> <category>accessing</category><body package="GraphQLExtensions" selector="associationAt:">associationAt: aKey	^ dictionary associationAt: aKey</body><body package="GraphQLExtensions" selector="associations">associations	| associations i |	associations := Array new: self size.	i := 1.	self associationsDo: [:each |		associations at: i put: each.		i := i + 1].	^ associations.</body><body package="GraphQLExtensions" selector="associationsDo:">associationsDo: aBlock	self keysDo: [:each | aBlock value: (self associationAt: each)]</body><body package="GraphQLExtensions" selector="at:">at: aKey	^ dictionary at: aKey</body><body package="GraphQLExtensions" selector="at:put:">at: aKey put: aValue	| oldSize |	oldSize := dictionary size.	dictionary at: aKey put: aValue.	dictionary size &gt; oldSize		ifTrue: [			orderedKeys size &gt; oldSize				ifFalse: [self growOrderedKeys].			orderedKeys at: oldSize + 1 put: aKey].	^ aValue.</body><body package="GraphQLExtensions" selector="do:">do: aBlock	self valuesDo: aBlock</body><body package="GraphQLExtensions" selector="encodeAsJSONDataUsing:">encodeAsJSONDataUsing: aJSONEncoder	| index |	aJSONEncoder beginObject.	index := 0.	(orderedKeys reject: #isNil) do: [ :k | | value |		index := index + 1.		value := dictionary at: k.		index &gt; 1 ifTrue: [aJSONEncoder emitComma].		aJSONEncoder encodeKey: k value: value	].	aJSONEncoder endObject.</body><body package="GraphQLExtensions" selector="growOrderedKeys">growOrderedKeys	orderedKeys :=		(Array new: ((orderedKeys size * 1.5) asInteger max: 10))			replaceFrom: 1			to: orderedKeys size			with: orderedKeys			startingAt: 1.</body><body package="GraphQLExtensions" selector="includesKey:">includesKey: aKey	^ dictionary includesKey: aKey</body><body package="GraphQLExtensions" selector="keys">keys	^ orderedKeys copyFrom: 1 to: self size</body><body package="GraphQLExtensions" selector="keysDo:">keysDo: aBlock	1 to: self size do: [:i | aBlock value: (orderedKeys at: i)]</body><body package="GraphQLExtensions" selector="size">size	^ dictionary size</body><body package="GraphQLExtensions" selector="values">values	^ self associations collect: [:each | each value]</body><body package="GraphQLExtensions" selector="valuesDo:">valuesDo: aBlock	self keysDo: [:each | aBlock value: (self at: each)]</body></methods><methods><class-id>OrderedDictionary class</class-id> <category>instance creation</category><body package="GraphQLExtensions" selector="new">new	^super new initialize</body></methods><methods><class-id>Stack</class-id> <category>initialize</category><body package="GraphQLExtensions" selector="initialize">initialize	list := LinkedList new.</body></methods><methods><class-id>Stack</class-id> <category>accessing</category><body package="GraphQLExtensions" selector="list">list	^ list</body><body package="GraphQLExtensions" selector="pop">pop 	^ self list removeFirst value</body><body package="GraphQLExtensions" selector="push:">push: anObject 	"Adds a new object of any kind on top of the stack."	self list addFirst: (LinkValue value: anObject).	^ anObject.</body><body package="GraphQLExtensions" selector="top">top	^ self list first value.</body></methods><methods><class-id>Stack class</class-id> <category>initialize</category><body package="GraphQLExtensions" selector="new">new	^ super new initialize</body></methods><methods><class-id>Core.Object</class-id> <category>As yet unclassified</category><body package="GraphQLExtensions" selector="as:">as: aSimilarClass	"Create an object of class aSimilarClass that has similar contents to the receiver."	^ aSimilarClass newFrom: self</body></methods><methods><class-id>Core.Object</class-id> <category>initialize-release</category><body package="GraphQLExtensions" selector="initialize">initialize</body></methods><methods><class-id>Core.Object</class-id> <category>As yet unclassified</category><body package="GraphQLExtensions" selector="isClass">isClass	^ false</body></methods><methods><class-id>Core.Object</class-id> <category>testing</category><body package="GraphQLExtensions" selector="isNotNil">isNotNil	"Coerces nil to false and everything else to true."	^true</body></methods><methods><class-id>Core.String class</class-id> <category>defaults</category><body package="GraphQLExtensions" selector="cr">cr	"Answer a string containing a single carriage return character."	^ self with: Character cr</body></methods><methods><class-id>Core.String</class-id> <category>accessing</category><body package="GraphQLExtensions" selector="capitalized">capitalized	"Return a copy with the first letter capitalized"	| cap |	self isEmpty ifTrue: [ ^self copy ].	cap := self copy.	cap at: 1 put: (cap at: 1) asUppercase.	^ cap</body><body package="GraphQLExtensions" selector="trimBoth">trimBoth	"Trim separators from both sides of the receiving string."		^ self trimBoth: [ :char | char isSeparator ]</body><body package="GraphQLExtensions" selector="trimBoth:">trimBoth: aBlock	"Trim characters satisfying the condition given in aBlock from both sides of the receiving string."	^ self trimLeft: aBlock right: aBlock</body><body package="GraphQLExtensions" selector="trimLeft:right:">trimLeft: aLeftBlock right: aRightBlock	"Trim characters satisfying the condition given in aLeftBlock from the left side and aRightBlock from the right sides of the receiving string."	| left right |	left := 1.	right := self size.		[ left &lt;= right and: [ aLeftBlock value: (self at: left) ] ]		whileTrue: [ left := left + 1 ].			[ left &lt;= right and: [ aRightBlock value: (self at: right) ] ]		whileTrue: [ right := right - 1 ].			^ self copyFrom: left to: right</body></methods><methods><class-id>Core.Collection</class-id> <category>converting</category><body package="GraphQLExtensions" selector="asDictionary">asDictionary	^ self as: Dictionary.</body><body package="GraphQLExtensions" selector="associationsDo:">associationsDo: aBlock	"Evaluate aBlock for each of the receiver's elements (key/value 	associations).  If any non-association is within, the error is not caught now,	but later, when a key or value message is sent to it."	self do: aBlock</body></methods><methods><class-id>Core.Collection</class-id> <category>enumerating</category><body package="GraphQLExtensions" selector="detect:ifFound:">detect: aBlock ifFound: foundBlock	"Evaluate aBlock with each of the receiver's elements as the argument.  	If some element evaluates aBlock to true, then cull this element into 	foundBlock. 	If no element matches the criteria then do nothing.	Always returns self to avoid misuse and a potential isNil check on the sender."	self		detect: aBlock		ifFound: foundBlock		ifNone: [ 			"Do nothing on purpose"			 ]</body><body package="GraphQLExtensions" selector="detect:ifFound:ifNone:">detect: aBlock ifFound: foundBlock ifNone: exceptionBlock	"Evaluate aBlock with each of the receiver's elements as the argument.  	If some element evaluates aBlock to true, then cull this element into 	foundBlock and answer the result of this evaluation. 	If none evaluate to true, then evaluate exceptionBlock."	self		do: [ :each | 			(aBlock value: each)				ifTrue: [ ^ foundBlock cull: each ] ].	^ exceptionBlock value	</body><body package="GraphQLExtensions" selector="doWithIndex:">doWithIndex: t1 	"	***This is decompiled code.*** 	The source was unavailable because the source pointer appears to point to 	an incorrect position in the file. The file may have been modified after this 	method was updated."	| t2 |	t2 := 0.	self do: [:t3 | t1 value: t3 value: (t2 := t2 + 1)].	^self</body><body package="GraphQLExtensions" selector="reject:thenCollect:">reject: t1 thenCollect: t2 	"	***This is decompiled code.*** 	The source was unavailable because the source pointer appears to point to 	an incorrect position in the file. The file may have been modified after this 	method was updated."	^(self reject: t1)		collect: t2</body><body package="GraphQLExtensions" selector="select:thenDo:">select: selectBlock thenDo: doBlock    "Utility method to improve readability.	Do not create the intermediate collection."    self do: [: each |        ( selectBlock value: each ) 			ifTrue: [ doBlock value: each ]    ].</body></methods><methods><class-id>Core.Metaclass</class-id> <category>accessing</category><body package="GraphQLExtensions" selector="isClass">isClass	^ true</body></methods><methods><class-id>Core.Class</class-id> <category>accessing</category><body package="GraphQLExtensions" selector="allMethods">allMethods	| methods |	methods := OrderedCollection new.	self withAllSuperclasses do: [:each | methods addAll: each methodDictionary values ].	^ methods</body><body package="GraphQLExtensions" selector="encodeAsJSONDataUsing:">encodeAsJSONDataUsing: aJSONEncoder	aJSONEncoder encode: self toDictionary </body><body package="GraphQLExtensions" selector="gqlMethods">gqlMethods	| methods |	methods := OrderedCollection new.	methods addAll: self methodDictionary values.	^ methods</body><body package="GraphQLExtensions" selector="isClass">isClass	^ true</body></methods><methods><class-id>Core.Class</class-id> <category>As yet unclassified</category><body package="GraphQLExtensions" selector="subclass:instanceVariableNames:classVariableNames:package:">subclass: aSubclassSymbol instanceVariableNames: instVarNames classVariableNames: classVarNames package: aPackageSymbol	"Added to allow for a simplified subclass creation experience. "	^ self		subclass: aSubclassSymbol		instanceVariableNames: instVarNames		classVariableNames: classVarNames		poolDictionaries: ''		category: aPackageSymbol</body></methods><methods><class-id>Core.Class</class-id> <category>accessing</category><body package="GraphQLExtensions" selector="toDictionary">toDictionary	^ Dictionary new 		at: #name put: name;		at: #gqlMethods put: self gqlMethods;		yourself</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>testing</category><body package="GraphQLExtensions" selector="beginsWith:">beginsWith: aSequenceableCollection	"Answer true if the receiver starts with the argument collection"	(aSequenceableCollection isEmpty or: [self size &lt; aSequenceableCollection size]) ifTrue: [^false].	aSequenceableCollection withIndexDo: [:each :index | (self at: index) ~= each ifTrue: [^false]].	^true</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>accessing</category><body package="GraphQLExtensions" selector="reduce:">reduce: aBlock	"Fold the result of the receiver into aBlock. The argument aBlock must take two or more arguments. It applies the argument, binaryBlock cumulatively to the elements of the receiver. For sequenceable collections the elements will be used in order, for unordered collections the order is unspecified."		"#(1 2 3) reduce: [ :a :b | a + b ]		--&gt; 1 + 2 + 3 = 6	#(1 2 3 4 5) reduce: [ :a :b :c | a + b + c ]		--&gt; 1 + 2 + 3 + 4 + 5 = 15"			^ self reduceLeft: aBlock</body><body package="GraphQLExtensions" selector="reduceLeft:">reduceLeft: aBlock	"Fold the result of the receiver from left to right into aBlock. The argument aBlock must take two or more arguments."	"#(1 2 3) reduceLeft: [ :a :b | a - b ].		--&gt; ((1 - 2) - 3) = -4	#(1 + 3 - 5) reduceLeft: [ :a :op :b | a perform: op with: b ].		--&gt; ((1 + 3) - 5) = -1"	| arguments |	self emptyCheck.	arguments := Array new: aBlock argumentCount.	(arguments size = 0 or: [ (self size + 1) \\ (arguments size - 1) &gt; 0 ])		ifTrue: [ self error: 'Collection size and block argument count do not match.' ].	arguments at: 1 put: self first.	2 to: self size by: arguments size - 1 do: [ :index |		arguments			replaceFrom: 2 to: arguments size with: self startingAt: index;			at: 1 put: (aBlock valueWithArguments: arguments) ].	^ arguments first</body></methods><methods><class-id>Core.SequenceableCollection</class-id> <category>enumerating</category><body package="GraphQLExtensions" selector="select:thenDo:">select: selectBock thenDo: aBlock	"Refer to the comment in Collection&gt;&gt;#select:thenDo:"		| each |	1 to: self size do: [ :index |		(selectBock value: (each := self at: index))			ifTrue: [ aBlock value: each ]].</body><body package="GraphQLExtensions" selector="withIndexDo:">withIndexDo: elementAndIndexBlock 	"Just like with:do: except that the iteration index supplies the second argument to the block. 	#(11 22 13) withWithDo: [ :each :i | Transcript show: (each * each + i) ;cr ].	prints: 		122		486		172"			1 to: self size do:		[:index |		elementAndIndexBlock			value: (self at: index)			value: index]</body></methods><methods><class-id>Core.Dictionary class</class-id> <category>As yet unclassified</category><body package="GraphQLExtensions" selector="newFrom:">newFrom: aDict 	"Answer an instance of me containing the same associations as aDict.	 Error if any key appears twice."	| newDictionary |	newDictionary := self new: aDict size.		aDict associationsDo:		[:x |		(newDictionary includesKey: x key)			ifTrue: [self error: 'Duplicate key: ', x key printString]			ifFalse: [newDictionary add: x]].	^ newDictionary"	NewDictionary newFrom: {1-&gt;#a. 2-&gt;#b. 3-&gt;#c}	{1-&gt;#a. 2-&gt;#b. 3-&gt;#c} as: NewDictionary	NewDictionary newFrom: {1-&gt;#a. 2-&gt;#b. 1-&gt;#c}	{1-&gt;#a. 2-&gt;#b. 1-&gt;#c} as: NewDictionary"</body></methods><methods><class-id>Core.Dictionary</class-id> <category>comparing</category><body package="GraphQLExtensions" selector="=">= aDictionary	"Determine whether aDictionary has equal values at the same keys as the receiver, and that the key set is the same between both."		self == aDictionary ifTrue: [^true].	self species == aDictionary species ifFalse: [^false].	self size = aDictionary size ifFalse: [^false].	self		keysAndValuesDo:			[:key :value | 			| otherValue |			otherValue := aDictionary				at: key				ifAbsent: [^false].			otherValue = value ifFalse: [^false]].	^true</body><body package="GraphQLExtensions" selector="hash">hash	"Answer an integer hash value for the receiver such that,	  -- the hash value of an unchanged object is constant over time, and	  -- two equal objects have equal hash values"	| hash |	hash := self species hash.	self size &lt;= 10 ifTrue:		[self do: [:elem | hash := hash bitXor: elem hash]].	^hash bitXor: self size hash</body></methods><methods><class-id>Core.Point</class-id> <category>accessing</category><body package="GraphQLExtensions" selector="encodeAsJSONDataUsing:">encodeAsJSONDataUsing: aJSONEncoder	aJSONEncoder encode: self toDictionary</body><body package="GraphQLExtensions" selector="toDictionary">toDictionary	^ Dictionary new 		at: #x put: x;		at: #y put: y;		yourself</body></methods><methods><class-id>Core.Behavior</class-id> <category>accessing</category><body package="GraphQLExtensions" selector="methodDict">methodDict	^ self methodDictionary</body></methods><methods><class-id>Core.UndefinedObject</class-id> <category>testing</category><body package="GraphQLExtensions" selector="isNotNil">isNotNil 	"Refer to the comment in Object|isNotNil."	^false</body></methods><methods><class-id>Kernel.BlockClosure</class-id> <category>As yet unclassified</category><body package="GraphQLExtensions" selector="argumentCount">argumentCount	"Answer the number of arguments that must be used to evaluate this block"	^ self numArgs	</body></methods><methods><class-id>Kernel.BlockClosure</class-id> <category>evaluating</category><body package="GraphQLExtensions" selector="cull:">cull: anObject	"If the receiver can handle an argument, evaluate with the argument, otherwise drop the last argument and evaluate as a no arg block."	^self numArgs = 0		ifTrue: [self value]		ifFalse: [self value: anObject]</body></methods><methods><class-id>Graphics.Rectangle</class-id> <category>accessing</category><body package="GraphQLExtensions" selector="encodeAsJSONDataUsing:">encodeAsJSONDataUsing: aJSONEncoder	aJSONEncoder encode: self toDictionary</body><body package="GraphQLExtensions" selector="toDictionary">toDictionary	^ Dictionary new	   at: #origin put: origin;	   at: #corner put: corner;	   yourself</body></methods><methods><class-id>Kernel.CompiledMethod</class-id> <category>accessing</category><body package="GraphQLExtensions" selector="encodeAsJSONDataUsing:">encodeAsJSONDataUsing: aJSONEncoder	aJSONEncoder encode: self toDictionary</body><body package="GraphQLExtensions" selector="toDictionary">toDictionary	^ Dictionary new	   at: #selector put: self selector;	   yourself</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Rectangle</name><environment>Graphics</environment><super>Graphics.Geometric</super><private>false</private><indexed-type>none</indexed-type><inst-vars>origin corner </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Geometry</category><attributes><package>Graphics-Geometry</package></attributes></class><class><name>UndefinedObject</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>BlockClosure</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method outerContext copiedValues </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>Collection</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>SequenceableCollection</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>Dictionary</name><environment>Core</environment><super>Core.Set</super><private>false</private><indexed-type>objects</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Unordered</category><attributes><package>Collections-Unordered</package></attributes></class><class><name>Behavior</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>superclass methodDict format subclasses </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>Class</name><environment>Core</environment><super>Core.ClassDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>name classPool environment </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>Metaclass</name><environment>Core</environment><super>Core.ClassDescription</super><private>false</private><indexed-type>none</indexed-type><inst-vars>thisClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Classes</category><attributes><package>Kernel-Classes</package></attributes></class><class><name>Point</name><environment>Core</environment><super>Core.ArithmeticValue</super><private>false</private><indexed-type>none</indexed-type><inst-vars>x y </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Graphics-Geometry</category><attributes><package>Graphics-Geometry</package></attributes></class><class><name>String</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>CompiledMethod</name><environment>Kernel</environment><super>Kernel.CompiledMainBlock</super><private>false</private><indexed-type>objects</indexed-type><inst-vars>mclass sourceCode </inst-vars><class-inst-vars></class-inst-vars><imports>			private Kernel.OpcodePool.*			</imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class></st-source>