<?xml version="1.0"?><st-source><!-- Name: PetitExtensionsBundleName: PetitExtensionsBundleStructure: a Store.BundleForParcelParcel: #('PetitExtensions')ParcelName: PetitExtensionsDate: 2:37:38 pm December 29, 2017 --><time-stamp>From VisualWorksÂ®, 7.4 of December 5, 2005 on December 29, 2017 at 2:37:38 pm</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><methods><class-id>Core.Object</class-id> <category>*petitparser-core-converting</category><body package="PetitExtensions" selector="becomeForward:">becomeForward: other	^ self oneWayBecome: other</body></methods><methods><class-id>Core.Object</class-id> <category>*petitparser-core-testing</category><body package="PetitExtensions" selector="isPetitFailure">isPetitFailure	^ false</body><body package="PetitExtensions" selector="isPetitParser">isPetitParser	^ false</body></methods><methods><class-id>Core.Collection</class-id> <category>*petitparser-core-converting</category><body package="PetitExtensions" selector="asParser">asParser    	"Create a range of characters between start and stop."	(self allSatisfy: [ :e | e isCharacter ]) ifTrue: [ 		| charSet |		charSet := PetitParser.PPCharSetPredicate on: [ :char | self includes: char ] .     	^ PetitParser.PPPredicateObjectParser on: charSet message: 'One of these charactes expected: ', self printString.	].	^ super asParser	"		($a to:$f) asParser parse:'a'		($a to:$f) asParser parse:'g'	"</body></methods><methods><class-id>Core.Character class</class-id> <category>accessing untypeable characters</category><body package="PetitExtensions" selector="codePoint:">codePoint: anInteger 	"Just for ANSI Compliance"		^self value: anInteger</body></methods><methods><class-id>Core.Character</class-id> <category>*petitparser-core-converting</category><body package="PetitExtensions" selector="asParser">asParser	"Answer a parser that accepts the receiving character."		^ PetitParser.PPLiteralObjectParser on: self</body><body package="PetitExtensions" selector="asString">asString	^ String with: self</body></methods><methods><class-id>Core.Character</class-id> <category>accessing</category><body package="PetitExtensions" selector="codePoint">codePoint	^ self asInteger</body></methods><methods><class-id>Core.Character</class-id> <category>*petitparser-core-converting</category><body package="PetitExtensions" selector="to:">to: other	"Answer with a collection in ascii order -- $a to: $z"	^ (self asInteger to: other asInteger) collect:				[:ascii | Character value: ascii]</body></methods><methods><class-id>Core.Symbol</class-id> <category>*petitparser-core-converting</category><body package="PetitExtensions" selector="value:">value: anObject 	^anObject perform: self.</body></methods><methods><class-id>PetitParser.PPRepeatingParser class</class-id> <category>initialize</category><body package="PetitExtensions" selector="new">new	^ super new initialize.</body></methods><methods><class-id>PetitParser.PPContext class</class-id> <category>as yet unclassified</category><body package="PetitExtensions" selector="new">new	^ super new initialize</body></methods><methods><class-id>Core.UndefinedObject</class-id> <category>converting</category><body package="PetitExtensions" selector="asParser">asParser	"Answer a parser that succeeds and does not consume anything."		^ PetitParser.PPEpsilonParser new</body></methods><methods><class-id>Kernel.BlockClosure</class-id> <category>*petitparser-core-converting</category><body package="PetitExtensions" selector="asParser">asParser	"Answer a parser implemented in the receiving one-argument block."	^ PetitParser.PPPluggableParser on: self</body></methods><methods><class-id>PetitParser.PPListParser class</class-id> <category>instance creation</category><body package="PetitExtensions" selector="new">new	^ super new initialize</body></methods><methods><class-id>Core.PositionableStream</class-id> <category>*petitparser-core-converting</category><body package="PetitExtensions" selector="asPetitStream">asPetitStream	"Some of my subclasses do not use the instance-variables collection, position and readLimit but instead have a completely different internal representation. In these cases just use the super implementation that is inefficient but should work in all cases.""	Disabled until we agree on some way how to optimize this	^ (collection isNil or: [ position isNil or: [ readLimit isNil ] ])		ifFalse: [ PPStream on: collection from: ( position + 1 ) to: readLimit ]      ifTrue: [ super asPetitStream ]"	^ super asPetitStream</body></methods><methods><class-id>Core.PositionableStream</class-id> <category>*petitparser-core</category><body package="PetitExtensions" selector="back">back	"Go back one element and return it."	self position = 0 ifTrue: [self positionError].	self skip: -1.	^ self peek</body><body package="PetitExtensions" selector="peekBack">peekBack	"Return the element at the previous position, without changing position.  Use indirect messages in case self is a StandardFileStream."	| element |	element := self back.	self skip: 1.	^ element</body><body package="PetitExtensions" selector="peekTwice">peekTwice	"Answer what would be returned if the message next were sent to the 	receiver. If the receiver is at the end, answer nil."	| array |	self atEnd 		ifTrue: [^Array with: nil with: nil].	array := Array with: (self next) with: (self peek).	position := position - 1.	^array</body><body package="PetitExtensions" selector="positionError">positionError	"Since I am not necessarily writable, it is up to my subclasses to override 	position: if expanding the collection is preferrable to giving this error."	self error: 'Attempt to set the position of a PositionableStream out of bounds'</body></methods><methods><class-id>Core.Stream</class-id> <category>*petitparser-core-converting</category><body package="PetitExtensions" selector="asPetitStream">asPetitStream	^ self contents asPetitStream</body></methods><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>Stream</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>UndefinedObject</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>BlockClosure</name><environment>Kernel</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>method outerContext copiedValues </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Methods</category><attributes><package>Kernel-Methods</package></attributes></class><class><name>Character</name><environment>Core</environment><super>Core.Magnitude</super><private>false</private><indexed-type>immediate</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Magnitude-General</category><attributes><package>Magnitude-General</package></attributes></class><class><name>Collection</name><environment>Core</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>SequenceableCollection</name><environment>Core</environment><super>Core.Collection</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Abstract</category><attributes><package>Collections-Abstract</package></attributes></class><class><name>String</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>Symbol</name><environment>Core</environment><super>Core.String</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class><class><name>PositionableStream</name><environment>Core</environment><super>Core.PeekableStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>collection position readLimit writeLimit policy </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class><class><name>Interval</name><environment>Core</environment><super>Core.SequenceableCollection</super><private>false</private><indexed-type>none</indexed-type><inst-vars>start stop step </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Sequenceable</category><attributes><package>Collections-Sequenceable</package></attributes></class><class><name>Text</name><environment>Core</environment><super>Core.CharacterArray</super><private>false</private><indexed-type>none</indexed-type><inst-vars>string runs </inst-vars><class-inst-vars></class-inst-vars><imports>			private Graphics.TextConstants.*			</imports><category>Collections-Text</category><attributes><package>Collections-Text</package></attributes></class></st-source>