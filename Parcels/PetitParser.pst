<?xml version="1.0"?><st-source><!-- Name: PetitParserBundleName: PetitParserBundleStructure: a Store.BundleForParcelParcel: #('PetitParser')ParcelName: PetitParserDate: 10:43:33 am March 20, 2018 --><time-stamp>From VisualWorksÂ®, 7.4 of December 5, 2005 on March 20, 2018 at 10:43:33 am</time-stamp><do-it>(Dialog confirm: 'You are filing-in a Parcel source file!\\While this is possible it will not have\the same effect as loading the parcel.\None of the Parcel''s prerequisites will\be loaded and none of its load actions\will be performed.\\Are you sure you want to file-in?' withCRs) ifFalse: [self error: 'Parcel file-in abandoned.  Choose terminate or close.']</do-it><name-space><name>PetitParser</name><environment>Smalltalk</environment><private>false</private><imports>			private Squeak.*			private Smalltalk.*			</imports><category>PetitParser</category><attributes><package>PetitParser</package></attributes></name-space><class><name>PPToken</name><environment>PetitParser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>collection start stop value </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Core</category><attributes><package>PetitParser</package></attributes></class><comment><class-id>PetitParser.PPToken</class-id><body>PPToken represents a parsed part of the input stream. Contrary to a simple String it remembers where it came from, the original collection and its start and stop position.Instance Variables:	collection	&lt;SequenceableCollection&gt;	The collection this token comes from.	start	&lt;Integer&gt;	The start position in the collection.	stop	&lt;Integer&gt;	The stop position in the collection.</body></comment><class><name>PPMemento</name><environment>PetitParser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>result count context </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Core</category><attributes><package>PetitParser</package></attributes></class><comment><class-id>PetitParser.PPMemento</class-id><body>PPMemento is an internal class used by PPMemoizedParser to cache results and detect left-recursive calls.Instance Variables:	result	&lt;Object&gt;	The cached result.	count	&lt;Integer&gt;	The number of recursive cycles followed.	</body></comment><class><name>PPCharSetPredicate</name><environment>PetitParser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>block classification </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Tools</category><attributes><package>PetitParser</package></attributes></class><class><name>PPContextMemento</name><environment>PetitParser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream position properties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Core</category><attributes><package>PetitParser</package></attributes></class><class><name>PPParser</name><environment>PetitParser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>properties </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Parsers</category><attributes><package>PetitParser</package></attributes></class><comment><class-id>PetitParser.PPParser</class-id><body>An abstract parser for all parsers in PetitParser. Subclasses implement #parseOn: to perform the actual recursive-descent parsing. All parsers support a variety of methods to perform an actual parse, see the methods in the #parsing protocol. Parsers are combined with a series of operators that can be found in the #operations protocol.Instance Variables:	properties	&lt;Dictionary&gt;	Stores additional state in the parser object.</body></comment><class><name>PPEndOfLineParser</name><environment>PetitParser</environment><super>PetitParser.PPParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Parsers</category><attributes><package>PetitParser</package></attributes></class><comment><class-id>PetitParser.PPEndOfLineParser</class-id><body>A PPEndOfLineParser is a parser that does not fail, if the stream position is at the end of a line. It does not consume anything.</body></comment><class><name>PPUnresolvedParser</name><environment>PetitParser</environment><super>PetitParser.PPParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Tools</category><attributes><package>PetitParser</package></attributes></class><comment><class-id>PetitParser.PPUnresolvedParser</class-id><body>This is a temporary placeholder or forward reference to a parser that has not been defined yet. If everything goes well it will eventually be replaced with the real parser instance.</body></comment><class><name>PPStartOfLogicalLineParser</name><environment>PetitParser</environment><super>PetitParser.PPParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Parsers</category><attributes><package>PetitParser</package></attributes></class><comment><class-id>PetitParser.PPStartOfLogicalLineParser</class-id><body>A PPStartOfLogicalLineParser is that does not fail, if the stream position is at the first non-blank character of a line. It does not consume anything.</body></comment><class><name>PPStartOfLineParser</name><environment>PetitParser</environment><super>PetitParser.PPParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Parsers</category><attributes><package>PetitParser</package></attributes></class><comment><class-id>PetitParser.PPStartOfLineParser</class-id><body>A PPStartOfLineParser is that does not fail, if the stream position is at the beginning of a line. It does not consume anything.</body></comment><class><name>PPEndOfFileParser</name><environment>PetitParser</environment><super>PetitParser.PPParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Parsers</category><attributes><package>PetitParser</package></attributes></class><comment><class-id>PetitParser.PPEndOfFileParser</class-id><body>A PPEndOfFileParser is parser that will will return true if the stream position is at the end, returns failure otherwise.The diffirenece between PPEndOfFIleParser and PPEndOfInputParser is: - PPEndOfFileParser can be created using #eof asParser - PPEndOfInputParser can be created by using parser end - PPEndOfFileParser does not delegate to any other parser - PPEndOfInputParser parsers its delegate and then decides if the input is at the end.The PPEndOfFileParser can be used to accept some input only if it is at the end of the input, e.g:   ('a' asParser, #eof asParser) parse: 'a'   ('a' asParser, #eof asParser) parse: 'aa'</body></comment><class><name>PPDelegateParser</name><environment>PetitParser</environment><super>PetitParser.PPParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parser </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Parsers</category><attributes><package>PetitParser</package></attributes></class><comment><class-id>PetitParser.PPDelegateParser</class-id><body>A parser that delegates to another parser.Instance Variables:	parser	&lt;PPParser&gt;	The parser to delegate to.</body></comment><class><name>PPAndParser</name><environment>PetitParser</environment><super>PetitParser.PPDelegateParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Parsers</category><attributes><package>PetitParser</package></attributes></class><comment><class-id>PetitParser.PPAndParser</class-id><body>The and-predicate, a parser that succeeds whenever its delegate does, but does not consume the input stream [Parr 1994, 1995].</body></comment><class><name>PPFlattenParser</name><environment>PetitParser</environment><super>PetitParser.PPDelegateParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Parsers</category><attributes><package>PetitParser</package></attributes></class><comment><class-id>PetitParser.PPFlattenParser</class-id><body>A parser that answers a flat copy of the range my delegate parses.</body></comment><class><name>PPTokenParser</name><environment>PetitParser</environment><super>PetitParser.PPFlattenParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>tokenClass </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Parsers</category><attributes><package>PetitParser</package></attributes></class><comment><class-id>PetitParser.PPTokenParser</class-id><body>A parser that answers a token with the value of my delegate parses.Instance Variables:	tokenClass	&lt;PPToken class&gt;	The token sub-class to be used.</body></comment><class><name>PPEndOfInputParser</name><environment>PetitParser</environment><super>PetitParser.PPDelegateParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Parsers</category><attributes><package>PetitParser</package></attributes></class><comment><class-id>PetitParser.PPEndOfInputParser</class-id><body>A parser that succeeds only at the end of the input stream.</body></comment><class><name>PPNotParser</name><environment>PetitParser</environment><super>PetitParser.PPDelegateParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Parsers</category><attributes><package>PetitParser</package></attributes></class><comment><class-id>PetitParser.PPNotParser</class-id><body>The not-predicate, a parser that succeeds whenever its delegate does not, but consumes no input [Parr 1994, 1995].</body></comment><class><name>PPConditionalParser</name><environment>PetitParser</environment><super>PetitParser.PPDelegateParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>block </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Parsers</category><attributes><package>PetitParser</package></attributes></class><comment><class-id>PetitParser.PPConditionalParser</class-id><body>A PPConditionalParser is a delegate parser that evaluates a block and if that returns true, the delegate parser is invoked and its result returned. If the block evaluates to false, the PPFailure is returned.The block accepts one argument, context.E.g.    ('a' asParser if: [ :ctx | (ctx propertyAt: #myProperty) isNotNil ]) parse: 'a'</body></comment><class><name>PPCompositeParser</name><environment>PetitParser</environment><super>PetitParser.PPDelegateParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>dependencies </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Tools</category><attributes><package>PetitParser</package></attributes></class><comment><class-id>PetitParser.PPCompositeParser</class-id><body>A PPCompositeParser is composed parser built from various primitive parsers. Every production in the receiver is specified as a method that returns its parser. Note that every production requires an instance variable of the same name, otherwise the production is not cached and cannot be used in recursive grammars. Productions should refer to each other by reading the respective inst-var. Note: these inst-vars are typically not written, as the assignment happens in the initialize method using reflection.The start production is defined in the method start. It is aliased to the inst-var parser defined in the superclass of PPCompositeParser.</body></comment><class><name>PPEpsilonParser</name><environment>PetitParser</environment><super>PetitParser.PPParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Parsers</category><attributes><package>PetitParser</package></attributes></class><comment><class-id>PetitParser.PPEpsilonParser</class-id><body>A parser that consumes nothing and always succeeds.</body></comment><class><name>PPTrimmingParser</name><environment>PetitParser</environment><super>PetitParser.PPDelegateParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>trimmer </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Parsers</category><attributes><package>PetitParser</package></attributes></class><comment><class-id>PetitParser.PPTrimmingParser</class-id><body>A parser that silently consumes spaces before and after the delegate parser.</body></comment><class><name>PPPluggableParser</name><environment>PetitParser</environment><super>PetitParser.PPParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>block </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Parsers</category><attributes><package>PetitParser</package></attributes></class><comment><class-id>PetitParser.PPPluggableParser</class-id><body>A pluggable parser that passes the parser stream into a block. This enables users to perform manual parsing or to embed other parser frameworks into PetitParser.Instance Variables:	block	&lt;BlockClosure&gt;	The pluggable one-argument block.</body></comment><class><name>PPActionParser</name><environment>PetitParser</environment><super>PetitParser.PPDelegateParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>block </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Parsers</category><attributes><package>PetitParser</package></attributes></class><comment><class-id>PetitParser.PPActionParser</class-id><body>A parser that performs an action block with the successful parse result of the delegate.Instance Variables:	block	&lt;BlockClosure&gt;	The action block to be executed.</body></comment><class><name>PPWrappingParser</name><environment>PetitParser</environment><super>PetitParser.PPActionParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Parsers</category><attributes><package>PetitParser</package></attributes></class><comment><class-id>PetitParser.PPWrappingParser</class-id><body>A parser that performs an action block upon activation with the stream and a continuation block.</body></comment><class><name>PPLiteralParser</name><environment>PetitParser</environment><super>PetitParser.PPParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>literal message </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Parsers</category><attributes><package>PetitParser</package></attributes></class><comment><class-id>PetitParser.PPLiteralParser</class-id><body>Abstract literal parser that parses some kind of literal type (to be specified by subclasses).Instance Variables:	literal	&lt;Object&gt;	The literal object to be parsed.	message	&lt;String&gt;	The error message to be generated.</body></comment><class><name>PPLiteralObjectParser</name><environment>PetitParser</environment><super>PetitParser.PPLiteralParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Parsers</category><attributes><package>PetitParser</package></attributes></class><comment><class-id>PetitParser.PPLiteralObjectParser</class-id><body>A parser that accepts a single literal object, such as a character. This is the same as the predicate parser 'PPPredicateParser expect: literal' but slightly more efficient.</body></comment><class><name>PPFailingParser</name><environment>PetitParser</environment><super>PetitParser.PPParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>message </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Parsers</category><attributes><package>PetitParser</package></attributes></class><comment><class-id>PetitParser.PPFailingParser</class-id><body>A parser that consumes nothing and always fails.Instance Variables:	message &lt;String&gt;	The failure message.</body></comment><class><name>PPMemoizedParser</name><environment>PetitParser</environment><super>PetitParser.PPDelegateParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>buffer identifier </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Parsers</category><attributes><package>PetitParser</package></attributes></class><comment><class-id>PetitParser.PPMemoizedParser</class-id><body>A memoized parser, for refraining redundant computations.Instance Variables:	stream	&lt;PositionableStream&gt;	The stream of the associated memento objects.	buffer	&lt;Array of: PPMemento&gt;	The buffer of memento objects.</body></comment><class><name>PPOptionalParser</name><environment>PetitParser</environment><super>PetitParser.PPDelegateParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Parsers</category><attributes><package>PetitParser</package></attributes></class><comment><class-id>PetitParser.PPOptionalParser</class-id><body>A parser that optionally parsers its delegate, or answers nil.</body></comment><class><name>PPExpressionParser</name><environment>PetitParser</environment><super>PetitParser.PPDelegateParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>operators </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Tools</category><attributes><package>PetitParser</package></attributes></class><comment><class-id>PetitParser.PPExpressionParser</class-id><body>A PPExpressionParser is a parser to conveniently define an expression grammar with prefix, postfix, and left- and right-associative infix operators.The following code initializes a parser for arithmetic expressions. First we instantiate an expression parser, a simple parser for expressions in parenthesis and a simple parser for integer numbers.	expression := PPExpressionParser new.	parens := $( asParser token trim , expression , $) asParser token trim 		==&gt; [ :nodes | nodes second ].	integer := #digit asParser plus token trim		==&gt; [ :token | token value asInteger ].	Then we define on what term the expression grammar is built on:	expression term: parens / integer.	Finally we define the operator-groups in descending precedence. Note, that the action blocks receive both, the terms and the parsed operator in the order they appear in the parsed input. 		expression		group: [ :g |			g prefix: $- asParser token trim do: [ :op :a | a negated ] ];		group: [ :g |			g postfix: '++' asParser token trim do: [ :a :op | a + 1 ].			g postfix: '--' asParser token trim do: [ :a :op | a - 1 ] ];		group: [ :g |			g right: $^ asParser token trim do: [ :a :op :b | a raisedTo: b ] ];		group: [ :g |			g left: $* asParser token trim do: [ :a :op :b | a * b ].			g left: $/ asParser token trim do: [ :a :op :b | a / b ] ];		group: [ :g |			g left: $+ asParser token trim do: [ :a :op :b | a + b ].			g left: $- asParser token trim do: [ :a :op :b | a - b ] ].		After evaluating the above code the 'expression' is an efficient parser that evaluates examples like:	expression parse: '-8++'.	expression parse: '1+2*3'.	expression parse: '1*2+3'.	expression parse: '(1+2)*3'.	expression parse: '8/4/2'.	expression parse: '8/(4/2)'.	expression parse: '2^2^3'.	expression parse: '(2^2)^3'.	Instance Variables:	operators	&lt;Dictionary&gt;	The operators defined in the current group.</body></comment><class><name>PPPredicateParser</name><environment>PetitParser</environment><super>PetitParser.PPParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>predicate predicateMessage negated negatedMessage </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Parsers</category><attributes><package>PetitParser</package></attributes></class><comment><class-id>PetitParser.PPPredicateParser</class-id><body>An abstract parser that accepts if a given predicate holds.Instance Variables:	predicate	&lt;BlockClosure&gt;	The block testing for the predicate.	predicateMessage	&lt;String&gt;	The error message of the predicate.	negated	&lt;BlockClosure&gt;	The block testing for the negation of the predicate.	negatedMessage	&lt;String&gt;	The error message of the negated predicate.</body></comment><class><name>PPPredicateObjectParser</name><environment>PetitParser</environment><super>PetitParser.PPPredicateParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars>cache </class-inst-vars><imports></imports><category>PetitParser-Parsers</category><attributes><package>PetitParser</package></attributes></class><comment><class-id>PetitParser.PPPredicateObjectParser</class-id><body>A parser that accepts if a given predicate on one element of the input sequence holds.</body></comment><class><name>PPPredicateSequenceParser</name><environment>PetitParser</environment><super>PetitParser.PPPredicateParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>size </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Parsers</category><attributes><package>PetitParser</package></attributes></class><comment><class-id>PetitParser.PPPredicateSequenceParser</class-id><body>A parser that accepts if a given predicate on an arbitrary number of elements of the input sequence holds.Instance Variables:	size	&lt;Integer&gt;	The number of elements to consume.</body></comment><class><name>PPLiteralSequenceParser</name><environment>PetitParser</environment><super>PetitParser.PPLiteralParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>size </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Parsers</category><attributes><package>PetitParser</package></attributes></class><comment><class-id>PetitParser.PPLiteralSequenceParser</class-id><body>A parser accepts a sequence of literal objects, such as a String. This is an optimization to avoid having to compose longer sequences from PPSequenceParser.</body></comment><class><name>PPStream</name><environment>PetitParser</environment><super>Core.ReadStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars>newlines </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Core</category><attributes><package>PetitParser</package></attributes></class><comment><class-id>PetitParser.PPStream</class-id><body>A positional stream implementation used for parsing. It overrides some methods for optimization reasons.</body></comment><class><name>PPFailure</name><environment>PetitParser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>message context position </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Core</category><attributes><package>PetitParser</package></attributes></class><comment><class-id>PetitParser.PPFailure</class-id><body>The failure object in PetitParser. It is the only class that responds to #isPetitFailure with true. It contains an error message and a position of the occurrence of the failure.Instance Variables:	message	&lt;String&gt;	The error message of this failure.	position	&lt;Integer&gt;	The position of this failure in the input stream.</body></comment><class><name>PPStartOfWordParser</name><environment>PetitParser</environment><super>PetitParser.PPParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Parsers</category><attributes><package>PetitParser</package></attributes></class><comment><class-id>PetitParser.PPStartOfWordParser</class-id><body>A PPStartOfWordParser is that matches a word boundary.I return success if no word character preceeds my position and if word chracter succeeds my position.Word characters are any alphanumeric characters.</body></comment><class><name>PPListParser</name><environment>PetitParser</environment><super>PetitParser.PPParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>parsers </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Parsers</category><attributes><package>PetitParser</package></attributes></class><comment><class-id>PetitParser.PPListParser</class-id><body>Abstract parser that parses a list of things in some way (to be specified by the subclasses).Instance Variables:	parsers	&lt;SequenceableCollection of: PPParser&gt;	A sequence of other parsers to delegate to.</body></comment><class><name>PPSequenceParser</name><environment>PetitParser</environment><super>PetitParser.PPListParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Parsers</category><attributes><package>PetitParser</package></attributes></class><comment><class-id>PetitParser.PPSequenceParser</class-id><body>A parser that parses a sequence of parsers.</body></comment><class><name>PPChoiceParser</name><environment>PetitParser</environment><super>PetitParser.PPListParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Parsers</category><attributes><package>PetitParser</package></attributes></class><comment><class-id>PetitParser.PPChoiceParser</class-id><body>A parser that uses the first parser that succeeds.</body></comment><class><name>PPLimitedChoiceParser</name><environment>PetitParser</environment><super>PetitParser.PPChoiceParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>limit </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Parsers</category><attributes><package>PetitParser</package></attributes></class><comment><class-id>PetitParser.PPLimitedChoiceParser</class-id><body>A PPLimitedChoiceParser is similar to the choice parser except for the fact, that limit must pass if one of the choices passes. This is similar strategy as with the PPLimitedRepeatingParsers.This way, one can implement choices that successfully parse this (if limit is filled with 'a'):('aa' // 'a') 'a' parse: 'aa'The limit can be automatically filled using elements from either follow or next set (see methods  PPParser&gt;&gt;followSets or PPParser&gt;&gt;nextSets).Limit is by default epsilon and therefore it behaves as an ordinary ordered choice.Instance Variables	limit:		&lt;Object&gt;limit	- xxxxx</body></comment><class><name>PPContext</name><environment>PetitParser</environment><super>Core.Object</super><private>false</private><indexed-type>none</indexed-type><inst-vars>stream root properties globals furthestFailure </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Core</category><attributes><package>PetitParser</package></attributes></class><comment><class-id>PetitParser.PPContext</class-id><body>A PPContext is provides contextual information to the parsing function.Instance Variables	globals:		&lt;Dictionary&gt;	properties:		&lt;Dictionar&gt;	root:		&lt;PPParser&gt;	stream:		&lt;PPStream&gt;globals	- properties that are not restored after backtrackingproperties	- properties that are restored after backtrackingroot	- the root parserstream	- input stream</body></comment><class><name>PPRepeatingParser</name><environment>PetitParser</environment><super>PetitParser.PPDelegateParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>min max </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Parsers</category><attributes><package>PetitParser</package></attributes></class><comment><class-id>PetitParser.PPRepeatingParser</class-id><body>An abstract parser that repeatedly parses between 'min' and 'max' instances of its delegate. The default configuration parses an infinite number of elements, as 'min' is set to 0 and 'max' to infinity (SmallInteger maxVal).Instance Variables:	min	&lt;Integer&gt;	The minimum number of repetitions.	max	&lt;Integer&gt;	The maximum number of repetitions.</body></comment><class><name>PPPossessiveRepeatingParser</name><environment>PetitParser</environment><super>PetitParser.PPRepeatingParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Parsers</category><attributes><package>PetitParser</package></attributes></class><comment><class-id>PetitParser.PPPossessiveRepeatingParser</class-id><body>The default repeating parser with standard PEG semantics (i.e. possessive, blind, eager).</body></comment><class><name>PPLimitedRepeatingParser</name><environment>PetitParser</environment><super>PetitParser.PPRepeatingParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars>limit </inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Parsers</category><attributes><package>PetitParser</package></attributes></class><comment><class-id>PetitParser.PPLimitedRepeatingParser</class-id><body>An abstract parser that repeatedly parses between 'min' and 'max' instances of my delegate and that requires the input to be completed with a specified parser 'limit'. Subclasses provide repeating behavior as typically seen in regular expression implementations (non-blind).Instance Variables:	limit	&lt;PPParser&gt;	The parser to complete the input with.</body></comment><class><name>PPLazyRepeatingParser</name><environment>PetitParser</environment><super>PetitParser.PPLimitedRepeatingParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Parsers</category><attributes><package>PetitParser</package></attributes></class><comment><class-id>PetitParser.PPLazyRepeatingParser</class-id><body>A lazy repeating parser, commonly seen in regular expression implementations. It limits its consumption to meet the 'limit' condition as early as possible.This class essentially implements the iterative version of the following recursive parser composition:	| parser |	parser := PPChoiceParser new.	parser setParsers: (Array		with: (limit and ==&gt; [ :each | OrderedCollection new ])		with: (self , parser map: [ :each :rest | rest addFirst: each; yourself ])).	^ parser ==&gt; [ :rest | rest asArray ]</body></comment><class><name>PPGreedyRepeatingParser</name><environment>PetitParser</environment><super>PetitParser.PPLimitedRepeatingParser</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>PetitParser-Parsers</category><attributes><package>PetitParser</package></attributes></class><comment><class-id>PetitParser.PPGreedyRepeatingParser</class-id><body>A greedy repeating parser, commonly seen in regular expression implementations. It aggressively consumes as much input as possible and then backtracks to meet the 'limit' condition.This class essentially implements the iterative version of the following recursive parser composition:	| parser |	parser := PPChoiceParser new.	parser setParsers: (Array		with: (self , parser map: [ :each :rest | rest addFirst: each; yourself ])		with: (limit and ==&gt; [ :each | OrderedCollection new ])).	^ parser ==&gt; [ :rest | rest asArray ]</body></comment><shared-variable><name>NewLineParser</name><environment>PetitParser.PPToken</environment><private>false</private><constant>false</constant><category>class variables</category><initializer>nil</initializer><attributes><package>PetitParser</package></attributes></shared-variable><methods><class-id>PetitParser.PPToken</class-id> <category>accessing</category><body package="PetitParser" selector="collection">collection	"Answer the underlying collection of this token."	^ collection</body><body package="PetitParser" selector="size">size	"Answer the size of this token in the underlying collection."	^ stop - start + 1</body><body package="PetitParser" selector="start">start	"Answer the start position of this token in the underlying collection."	^ start</body><body package="PetitParser" selector="stop">stop	"Answer the stop position of this token in the underlying collection."		^ stop</body></methods><methods><class-id>PetitParser.PPToken</class-id> <category>comparing</category><body package="PetitParser" selector="=">= anObject	^ self class = anObject class and: [ self inputValue = anObject inputValue ]</body><body package="PetitParser" selector="hash">hash	^ self inputValue hash</body></methods><methods><class-id>PetitParser.PPToken</class-id> <category>querying</category><body package="PetitParser" selector="column">column	"Answer the column number of this token in the underlying collection."		| position |	position := 0.	(NewLineParser , [ :stream |		start &lt;= stream position			ifTrue: [ ^ start - position ].		position := stream position ] asParser		/ #any asParser) star			parse: collection.	 ^ start - position</body><body package="PetitParser" selector="line">line	"Answer the line number of this token in the underlying collection."		| line |	line := 1.	(NewLineParser , [ :stream |		start &lt;= stream position			ifTrue: [ ^ line ].		line := line + 1 ] asParser		/ #any asParser) star			parse: collection.	^ line</body></methods><methods><class-id>PetitParser.PPToken</class-id> <category>accessing-values</category><body package="PetitParser" selector="inputValue">inputValue	"Answer the consumed input of this token."	^ collection copyFrom: start to: stop</body><body package="PetitParser" selector="parsedValue">parsedValue	"Answer the parsed value of this token."	^ value</body><body package="PetitParser" selector="value">value	self notify: 'Token&gt;&gt;#value is no longer supported. Instead use Token&gt;&gt;#inputValue'.	^ self inputValue</body></methods><methods><class-id>PetitParser.PPToken</class-id> <category>initialization</category><body package="PetitParser" selector="initializeOn:start:stop:value:">initializeOn: aSequenceableCollection start: aStartInteger stop: aStopInteger value: anObject	collection := aSequenceableCollection.	start := aStartInteger.	stop := aStopInteger.	value := anObject</body></methods><methods><class-id>PetitParser.PPToken</class-id> <category>printing</category><body package="PetitParser" selector="printOn:">printOn: aStream	super printOn: aStream.	aStream nextPut: $[; print: self start; nextPut: $,; print: self stop; nextPut: $].	aStream nextPut: $(; print: self inputValue; nextPut: $)</body></methods><methods><class-id>PetitParser.PPToken</class-id> <category>copying</category><body package="PetitParser" selector="copyFrom:to:">copyFrom: aStartInteger to: aStopInteger	^ self class on: collection start: start + aStartInteger - 1 stop: stop + aStopInteger - 3 value: value</body></methods><methods><class-id>PetitParser.PPToken class</class-id> <category>instance creation</category><body package="PetitParser" selector="new">new	self error: 'Token can only be created using a dedicated constructor.'</body><body package="PetitParser" selector="on:">on: aSequenceableCollection	^ self on: aSequenceableCollection start: 1 stop: aSequenceableCollection size value: nil</body><body package="PetitParser" selector="on:start:stop:value:">on: aSequenceableCollection start: aStartInteger stop: aStopInteger value: anObject	^ self basicNew 		initializeOn: aSequenceableCollection		start: aStartInteger stop: aStopInteger		value: anObject</body></methods><methods><class-id>PetitParser.PPToken class</class-id> <category>initialization</category><body package="PetitParser" selector="initialize">initialize	"Platform independent newline sequence. LF: Unix, CR+LF: Windows, and CR: Apple."	| cr lf |	cr := Character codePoint: 13.	lf := Character codePoint: 10.	NewLineParser := lf asParser / (cr asParser , lf asParser optional)</body></methods><methods><class-id>PetitParser.PPMemento</class-id> <category>accessing</category><body package="PetitParser" selector="contextMemento">contextMemento	^ context</body><body package="PetitParser" selector="contextMemento:">contextMemento: aPPContextMemento	context  := aPPContextMemento </body><body package="PetitParser" selector="result">result	^ result</body><body package="PetitParser" selector="result:">result: anObject	result := anObject</body></methods><methods><class-id>PetitParser.PPMemento</class-id> <category>initialization</category><body package="PetitParser" selector="initialize">initialize	count := 0	</body></methods><methods><class-id>PetitParser.PPMemento</class-id> <category>accessing-readonly</category><body package="PetitParser" selector="count">count	^ count</body></methods><methods><class-id>PetitParser.PPMemento</class-id> <category>actions</category><body package="PetitParser" selector="increment">increment	count := count + 1</body></methods><methods><class-id>PetitParser.PPMemento class</class-id> <category>instance creation</category><body package="PetitParser" selector="new">new	^ self basicNew initialize</body></methods><methods><class-id>PetitParser.PPCharSetPredicate</class-id> <category>initialization</category><body package="PetitParser" selector="initializeOn:">initializeOn: aBlock	block := aBlock.	classification := Array new: 255.	1 to: classification size do: [ :index |		classification at: index put: (block			value: (Character codePoint: index)) ]</body></methods><methods><class-id>PetitParser.PPCharSetPredicate</class-id> <category>evaluating</category><body package="PetitParser" selector="value:">value: aCharacter	| index |	index := aCharacter asInteger.	index == 0		ifTrue: [ ^ block value: aCharacter ].	index &gt; 255		ifTrue: [ ^ block value: aCharacter ].	^ classification at: index</body></methods><methods><class-id>PetitParser.PPCharSetPredicate class</class-id> <category>instance creation</category><body package="PetitParser" selector="on:">on: aBlock	^ self basicNew initializeOn: aBlock</body></methods><methods><class-id>PetitParser.PPContextMemento</class-id> <category>accessing - properties</category><body package="PetitParser" selector="hasProperty:">hasProperty: aKey	"Test if the property aKey is present."		^ properties notNil and: [ properties includesKey: aKey ]</body><body package="PetitParser" selector="keysAndValuesDo:">keysAndValuesDo: aBlock	properties ifNil: [ ^ self ].	properties keysAndValuesDo: [ :key :value | aBlock value: key value: value copy ] </body><body package="PetitParser" selector="propertiesSize">propertiesSize	properties ifNil: [ ^ 0 ].	^ properties size.</body><body package="PetitParser" selector="propertyAt:">propertyAt: aKey	"Answer the property value associated with aKey."		^ self propertyAt: aKey ifAbsent: [ self error: 'Property not found' ]</body><body package="PetitParser" selector="propertyAt:ifAbsent:">propertyAt: aKey ifAbsent: aBlock	"Answer the property value associated with aKey or, if aKey isn't found, answer the result of evaluating aBlock."		properties isNil		ifTrue: [ ^ aBlock value ]		ifFalse: [ 			(properties includesKey: aKey) ifTrue: [ 				^ (properties at: aKey) copy			].			^ aBlock value		]</body><body package="PetitParser" selector="propertyAt:ifAbsentPut:">propertyAt: aKey ifAbsentPut: aBlock	"Answer the property associated with aKey or, if aKey isn't found store the result of evaluating aBlock as new value."		^ self propertyAt: aKey ifAbsent: [ self propertyAt: aKey put: aBlock value ]</body><body package="PetitParser" selector="propertyAt:put:">propertyAt: aKey put: anObject	"Set the property at aKey to be anObject. If aKey is not found, create a new entry for aKey and set is value to anObject. Answer anObject."	^ (properties ifNil: [ properties := Dictionary new: 1 ])		at: aKey put: (anObject copy)</body><body package="PetitParser" selector="removeProperty:">removeProperty: aKey	"Remove the property with aKey. Answer the property or raise an error if aKey isn't found."		^ self removeProperty: aKey ifAbsent: [ self error: 'Property not found' ]</body><body package="PetitParser" selector="removeProperty:ifAbsent:">removeProperty: aKey ifAbsent: aBlock	"Remove the property with aKey. Answer the value or, if aKey isn't found, answer the result of evaluating aBlock."		| answer |	properties isNil ifTrue: [ ^ aBlock value ].	answer := properties removeKey: aKey ifAbsent: aBlock.	properties isEmpty ifTrue: [ properties := nil ].	^ answer</body></methods><methods><class-id>PetitParser.PPContextMemento</class-id> <category>accessing</category><body package="PetitParser" selector="position">position	^ position</body><body package="PetitParser" selector="position:">position: anInteger	position := anInteger </body><body package="PetitParser" selector="stream">stream	^ stream</body><body package="PetitParser" selector="stream:">stream: aStream	stream := aStream</body></methods><methods><class-id>PetitParser.PPContextMemento</class-id> <category>comparing</category><body package="PetitParser" selector="=">= anObject		(self == anObject) ifTrue: [ ^ true ].	(anObject class = PPContextMemento) ifFalse: [ ^ false ].		(anObject stream == stream) ifFalse: [ ^ false ].	(anObject position == position) ifFalse: [ ^ false ].		(self propertiesSize == anObject propertiesSize) ifFalse: [ ^ false ].	self keysAndValuesDo: [ :key :value |		(anObject hasProperty: key) ifFalse: [ ^ false ].		((anObject propertyAt: key) = value) ifFalse: [ ^ false ].  	].		^ true.</body><body package="PetitParser" selector="hash">hash	^ (position hash bitXor: stream hash) bitXor: properties hash.</body></methods><methods><class-id>PetitParser.PPParser</class-id> <category>enumerating</category><body package="PetitParser" selector="allParsers">allParsers	"Answer all the parse nodes of the receiver."	| result |	result := OrderedCollection new.	self allParsersDo: [ :parser | result addLast: parser ].	^ result</body><body package="PetitParser" selector="allParsersDo:">allParsersDo: aBlock	"Iterate over all the parse nodes of the receiver."	self allParsersDo: aBlock seen: IdentitySet new</body><body package="PetitParser" selector="allParsersDo:seen:">allParsersDo: aBlock seen: aSet	"Iterate over all the parse nodes of the receiver, do not visit and follow the ones contained in aSet."	(aSet includes: self)		ifTrue: [ ^ self ].	aSet add: self.	aBlock value: self.	self children		do: [ :each | each allParsersDo: aBlock seen: aSet ]</body></methods><methods><class-id>PetitParser.PPParser</class-id> <category>initialization</category><body package="PetitParser" selector="initialize">initialize</body></methods><methods><class-id>PetitParser.PPParser</class-id> <category>operators-mapping</category><body package="PetitParser" selector="answer:">answer: anObject	"Answer a new parser that always returns anObject from a successful parse."	^ self performs: [ :nodes | anObject ]</body><body package="PetitParser" selector="flatten">flatten	"Answer a new parser that flattens the underlying collection."		^ PPFlattenParser on: self</body><body package="PetitParser" selector="foldLeft:">foldLeft: aBlock	"Answer a new parser that that folds the result of the receiver from left-to-right into aBlock. The argument aBlock must take two or more arguments."		| size args |	size := aBlock numArgs.	args := Array new: size.	^ self performs: [ :nodes |		args at: 1 put: nodes first.		2 to: nodes size by: size - 1 do: [ :index |			args				replaceFrom: 2 to: size with: nodes startingAt: index;				at: 1 put: (aBlock valueWithArguments: args) ].		args first ]</body><body package="PetitParser" selector="foldRight:">foldRight: aBlock	"Answer a new parser that that folds the result of the receiver from right-to-left into aBlock. The argument aBlock must take two or more arguments."	| size args |	size := aBlock numArgs.	args := Array new: size.	^ self performs: [ :nodes |		args at: size put: nodes last.		nodes size - size + 1 to: 1 by: 1 - size do: [ :index |			args				replaceFrom: 1 to: size - 1 with: nodes startingAt: index;				at: size put: (aBlock valueWithArguments: args) ].		args at: size ]</body><body package="PetitParser" selector="map:">map: aBlock	"Answer a new parser that works on the receiving sequence an passes in each element as a block argument."		^ aBlock numArgs = 1		ifTrue: [ self performs: aBlock ]		ifFalse: [ self error: aBlock numArgs asString , ' arguments expected.' ]</body><body package="PetitParser" selector="performs:">performs: aBlock	"Answer a new parser that performs aBlock as action handler on success."	^ PPActionParser on: self block: aBlock</body><body package="PetitParser" selector="token">token	"Answer a new parser that transforms the input to a token."		^ PPTokenParser on: self</body><body package="PetitParser" selector="token:">token: aTokenClass	"Answer a new parser that transforms the input to a token of class aTokenClass."		^ self token tokenClass: aTokenClass</body><body package="PetitParser" selector="trim">trim	"Answer a new parser that consumes spaces before and after the receiving parser."		^ self trimSpaces</body><body package="PetitParser" selector="trim:">trim: aParser	"Answer a new parser that consumes and ignores aParser repeatedly before and after the receiving parser."		^ PPTrimmingParser on: self trimmer: aParser</body><body package="PetitParser" selector="trimBlanks">trimBlanks	"Answer a new parser that consumes blanks before and after the receiving parser."		^ self trim: #blank asParser</body><body package="PetitParser" selector="trimLeft">trimLeft	"Answer a new parser that consumes spaces before the receiving parser."		^ self trimSpacesLeft</body><body package="PetitParser" selector="trimRight">trimRight	"Answer a new parser that consumes spaces after the receiving parser."		^ self trimSpacesRight</body><body package="PetitParser" selector="trimRight:">trimRight: trimmer	"Answer a new parser that consumes spaces after the receiving parser."		^ (self, trimmer star) performs: #first</body><body package="PetitParser" selector="trimSpaces">trimSpaces	"Answer a new parser that consumes spaces before and after the receiving parser."		^ self trim: #space asParser</body><body package="PetitParser" selector="trimSpacesLeft">trimSpacesLeft	"Answer a new parser that consumes spaces before the receiving parser."		^ (#space asParser star, self) performs: #second</body><body package="PetitParser" selector="trimSpacesRight">trimSpacesRight	"Answer a new parser that consumes spaces after the receiving parser."		^ (self, #space asParser star) performs: #first</body><body package="PetitParser" selector="wraps:">wraps: aBlock	"Answer a new parser that wraps the receiving parser with a two argument block. The first argument is the parsed stream, the second argument a continuation block on the delegate parser."	^ PPWrappingParser on: self block: aBlock</body></methods><methods><class-id>PetitParser.PPParser</class-id> <category>operators</category><body package="PetitParser" selector=",">, aParser 	"Answer a new parser that parses the receiver followed by aParser."	^ PPSequenceParser with: self with: aParser</body><body package="PetitParser" selector="/">/ aParser 	"Answer a new parser that parses the receiver, if the receiver fails try with aParser (ordered-choice)."		^ PPChoiceParser with: self with: aParser</body><body package="PetitParser" selector="//">// aParser 	"		Answer a new parser that parses the receiver, if the receiver fails try with aParser (ordered-choice).		If the receiver passes, limit must pass as well.	"		^ PPLimitedChoiceParser with: self with: aParser</body><body package="PetitParser" selector="and">and	"Answer a new parser (logical and-predicate) that succeeds whenever the receiver does, but never consumes input."	^ PPAndParser on: self</body><body package="PetitParser" selector="def:">def: aParser	"Redefine the receiver as the argument aParser. This method is useful when defining recursive parsers: instantiate a PPUnresolvedParser and later redefine it with another one."	^ self becomeForward: (aParser name: self name)</body><body package="PetitParser" selector="end">end	"Answer a new parser that succeeds at the end of the input and return the result of the receiver."	^ PPEndOfInputParser on: self</body><body package="PetitParser" selector="if:">if: aBlock	^ PPConditionalParser on: self block: aBlock</body><body package="PetitParser" selector="memoized">memoized	"Answer a new memoized parser, for refraining redundant computations. This ensures polynomial time O(n^4) for left-recursive grammars and O(n^3) for non left-recursive grammars in the worst case. Not necessary for most grammars that are carefully written and in O(n) anyway."		^ PPMemoizedParser on: self</body><body package="PetitParser" selector="negate">negate	"Answer a new parser consumes any input token but the receiver."		^ self not , #any asParser performs: #second</body><body package="PetitParser" selector="nonMemoized">nonMemoized	^ self</body><body package="PetitParser" selector="not">not	"Answer a new parser (logical not-predicate) that succeeds whenever the receiver fails, but never consumes input."	^ PPNotParser on: self</body><body package="PetitParser" selector="optional">optional	"Answer a new parser that parses the receiver, if possible."	^ PPOptionalParser on: self</body><body package="PetitParser" selector="wrapped">wrapped	"Answer a new parser that is simply wrapped."		^ PPDelegateParser on: self</body><body package="PetitParser" selector="|">| aParser	"Answer a new parser that either parses the receiver or aParser. Fail if both pass or fail (exclusive choice, unordered choice)."	^ (self not , aParser) / (aParser not , self) performs: #second</body></methods><methods><class-id>PetitParser.PPParser</class-id> <category>parsing</category><body package="PetitParser" selector="matches:">matches: anObject	"Answer if anObject can be parsed by the receiver."		^ (self parse: anObject) isPetitFailure not</body><body package="PetitParser" selector="matchesIn:">matchesIn: anObject	"Search anObject repeatedly for the matches of the receiver. Answered an OrderedCollection of the matched parse-trees."	| result |	result := OrderedCollection new.	self 		matchesIn: anObject		do: [ :each | result addLast: each ].	^ result</body><body package="PetitParser" selector="matchesIn:do:">matchesIn: anObject do: aBlock	"Search anObject repeatedly for the matches of the receiver. Evaluate aBlock for each match with the matched parse-tree as the argument. Make sure to always consume exactly one character with each step, to not miss any match."	(((self and performs: aBlock) , #any asParser) / #any asParser) star parse: anObject</body><body package="PetitParser" selector="matchesSkipIn:">matchesSkipIn: anObject	"Search anObject repeatedly for the matches of the receiver. Answer an OrderedCollection of the matched parse-trees. Skip over matches."	| result |	result := OrderedCollection new.	self 		matchesSkipIn: anObject		do: [ :each | result addLast: each ].	^ result</body><body package="PetitParser" selector="matchesSkipIn:do:">matchesSkipIn: anObject do: aBlock	"Search anObject repeatedly for the matches of the receiver. Evaluate aBlock for each match with the matched parse-tree as the argument. Skip over matches."	((self performs: aBlock) / #any asParser) star parse: anObject</body><body package="PetitParser" selector="matchingRangesIn:">matchingRangesIn: anObject	"Search anObject repeatedly for the matches of the receiver. Answer an OrderedCollection of ranges of each match (index of first character to: index of last character)."		| result |	result := OrderedCollection new.	self		matchingRangesIn: anObject		do: [ :value | result addLast: value ].	^ result</body><body package="PetitParser" selector="matchingRangesIn:do:">matchingRangesIn: anObject do: aBlock	"Search anObject repeatedly for the matches of the receiver. Evaluate aBlock with the range of each match (index of first character to: index of last character)."	self token		matchesIn: anObject		do: [ :token | aBlock value: (token start to: token stop) ]</body><body package="PetitParser" selector="matchingSkipRangesIn:">matchingSkipRangesIn: anObject	"Search anObject repeatedly for the matches of the receiver. Skip over matches. Answer an OrderedCollection of ranges of each match (index of first character to: index of last character)."		| result |	result := OrderedCollection new.	self		matchingSkipRangesIn: anObject		do: [ :value | result addLast: value ].	^ result</body><body package="PetitParser" selector="matchingSkipRangesIn:do:">matchingSkipRangesIn: anObject do: aBlock	"Search anObject repeatedly for the matches of the receiver. Skip over matches. Evaluate aBlock with the range of each match (index of first character to: index of last character)."		self token		matchesSkipIn: anObject		do: [ :token | aBlock value: (token start to: token stop) ]</body><body package="PetitParser" selector="parse:">parse: anObject	"Parse anObject with the receiving parser and answer the parse-result or an instance of PPFailure."	^ self parse: anObject withContext: PPContext new</body><body package="PetitParser" selector="parse:onError:">parse: anObject onError: aBlock	"Parse anObject with the receiving parser and answer the parse-result or answer the result of evaluating aBlock. Depending on the number of arguments of the block it is simply evaluated, evaluated with the failure object, or evaluated with the error message and position."		| result |	result := self parse: anObject.	result isPetitFailure		ifFalse: [ ^ result ].	aBlock numArgs = 0		ifTrue: [ ^ aBlock value ].	aBlock numArgs = 1		ifTrue: [ ^ aBlock value: result ].	^ aBlock value: result message value: result position</body><body package="PetitParser" selector="parseOn:">parseOn: aPPContext	"Parse aStream with the receiving parser and answer the parse-result or an instance of PPFailure. Override this method in subclasses to specify custom parse behavior. Do not call this method from outside, instead use #parse:."		self subclassResponsibility</body></methods><methods><class-id>PetitParser.PPParser</class-id> <category>operators-repeating</category><body package="PetitParser" selector="max:">max: anInteger	"Answer a new parser that parses the receiver at most anInteger times."		^ self star setMax: anInteger</body><body package="PetitParser" selector="max:greedy:">max: anInteger greedy: aParser	"Answer a new parser that parses the receiver at most anInteger times until it reaches aParser. This is a greedy non-blind implementation. aParser is not consumed."		^ (self starGreedy: aParser) setMax: anInteger</body><body package="PetitParser" selector="max:lazy:">max: anInteger lazy: aParser	"Answer a new parser that parses the receiver at most anInteger times until it reaches aParser. This is a lazy non-blind implementation. aParser is not consumed."		^ (self starLazy: aParser) setMax: anInteger</body><body package="PetitParser" selector="min:">min: anInteger	"Answer a new parser that parses the receiver at least anInteger times."		^ self star setMin: anInteger</body><body package="PetitParser" selector="min:greedy:">min: anInteger greedy: aParser	"Answer a new parser that parses the receiver at least anInteger times until it reaches aParser. This is a greedy non-blind implementation. aParser is not consumed."		^ (self starGreedy: aParser) setMin: anInteger</body><body package="PetitParser" selector="min:lazy:">min: anInteger lazy: aParser	"Answer a new parser that parses the receiver at least anInteger times until it reaches aParser. This is a lazy non-blind implementation. aParser is not consumed."		^ (self starLazy: aParser) setMin: anInteger</body><body package="PetitParser" selector="min:max:">min: aMinInteger max: aMaxInteger	"Answer a new parser that parses the receiver at least aMinInteger and at most aMaxInteger times."		^ self star setMin: aMinInteger; setMax: aMaxInteger</body><body package="PetitParser" selector="min:max:greedy:">min: aMinInteger max: aMaxInteger greedy: aParser	"Answer a new parser that parses the receiver at least aMinInteger and at most aMaxInteger times until it reaches aParser. This is a greedy non-blind implementation. aParser is not consumed."		^ (self starGreedy: aParser) setMin: aMinInteger; setMax: aMaxInteger</body><body package="PetitParser" selector="min:max:lazy:">min: aMinInteger max: aMaxInteger lazy: aParser	"Answer a new parser that parses the receiver at least aMinInteger and at most aMaxInteger times until it reaches aParser. This is a greedy non-blind implementation. aParser is not consumed."		^ (self starLazy: aParser) setMin: aMinInteger; setMax: aMaxInteger</body><body package="PetitParser" selector="plus">plus	"Answer a new parser that parses the receiver one or more times."	^ self star setMin: 1</body><body package="PetitParser" selector="plusGreedy:">plusGreedy: aParser	"Answer a new parser that parses the receiver one or more times until it reaches aParser. This is a greedy non-blind implementation of the star operator. aParser is not consumed."		^ (self starGreedy: aParser) setMin: 1</body><body package="PetitParser" selector="plusLazy:">plusLazy: aParser	"Answer a new parser that parses the receiver one or more times until it reaches aParser. This is a lazy non-blind implementation of the star operator. aParser is not consumed."		^ (self starLazy: aParser) setMin: 1</body><body package="PetitParser" selector="star">star	"Answer a new parser that parses the receiver zero or more times. This is a greedy and blind implementation that tries to consume as much input as possible and it does not consider what comes afterwards."	^ PPPossessiveRepeatingParser on: self</body><body package="PetitParser" selector="starGreedy:">starGreedy: aParser	"Answer a new parser that parses the receiver zero or more times until it reaches aParser. This is a greedy non-blind implementation of the star operator. aParser is not consumed."		^ PPGreedyRepeatingParser on: self limit: aParser</body><body package="PetitParser" selector="starLazy:">starLazy: aParser	"Answer a new parser that parses the receiver zero or more times until it reaches aParser. This is a lazy non-blind implementation of the star operator. aParser is not consumed."		^ PPLazyRepeatingParser on: self limit: aParser</body><body package="PetitParser" selector="times:">times: anInteger	"Answer a new parser that parses the receiver exactly anInteger times."		^ self min: anInteger max: anInteger</body></methods><methods><class-id>PetitParser.PPParser</class-id> <category>accessing</category><body package="PetitParser" selector="child">child	self assert: (self children size == 1).	^ self children first</body><body package="PetitParser" selector="children">children	"Answer a set of child parsers that could follow the receiver."	^ #()</body><body package="PetitParser" selector="name">name	"Answer the production name of the receiver."		^ self propertyAt: #name ifAbsent: [ nil ]</body><body package="PetitParser" selector="name:">name: aString	self propertyAt: #name put: aString</body></methods><methods><class-id>PetitParser.PPParser</class-id> <category>accessing-properties</category><body package="PetitParser" selector="hasProperty:">hasProperty: aKey	"Test if the property aKey is present."		^ properties notNil and: [ properties includesKey: aKey ]</body><body package="PetitParser" selector="properties">properties	^ properties</body><body package="PetitParser" selector="propertyAt:">propertyAt: aKey	"Answer the property value associated with aKey."		^ self propertyAt: aKey ifAbsent: [ self error: 'Property not found' ]</body><body package="PetitParser" selector="propertyAt:ifAbsent:">propertyAt: aKey ifAbsent: aBlock	"Answer the property value associated with aKey or, if aKey isn't found, answer the result of evaluating aBlock."		^ properties isNil		ifTrue: [ aBlock value ]		ifFalse: [ properties at: aKey ifAbsent: aBlock ]</body><body package="PetitParser" selector="propertyAt:ifAbsentPut:">propertyAt: aKey ifAbsentPut: aBlock	"Answer the property associated with aKey or, if aKey isn't found store the result of evaluating aBlock as new value."		^ self propertyAt: aKey ifAbsent: [ self propertyAt: aKey put: aBlock value ]</body><body package="PetitParser" selector="propertyAt:put:">propertyAt: aKey put: anObject	"Set the property at aKey to be anObject. If aKey is not found, create a new entry for aKey and set is value to anObject. Answer anObject."	^ (properties ifNil: [ properties := Dictionary new: 1 ])		at: aKey put: anObject</body><body package="PetitParser" selector="removeProperty:">removeProperty: aKey	"Remove the property with aKey. Answer the property or raise an error if aKey isn't found."		^ self removeProperty: aKey ifAbsent: [ self error: 'Property not found' ]</body><body package="PetitParser" selector="removeProperty:ifAbsent:">removeProperty: aKey ifAbsent: aBlock	"Remove the property with aKey. Answer the value or, if aKey isn't found, answer the result of evaluating aBlock."		| answer |	properties isNil ifTrue: [ ^ aBlock value ].	answer := properties removeKey: aKey ifAbsent: aBlock.	properties isEmpty ifTrue: [ properties := nil ].	^ answer</body></methods><methods><class-id>PetitParser.PPParser</class-id> <category>converting</category><body package="PetitParser" selector="asParser">asParser	"Answer the receiving parser."		^ self</body></methods><methods><class-id>PetitParser.PPParser</class-id> <category>operators-convenience</category><body package="PetitParser" selector="delimitedBy:">delimitedBy: aParser	"Answer a new parser that parses the receiver one or more times, separated and possibly ended by aParser."		^ (self separatedBy: aParser) , (aParser optional) performs: [ :node |		node second isNil			ifTrue: [ node first ]			ifFalse: [ node first copyWith: node second ] ]</body><body package="PetitParser" selector="separatedBy:">separatedBy: aParser	"Answer a new parser that parses the receiver one or more times, separated by aParser."		^ (PPSequenceParser with: self with: (PPSequenceParser with: aParser with: self) star) performs: [ :nodes |		| result |		result := Array new: 2 * nodes second size + 1.		result at: 1 put: nodes first.		nodes second 			keysAndValuesDo: [ :index :pair | result replaceFrom: 2 * index to: 2 * index + 1 with: pair startingAt: 1 ].		result ]</body><body package="PetitParser" selector="withoutSeparators">withoutSeparators	"Filters out the separators from a parse result produced by one of the productions #delimitedBy: or #separatedBy:."		^ self performs: [ :items |		| result |		result := Array new: items size + 1 // 2.		1 to: result size do: [ :index | result at: index put: (items at: 2 * index - 1) ].		result ]</body></methods><methods><class-id>PetitParser.PPParser</class-id> <category>context</category><body package="PetitParser" selector="parse:withContext:">parse: anObject withContext: aPPContext	"Parse anObject with the receiving parser and answer the parse-result or an instance of PPFailure."	aPPContext stream: anObject asPetitStream.	^ self parseWithContext: aPPContext.</body><body package="PetitParser" selector="parseWithContext:">parseWithContext: context	| result |	context initializeFor: self.	result := self parseOn: context.		"Return the furthest failure, it gives better results than the last failure"	(result isPetitFailure and: [ context furthestFailure notNil]) 		ifTrue: [ ^ context furthestFailure ].	^ result	</body></methods><methods><class-id>PetitParser.PPParser</class-id> <category>copying</category><body package="PetitParser" selector="postCopy">postCopy	super postCopy.	properties := properties copy</body></methods><methods><class-id>PetitParser.PPParser</class-id> <category>printing</category><body package="PetitParser" selector="printNameOn:">printNameOn: aStream	self name isNil		ifTrue: [ aStream print: self hash ]		ifFalse: [ aStream nextPutAll: self name ]</body><body package="PetitParser" selector="printOn:">printOn: aStream	super printOn: aStream.	aStream nextPut: $(.	self printNameOn: aStream.	aStream nextPut: $)</body></methods><methods><class-id>PetitParser.PPParser</class-id> <category>testing</category><body package="PetitParser" selector="isPetitParser">isPetitParser	^ true</body><body package="PetitParser" selector="isUnresolved">isUnresolved	^ false</body></methods><methods><class-id>PetitParser.PPParser class</class-id> <category>instance creation</category><body package="PetitParser" selector="named:">named: aString	^ self new name: aString</body><body package="PetitParser" selector="new">new	^ self basicNew initialize</body></methods><methods><class-id>PetitParser.PPEndOfLineParser</class-id> <category>parsing</category><body package="PetitParser" selector="parseOn:">parseOn: aPPContext	(aPPContext isEndOfLine) ifTrue: [ 		^ #endOfLine	].	^ PPFailure message: 'End of line expected' context: aPPContext at: aPPContext position</body></methods><methods><class-id>PetitParser.PPUnresolvedParser</class-id> <category>parsing</category><body package="PetitParser" selector="parseOn:">parseOn: aStream	self error: self printString , ' need to be resolved before execution.'</body></methods><methods><class-id>PetitParser.PPUnresolvedParser</class-id> <category>testing</category><body package="PetitParser" selector="isUnresolved">isUnresolved	^ true</body></methods><methods><class-id>PetitParser.PPStartOfLogicalLineParser</class-id> <category>as yet unclassified</category><body package="PetitParser" selector="isBlank:">isBlank: character	^ (character == Character space or: [character == Character tab])</body><body package="PetitParser" selector="parseOn:">parseOn: aPPContext	aPPContext peek isAlphaNumeric ifFalse: [ 		^ PPFailure message: 'Start of logical line expected' context: aPPContext 	].	aPPContext isStartOfLine ifTrue: [ ^ #startOfLogicalLine ].			[ aPPContext position ~= 0 ] whileTrue: [  		aPPContext back.		(self isBlank: aPPContext peek) ifFalse: [ 			^ PPFailure message: 'Start of logical line expected' context: aPPContext		].		aPPContext isStartOfLine ifTrue: [ ^ #startOfLogicalLine ].	]</body></methods><methods><class-id>PetitParser.PPStartOfLineParser</class-id> <category>parsing</category><body package="PetitParser" selector="parseOn:">parseOn: aPPContext	(aPPContext isStartOfLine) ifTrue: [ 		^ #startOfLine	].	^ PPFailure message: 'Start of line expected' context: aPPContext at: aPPContext position</body></methods><methods><class-id>PetitParser.PPEndOfFileParser</class-id> <category>parsing</category><body package="PetitParser" selector="parseOn:">parseOn: aPPContext	(aPPContext atEnd) ifFalse:	[		^ PPFailure message: 'end of input expected' context: aPPContext.	].	^ #'end-of-input'</body></methods><methods><class-id>PetitParser.PPDelegateParser</class-id> <category>accessing</category><body package="PetitParser" selector="children">children	^ Array with: parser</body></methods><methods><class-id>PetitParser.PPDelegateParser</class-id> <category>parsing</category><body package="PetitParser" selector="parseOn:">parseOn: aPPContext	^ parser parseOn: aPPContext</body></methods><methods><class-id>PetitParser.PPDelegateParser</class-id> <category>initialization</category><body package="PetitParser" selector="setParser:">setParser: aParser	parser := aParser</body></methods><methods><class-id>PetitParser.PPDelegateParser class</class-id> <category>instance creation</category><body package="PetitParser" selector="on:">on: aParser	^ self new setParser: aParser</body></methods><methods><class-id>PetitParser.PPAndParser</class-id> <category>operators</category><body package="PetitParser" selector="and">and	^ self</body></methods><methods><class-id>PetitParser.PPAndParser</class-id> <category>parsing</category><body package="PetitParser" selector="parseOn:">parseOn: aPPContext	| element memento |	memento := aPPContext remember.	element := parser parseOn: aPPContext.	aPPContext restore: memento.	^ element</body></methods><methods><class-id>PetitParser.PPFlattenParser</class-id> <category>private</category><body package="PetitParser" selector="on:start:stop:value:">on: aCollection start: aStartInteger stop: aStopInteger value: anObject	^ aCollection copyFrom: aStartInteger to: aStopInteger</body></methods><methods><class-id>PetitParser.PPFlattenParser</class-id> <category>parsing</category><body package="PetitParser" selector="parseOn:">parseOn: aPPContext	| start element |	start := aPPContext position.	element := parser parseOn: aPPContext.	element isPetitFailure ifTrue: [ ^ element ].	^ self on: aPPContext stream collection start: start + 1 stop: aPPContext position value: element</body></methods><methods><class-id>PetitParser.PPTokenParser</class-id> <category>private</category><body package="PetitParser" selector="defaultTokenClass">defaultTokenClass	^ PPToken</body><body package="PetitParser" selector="on:start:stop:value:">on: aCollection start: aStartInteger stop: aStopInteger value: anObject	^ self tokenClass on: aCollection start: aStartInteger stop: aStopInteger value: anObject</body></methods><methods><class-id>PetitParser.PPTokenParser</class-id> <category>initialization</category><body package="PetitParser" selector="initialize">initialize	tokenClass := self defaultTokenClass	</body></methods><methods><class-id>PetitParser.PPTokenParser</class-id> <category>accessing</category><body package="PetitParser" selector="tokenClass">tokenClass	^ tokenClass</body><body package="PetitParser" selector="tokenClass:">tokenClass: aTokenClass	tokenClass := aTokenClass</body></methods><methods><class-id>PetitParser.PPEndOfInputParser</class-id> <category>parsing</category><body package="PetitParser" selector="parseOn:">parseOn: aPPContext	| memento result |	memento := aPPContext remember.	result := parser parseOn: aPPContext.	(result isPetitFailure or: [ aPPContext stream atEnd ])		ifTrue: [ ^ result ].	result := PPFailure		message: 'end of input expected'		context: aPPContext.	aPPContext restore: memento.	^ result</body></methods><methods><class-id>PetitParser.PPEndOfInputParser</class-id> <category>operators</category><body package="PetitParser" selector="end">end	^ self</body></methods><methods><class-id>PetitParser.PPNotParser</class-id> <category>parsing</category><body package="PetitParser" selector="parseOn:">parseOn: aPPContext	| element memento |	memento := aPPContext remember.	element := parser parseOn: aPPContext.	aPPContext restore: memento.	^ element isPetitFailure		ifFalse: [ PPFailure message: '' context: aPPContext ]</body></methods><methods><class-id>PetitParser.PPConditionalParser</class-id> <category>parsing</category><body package="PetitParser" selector="parseOn:">parseOn: aPPContext	^ (block value: aPPContext) 		ifTrue: [ parser parseOn: aPPContext ]		ifFalse: [ PPFailure message: block asString, ' was not evaluated to true.' context: aPPContext ]</body></methods><methods><class-id>PetitParser.PPConditionalParser</class-id> <category>accessing</category><body package="PetitParser" selector="block:">block: aBlock	block := aBlock</body></methods><methods><class-id>PetitParser.PPConditionalParser class</class-id> <category>as yet unclassified</category><body package="PetitParser" selector="on:block:">on: aPPParser block: block	^ (PPConditionalParser on: aPPParser)		block: block;		yourself</body></methods><methods><class-id>PetitParser.PPCompositeParser</class-id> <category>querying</category><body package="PetitParser" selector="dependencyAt:">dependencyAt: aClass	"Answer the dependent parser aClass. Throws an error if this parser class is not declared in the method #dependencies on the class-side of the receiver."		^ dependencies at: aClass ifAbsent: [ self error: 'Undeclared dependency in ' , self class name , ' to ' , aClass name ]</body><body package="PetitParser" selector="productionAt:">productionAt: aSymbol	"Answer the production named aSymbol."		^ self productionAt: aSymbol ifAbsent: [ nil ]</body><body package="PetitParser" selector="productionAt:ifAbsent:">productionAt: aSymbol ifAbsent: aBlock	"Answer the production named aSymbol, if there is no such production answer the result of evaluating aBlock."		(self class ignoredNames includes: aSymbol asString)		ifTrue: [ ^ aBlock value ].	(self class startSymbol = aSymbol)		ifTrue: [ ^ parser ].	^ self instVarAt: (self class allInstVarNames		indexOf: aSymbol asString		ifAbsent: [ ^ aBlock value ])</body><body package="PetitParser" selector="productionNames">productionNames	"Answer a dictionary of slot indexes and production names."		| productionNames ignoredNames |	productionNames := Dictionary new.	ignoredNames := self class ignoredNames		collect: [ :each | each asSymbol ].	self class allInstVarNames keysAndValuesDo: [ :key :value |		(ignoredNames includes: value asSymbol)			ifFalse: [ productionNames at: key put: value asSymbol ] ].	^ productionNames</body></methods><methods><class-id>PetitParser.PPCompositeParser</class-id> <category>initialization</category><body package="PetitParser" selector="initializeStartingAt:dependencies:">initializeStartingAt: aSymbol dependencies: aDictionary	self initialize.	parser := PPDelegateParser named: aSymbol.	self productionNames keysAndValuesDo: [ :key :value |		self instVarAt: key put: (PPDelegateParser named: value) ].	dependencies := aDictionary</body></methods><methods><class-id>PetitParser.PPCompositeParser</class-id> <category>accessing</category><body package="PetitParser" selector="start">start	"Answer the production to start this parser with."		self subclassResponsibility</body></methods><methods><class-id>PetitParser.PPCompositeParser class</class-id> <category>parsing</category><body package="PetitParser" selector="parse:">parse: anObject	^ self parse: anObject startingAt: self startSymbol</body><body package="PetitParser" selector="parse:onError:">parse: anObject onError: aBlock	^ self parse: anObject startingAt: self startSymbol onError: aBlock</body><body package="PetitParser" selector="parse:startingAt:">parse: anObject startingAt: aSymbol	^ (self newStartingAt: aSymbol) parse: anObject</body><body package="PetitParser" selector="parse:startingAt:onError:">parse: anObject startingAt: aSymbol onError: aBlock	^ (self newStartingAt: aSymbol) parse: anObject onError: aBlock</body></methods><methods><class-id>PetitParser.PPCompositeParser class</class-id> <category>instance creation</category><body package="PetitParser" selector="new">new	"Answer a new parser starting at the default start symbol."	^ self newStartingAt: self startSymbol</body><body package="PetitParser" selector="newStartingAt:">newStartingAt: aSymbol	"Answer a new parser starting at aSymbol. The code makes sure to resolve all dependent parsers correctly."	| parsers remaining |	parsers := IdentityDictionary new.	remaining := OrderedCollection with: self.	[ remaining isEmpty ] whileFalse: [		| dependency |		dependency := remaining removeLast.		(parsers includesKey: dependency) ifFalse: [			parsers at: dependency put: dependency basicNew.			remaining addAll: dependency dependencies ] ].	parsers keysAndValuesDo: [ :class :parser |		| dependencies |		dependencies := IdentityDictionary new.		class dependencies 			do: [ :dependency | dependencies at: dependency put: (parsers at: dependency) ].		parser 			initializeStartingAt: (class == self				ifTrue: [ aSymbol ]				ifFalse: [ class startSymbol ]) 			dependencies: dependencies ].	parsers keysAndValuesDo: [ :class :parser |		parser setParser: (parser perform: parser children first name).		parser productionNames keysAndValuesDo: [ :key :value |			(parser instVarAt: key) setParser: (parser perform: value) ] ].	^ parsers at: self</body></methods><methods><class-id>PetitParser.PPCompositeParser class</class-id> <category>accessing</category><body package="PetitParser" selector="dependencies">dependencies	"Answer a collection of PPCompositeParser classes that this parser directly dependends on. Override this method in subclasses to declare dependent parsers. The default implementation does not depend on other PPCompositeParser."	^ #()</body><body package="PetitParser" selector="ignoredNames">ignoredNames	"Answer a collection of instance-variables that should not be automatically initialized with productions, but that are used internal to the composite parser."	^ PPCompositeParser allInstVarNames</body><body package="PetitParser" selector="startSymbol">startSymbol	"Answer the method that represents the default start symbol."	^ #start</body></methods><methods><class-id>PetitParser.PPEpsilonParser</class-id> <category>parsing</category><body package="PetitParser" selector="parseOn:">parseOn: aStream	^ nil</body></methods><methods><class-id>PetitParser.PPTrimmingParser</class-id> <category>parsing</category><body package="PetitParser" selector="parseOn:">parseOn: aPPContext	| memento element trimContext |	memento := aPPContext remember.	trimContext := aPPContext copy.	[ (trimmer parseOn: trimContext) isPetitFailure ]		whileFalse.	element := parser parseOn: aPPContext.	element isPetitFailure ifTrue: [		aPPContext restore: memento.		^ element ].	[ (trimmer parseOn: trimContext) isPetitFailure ]		whileFalse.	^ element</body></methods><methods><class-id>PetitParser.PPTrimmingParser</class-id> <category>initialization</category><body package="PetitParser" selector="setTrimmer:">setTrimmer: aParser	trimmer := aParser</body></methods><methods><class-id>PetitParser.PPTrimmingParser class</class-id> <category>instance creation</category><body package="PetitParser" selector="on:trimmer:">on: aParser trimmer: aTrimParser	^ self new		setParser: aParser;		setTrimmer: aTrimParser;		yourself</body></methods><methods><class-id>PetitParser.PPPluggableParser</class-id> <category>parsing</category><body package="PetitParser" selector="parseOn:">parseOn: aPPContext	| memento result |	memento := aPPContext remember.	result := block value: aPPContext.	result isPetitFailure		ifTrue: [ aPPContext restore: memento ].	^ result</body></methods><methods><class-id>PetitParser.PPPluggableParser</class-id> <category>initialization</category><body package="PetitParser" selector="initializeOn:">initializeOn: aBlock	block := aBlock</body></methods><methods><class-id>PetitParser.PPPluggableParser</class-id> <category>accessing</category><body package="PetitParser" selector="block">block	"Answer the pluggable block."	^ block</body></methods><methods><class-id>PetitParser.PPPluggableParser class</class-id> <category>instance creation</category><body package="PetitParser" selector="on:">on: aBlock	^ self new initializeOn: aBlock</body></methods><methods><class-id>PetitParser.PPActionParser</class-id> <category>parsing</category><body package="PetitParser" selector="parseOn:">parseOn: aPPContext	| element |	^ (element := parser parseOn: aPPContext) isPetitFailure		ifFalse: [ block value: element ]		ifTrue: [ element ]</body></methods><methods><class-id>PetitParser.PPActionParser</class-id> <category>initialization</category><body package="PetitParser" selector="setBlock:">setBlock: aBlock	block := aBlock</body></methods><methods><class-id>PetitParser.PPActionParser</class-id> <category>accessing</category><body package="PetitParser" selector="block">block	"Answer the action block of the receiver."	^ block</body></methods><methods><class-id>PetitParser.PPActionParser class</class-id> <category>instance creation</category><body package="PetitParser" selector="on:block:">on: aParser block: aBlock	^ (self on: aParser) setBlock: aBlock</body></methods><methods><class-id>PetitParser.PPWrappingParser</class-id> <category>parsing</category><body package="PetitParser" selector="parseOn:">parseOn: aPPContext	^ block value: aPPContext value: [ parser parseOn: aPPContext ]</body></methods><methods><class-id>PetitParser.PPLiteralParser</class-id> <category>operators</category><body package="PetitParser" selector="caseInsensitive">caseInsensitive	"Answer a parser that can parse the receiver case-insensitive."		self subclassResponsibility</body></methods><methods><class-id>PetitParser.PPLiteralParser</class-id> <category>printing</category><body package="PetitParser" selector="printNameOn:">printNameOn: aStream	super printNameOn: aStream.	aStream nextPutAll: ', '; print: literal</body></methods><methods><class-id>PetitParser.PPLiteralParser</class-id> <category>accessing</category><body package="PetitParser" selector="literal">literal	"Answer the parsed literal."	^ literal</body><body package="PetitParser" selector="message">message	"Answer the failure message."		^ message</body></methods><methods><class-id>PetitParser.PPLiteralParser</class-id> <category>initialization</category><body package="PetitParser" selector="initializeOn:message:">initializeOn: anObject message: aString	literal := anObject.	message := aString</body></methods><methods><class-id>PetitParser.PPLiteralParser class</class-id> <category>instance creation</category><body package="PetitParser" selector="on:">on: anObject	^ self on: anObject message: anObject printString , ' expected'</body><body package="PetitParser" selector="on:message:">on: anObject message: aString	^ self new initializeOn: anObject message: aString</body></methods><methods><class-id>PetitParser.PPLiteralObjectParser</class-id> <category>parsing</category><body package="PetitParser" selector="parseOn:">parseOn: aPPContext	^ (aPPContext stream atEnd not and: [ literal = aPPContext stream uncheckedPeek ])		ifFalse: [ PPFailure message: message context: aPPContext ]		ifTrue: [ aPPContext next ]</body></methods><methods><class-id>PetitParser.PPLiteralObjectParser</class-id> <category>operators</category><body package="PetitParser" selector="caseInsensitive">caseInsensitive	"Answer a parser that can parse the receiver case-insensitive."		literal asUppercase = literal asLowercase ifTrue: [ ^ self ].	^ PPPredicateObjectParser on: [ :value | literal sameAs: value ] message: message</body><body package="PetitParser" selector="negate">negate	^ (PPPredicateObjectParser expect: literal message: message) negate</body></methods><methods><class-id>PetitParser.PPFailingParser</class-id> <category>pp-context</category><body package="PetitParser" selector="parseOn:">parseOn: aPPContext	^ PPFailure message: message context: aPPContext</body></methods><methods><class-id>PetitParser.PPFailingParser</class-id> <category>printing</category><body package="PetitParser" selector="printNameOn:">printNameOn: aStream	super printNameOn: aStream.	aStream nextPutAll: ', '; print: message</body></methods><methods><class-id>PetitParser.PPFailingParser</class-id> <category>accessing</category><body package="PetitParser" selector="message">message	"Answer the error message of the receiving parser."	^ message</body></methods><methods><class-id>PetitParser.PPFailingParser</class-id> <category>initialization</category><body package="PetitParser" selector="setMessage:">setMessage: aString	message := aString</body></methods><methods><class-id>PetitParser.PPFailingParser class</class-id> <category>instance creation</category><body package="PetitParser" selector="message:">message: aString	^ self new setMessage: aString</body></methods><methods><class-id>PetitParser.PPMemoizedParser</class-id> <category>parsing</category><body package="PetitParser" selector="check:">check: aPPContext	(identifier == aPPContext identifier)		ifFalse: [ self reset: aPPContext ].</body><body package="PetitParser" selector="parseOn:">parseOn: aPPContext	| memento contextMemento  aStream |	"TODO: JK memoizing needs review!"	self check: aPPContext.	contextMemento := aPPContext remember.	memento := (buffer at: contextMemento ifAbsentPut: [ PPMemento new ]).		memento contextMemento isNil		ifTrue: [			aStream := aPPContext stream.			memento result: (aStream size - aStream position + 2 &lt; memento count				ifTrue: [ PPFailure message: 'overflow' context: aPPContext ]				ifFalse: [ memento increment. parser parseOn: aPPContext ]).			memento contextMemento: aPPContext remember ]		ifFalse: [ aPPContext restore: memento contextMemento ].	^ memento result.</body><body package="PetitParser" selector="reset:">reset: aPPContext	buffer := Dictionary new.	identifier := aPPContext identifier.</body></methods><methods><class-id>PetitParser.PPMemoizedParser</class-id> <category>operators</category><body package="PetitParser" selector="memoized">memoized	"Ther is no point in memoizing more than once."	^ self</body><body package="PetitParser" selector="nonMemoized">nonMemoized	^ parser</body></methods><methods><class-id>PetitParser.PPOptionalParser</class-id> <category>parsing</category><body package="PetitParser" selector="parseOn:">parseOn: aPPContext	| element |	element := parser parseOn: aPPContext.	^ element isPetitFailure ifFalse: [ element ]</body></methods><methods><class-id>PetitParser.PPExpressionParser</class-id> <category>specifying</category><body package="PetitParser" selector="group:">group: aOneArgumentBlock	"Defines a priority group by evaluating aOneArgumentBlock."		operators := Dictionary new.	parser := [ 		aOneArgumentBlock value: self.	 	self buildOn: parser ]			ensure: [ operators := nil ]</body><body package="PetitParser" selector="left:do:">left: aParser do: aThreeArgumentBlock	"Define an operator aParser that is left-associative. Evaluate aThreeArgumentBlock with the first term, the operator, and the second term."		self operator: #build:left: parser: aParser do: aThreeArgumentBlock</body><body package="PetitParser" selector="postfix:do:">postfix: aParser do: aTwoArgumentBlock	"Define a postfix operator aParser. Evaluate aTwoArgumentBlock with the term and the operator."	self operator: #build:postfix: parser: aParser do: aTwoArgumentBlock</body><body package="PetitParser" selector="prefix:do:">prefix: aParser do: aTwoArgumentBlock	"Define a prefix operator aParser. Evaluate aTwoArgumentBlock with the operator and the term."	self operator: #build:prefix: parser: aParser do: aTwoArgumentBlock</body><body package="PetitParser" selector="right:do:">right: aParser do: aThreeArgumentBlock	"Define an operator aParser that is right-associative. Evaluate aThreeArgumentBlock with the first term, the operator, and the second term."		self operator: #build:right: parser: aParser do: aThreeArgumentBlock</body><body package="PetitParser" selector="term:">term: aParser	"Defines the initial term aParser of the receiver."		parser isNil		ifTrue: [ parser := aParser ]		ifFalse: [ self error: 'Unable to redefine the term.' ]</body></methods><methods><class-id>PetitParser.PPExpressionParser</class-id> <category>private</category><body package="PetitParser" selector="build:left:">build: aParser left: aChoiceParser	^ (aParser separatedBy: aChoiceParser) foldLeft: [ :a :op :b | op first value: a value: op second value: b ]</body><body package="PetitParser" selector="build:postfix:">build: aParser postfix: aChoiceParser	^ aParser , aChoiceParser star map: [ :term :ops | ops inject: term into: [ :result :operator | operator first value: result value: operator second ] ]</body><body package="PetitParser" selector="build:prefix:">build: aParser prefix: aChoiceParser	^ aChoiceParser star , aParser map: [ :ops :term | ops reverse inject: term into: [ :result :operator | operator first value: operator second value: result ] ]</body><body package="PetitParser" selector="build:right:">build: aParser right: aChoiceParser	^ (aParser separatedBy: aChoiceParser) foldRight: [ :a :op :b | op first value: a value: op second value: b ]</body><body package="PetitParser" selector="buildOn:">buildOn: aParser	^ self buildSelectors inject: aParser into: [ :term :selector |		| list |		list := operators at: selector ifAbsent: [ #() ].		list isEmpty			ifTrue: [ term ]			ifFalse: [				self					perform: selector with: term 					with: (list size = 1						ifTrue: [ list first first performs: [ :operator | Array with: list first second with: operator ] ]						ifFalse: [ 							list								inject: PPChoiceParser new								into: [ :choice :each | choice / (each first performs: [ :operator | Array with: each second with: operator ]) ] ]) ] ]</body><body package="PetitParser" selector="buildSelectors">buildSelectors	^ #(build:prefix: build:postfix: build:right: build:left:)</body><body package="PetitParser" selector="operator:parser:do:">operator: aSymbol parser: aParser do: aBlock	parser isNil		ifTrue: [ ^ self error: 'You did not specify a term when creating the receiver.' ].	operators isNil		ifTrue: [ ^ self error: 'Use #group: to define precedence groups in descending order.' ].	(operators at: aSymbol ifAbsentPut: [ OrderedCollection new ])		addLast: (Array with: aParser asParser with: aBlock)</body></methods><methods><class-id>PetitParser.PPPredicateParser</class-id> <category>printing</category><body package="PetitParser" selector="printNameOn:">printNameOn: aStream	super printNameOn: aStream.	aStream nextPutAll: ', '; print: predicateMessage</body></methods><methods><class-id>PetitParser.PPPredicateParser</class-id> <category>accessing</category><body package="PetitParser" selector="block">block	"Answer the predicate block of the receiver."		^ predicate</body><body package="PetitParser" selector="message">message	"Answer the failure message."		^ predicateMessage</body></methods><methods><class-id>PetitParser.PPPredicateObjectParser</class-id> <category>parsing</category><body package="PetitParser" selector="parseOn:">parseOn: aPPContext	^ (aPPContext atEnd not and: [ predicate value: aPPContext uncheckedPeek ])		ifFalse: [ PPFailure message: predicateMessage context: aPPContext ]		ifTrue: [ aPPContext next ]</body></methods><methods><class-id>PetitParser.PPPredicateObjectParser</class-id> <category>operators</category><body package="PetitParser" selector="negate">negate	"Answer a parser that is the negation of the receiving predicate parser."		^ self class 		on: negated message: negatedMessage 		negated: predicate message: predicateMessage</body></methods><methods><class-id>PetitParser.PPPredicateObjectParser</class-id> <category>initialization</category><body package="PetitParser" selector="initializeOn:message:negated:message:">initializeOn: aBlock message: aString negated: aNegatedBlock message: aNegatedString	predicate := aBlock.	predicateMessage := aString.	negated := aNegatedBlock.	negatedMessage := aNegatedString</body></methods><methods><class-id>PetitParser.PPPredicateObjectParser class</class-id> <category>cache</category><body package="PetitParser" selector="cacheAt:ifAbsentPut:">cacheAt: aSymbol ifAbsentPut: aBlock	cache ifNil: [ cache := Dictionary new ].	^(cache		at: aSymbol		ifAbsentPut: aBlock) copy</body></methods><methods><class-id>PetitParser.PPPredicateObjectParser class</class-id> <category>factory-chars</category><body package="PetitParser" selector="blank">blank	^self		cacheAt: #'blank'		ifAbsentPut: [ self			chars: (String with: Character space with: Character tab) message: 'blank expected' ]</body><body package="PetitParser" selector="char:">char: aCharacter	^ self expect: aCharacter message: (String with: $" with: aCharacter with: $") , ' expected'</body><body package="PetitParser" selector="char:message:">char: aCharacter message: aString	^ self expect: aCharacter message: aString</body><body package="PetitParser" selector="chars:message:">chars: aCollection message: aString	^ self on: (PPCharSetPredicate on: [ :char | aCollection includes: char ]) message: aString</body><body package="PetitParser" selector="cr">cr	^self		cacheAt: #'cr'		ifAbsentPut: [ self char: (Character codePoint: 13) message: 'carriage return expected' ]</body><body package="PetitParser" selector="digit">digit	^self		cacheAt: #'digit'		ifAbsentPut: [ self on: (PPCharSetPredicate on: [ :char | char isDigit ]) message: 'digit expected' ]</body><body package="PetitParser" selector="hex">hex	^self		cacheAt: #'hex'		ifAbsentPut: [ self		on: (PPCharSetPredicate on: [ :char | 			(char between: $0 and: $9) 				or: [ (char between: $a and: $f) 				or: [ (char between: $A and: $F) ] ] ])		message: 'hex digit expected' ]</body><body package="PetitParser" selector="letter">letter	^self		cacheAt: #'letter'		ifAbsentPut: [ self on: (PPCharSetPredicate on: [ :char | char isLetter ]) message: 'letter expected' ]</body><body package="PetitParser" selector="lf">lf	^self		cacheAt: #'lf'		ifAbsentPut: [ self char: (Character codePoint: 10) ]</body><body package="PetitParser" selector="lowercase">lowercase	^self		cacheAt: #'lowercase'		ifAbsentPut: [ self on: (PPCharSetPredicate on: [ :char | char isLowercase ]) message: 'lowercase letter expected' ]</body><body package="PetitParser" selector="newline">newline	^self		cacheAt: #'newline'		ifAbsentPut: [ self chars: (String with: (Character codePoint: 13) with: (Character codePoint: 10)) message: 'newline expected' ]</body><body package="PetitParser" selector="punctuation">punctuation	^self		cacheAt: #'punctuation'		ifAbsentPut: [ self chars: '.,"''?!;:#$%&amp;()*+-/&lt;&gt;=@[]\^_{}|~' message: 'punctuation expected' ]</body><body package="PetitParser" selector="space">space	^self		cacheAt: #'space'		ifAbsentPut: [ self on: (PPCharSetPredicate on: [ :char | char isSeparator ]) message: 'separator expected' ]</body><body package="PetitParser" selector="tab">tab	^self		cacheAt: #'tab'		ifAbsentPut: [ self char: Character tab message: 'tab expected' ]</body><body package="PetitParser" selector="uppercase">uppercase	^self		cacheAt: #'uppercase'		ifAbsentPut: [ self on: (PPCharSetPredicate on: [ :char | char isUppercase ]) message: 'uppercase letter expected' ]</body><body package="PetitParser" selector="word">word	^self		cacheAt: #'word'		ifAbsentPut: [ self on: (PPCharSetPredicate on: [ :char | char isAlphaNumeric ]) message: 'letter or digit expected' ]</body></methods><methods><class-id>PetitParser.PPPredicateObjectParser class</class-id> <category>factory-objects</category><body package="PetitParser" selector="any">any	^self		cacheAt: #'any'		ifAbsentPut: [ self			on: [ :each | true ] message: 'input expected'			negated: [ :each | false ] message: 'no input expected' ]</body><body package="PetitParser" selector="anyExceptAnyOf:">anyExceptAnyOf: aCollection	^ self		on: [ :each | (aCollection includes: each) not ] message: 'any except ' , aCollection printString , ' expected'		negated: [ :each | aCollection includes: each ] message: aCollection printString ,  ' not expected'</body><body package="PetitParser" selector="anyOf:">anyOf: aCollection	^ self		on: [ :each | aCollection includes: each ] message: 'any of ' , aCollection printString , ' expected'		negated: [ :each | (aCollection includes: each) not ] message: 'none of ' , aCollection printString ,  'expected'</body><body package="PetitParser" selector="between:and:">between: min and: max	^ self		on: [ :each | each &gt;= min and: [ each &lt;= max ] ] message: min printString , '..' , max printString , ' expected'		negated: [ :each | each &lt; min or: [ each &gt; max ] ] message: min printString , '..' , max printString , ' not expected'</body><body package="PetitParser" selector="endOfLine">endOfLine		^ PPEndOfLineParser new.</body><body package="PetitParser" selector="eof">eof		^ PPEndOfFileParser new</body><body package="PetitParser" selector="expect:">expect: anObject	^ self expect: anObject message: anObject printString , ' expected'</body><body package="PetitParser" selector="expect:message:">expect: anObject message: aString	^ self 		on: [ :each | each = anObject ] message: aString		negated: [ :each | each ~= anObject ] message: 'no ' , aString</body><body package="PetitParser" selector="startOfLine">startOfLine		^ PPStartOfLineParser new.</body><body package="PetitParser" selector="startOfLogicalLine">startOfLogicalLine		^ PPStartOfLogicalLineParser new.</body><body package="PetitParser" selector="startOfWord">startOfWord		^ PPStartOfWordParser new.</body></methods><methods><class-id>PetitParser.PPPredicateObjectParser class</class-id> <category>instance creation</category><body package="PetitParser" selector="on:message:">on: aBlock message: aString	^ self on: aBlock message: aString negated: [ :each | (aBlock value: each) not ] message: 'no ' , aString</body><body package="PetitParser" selector="on:message:negated:message:">on: aBlock message: aString negated: aNegatedBlock message: aNegatedString	^ self new initializeOn: aBlock message: aString negated: aNegatedBlock message: aNegatedString</body></methods><methods><class-id>PetitParser.PPPredicateSequenceParser</class-id> <category>parsing</category><body package="PetitParser" selector="parseOn:">parseOn: aPPContext	| memento result |	memento := aPPContext remember.	result := aPPContext stream next: size.	(result size = size and: [ predicate value: result ])		ifTrue: [ ^ result ].	aPPContext restore: memento.	^ PPFailure message: predicateMessage context: aPPContext</body></methods><methods><class-id>PetitParser.PPPredicateSequenceParser</class-id> <category>operators</category><body package="PetitParser" selector="negate">negate	"Answer a parser that is the negation of the receiving predicate parser."		^ self class 		on: negated message: negatedMessage		negated: predicate message: predicateMessage		size: size</body></methods><methods><class-id>PetitParser.PPPredicateSequenceParser</class-id> <category>initialization</category><body package="PetitParser" selector="initializeOn:message:negated:message:size:">initializeOn: aBlock message: aString negated: aNegatedBlock message: aNegatedString size: anInteger	predicate := aBlock.	predicateMessage := aString.	negated := aNegatedBlock.	negatedMessage := aNegatedString.	size := anInteger </body></methods><methods><class-id>PetitParser.PPPredicateSequenceParser</class-id> <category>accessing</category><body package="PetitParser" selector="size">size	"Answer the sequence size of the receiver."	^ size</body></methods><methods><class-id>PetitParser.PPPredicateSequenceParser class</class-id> <category>instance creation</category><body package="PetitParser" selector="on:message:negated:message:size:">on: aBlock message: aString negated: aNegatedBlock message: aNegatedString size: anInteger 	^ self new initializeOn: aBlock message: aString negated: aNegatedBlock message: aNegatedString size: anInteger</body><body package="PetitParser" selector="on:message:size:">on: aBlock message: aString size: anInteger	^ self on: aBlock message: aString negated: [ :each | (aBlock value: each) not ] message: 'no ' , aString size: anInteger </body></methods><methods><class-id>PetitParser.PPLiteralSequenceParser</class-id> <category>parsing</category><body package="PetitParser" selector="parseOn:">parseOn: aPPContext	| memento result |	memento := aPPContext remember.	result := aPPContext next: size.	literal = result ifTrue: [ ^ result ].	aPPContext restore: memento.	^ PPFailure message: message context: aPPContext</body></methods><methods><class-id>PetitParser.PPLiteralSequenceParser</class-id> <category>operators</category><body package="PetitParser" selector="caseInsensitive">caseInsensitive	"Answer a parser that can parse the receiver case-insensitive."		literal asUppercase = literal asLowercase ifTrue: [ ^ self ].	^ PPPredicateSequenceParser on: [ :value | literal sameAs: value ] message: message size: size</body></methods><methods><class-id>PetitParser.PPLiteralSequenceParser</class-id> <category>initialization</category><body package="PetitParser" selector="initializeOn:message:">initializeOn: anObject message: aString	super initializeOn: anObject message: aString.	size := literal size</body></methods><methods><class-id>PetitParser.PPLiteralSequenceParser</class-id> <category>accessing</category><body package="PetitParser" selector="size">size	"Answer the sequence size of the receiver."	^ size</body></methods><methods><class-id>PetitParser.PPStream</class-id> <category>positioning</category><body package="PetitParser" selector="column">column	^ self column: position.</body><body package="PetitParser" selector="column:">column: pos	| nl |	(pos = -1) ifTrue: [  ^ 0 ].	(pos &gt; readLimit) ifTrue: [ ^ self error: 'Out of limit' ].		nl := self newlines.	1 to: nl size do: [ :index | 		((nl at: index) &gt; pos) ifTrue: [ ^ pos - (nl at: (index - 1)) + 1 ]	]."	nl keysAndValuesDo: [ :index :value |		(value &gt; pos) ifTrue: [ ^ pos - (nl at: (index - 1)) + 1]	].	"	^ pos - (nl at: (nl size )) + 1</body><body package="PetitParser" selector="fillNewlines">fillNewlines	| tmp line |	newlines := OrderedCollection new.			tmp := position.	line := 0.		(0 to: readLimit) do: [:index |		position := index.		self isStartOfLine ifTrue: [ newlines add: position ]	].	position := tmp.	newlines := newlines asArray.	^ newlines</body><body package="PetitParser" selector="line">line	^ self line: position</body><body package="PetitParser" selector="line:">line: pos	| nl |	(pos = -1) ifTrue: [  ^ 0 ].	(pos &gt; readLimit) ifTrue: [ ^ self error: 'Out of limit' ].		nl := self newlines.	nl keysAndValuesDo: [ :index :value |		(value &gt; pos) ifTrue: [ ^ (index - 1)]	].		^ nl size</body><body package="PetitParser" selector="newlines">newlines	^ newlines ifNil: [ 		newlines := self fillNewlines.	]</body></methods><methods><class-id>PetitParser.PPStream</class-id> <category>queries</category><body package="PetitParser" selector="insideCRLF">insideCRLF	(position &lt; 1) ifTrue: [ ^ false ].		^ (self peek = (Character codePoint: 10)) and: [ self peekBack = (Character codePoint: 13) ]</body><body package="PetitParser" selector="isEndOfLine">isEndOfLine	self atEnd ifTrue: [ ^ true ].	self insideCRLF ifTrue: [ ^ false ].	^ (self peek = (Character codePoint: 13) or: [ self peek = (Character codePoint: 10)]).</body><body package="PetitParser" selector="isStartOfLine">isStartOfLine	(position = 0) ifTrue: [ ^ true ].	self insideCRLF ifTrue: [ ^ false ].		^ (self peekBack = (Character codePoint: 13)) or: [ self peekBack = (Character codePoint: 10)].</body></methods><methods><class-id>PetitParser.PPStream</class-id> <category>accessing</category><body package="PetitParser" selector="collection">collection	"Answer the underlying collection."		^ collection</body><body package="PetitParser" selector="next:">next: anInteger 	"Answer up to anInteger elements of my collection. Overridden for efficiency."	| answer endPosition |	endPosition := position + anInteger min: readLimit.	answer := collection copyFrom: position + 1 to: endPosition.	position := endPosition.	^ answer</body><body package="PetitParser" selector="peek">peek	"An improved version of peek, that is slightly faster than the built in version."	^ self atEnd ifFalse: [ collection at: position + 1 ]</body><body package="PetitParser" selector="position:">position: anInteger	"The receiver does not check for invalid arguments passed to this method, as it is solely used with valid indexes for backtracking."	position := anInteger</body><body package="PetitParser" selector="size">size	"		The same implementation as a ReadStream. Implemented here for compatibility with Smalltalk/X		that has different implementation in a ReadStream	"	^readLimit</body><body package="PetitParser" selector="uncheckedPeek">uncheckedPeek	"An unchecked version of peek that throws an error if we try to peek over the end of the stream, even faster than #peek."	^ collection at: position + 1</body></methods><methods><class-id>PetitParser.PPStream</class-id> <category>converting</category><body package="PetitParser" selector="asPetitStream">asPetitStream	^ self</body></methods><methods><class-id>PetitParser.PPStream</class-id> <category>printing</category><body package="PetitParser" selector="printOn:">printOn: aStream	collection isString		ifFalse: [ ^ super printOn: aStream ].	aStream		nextPutAll: (collection copyFrom: 1 to: position);		nextPutAll: 'Â·';		nextPutAll: (collection copyFrom: position + 1 to: readLimit)</body></methods><methods><class-id>PetitParser.PPFailure</class-id> <category>initialization</category><body package="PetitParser" selector="initializeMessage:">initializeMessage: aString		message := aString.</body><body package="PetitParser" selector="initializeMessage:at:">initializeMessage: aString at: anInteger	"One should not use this method if the furthest failure is supposed to be reported correctly"	message := aString.	position := anInteger.</body><body package="PetitParser" selector="initializeMessage:context:">initializeMessage: aString context: aPPContext	self initializeMessage: aString context:  aPPContext position: aPPContext position</body><body package="PetitParser" selector="initializeMessage:context:position:">initializeMessage: aString context: aPPContext position: anInteger	message := aString.	context := aPPContext.	position := anInteger.		"record the furthest failure encountered while parsing the input stream "	aPPContext noteFailure: self.	</body></methods><methods><class-id>PetitParser.PPFailure</class-id> <category>testing</category><body package="PetitParser" selector="isPetitFailure">isPetitFailure	"I am the only class that should implement this method to return true."	^ true</body></methods><methods><class-id>PetitParser.PPFailure</class-id> <category>accessing</category><body package="PetitParser" selector="message">message	"Answer a human readable error message of this parse failure."		^ message</body><body package="PetitParser" selector="position">position	"Answer the position in the source string that caused this parse failure."	^ position</body></methods><methods><class-id>PetitParser.PPFailure</class-id> <category>printing</category><body package="PetitParser" selector="printOn:">printOn: aStream	aStream 		nextPutAll: (self message ifNil: ['&lt;message not specified&gt;']); 		nextPutAll: ' at '; print: self position</body></methods><methods><class-id>PetitParser.PPFailure class</class-id> <category>instance creation</category><body package="PetitParser" selector="message:">message: aString	^ self basicNew initializeMessage: aString </body><body package="PetitParser" selector="message:at:">message: aString at: anInteger	"One should not use this method if the furthest failure is supposed to be reported correctly"	^ self basicNew initializeMessage: aString at: anInteger</body><body package="PetitParser" selector="message:context:">message: aString context: aPPContext	^ self basicNew initializeMessage: aString context: aPPContext</body><body package="PetitParser" selector="message:context:at:">message: aString context: aPPContext at: position	^ self basicNew initializeMessage: aString context: aPPContext position: position</body></methods><methods><class-id>PetitParser.PPStartOfWordParser</class-id> <category>as yet unclassified</category><body package="PetitParser" selector="acceptsEpsilon">acceptsEpsilon	^ false</body><body package="PetitParser" selector="parseOn:">parseOn: aPPContext	aPPContext atEnd ifTrue: [  		^ PPFailure message: 'Start of word expected' context: aPPContext at: aPPContext position 	].	(aPPContext position == 0) ifTrue: [ 		(aPPContext peek isAlphaNumeric) ifTrue: [ 			^ #startOfWord		] ifFalse: [ 			^ PPFailure message: 'Start of word expected' context: aPPContext at: aPPContext position 	 	]	].	aPPContext back.	aPPContext peek isAlphaNumeric ifTrue: [		^ PPFailure message: 'Start of word expected' context: aPPContext at: aPPContext position 	].	aPPContext next.		^ aPPContext peek isAlphaNumeric ifTrue: [ #startOfWord ] ifFalse: [ 		PPFailure message: 'Start of word expected' context: aPPContext at: aPPContext position 	]	</body></methods><methods><class-id>PetitParser.PPListParser</class-id> <category>copying</category><body package="PetitParser" selector="copyWith:">copyWith: aParser	^ self species withAll: (parsers copyWith: aParser)</body><body package="PetitParser" selector="postCopy">postCopy	super postCopy.	parsers := parsers copy</body></methods><methods><class-id>PetitParser.PPListParser</class-id> <category>accessing</category><body package="PetitParser" selector="children">children	^ parsers</body></methods><methods><class-id>PetitParser.PPListParser</class-id> <category>initialization</category><body package="PetitParser" selector="initialize">initialize	super initialize.	self setParsers: #()</body><body package="PetitParser" selector="setParsers:">setParsers: aCollection	parsers := aCollection asArray</body></methods><methods><class-id>PetitParser.PPListParser class</class-id> <category>instance creation</category><body package="PetitParser" selector="with:">with: aParser	^ self withAll: (Array with: aParser)</body><body package="PetitParser" selector="with:with:">with: aFirstParser with: aSecondParser	^ self withAll: (Array with: aFirstParser with: aSecondParser)</body><body package="PetitParser" selector="withAll:">withAll: aCollection	^ self basicNew initialize;		setParsers: aCollection</body></methods><methods><class-id>PetitParser.PPSequenceParser</class-id> <category>operators-mapping</category><body package="PetitParser" selector="map:">map: aBlock	^ aBlock numArgs = self children size		ifTrue: [ self performs: [ :nodes | aBlock valueWithArguments: nodes ] ]		ifFalse: [ self error: aBlock numArgs asString , ' arguments expected.' ]</body><body package="PetitParser" selector="permutation:">permutation: anArrayOfIntegers	"Answer a permutation of the receivers sequence."		anArrayOfIntegers do: [ :index |		(index isInteger and: [ index between: 1 and: parsers size ])			ifFalse: [ self error: 'Invalid permutation index: ' , index printString ] ].	^ self performs: [ :nodes | anArrayOfIntegers collect: [ :index | nodes at: index ] ]</body></methods><methods><class-id>PetitParser.PPSequenceParser</class-id> <category>parsing</category><body package="PetitParser" selector="parseOn:">parseOn: aPPContext	"This is optimized code that avoids unnecessary block activations, do not change."		| memento elements element |	memento := aPPContext remember.	elements := Array new: parsers size.	1 to: parsers size do: [ :index |		element := (parsers at: index) 			parseOn: aPPContext.		element isPetitFailure ifTrue: [			aPPContext restore: memento.			^ element ].		elements at: index put: element ].	^ elements</body></methods><methods><class-id>PetitParser.PPSequenceParser</class-id> <category>operators</category><body package="PetitParser" selector=",">, aRule	^ self copyWith: aRule</body></methods><methods><class-id>PetitParser.PPChoiceParser</class-id> <category>parsing</category><body package="PetitParser" selector="parseOn:">parseOn: aPPContext	"This is optimized code that avoids unnecessary block activations, do not change. When all choices fail, the last failure is answered."	| element |	1 to: parsers size do: [ :index |		element := (parsers at: index)			parseOn: aPPContext.		element isPetitFailure			ifFalse: [ ^ element ] ].	^ element</body></methods><methods><class-id>PetitParser.PPChoiceParser</class-id> <category>operators</category><body package="PetitParser" selector="/">/ aRule 	^ self copyWith: aRule</body></methods><methods><class-id>PetitParser.PPLimitedChoiceParser</class-id> <category>as yet unclassified</category><body package="PetitParser" selector="//">// aRule 	^ self copyWith: aRule</body><body package="PetitParser" selector="initialize">initialize	limit := nil asParser</body><body package="PetitParser" selector="parseOn:">parseOn: aPPContext	"This is optimized code that avoids unnecessary block activations, do not change. When all choices fail, the last failure is answered."	| element limitResult memento |	"self halt."	1 to: parsers size do: [ :index |		memento := aPPContext remember.				element := (parsers at: index)			parseOn: aPPContext.				(element isPetitFailure not) ifTrue: [ 			"check limit"			limitResult := limit parseOn: aPPContext.			limitResult isPetitFailure ifTrue: [ 				element := PPFailure message: 'limit failed' at: aPPContext position .				aPPContext restore: memento.			] ifFalse: [ ^ element ].		].	].		^ element</body></methods><methods><class-id>PetitParser.PPLimitedChoiceParser</class-id> <category>accessing</category><body package="PetitParser" selector="limit">limit		^ limit</body><body package="PetitParser" selector="limit:">limit: anObject		limit := anObject</body></methods><methods><class-id>PetitParser.PPContext</class-id> <category>acessing</category><body package="PetitParser" selector="root">root	^ root </body><body package="PetitParser" selector="stream">stream	^ stream</body><body package="PetitParser" selector="stream:">stream: aStream	stream := aStream.</body></methods><methods><class-id>PetitParser.PPContext</class-id> <category>initialization</category><body package="PetitParser" selector="initialize">initialize	stream := nil.</body><body package="PetitParser" selector="initializeFor:">initializeFor: parser	root := parser.</body><body package="PetitParser" selector="postCopy">postCopy	super postCopy.	globals := globals copy.	</body><body package="PetitParser" selector="reset">reset	properties := nil.	globals := nil.</body></methods><methods><class-id>PetitParser.PPContext</class-id> <category>stream mimicry</category><body package="PetitParser" selector="atEnd">atEnd	^ stream atEnd</body><body package="PetitParser" selector="back">back	^ stream back</body><body package="PetitParser" selector="collection">collection	^ stream collection  </body><body package="PetitParser" selector="contents">contents 	^ stream contents</body><body package="PetitParser" selector="isEndOfLine">isEndOfLine	^ stream isEndOfLine</body><body package="PetitParser" selector="isStartOfLine">isStartOfLine	^ stream isStartOfLine</body><body package="PetitParser" selector="next">next	^ stream next</body><body package="PetitParser" selector="next:">next: anInteger	^ stream next: anInteger</body><body package="PetitParser" selector="peek">peek	^ stream peek</body><body package="PetitParser" selector="peekTwice">peekTwice	^ stream peekTwice</body><body package="PetitParser" selector="position">position	^ stream position</body><body package="PetitParser" selector="position:">position: anInteger	^ stream position: anInteger</body><body package="PetitParser" selector="skip:">skip: anInteger 	^ stream skip: anInteger </body><body package="PetitParser" selector="skipTo:">skipTo: anObject 	^ stream skipTo: anObject </body><body package="PetitParser" selector="skipToAll:">skipToAll: aString	"Set the access position of the receiver to be past the next occurrence of the subCollection. Answer whether subCollection is found.  No wildcards, and case does matter."	| pattern startMatch |	pattern := aString readStream.	startMatch := nil.	[ pattern atEnd ] whileFalse: 		[ stream atEnd ifTrue: [ ^ false ].		stream next = pattern next 			ifTrue: [ pattern position = 1 ifTrue: [ startMatch := stream position ] ]			ifFalse: 				[ pattern position: 0.				startMatch ifNotNil: 					[ stream position: startMatch.					startMatch := nil ] ] ].	^ true</body><body package="PetitParser" selector="skipToAnyOf:">skipToAnyOf: aCharacterSet 	"Set the access position of the receiver to be past the next occurrence of	a character in the character set. Answer whether a fitting character is found."	[stream atEnd]		whileFalse: [ (aCharacterSet includes: stream next) ifTrue: [^true]].	^false</body><body package="PetitParser" selector="uncheckedPeek">uncheckedPeek	^ stream uncheckedPeek</body><body package="PetitParser" selector="upTo:">upTo: anObject	^ stream upTo: anObject</body><body package="PetitParser" selector="upToAll:">upToAll: whatever	^ stream upToAll: whatever</body><body package="PetitParser" selector="upToAnyOf:">upToAnyOf: whatever	^ stream upToAnyOf: whatever</body></methods><methods><class-id>PetitParser.PPContext</class-id> <category>accessing-properties</category><body package="PetitParser" selector="hasProperty:">hasProperty: aKey	"Test if the property aKey is present."		^ properties notNil and: [ properties includesKey: aKey ]</body><body package="PetitParser" selector="properties">properties	^ properties </body><body package="PetitParser" selector="propertyAt:">propertyAt: aKey	"Answer the property value associated with aKey."		^ self propertyAt: aKey ifAbsent: [ self error: 'Property not found' ]</body><body package="PetitParser" selector="propertyAt:ifAbsent:">propertyAt: aKey ifAbsent: aBlock	"Answer the property value associated with aKey or, if aKey isn't found, answer the result of evaluating aBlock."		^ properties isNil		ifTrue: [ aBlock value ]		ifFalse: [ properties at: aKey ifAbsent: aBlock ]</body><body package="PetitParser" selector="propertyAt:ifAbsentPut:">propertyAt: aKey ifAbsentPut: aBlock	"Answer the property associated with aKey or, if aKey isn't found store the result of evaluating aBlock as new value."		^ self propertyAt: aKey ifAbsent: [ self propertyAt: aKey put: aBlock value ]</body><body package="PetitParser" selector="propertyAt:put:">propertyAt: aKey put: anObject	"Set the property at aKey to be anObject. If aKey is not found, create a new entry for aKey and set is value to anObject. Answer anObject."	^ (properties ifNil: [ properties := Dictionary new: 1 ])		at: aKey put: anObject</body><body package="PetitParser" selector="removeProperty:">removeProperty: aKey	"Remove the property with aKey. Answer the property or raise an error if aKey isn't found."		^ self removeProperty: aKey ifAbsent: [ self error: 'Property not found' ]</body><body package="PetitParser" selector="removeProperty:ifAbsent:">removeProperty: aKey ifAbsent: aBlock	"Remove the property with aKey. Answer the value or, if aKey isn't found, answer the result of evaluating aBlock."		| answer |	properties isNil ifTrue: [ ^ aBlock value ].	answer := properties removeKey: aKey ifAbsent: aBlock.	properties isEmpty ifTrue: [ properties := nil ].	^ answer</body></methods><methods><class-id>PetitParser.PPContext</class-id> <category>printing</category><body package="PetitParser" selector="printOn:">printOn: aStream	super printOn: aStream.	aStream nextPut: $:.	aStream nextPut: $ .	stream printOn: aStream</body></methods><methods><class-id>PetitParser.PPContext</class-id> <category>memoization</category><body package="PetitParser" selector="identifier">identifier	"		I provide an identifier that is used by memoizing parser to figure out if the		cache should be flushed or not.	"	^ stream</body><body package="PetitParser" selector="remember">remember	| memento |	memento := PPContextMemento new		stream: stream;		position: stream position;		yourself.			self rememberProperties: memento.	^ memento</body><body package="PetitParser" selector="rememberProperties:">rememberProperties: aPPContextMemento	properties ifNil: [ ^ self ].		properties keysAndValuesDo: [ :key :value |		aPPContextMemento propertyAt: key put: value	].</body><body package="PetitParser" selector="restore:">restore: aPPContextMemento	aPPContextMemento stream == stream ifFalse: [ self error: 'Oops!' ].	stream position: aPPContextMemento position.	self restoreProperties: aPPContextMemento.</body><body package="PetitParser" selector="restoreProperties:">restoreProperties: aPPContextMemento	aPPContextMemento stream == stream ifFalse: [ self error: 'Oops!' ].		properties ifNil: [ ^ self ].		properties keysDo: [ :key |		(aPPContextMemento hasProperty: key)			ifTrue: [ properties at: key put: (aPPContextMemento propertyAt: key) ]			ifFalse: [ properties removeKey: key  ]. 	].	aPPContextMemento keysAndValuesDo: [ :key :value |		properties at: key put: value	]</body><body package="PetitParser" selector="size">size	^ stream size</body></methods><methods><class-id>PetitParser.PPContext</class-id> <category>accessing-globals</category><body package="PetitParser" selector="globalAt:">globalAt: aKey	"Answer the global property value associated with aKey."		^ self globalAt: aKey ifAbsent: [ self error: 'Property not found' ]</body><body package="PetitParser" selector="globalAt:ifAbsent:">globalAt: aKey ifAbsent: aBlock	"Answer the global property value associated with aKey or, if aKey isn't found, answer the result of evaluating aBlock."		^ globals isNil		ifTrue: [ aBlock value ]		ifFalse: [ globals at: aKey ifAbsent: aBlock ]</body><body package="PetitParser" selector="globalAt:ifAbsentPut:">globalAt: aKey ifAbsentPut: aBlock	"Answer the global property associated with aKey or, if aKey isn't found store the result of evaluating aBlock as new value."		^ self globalAt: aKey ifAbsent: [ self globalAt: aKey put: aBlock value ]</body><body package="PetitParser" selector="globalAt:put:">globalAt: aKey put: anObject	"Set the global property at aKey to be anObject. If aKey is not found, create a new entry for aKey and set is value to anObject. Answer anObject."	^ (globals ifNil: [ globals := Dictionary new: 1 ])		at: aKey put: anObject</body><body package="PetitParser" selector="globals">globals	^ globals</body><body package="PetitParser" selector="hasGlobal:">hasGlobal: aKey	"Test if the global property aKey is present."		^ globals notNil and: [ globals includesKey: aKey ]</body><body package="PetitParser" selector="removeGlobal:">removeGlobal: aKey	"Remove the property with aKey. Answer the property or raise an error if aKey isn't found."		^ self removeGlobal: aKey ifAbsent: [ self error: 'Property not found' ]</body><body package="PetitParser" selector="removeGlobal:ifAbsent:">removeGlobal: aKey ifAbsent: aBlock	"Remove the global property with aKey. Answer the value or, if aKey isn't found, answer the result of evaluating aBlock."		| answer |	globals isNil ifTrue: [ ^ aBlock value ].	answer := globals removeKey: aKey ifAbsent: aBlock.	globals isEmpty ifTrue: [ globals := nil ].	^ answer</body></methods><methods><class-id>PetitParser.PPContext</class-id> <category>failures</category><body package="PetitParser" selector="furthestFailure">furthestFailure	" the furthest failure encountered while parsing the input stream "		"^ self globalAt: #furthestFailure ifAbsent: [ nil ]"	"performance optimization:"	^ furthestFailure</body><body package="PetitParser" selector="noteFailure:">noteFailure: aPPFailure	"record the furthest failure encountered while parsing the input stream "	( furthestFailure isNil or: [ aPPFailure position &gt; furthestFailure position ]) 		ifTrue: [ furthestFailure := aPPFailure ].</body></methods><methods><class-id>PetitParser.PPContext class</class-id> <category>as yet unclassified</category><body package="PetitParser" selector="on:stream:">on: aPPParser stream: aStream	^ self basicNew 		initialize;		root: aPPParser;		stream: aStream asPetitStream;		yourself</body></methods><methods><class-id>PetitParser.PPRepeatingParser</class-id> <category>accessing</category><body package="PetitParser" selector="max">max	"Answer the maximum number of repetitions."	^ max</body><body package="PetitParser" selector="min">min	"Answer the minimum number of repetitions."		^ min</body></methods><methods><class-id>PetitParser.PPRepeatingParser</class-id> <category>initialization</category><body package="PetitParser" selector="initialize">initialize	super initialize.	self setMin: 0; setMax: SmallInteger maxVal</body><body package="PetitParser" selector="setMax:">setMax: anInteger	max := anInteger</body><body package="PetitParser" selector="setMin:">setMin: anInteger	min := anInteger</body></methods><methods><class-id>PetitParser.PPRepeatingParser</class-id> <category>printing</category><body package="PetitParser" selector="printOn:">printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' ['; print: min; nextPutAll: ', '; nextPutAll: (max = SmallInteger maxVal		ifTrue: [ '*' ] ifFalse: [ max printString ]); nextPut: $]</body></methods><methods><class-id>PetitParser.PPPossessiveRepeatingParser</class-id> <category>parsing</category><body package="PetitParser" selector="parseOn:">parseOn: aPPContext	| memento element elements |	memento := aPPContext remember.	elements := OrderedCollection new.	[ elements size &lt; min ] whileTrue: [		(element := parser parseOn: aPPContext) isPetitFailure ifTrue: [			aPPContext restore: memento.			^ element ].		elements addLast: element ].	[ elements size &lt; max ] whileTrue: [	 	(element := parser parseOn: aPPContext) isPetitFailure			ifTrue: [ ^ elements asArray ].		elements addLast: element ].	^ elements asArray</body></methods><methods><class-id>PetitParser.PPLimitedRepeatingParser</class-id> <category>accessing</category><body package="PetitParser" selector="children">children	^ Array with: parser with: limit</body><body package="PetitParser" selector="limit">limit	"Answer the parser that limits (or ends) this repetition."		^ limit</body></methods><methods><class-id>PetitParser.PPLimitedRepeatingParser</class-id> <category>parsing</category><body package="PetitParser" selector="matchesLimitOn:">matchesLimitOn: aPPContext	| element position |	position := aPPContext remember.	element := limit parseOn: aPPContext.	aPPContext restore: position.	^ element isPetitFailure not</body></methods><methods><class-id>PetitParser.PPLimitedRepeatingParser</class-id> <category>initialization</category><body package="PetitParser" selector="setLimit:">setLimit: aParser	limit := aParser</body></methods><methods><class-id>PetitParser.PPLimitedRepeatingParser class</class-id> <category>instance creation</category><body package="PetitParser" selector="on:limit:">on: aParser limit: aLimitParser	^ (self on: aParser) setLimit: aLimitParser</body></methods><methods><class-id>PetitParser.PPLazyRepeatingParser</class-id> <category>parsing</category><body package="PetitParser" selector="parseOn:">parseOn: aPPContext	| memento element elements |	memento := aPPContext remember.	elements := OrderedCollection new.	[ elements size &lt; min ] whileTrue: [		(element := parser parseOn: aPPContext) isPetitFailure ifTrue: [			aPPContext restore: memento.			^ element ].		elements addLast: element ].	[ self matchesLimitOn: aPPContext ] whileFalse: [		elements size &lt; max ifFalse: [			aPPContext restore: memento.			^ PPFailure message: 'overflow' context: aPPContext at: memento position ].		element := parser parseOn: aPPContext.		element isPetitFailure ifTrue: [			aPPContext restore: memento.			^ element ].		elements addLast: element ].	^ elements asArray</body></methods><methods><class-id>PetitParser.PPGreedyRepeatingParser</class-id> <category>parsing</category><body package="PetitParser" selector="parseOn:">parseOn: aPPContext	| memento element elements positions |	memento := aPPContext remember.	elements := OrderedCollection new.	[ elements size &lt; min ] whileTrue: [ 		(element := parser parseOn: aPPContext) isPetitFailure ifTrue: [ 			aPPContext restore: memento.			^ element ].		elements addLast: element ].	positions := OrderedCollection with: aPPContext remember.	[ elements size &lt; max and: [ (element := parser parseOn: aPPContext) isPetitFailure not ] ] whileTrue: [		elements addLast: element.		positions addLast: aPPContext remember ].	[ positions isEmpty ] whileFalse: [		aPPContext restore: positions last.		element := limit parseOn: aPPContext.		element isPetitFailure ifFalse: [			aPPContext restore: positions last.			^ elements asArray ].		elements isEmpty ifTrue: [			aPPContext restore: memento.			^ element ].		elements removeLast.		positions removeLast ].	aPPContext restore: memento.	^ PPFailure message: 'overflow' context: aPPContext at: memento position</body></methods><initialize><class-id>PetitParser.PPToken</class-id></initialize><do-it>"Imported Classes:"</do-it><do-it>self error: 'Attempting to file-in parcel imports.  Choose terminate or close'</do-it><class><name>Object</name><environment>Core</environment><super></super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Kernel-Objects</category><attributes><package>Kernel-Objects</package></attributes></class><class><name>ReadStream</name><environment>Core</environment><super>Core.InternalStream</super><private>false</private><indexed-type>none</indexed-type><inst-vars></inst-vars><class-inst-vars></class-inst-vars><imports></imports><category>Collections-Streams</category><attributes><package>Collections-Streams</package></attributes></class></st-source>